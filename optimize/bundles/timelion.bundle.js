webpackJsonp([3],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Test entry file
	 *
	 * This is programatically created and updated, do not modify
	 *
	 * context: {"env":"development","urlBasePath":"","sourceMaps":true,"kbnVersion":"5.3.3","buildNum":8467}
	 * includes code from:
	 *  - console@kibana
	 *  - dev_mode@kibana
	 *  - elasticsearch@kibana
	 *  - kbn_doc_views@kibana
	 *  - kbn_vislib_vis_types@kibana
	 *  - kibana@kibana
	 *  - markdown_vis@kibana
	 *  - metric_vis@kibana
	 *  - spy_modes@kibana
	 *  - status_page@kibana
	 *  - table_vis@kibana
	 *  - tagcloud@kibana
	 *  - tests_bundle@kibana
	 *  - timelion@kibana
	 *
	 */
	
	'use strict';
	
	__webpack_require__(1);
	__webpack_require__(1448);
	__webpack_require__(1405);
	__webpack_require__(1406);
	__webpack_require__(1308);
	__webpack_require__(1407);
	__webpack_require__(1).bootstrap();
	/* xoxo */

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(465);
	
	__webpack_require__(736);
	
	__webpack_require__(772);
	
	__webpack_require__(783);

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(17);
	
	__webpack_require__(1);
	
	__webpack_require__(319);
	
	__webpack_require__(466);
	
	__webpack_require__(476);
	
	__webpack_require__(330);
	
	__webpack_require__(477);
	
	__webpack_require__(584);
	
	__webpack_require__(585);
	
	__webpack_require__(586);
	
	__webpack_require__(478);
	
	__webpack_require__(283);
	
	__webpack_require__(587);
	
	__webpack_require__(589);
	
	__webpack_require__(615);
	
	__webpack_require__(481);
	
	__webpack_require__(617);
	
	__webpack_require__(366);
	
	__webpack_require__(618);
	
	__webpack_require__(621);
	
	__webpack_require__(390);
	
	__webpack_require__(391);
	
	__webpack_require__(622);
	
	__webpack_require__(416);
	
	__webpack_require__(238);
	
	__webpack_require__(392);
	
	__webpack_require__(628);
	
	__webpack_require__(669);
	
	__webpack_require__(234);
	
	__webpack_require__(671);
	
	__webpack_require__(682);
	
	__webpack_require__(727);
	
	__webpack_require__(412);
	
	__webpack_require__(732);
	
	__webpack_require__(395);
	
	__webpack_require__(734);

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A configuration object for a top nav component.
	 * @typedef {Object} KbnTopNavConfig
	 * @type Object
	 * @property {string} key - A display string which will be shown in the top nav for this option.
	 * @property {string} [description] - optional, used for the screen-reader description of this
	 *  menu. Defaults to "Toggle ${key} view" for templated menu items and just "${key}" for
	 *  programmatic menu items
	 * @property {string} testId - for testing purposes, can be used to retrieve this item.
	 * @property {Object} [template] - an html template that will be shown when this item is clicked.
	 *  If template is not given then run should be supplied.
	 * @property {function} [run] - an optional function that will be run when the nav item is clicked.
	 *  Either this or template parameter should be specified.
	 * @param {boolean} [hideButton] - optional, set to true to prevent a menu item from being created.
	 *  This allow injecting templates into the navbar that don't have an associated template
	 */
	
	/**
	 * kbnTopNav directive
	 *
	 * The top section that shows the timepicker, load, share and save dialogues.
	 *
	 * ```
	 * <kbn-top-nav name="current-app-for-extensions" config="path.to.menuItems"></kbn-top-nav>
	 * ```
	 *
	 * Menu items/templates are passed to the kbnTopNav via the config attribute
	 * and should be defined as an array of objects. Each object represents a menu
	 * item and should be of type kbnTopNavConfig.
	 *
	 * @param {Array<kbnTopNavConfig>|KbnTopNavController} config
	 *
	 * Programmatic control of the navbar can be achieved one of two ways
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(395);
	
	__webpack_require__(467);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _kbn_top_navHtml = __webpack_require__(468);
	
	var _kbn_top_navHtml2 = _interopRequireDefault(_kbn_top_navHtml);
	
	var _kbn_top_nav_controller = __webpack_require__(469);
	
	var _kbn_top_nav_controller2 = _interopRequireDefault(_kbn_top_nav_controller);
	
	var _uiRegistryNavbar_extensions = __webpack_require__(472);
	
	var _uiRegistryNavbar_extensions2 = _interopRequireDefault(_uiRegistryNavbar_extensions);
	
	__webpack_require__(473);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('kbnTopNav', function (Private) {
	  var KbnTopNavController = Private(_kbn_top_nav_controller2['default']);
	  var navbarExtensions = Private(_uiRegistryNavbar_extensions2['default']);
	  var getNavbarExtensions = _lodash2['default'].memoize(function (name) {
	    if (!name) throw new Error('navbar directive requires a name attribute');
	    return _lodash2['default'].sortBy(navbarExtensions.byAppName[name], 'order');
	  });
	
	  return {
	    restrict: 'E',
	    transclude: true,
	    template: _kbn_top_navHtml2['default'],
	
	    // TODO: The kbnTopNav currently requires that it share a scope with
	    // its parent directive. This allows it to export the kbnTopNav controller
	    // and allows the config templates to use values from the parent scope.
	    //
	    // Moving this to an isolate scope will require modifying the config
	    // directive to support child directives, instead of templates, so that
	    // parent controllers can be imported/required rather than simply referenced
	    // directly in the template.
	    //
	    // TODO: Our fake multi-slot transclusion solution also depends on an inherited
	    // scope. Moving this to an isolate scope will cause this to break.
	    //
	    // scope: {}
	
	    controller: function controller($scope, $attrs, $element, $transclude) {
	      // This is a semi-hacky solution to missing slot-transclusion support in Angular 1.4.7
	      // (it was added as a core feature in 1.5). Borrowed from http://stackoverflow.com/a/22080765.
	      $scope.transcludes = {};
	
	      // Extract transcluded elements for use in the link function.
	      $transclude(function (clone) {
	        // We expect the transcluded elements to be wrapped in a single div.
	        var transcludedContentContainer = _lodash2['default'].find(clone, function (item) {
	          if (item.attributes) {
	            return _lodash2['default'].find(item.attributes, function (attr) {
	              return attr.name.indexOf('data-transclude-slots') !== -1;
	            });
	          }
	        });
	
	        if (!transcludedContentContainer) {
	          return;
	        }
	
	        var transcludedContent = transcludedContentContainer.children;
	        _lodash2['default'].forEach(transcludedContent, function (transcludedItem) {
	          var transclusionSlot = transcludedItem.getAttribute('data-transclude-slot');
	          $scope.transcludes[transclusionSlot] = transcludedItem;
	        });
	      });
	
	      var extensions = getNavbarExtensions($attrs.name);
	      var controls = _lodash2['default'].get($scope, $attrs.config, []);
	
	      if (controls instanceof KbnTopNavController) {
	        controls.addItems(extensions);
	      } else {
	        controls = controls.concat(extensions);
	      }
	
	      $scope.kbnTopNav = new KbnTopNavController(controls);
	      $scope.kbnTopNav._link($scope, $element);
	
	      return $scope.kbnTopNav;
	    },
	
	    link: function link(scope, element) {
	      // These are the slots where transcluded elements can go.
	      var transclusionSlotNames = ['topLeftCorner', 'bottomRow'];
	
	      // Transclude elements into specified "slots" in the top nav.
	      transclusionSlotNames.forEach(function (name) {
	        var transcludedItem = scope.transcludes[name];
	        if (transcludedItem) {
	          var transclusionSlot = document.querySelector('[data-transclude-slot="' + name + '"]');
	          _angular2['default'].element(transclusionSlot).replaceWith(transcludedItem);
	        }
	      });
	    }
	  };
	});

/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('inputFocus', function ($timeout) {
	  return {
	    restrict: 'A',
	    link: function link($scope, $elem, attrs) {
	      $timeout(function () {
	        $elem.focus();
	        if (attrs.inputFocus === 'select') $elem.select();
	      });
	    }
	  };
	});

/***/ },
/* 468 */
/***/ function(module, exports) {

	module.exports = "<div\n  class=\"kuiLocalNav\"\n  ng-show=\"kbnTopNav.isVisible()\"\n  data-test-subj=\"top-nav\"\n>\n  <!-- Top row -->\n  <div class=\"kuiLocalNavRow\">\n    <!-- Top left corner slot, e.g. breadcrumbs, title. -->\n    <div\n      class=\"kuiLocalNavRow__section\"\n      data-transclude-slot=\"topLeftCorner\"\n    ></div>\n\n    <!-- Right-side: menu -->\n    <div class=\"kuiLocalNavRow__section\">\n      <div class=\"kuiLocalMenu\">\n        <div\n          class=\"kuiLocalMenuItem\"\n          ng-repeat=\"menuItem in kbnTopNav.menuItems\"\n          aria-label=\"{{::menuItem.description}}\"\n          aria-haspopup=\"{{!menuItem.hasFunction}}\"\n          aria-expanded=\"{{kbnTopNav.isCurrent(menuItem.key)}}\"\n          ng-class=\"{'kuiLocalMenuItem-isSelected': kbnTopNav.isCurrent(menuItem.key), 'kuiLocalMenuItem-isDisabled': menuItem.disableButton()}\"\n          ng-click=\"kbnTopNav.handleClick(menuItem)\"\n          ng-bind=\"menuItem.label\"\n          tooltip=\"{{menuItem.tooltip()}}\"\n          tooltip-placement=\"bottom\"\n          tooltip-popup-delay=\"400\"\n          tooltip-append-to-body=\"1\"\n          data-test-subj=\"{{menuItem.testId}}\"\n        ></div>\n\n        <!-- Time-picker \"menu item\" -->\n        <kbn-global-timepicker></kbn-global-timepicker>\n      </div>\n    </div>\n  </div>\n\n  <!-- Dropdown content, e.g. time-picker. -->\n  <div\n    class=\"kuiLocalDropdown\"\n    ng-show=\"kbnTopNav.rendered\"\n  >\n    <button class=\"kuiLocalDropdownCloseButton\" ng-click=\"kbnTopNav.close()\">\n      <span class=\"fa fa-chevron-circle-up\"></span>\n    </button>\n    <div id=\"template_wrapper\">\n      <!-- Content gets dynamically inserted here. -->\n    </div>\n  </div>\n\n  <div class=\"kuiLocalNavRow kuiLocalNavRow--secondary\">\n    <!-- Bottom row slot, e.g. tabs. -->\n    <div data-transclude-slot=\"bottomRow\"></div>\n  </div>\n</div>\n"

/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _Object$assign = __webpack_require__(352)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _uiChrome = __webpack_require__(1);
	
	var _uiChrome2 = _interopRequireDefault(_uiChrome);
	
	var _uiChromeConfigFilterHtml = __webpack_require__(470);
	
	var _uiChromeConfigFilterHtml2 = _interopRequireDefault(_uiChromeConfigFilterHtml);
	
	var _uiChromeConfigIntervalHtml = __webpack_require__(471);
	
	var _uiChromeConfigIntervalHtml2 = _interopRequireDefault(_uiChromeConfigIntervalHtml);
	
	exports['default'] = function ($compile) {
	  return (function () {
	    function KbnTopNavController() {
	      var opts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	
	      _classCallCheck(this, KbnTopNavController);
	
	      if (opts instanceof KbnTopNavController) {
	        return opts;
	      }
	
	      this.opts = [];
	      this.menuItems = [];
	      this.currentKey = null;
	      this.templates = {
	        interval: _uiChromeConfigIntervalHtml2['default'],
	        filter: _uiChromeConfigFilterHtml2['default']
	      };
	
	      this.addItems(opts);
	    }
	
	    _createClass(KbnTopNavController, [{
	      key: 'isVisible',
	      value: function isVisible() {
	        return _uiChrome2['default'].getVisible();
	      }
	    }, {
	      key: 'addItems',
	      value: function addItems(rawOpts) {
	        var _this = this;
	
	        if (!(0, _lodash.isArray)(rawOpts)) rawOpts = [rawOpts];
	
	        rawOpts.forEach(function (rawOpt) {
	          var opt = _this._applyOptDefault(rawOpt);
	          if (!opt.key) throw new TypeError('KbnTopNav: menu items must have a key');
	          _this.opts.push(opt);
	          if (!opt.hideButton()) _this.menuItems.push(opt);
	          if (opt.template) _this.templates[opt.key] = opt.template;
	        });
	      }
	
	      // change the current key and rerender
	    }, {
	      key: 'setCurrent',
	      value: function setCurrent(key) {
	        if (key && !this.templates.hasOwnProperty(key)) {
	          throw new TypeError('KbnTopNav: unknown template key "' + key + '"');
	        }
	
	        this.currentKey = key || null;
	        this._render();
	      }
	
	      // little usability helpers
	    }, {
	      key: 'getCurrent',
	      value: function getCurrent() {
	        return this.currentKey;
	      }
	    }, {
	      key: 'isCurrent',
	      value: function isCurrent(key) {
	        return this.getCurrent() === key;
	      }
	    }, {
	      key: 'open',
	      value: function open(key) {
	        this.setCurrent(key);
	      }
	    }, {
	      key: 'close',
	      value: function close(key) {
	        (!key || this.isCurrent(key)) && this.setCurrent(null);
	      }
	    }, {
	      key: 'toggle',
	      value: function toggle(key) {
	        this.setCurrent(this.isCurrent(key) ? null : key);
	      }
	    }, {
	      key: 'handleClick',
	      value: function handleClick(menuItem) {
	        if (menuItem.disableButton()) {
	          return false;
	        }
	        menuItem.run(menuItem, this);
	      }
	
	      // apply the defaults to individual options
	    }, {
	      key: '_applyOptDefault',
	      value: function _applyOptDefault() {
	        var _this2 = this;
	
	        var opt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	        var defaultedOpt = _Object$assign({
	          label: (0, _lodash.capitalize)(opt.key),
	          hasFunction: !!opt.run,
	          description: opt.run ? opt.key : 'Toggle ' + opt.key + ' view',
	          run: function run(item) {
	            return _this2.toggle(item.key);
	          }
	        }, opt);
	
	        defaultedOpt.hideButton = (0, _lodash.isFunction)(opt.hideButton) ? opt.hideButton : function () {
	          return !!opt.hideButton;
	        };
	        defaultedOpt.disableButton = (0, _lodash.isFunction)(opt.disableButton) ? opt.disableButton : function () {
	          return !!opt.disableButton;
	        };
	        defaultedOpt.tooltip = (0, _lodash.isFunction)(opt.tooltip) ? opt.tooltip : function () {
	          return opt.tooltip;
	        };
	
	        return defaultedOpt;
	      }
	
	      // enable actual rendering
	    }, {
	      key: '_link',
	      value: function _link($scope, $element) {
	        this.$scope = $scope;
	        this.$element = $element;
	        this._render();
	      }
	
	      // render the current template to the $element if possible
	      // function is idempotent
	    }, {
	      key: '_render',
	      value: function _render() {
	        var $scope = this.$scope;
	        var $element = this.$element;
	        var rendered = this.rendered;
	        var currentKey = this.currentKey;
	
	        var templateToRender = currentKey && this.templates[currentKey];
	
	        if (rendered) {
	          if (rendered.key !== currentKey) {
	            // we have an invalid render, clear it
	            rendered.$childScope.$destroy();
	            rendered.$el.remove();
	            this.rendered = null;
	          } else {
	            // our previous render is still valid, keep it
	            return;
	          }
	        }
	
	        if (!templateToRender || !$scope || !$element) {
	          // we either have nothing to render, or we can't render
	          return;
	        }
	
	        var $childScope = $scope.$new();
	        var $el = $element.find('#template_wrapper').html(templateToRender).contents();
	        $compile($el)($childScope);
	
	        this.rendered = { $childScope: $childScope, $el: $el, key: currentKey };
	      }
	    }]);
	
	    return KbnTopNavController;
	  })();
	};
	
	module.exports = exports['default'];

/***/ },
/* 470 */
/***/ function(module, exports) {

	module.exports = "<kbn-timepicker\n  from=\"timefilter.time.from\"\n  to=\"timefilter.time.to\"\n  mode=\"timefilter.time.mode\"\n  active-tab=\"'filter'\"\n  interval=\"timefilter.refreshInterval\"\n  on-filter-select=\"updateFilter(from, to)\"\n  on-interval-select=\"updateInterval(interval)\">\n</kbn-timepicker>\n"

/***/ },
/* 471 */
/***/ function(module, exports) {

	module.exports = "<kbn-timepicker\n  from=\"timefilter.time.from\"\n  to=\"timefilter.time.to\"\n  mode=\"timefilter.time.mode\"\n  active-tab=\"'interval'\"\n  interval=\"timefilter.refreshInterval\"\n  on-filter-select=\"updateFilter(from, to)\"\n  on-interval-select=\"updateInterval(interval)\">\n</kbn-timepicker>\n"

/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _uiRegistry_registry = __webpack_require__(446);
	
	var _uiRegistry_registry2 = _interopRequireDefault(_uiRegistry_registry);
	
	exports['default'] = (0, _uiRegistry_registry2['default'])({
	  name: 'navbarExtensions',
	  index: ['name'],
	  group: ['appName'],
	  order: ['order']
	});
	module.exports = exports['default'];

/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiChromeChrome = __webpack_require__(1);
	
	var _uiChromeChrome2 = _interopRequireDefault(_uiChromeChrome);
	
	var _bread_crumbsHtml = __webpack_require__(474);
	
	var _bread_crumbsHtml2 = _interopRequireDefault(_bread_crumbsHtml);
	
	var _bread_crumb_urls = __webpack_require__(475);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('breadCrumbs', function ($location) {
	  return {
	    restrict: 'E',
	    replace: true,
	    scope: {
	      omitCurrentPage: '=',
	      /**
	       * Pages to omit from the breadcrumbs. Should be lower-case.
	       * @type {Array}
	       */
	      omitPages: '=',
	      /**
	       * Optional title to append at the end of the breadcrumbs. Note that this can't just be
	       * 'title', because that will be interpreted by browsers as an actual 'title' HTML attribute.
	       * @type {String}
	       */
	      pageTitle: '=',
	      /**
	       * If true, makes each breadcrumb a clickable link.
	       * @type {String}
	       */
	      useLinks: '='
	    },
	    template: _bread_crumbsHtml2['default'],
	    controller: function controller($scope) {
	      var breadcrumbs = _uiChromeChrome2['default'].getBreadcrumbs();
	
	      if ($scope.useLinks) {
	        var url = '#' + $location.path();
	        $scope.breadcrumbs = (0, _bread_crumb_urls.getBreadCrumbUrls)(breadcrumbs, url);
	      } else {
	        $scope.breadcrumbs = breadcrumbs.map(function (path) {
	          return {
	            path: path,
	            title: _lodash2['default'].startCase(path)
	          };
	        });
	      }
	      if ($scope.omitCurrentPage === true) {
	        $scope.breadcrumbs.pop();
	      }
	    }
	  };
	});

/***/ },
/* 474 */
/***/ function(module, exports) {

	module.exports = "<div class=\"kuiLocalBreadcrumbs\" data-test-subj=\"breadcrumbs\">\n  <div\n    class=\"kuiLocalBreadcrumb\"\n    ng-if=\"useLinks && (!omitPages || !omitPages.includes(breadcrumb.path))\"\n    ng-repeat=\"breadcrumb in breadcrumbs\"\n  >\n    <a\n      class=\"kuiLocalBreadcrumb__link\"\n      href=\"{{breadcrumb.url}}\"\n    >\n      {{breadcrumb.title}}\n    </a>\n  </div>\n\n  <div\n    class=\"kuiLocalBreadcrumb\"\n    ng-if=\"!useLinks && (!omitPages || !omitPages.includes(breadcrumb.path))\"\n    ng-repeat=\"breadcrumb in breadcrumbs\"\n  >\n    {{ breadcrumb.title }}\n  </div>\n\n  <div\n    class=\"kuiLocalBreadcrumb\"\n    ng-if=\"pageTitle\"\n  >\n    {{ pageTitle }}\n  </div>\n</div>\n"

/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.getBreadCrumbUrls = getBreadCrumbUrls;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	/**
	 * @typedef BreadCrumbUrl {Object}
	 * @property title {String} the display title for the breadcrumb
	 * @property path {String} the subdirectory for this particular breadcrumb
	 * @property url {String} a url for the breadcrumb
	 */
	
	/**
	 *
	 * @param {Array.<String>} breadcrumbs An array of breadcrumbs for the given url.
	 * @param {String} url The current url that the breadcrumbs have been generated for
	 * @returns {Array.<BreadCrumbUrl> An array comprised of objects that
	 * will contain both the url for the given breadcrumb, as well as the breadcrumb the url
	 * was generated for.
	 */
	
	function getBreadCrumbUrls(breadcrumbs, url) {
	  // the url should not have a slash on the end or else the route will not be properly built
	  var urlBase = url.replace(/\/+$/, '').replace(breadcrumbs.join('/'), '');
	  return breadcrumbs.map(function (path, index) {
	    return {
	      path: path,
	      title: _lodash2['default'].startCase(path),
	      url: urlBase + breadcrumbs.slice(0, index + 1).join('/')
	    };
	  });
	}

/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = BoundToConfigObjProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function BoundToConfigObjProvider(config) {
	
	  /**
	   * Create an object with properties that may be bound to config values.
	   * The input object is basically cloned unless one of it's own properties
	   * resolved to a string value that starts with an equal sign. When that is
	   * found, that property is forever bound to the corresponding config key.
	   *
	   * example:
	   *
	   * // name is cloned, height is bound to the defaultHeight config key
	   * { name: 'john', height: '=defaultHeight' };
	   *
	   * @param  {Object} input
	   * @return {Object}
	   */
	  function BoundToConfigObj(input) {
	    var self = this;
	
	    _lodash2['default'].forOwn(input, function (value, prop) {
	      if (!_lodash2['default'].isString(value) || value.charAt(0) !== '=') {
	        self[prop] = value;
	        return;
	      }
	
	      var configKey = value.substr(1);
	
	      config.watch(configKey, function update(value) {
	        self[prop] = value;
	      });
	    });
	  }
	
	  return BoundToConfigObj;
	}
	
	module.exports = exports['default'];

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	__webpack_require__(478);
	
	__webpack_require__(391);
	
	__webpack_require__(481);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	var _data_sourceDoc_source = __webpack_require__(543);
	
	var _data_sourceDoc_source2 = _interopRequireDefault(_data_sourceDoc_source);
	
	var _data_sourceSearch_source = __webpack_require__(546);
	
	var _data_sourceSearch_source2 = _interopRequireDefault(_data_sourceSearch_source);
	
	var _fetchStrategySearch = __webpack_require__(555);
	
	var _fetchStrategySearch2 = _interopRequireDefault(_fetchStrategySearch);
	
	var _request_queue = __webpack_require__(508);
	
	var _request_queue2 = _interopRequireDefault(_request_queue);
	
	var _error_handlers = __webpack_require__(517);
	
	var _error_handlers2 = _interopRequireDefault(_error_handlers);
	
	var _fetch = __webpack_require__(509);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _looperDoc_data = __webpack_require__(559);
	
	var _looperDoc_data2 = _interopRequireDefault(_looperDoc_data);
	
	var _looperDoc_admin = __webpack_require__(561);
	
	var _looperDoc_admin2 = _interopRequireDefault(_looperDoc_admin);
	
	var _looperSearch = __webpack_require__(562);
	
	var _looperSearch2 = _interopRequireDefault(_looperSearch);
	
	var _data_source_root_search_source = __webpack_require__(553);
	
	var _data_source_root_search_source2 = _interopRequireDefault(_data_source_root_search_source);
	
	var _saved_object = __webpack_require__(563);
	
	var _saved_object2 = _interopRequireDefault(_saved_object);
	
	var _redirect_when_missing = __webpack_require__(583);
	
	var _redirect_when_missing2 = _interopRequireDefault(_redirect_when_missing);
	
	_uiModules2['default'].get('kibana/courier').service('courier', function ($rootScope, Private, Promise, indexPatterns) {
	  function Courier() {
	    var self = this;
	
	    var DocSource = Private(_data_sourceDoc_source2['default']);
	    var SearchSource = Private(_data_sourceSearch_source2['default']);
	    var searchStrategy = Private(_fetchStrategySearch2['default']);
	
	    var requestQueue = Private(_request_queue2['default']);
	    var errorHandlers = Private(_error_handlers2['default']);
	
	    var fetch = Private(_fetch2['default']);
	    var docDataLooper = self.docLooper = Private(_looperDoc_data2['default']);
	    var docAdminLooper = self.docLooper = Private(_looperDoc_admin2['default']);
	    var searchLooper = self.searchLooper = Private(_looperSearch2['default']);
	
	    // expose some internal modules
	    self.setRootSearchSource = Private(_data_source_root_search_source2['default']).set;
	
	    self.SavedObject = Private(_saved_object2['default']);
	    self.indexPatterns = indexPatterns;
	    self.redirectWhenMissing = Private(_redirect_when_missing2['default']);
	
	    self.DocSource = DocSource;
	    self.SearchSource = SearchSource;
	
	    var HastyRefresh = _uiErrors2['default'].HastyRefresh;
	
	    /**
	     * update the time between automatic search requests
	     *
	     * @chainable
	     */
	    self.fetchInterval = function (ms) {
	      searchLooper.ms(ms);
	      return this;
	    };
	
	    /**
	     * Start fetching search requests on an interval
	     * @chainable
	     */
	    self.start = function () {
	      searchLooper.start();
	      docDataLooper.start();
	      docAdminLooper.start();
	      return this;
	    };
	
	    /**
	     * Process the pending request queue right now, returns
	     * a promise that resembles the success of the fetch completing,
	     * individual errors are routed to their respective requests.
	     */
	    self.fetch = function () {
	      fetch.fetchQueued(searchStrategy).then(function () {
	        searchLooper.restart();
	      });
	    };
	
	    /**
	     * is the currior currently fetching search
	     * results automatically?
	     *
	     * @return {boolean}
	     */
	    self.started = function () {
	      return searchLooper.started();
	    };
	
	    /**
	     * stop the courier from fetching more search
	     * results, does not stop vaidating docs.
	     *
	     * @chainable
	     */
	    self.stop = function () {
	      searchLooper.stop();
	      return this;
	    };
	
	    /**
	     * create a source object that is a child of this courier
	     *
	     * @param {string} type - the type of Source to create
	     */
	    self.createSource = function (type) {
	      switch (type) {
	        case 'doc':
	          return new DocSource();
	        case 'search':
	          return new SearchSource();
	      }
	    };
	
	    /**
	     * Abort all pending requests
	     * @return {[type]} [description]
	     */
	    self.close = function () {
	      searchLooper.stop();
	      docAdminLooper.stop();
	      docDataLooper.stop();
	
	      _lodash2['default'].invoke(requestQueue, 'abort');
	
	      if (requestQueue.length) {
	        throw new Error('Aborting all pending requests failed.');
	      }
	    };
	
	    // Listen for refreshInterval changes
	    $rootScope.$watchCollection('timefilter.refreshInterval', function () {
	      var refreshValue = _lodash2['default'].get($rootScope, 'timefilter.refreshInterval.value');
	      var refreshPause = _lodash2['default'].get($rootScope, 'timefilter.refreshInterval.pause');
	      if (_lodash2['default'].isNumber(refreshValue) && !refreshPause) {
	        self.fetchInterval(refreshValue);
	      } else {
	        self.fetchInterval(0);
	      }
	    });
	
	    var onFatalDefer = Promise.defer();
	    onFatalDefer.promise.then(self.close);
	    _uiNotifyNotifier2['default'].fatalCallbacks.push(onFatalDefer.resolve);
	  }
	
	  return new Courier();
	});

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name es
	 *
	 * @description This is the result of calling esFactory. esFactory is exposed by the
	 * elasticsearch.angular.js client.
	 */
	
	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	__webpack_require__(479);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var plugins = [function (Client, config) {
	  // esFactory automatically injects the AngularConnector to the config
	  // https://github.com/elastic/elasticsearch-js/blob/master/src/lib/connectors/angular.js
	
	  var CustomAngularConnector = (function (_config$connectionClass) {
	    _inherits(CustomAngularConnector, _config$connectionClass);
	
	    function CustomAngularConnector() {
	      _classCallCheck(this, CustomAngularConnector);
	
	      _get(Object.getPrototypeOf(CustomAngularConnector.prototype), 'constructor', this).apply(this, arguments);
	
	      this.request = _lodash2['default'].wrap(this.request, function (request, params, cb) {
	        if (String(params.method).toUpperCase() === 'GET') {
	          params.query = _lodash2['default'].defaults({ _: Date.now() }, params.query);
	        }
	
	        return request.call(this, params, cb);
	      });
	    }
	
	    return CustomAngularConnector;
	  })(config.connectionClass);
	
	  config.connectionClass = CustomAngularConnector;
	}];
	
	_uiModules2['default'].get('kibana', ['elasticsearch', 'kibana/config'])
	
	//Elasticsearch client used for requesting data.  Connects to the /elasticsearch proxy,
	//Uses a tribe node if configured, otherwise uses the base elasticsearch configuration
	.service('es', function (esFactory, esUrl, esApiVersion, esRequestTimeout) {
	  return esFactory({
	    host: esUrl,
	    log: 'info',
	    requestTimeout: esRequestTimeout,
	    apiVersion: esApiVersion,
	    plugins: plugins
	  });
	})
	
	//Elasticsearch client used for managing Kibana's state.  Connects to the /es-admin proxy,
	//Always uses the base elasticsearch configuartion
	.service('esAdmin', function (esFactory, esAdminUrl, esApiVersion, esRequestTimeout) {
	  return esFactory({
	    host: esAdminUrl,
	    log: 'info',
	    requestTimeout: esRequestTimeout,
	    apiVersion: esApiVersion,
	    plugins: plugins
	  });
	});

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(17);
	module.exports = __webpack_require__(480);
	__webpack_require__(24).get('kibana', ['elasticsearch']);


/***/ },
/* 480 */
/***/ function(module, exports) {

	/*! elasticsearch - v13.0.0-beta2 - 2017-02-22
	 * http://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html
	 * Copyright (c) 2017 Elasticsearch BV; Licensed Apache-2.0 */
	
	;(function () {
	/* prevent lodash from detecting external amd loaders */var define; 
	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Wrapper for the elasticsearch.js client, which will register the client constructor
		 * as a factory within angular that can be easily injected with Angular's awesome DI.
		 *
		 * It will also instruct the client to use Angular's $http service for it's ajax requests
		 */
		var AngularConnector = __webpack_require__(2);
		var Client = __webpack_require__(30);
	
		process.angular_build = true;
	
		/* global angular */
		angular.module('elasticsearch', [])
		  .factory('esFactory', ['$injector', '$q', function ($injector, $q) {
	
		    var factory = function (config) {
		      config = config || {};
		      config.connectionClass = AngularConnector;
		      config.$injector = $injector;
		      config.defer = function () {
		        return $q.defer();
		      };
		      config.serializer = config.serializer || 'angular';
		      return new Client(config);
		    };
	
		    factory.errors = __webpack_require__(29);
		    factory.ConnectionPool = __webpack_require__(35);
		    factory.Transport = __webpack_require__(31);
	
		    return factory;
		  }]);
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		// shim for using process in browser
		var process = module.exports = {};
	
		// cached from whatever global is present so that test runners that stub it
		// don't break things.  But we need to wrap it in a try catch in case it is
		// wrapped in strict mode code which doesn't define any globals.  It's inside a
		// function because try/catches deoptimize in certain engines.
	
		var cachedSetTimeout;
		var cachedClearTimeout;
	
		function defaultSetTimout() {
		    throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout () {
		    throw new Error('clearTimeout has not been defined');
		}
		(function () {
		    try {
		        if (typeof setTimeout === 'function') {
		            cachedSetTimeout = setTimeout;
		        } else {
		            cachedSetTimeout = defaultSetTimout;
		        }
		    } catch (e) {
		        cachedSetTimeout = defaultSetTimout;
		    }
		    try {
		        if (typeof clearTimeout === 'function') {
		            cachedClearTimeout = clearTimeout;
		        } else {
		            cachedClearTimeout = defaultClearTimeout;
		        }
		    } catch (e) {
		        cachedClearTimeout = defaultClearTimeout;
		    }
		} ())
		function runTimeout(fun) {
		    if (cachedSetTimeout === setTimeout) {
		        //normal enviroments in sane situations
		        return setTimeout(fun, 0);
		    }
		    // if setTimeout wasn't available but was latter defined
		    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		        cachedSetTimeout = setTimeout;
		        return setTimeout(fun, 0);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedSetTimeout(fun, 0);
		    } catch(e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		            return cachedSetTimeout.call(null, fun, 0);
		        } catch(e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		            return cachedSetTimeout.call(this, fun, 0);
		        }
		    }
	
	
		}
		function runClearTimeout(marker) {
		    if (cachedClearTimeout === clearTimeout) {
		        //normal enviroments in sane situations
		        return clearTimeout(marker);
		    }
		    // if clearTimeout wasn't available but was latter defined
		    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		        cachedClearTimeout = clearTimeout;
		        return clearTimeout(marker);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedClearTimeout(marker);
		    } catch (e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		            return cachedClearTimeout.call(null, marker);
		        } catch (e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		            return cachedClearTimeout.call(this, marker);
		        }
		    }
	
	
	
		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
	
		function cleanUpNextTick() {
		    if (!draining || !currentQueue) {
		        return;
		    }
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}
	
		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = runTimeout(cleanUpNextTick);
		    draining = true;
	
		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    runClearTimeout(timeout);
		}
	
		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        runTimeout(drainQueue);
		    }
		};
	
		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
	
		function noop() {}
	
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
	
		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};
	
		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Connection that registers a module with angular, using angular's $http service
		 * to communicate with ES.
		 *
		 * @class connections.Angular
		 */
		module.exports = AngularConnector;
	
		var _ = __webpack_require__(3);
		var ConnectionAbstract = __webpack_require__(16);
		var ConnectionFault = __webpack_require__(29).ConnectionFault;
	
		function AngularConnector(host, config) {
		  ConnectionAbstract.call(this, host, config);
	
		  var self = this;
		  config.$injector.invoke(['$http', '$q', function ($http, $q) {
		    self.$q = $q;
		    self.$http = $http;
		  }]);
	
		}
		_.inherits(AngularConnector, ConnectionAbstract);
	
		AngularConnector.prototype.request = function (params, cb) {
		  var abort = this.$q.defer();
	
		  this.$http({
		    method: params.method,
		    url: this.host.makeUrl(params),
		    data: params.body,
		    cache: false,
		    headers: this.host.getHeaders(params.headers),
		    transformRequest: [],
		    transformResponse: [],
		    // not actually for timing out, that's handled by the transport
		    timeout: abort.promise
		  }).then(function (response) {
		    cb(null, response.data, response.status, response.headers());
		  }, function (err) {
		    if (err.status) {
		      cb(null, err.data, err.status, err.headers());
		    } else {
		      cb(new ConnectionFault(err.message));
		    }
		  });
	
		  return function () {
		    abort.resolve();
		  };
		};
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process, Buffer) {var path = __webpack_require__(8);
		var nodeUtils = __webpack_require__(9);
		var lodash = __webpack_require__(12);
	
		/**
		 * Custom utils library, basically a modified version of [lodash](http://lodash.com/docs) +
		 * [node.utils](http://nodejs.org/api/util.html#util_util) that doesn't use mixins to prevent
		 * confusion when requiring lodash itself.
		 *
		 * @class utils
		 * @static
		 */
		var _ = lodash.assign({}, lodash, nodeUtils);
	
		/**
		 * Link to [path.join](http://nodejs.org/api/path.html#path_path_join_path1_path2)
		 *
		 * @method _.joinPath
		 * @type {function}
		 */
		_.joinPath = path.join;
	
		_.get = __webpack_require__(14);
		_.trimEnd = __webpack_require__(15);
	
		/**
		 * Recursively merge two objects, walking into each object and concating arrays. If both to and from have a value at a
		 * key, but the values' types don't match to's value is left unmodified. Only Array and Object values are merged - that
		 * it to say values with a typeof "object"
		 *
		 * @param  {Object} to - Object to merge into (no cloning, the original object
		 *   is modified)
		 * @param  {Object} from - Object to pull changed from
		 * @return {Object} - returns the modified to value
		 */
		_.deepMerge = function (to, from) {
		  _.each(from, function (fromVal, key) {
		    switch (typeof to[key]) {
		      case 'undefined':
		        to[key] = from[key];
		        break;
		      case 'object':
		        if (_.isArray(to[key]) && _.isArray(from[key])) {
		          to[key] = to[key].concat(from[key]);
		        }
		        else if (_.isPlainObject(to[key]) && _.isPlainObject(from[key])) {
		          _.deepMerge(to[key], from[key]);
		        }
		    }
		  });
		  return to;
		};
	
		/**
		 * Test if a value is an array and it's contents are of a specific type
		 *
		 * @method isArrayOf<Strings|Object|Array|Finite|Function|RegExp>s
		 * @param  {Array} arr - An array to check
		 * @return {Boolean}
		 */
		_.each([
		  'String',
		  'Object',
		  'PlainObject',
		  'Array',
		  'Finite',
		  'Function',
		  'RegExp'
		], function (type) {
		  var check = _['is' + type];
	
		  _['isArrayOf' + type + 's'] = function (arr) {
		    // quick shallow check of arrays
		    return _.isArray(arr) && _.every(arr.slice(0, 10), check);
		  };
		});
	
	
		/**
		 * Capitalize the first letter of a word
		 *
		 * @method  ucfirst
		 * @param  {string} word - The word to transform
		 * @return {string}
		 */
		_.ucfirst = function (word) {
		  return word[0].toUpperCase() + word.substring(1).toLowerCase();
		};
	
		/**
		 * Base algo for studlyCase and camelCase
		 * @param  {boolean} firstWordCap - Should the first character of the first word be capitalized
		 * @return {Function}
		 */
		function adjustWordCase(firstWordCap, otherWordsCap, sep) {
		  return function (string) {
		    var i = 0;
		    var words = [];
		    var word = '';
		    var code, c, upper, lower;
	
		    for (; i < string.length; i++) {
		      code = string.charCodeAt(i);
		      c = string.charAt(i);
		      lower = (code >= 97 && code <= 122) || (code >= 48 && code <= 57);
		      upper = code >= 65 && code <= 90;
	
		      if (upper || !lower) {
		        // new word
		        if (word.length) {
		          words.push(word);
		        }
		        word = '';
		      }
	
		      if (upper || lower) {
		        if (lower && word.length) {
		          word += c;
		        } else {
		          if ((!words.length && firstWordCap) || (words.length && otherWordsCap)) {
		            word = c.toUpperCase();
		          }
		          else {
		            word = c.toLowerCase();
		          }
		        }
		      }
		    }
		    if (word.length) {
		      words.push(word);
		    }
		    // add the leading underscore back to strings the had it originally
		    if (words.length && string.charAt(0) === '_') {
		      words[0] = '_' + words[0];
		    }
		    return words.join(sep);
		  };
		}
	
		/**
		 * Transform a string into StudlyCase
		 *
		 * @method studlyCase
		 * @param  {String} string
		 * @return {String}
		 */
		_.studlyCase = adjustWordCase(true, true, '');
	
		/**
		 * Transform a string into camelCase
		 *
		 * @method camelCase
		 * @param  {String} string
		 * @return {String}
		 */
		_.camelCase = adjustWordCase(false, true, '');
	
		/**
		 * Transform a string into snakeCase
		 *
		 * @method snakeCase
		 * @param  {String} string
		 * @return {String}
		 */
		_.snakeCase = adjustWordCase(false, false, '_');
	
		/**
		 * Lower-case a string, and return an empty string if any is not a string
		 *
		 * @param any {*} - Something or nothing
		 * @returns {string}
		 */
		_.toLowerString = function (any) {
		  if (any) {
		    if (typeof any !== 'string') {
		      any = any.toString();
		    }
		  } else {
		    any = '';
		  }
		  return any.toLowerCase();
		};
	
		/**
		 * Upper-case the string, return an empty string if any is not a string
		 *
		 * @param any {*} - Something or nothing
		 * @returns {string}
		 */
		_.toUpperString = function (any) {
		  if (any) {
		    if (typeof any !== 'string') {
		      any = any.toString();
		    }
		  } else {
		    any = '';
		  }
		  return any.toUpperCase();
		};
	
		/**
		 * Test if a value is "numeric" meaning that it can be transformed into something besides NaN
		 *
		 * @method isNumeric
		 * @param  {*} val
		 * @return {Boolean}
		 */
		_.isNumeric = function (val) {
		  return typeof val !== 'object' && val - parseFloat(val) >= 0;
		};
	
		// regexp to test for intervals
		var intervalRE = /^(\d+(?:\.\d+)?)(M|w|d|h|m|s|y|ms)$/;
	
		/**
		 * Test if a string represents an interval (eg. 1m, 2Y)
		 *
		 * @method isInterval
		 * @param {String} val
		 * @return {Boolean}
		 */
		_.isInterval = function (val) {
		  return !!(val.match && val.match(intervalRE));
		};
	
		/**
		 * Repeat a string n times
		 *
		 * @todo TestPerformance
		 * @method repeat
		 * @param {String} what - The string to repeat
		 * @param {Number} times - Times the string should be repeated
		 * @return {String}
		 */
		_.repeat = function (what, times) {
		  return (new Array(times + 1)).join(what);
		};
	
		/**
		 * Call a function, applying the arguments object to it in an optimized way, rather than always turning it into an array
		 *
		 * @param func {Function} - The function to execute
		 * @param context {*} - The context the function will be executed with
		 * @param args {Arguments} - The arguments to send to func
		 * @param [sliceIndex=0] {Integer} - The index that args should be sliced at, before feeding args to func
		 * @returns {*} - the return value of func
		 */
		_.applyArgs = function (func, context, args, sliceIndex) {
		  sliceIndex = sliceIndex || 0;
		  switch (args.length - sliceIndex) {
		    case 0:
		      return func.call(context);
		    case 1:
		      return func.call(context, args[0 + sliceIndex]);
		    case 2:
		      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);
		    case 3:
		      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex]);
		    case 4:
		      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex]);
		    case 5:
		      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex],
		      args[2 + sliceIndex], args[3 + sliceIndex], args[4 + sliceIndex]);
		    default:
		      return func.apply(context, Array.prototype.slice.call(args, sliceIndex));
		  }
		};
	
		/**
		 * Schedule a function to be called on the next tick, and supply it with these arguments
		 * when it is called.
		 * @return {[type]} [description]
		 */
		_.nextTick = function (cb) {
		  // bind the function and schedule it
		  process.nextTick(_.bindKey(_, 'applyArgs', cb, null, arguments, 1));
		};
	
		/**
		 * Marks a method as a handler. Currently this just makes a property on the method
		 * flagging it to be bound to the object at object creation when "makeBoundMethods" is called
		 *
		 * ```
		 * ClassName.prototype.methodName = _.handler(function () {
		 *   // this will always be bound when called via classInstance.bound.methodName
		 *   this === classInstance
		 * });
		 * ```
		 *
		 * @alias _.scheduled
		 * @param  {Function} func - The method that is being defined
		 * @return {Function}
		 */
		_.handler = function (func) {
		  func._provideBound = true;
		  return func;
		};
		_.scheduled = _.handler;
	
		/**
		 * Creates an "bound" property on an object, which all or a subset of methods from
		 * the object which are bound to the original object.
		 *
		 * ```
		 * var obj = {
		 *   onEvent: function () {}
		 * };
		 *
		 * _.makeBoundMethods(obj);
		 *
		 * obj.bound.onEvent() // is bound to obj, and can safely be used as an event handler.
		 * ```
		 *
		 * @param {Object} obj - The object to bind the methods to
		 */
		_.makeBoundMethods = function (obj) {
		  obj.bound = {};
		  for (var prop in obj) {
		    // dearest maintainer, we want to look through the prototype
		    if (typeof obj[prop] === 'function' && obj[prop]._provideBound === true) {
		      obj.bound[prop] = _.bind(obj[prop], obj);
		    }
		  }
		};
	
		_.noop = function () {};
	
		/**
		 * Implements the standard "string or constructor" check that I was copy/pasting everywhere
		 * @param  {String|Function} val - the value that the user passed in
		 * @param  {Object} opts - a map of the options
		 * @return {Function|undefined} - If a valid option was specified, then the constructor is returned
		 */
		_.funcEnum = function (config, name, opts, def) {
		  var val = config[name];
		  switch (typeof val) {
		    case 'undefined':
		      return opts[def];
		    case 'function':
		      return val;
		    case 'string':
		      if (opts.hasOwnProperty(val)) {
		        return opts[val];
		      }
		    /* falls through */
		    default:
		      var err = 'Invalid ' + name + ' "' + val + '", expected a function';
		      switch (_.size(opts)) {
		        case 0:
		          break;
		        case 1:
		          err += ' or ' + _.keys(opts)[0];
		          break;
		        default:
		          err += ' or one of ' + _.keys(opts).join(', ');
		          break;
		      }
		      throw new TypeError(err);
		  }
		};
	
		/**
		 * Accepts any object and attempts to convert it into an array. If the object passed in is not
		 * an array it will be wrapped in one. Then the transform/map function will be called for each element
		 * and create a new array that is returned. If the map function fails to return something, the loop is
		 * halted and false is returned instead of an array.
		 *
		 * @param  {*} input - The value to convert
		 * @param  {Function} transform - A function called for each element of the resulting array
		 * @return {Array|false} - an array on success, or false on failure.
		 */
		_.createArray = function (input, transform) {
		  transform = typeof transform === 'function' ? transform : _.identity;
		  var output = [];
		  var item;
		  var i;
	
		  if (!_.isArray(input)) {
		    input = [input];
		  }
	
		  for (i = 0; i < input.length; i++) {
		    item = transform(input[i]);
		    if (item === void 0) {
		      return false;
		    } else {
		      output.push(item);
		    }
		  }
		  return output;
		};
	
		/**
		 * Takes a WritableStream, and returns the chunks that have not successfully written, returning them as a string.
		 *
		 * ONLY WORKS FOR TEXT STREAMS
		 *
		 * @param  {WritableStream} stream - an instance of stream.Writable
		 * @return {string} - the remaining test to be written to the stream
		 */
		_.getUnwrittenFromStream = function (stream) {
		  var writeBuffer = _.getStreamWriteBuffer(stream);
		  if (!writeBuffer) return;
	
		  // flush the write buffer
		  var out = '';
		  if (!writeBuffer.length) return out;
	
		  _.each(writeBuffer, function (writeReq) {
		    if (writeReq.chunk) {
		      // 0.9.12+ uses WriteReq objects with a chunk prop
		      out += '' + writeReq.chunk;
		    } else if (_.isArray(writeReq) && (typeof writeReq[0] === 'string' || Buffer.isBuffer(writeReq[0]))) {
		      // 0.9.4 - 0.9.9 buffers are arrays of arrays like [[chunk, cb], [chunk, undef], ...].
		      out += '' + writeReq[0];
		    } else {
		      return false;
		    }
		  });
		  return out;
		};
	
		_.getStreamWriteBuffer = function (stream) {
		  if (!stream || !stream._writableState) return;
	
		  var writeState = stream._writableState;
	
		  if (writeState.getBuffer) {
		    return writeState.getBuffer();
		  } else if (writeState.buffer) {
		    return writeState.buffer;
		  }
		};
	
		_.clearWriteStreamBuffer = function (stream) {
		  var buffer = _.getStreamWriteBuffer(stream);
		  return buffer && buffer.splice(0);
		};
	
		/**
		 * return the current time in milliseconds since epoch
		 */
		_.now = function () {
		  return (typeof Date.now === 'function') ? Date.now() : (new Date()).getTime();
		};
	
		module.exports = _;
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(4).Buffer))
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
		 * @license  MIT
		 */
		/* eslint-disable no-proto */
	
		'use strict'
	
		var base64 = __webpack_require__(5)
		var ieee754 = __webpack_require__(6)
		var isArray = __webpack_require__(7)
	
		exports.Buffer = Buffer
		exports.SlowBuffer = SlowBuffer
		exports.INSPECT_MAX_BYTES = 50
	
		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Use Object implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * Due to various browser bugs, sometimes the Object implementation will be used even
		 * when the browser supports typed arrays.
		 *
		 * Note:
		 *
		 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
		 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
		 *
		 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
		 *
		 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
		 *     incorrect length in some situations.
	
		 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
		 * get the Object implementation, which is slower but behaves correctly.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
		  ? global.TYPED_ARRAY_SUPPORT
		  : typedArraySupport()
	
		/*
		 * Export kMaxLength after typed array support is determined.
		 */
		exports.kMaxLength = kMaxLength()
	
		function typedArraySupport () {
		  try {
		    var arr = new Uint8Array(1)
		    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
		    return arr.foo() === 42 && // typed array instances can be augmented
		        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
		        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
		  } catch (e) {
		    return false
		  }
		}
	
		function kMaxLength () {
		  return Buffer.TYPED_ARRAY_SUPPORT
		    ? 0x7fffffff
		    : 0x3fffffff
		}
	
		function createBuffer (that, length) {
		  if (kMaxLength() < length) {
		    throw new RangeError('Invalid typed array length')
		  }
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    that = new Uint8Array(length)
		    that.__proto__ = Buffer.prototype
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    if (that === null) {
		      that = new Buffer(length)
		    }
		    that.length = length
		  }
	
		  return that
		}
	
		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */
	
		function Buffer (arg, encodingOrOffset, length) {
		  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
		    return new Buffer(arg, encodingOrOffset, length)
		  }
	
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new Error(
		        'If encoding is specified then the first argument must be a string'
		      )
		    }
		    return allocUnsafe(this, arg)
		  }
		  return from(this, arg, encodingOrOffset, length)
		}
	
		Buffer.poolSize = 8192 // not used by this implementation
	
		// TODO: Legacy, not needed anymore. Remove in next major version.
		Buffer._augment = function (arr) {
		  arr.__proto__ = Buffer.prototype
		  return arr
		}
	
		function from (that, value, encodingOrOffset, length) {
		  if (typeof value === 'number') {
		    throw new TypeError('"value" argument must not be a number')
		  }
	
		  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
		    return fromArrayBuffer(that, value, encodingOrOffset, length)
		  }
	
		  if (typeof value === 'string') {
		    return fromString(that, value, encodingOrOffset)
		  }
	
		  return fromObject(that, value)
		}
	
		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(null, value, encodingOrOffset, length)
		}
	
		if (Buffer.TYPED_ARRAY_SUPPORT) {
		  Buffer.prototype.__proto__ = Uint8Array.prototype
		  Buffer.__proto__ = Uint8Array
		  if (typeof Symbol !== 'undefined' && Symbol.species &&
		      Buffer[Symbol.species] === Buffer) {
		    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
		    Object.defineProperty(Buffer, Symbol.species, {
		      value: null,
		      configurable: true
		    })
		  }
		}
	
		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be a number')
		  } else if (size < 0) {
		    throw new RangeError('"size" argument must not be negative')
		  }
		}
	
		function alloc (that, size, fill, encoding) {
		  assertSize(size)
		  if (size <= 0) {
		    return createBuffer(that, size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpretted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(that, size).fill(fill, encoding)
		      : createBuffer(that, size).fill(fill)
		  }
		  return createBuffer(that, size)
		}
	
		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(null, size, fill, encoding)
		}
	
		function allocUnsafe (that, size) {
		  assertSize(size)
		  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) {
		    for (var i = 0; i < size; ++i) {
		      that[i] = 0
		    }
		  }
		  return that
		}
	
		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(null, size)
		}
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(null, size)
		}
	
		function fromString (that, string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8'
		  }
	
		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('"encoding" must be a valid string encoding')
		  }
	
		  var length = byteLength(string, encoding) | 0
		  that = createBuffer(that, length)
	
		  var actual = that.write(string, encoding)
	
		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    that = that.slice(0, actual)
		  }
	
		  return that
		}
	
		function fromArrayLike (that, array) {
		  var length = array.length < 0 ? 0 : checked(array.length) | 0
		  that = createBuffer(that, length)
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}
	
		function fromArrayBuffer (that, array, byteOffset, length) {
		  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('\'offset\' is out of bounds')
		  }
	
		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('\'length\' is out of bounds')
		  }
	
		  if (byteOffset === undefined && length === undefined) {
		    array = new Uint8Array(array)
		  } else if (length === undefined) {
		    array = new Uint8Array(array, byteOffset)
		  } else {
		    array = new Uint8Array(array, byteOffset, length)
		  }
	
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    that = array
		    that.__proto__ = Buffer.prototype
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    that = fromArrayLike(that, array)
		  }
		  return that
		}
	
		function fromObject (that, obj) {
		  if (Buffer.isBuffer(obj)) {
		    var len = checked(obj.length) | 0
		    that = createBuffer(that, len)
	
		    if (that.length === 0) {
		      return that
		    }
	
		    obj.copy(that, 0, 0, len)
		    return that
		  }
	
		  if (obj) {
		    if ((typeof ArrayBuffer !== 'undefined' &&
		        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
		      if (typeof obj.length !== 'number' || isnan(obj.length)) {
		        return createBuffer(that, 0)
		      }
		      return fromArrayLike(that, obj)
		    }
	
		    if (obj.type === 'Buffer' && isArray(obj.data)) {
		      return fromArrayLike(that, obj.data)
		    }
		  }
	
		  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
		}
	
		function checked (length) {
		  // Note: cannot use `length < kMaxLength()` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= kMaxLength()) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
		  }
		  return length | 0
		}
	
		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0
		  }
		  return Buffer.alloc(+length)
		}
	
		Buffer.isBuffer = function isBuffer (b) {
		  return !!(b != null && b._isBuffer)
		}
	
		Buffer.compare = function compare (a, b) {
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError('Arguments must be Buffers')
		  }
	
		  if (a === b) return 0
	
		  var x = a.length
		  var y = b.length
	
		  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i]
		      y = b[i]
		      break
		    }
		  }
	
		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		}
	
		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		}
	
		Buffer.concat = function concat (list, length) {
		  if (!isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }
	
		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }
	
		  var i
		  if (length === undefined) {
		    length = 0
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length
		    }
		  }
	
		  var buffer = Buffer.allocUnsafe(length)
		  var pos = 0
		  for (i = 0; i < list.length; ++i) {
		    var buf = list[i]
		    if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    }
		    buf.copy(buffer, pos)
		    pos += buf.length
		  }
		  return buffer
		}
	
		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
		      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    string = '' + string
		  }
	
		  var len = string.length
		  if (len === 0) return 0
	
		  // Use a for loop to avoid recursion
		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		      case undefined:
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) return utf8ToBytes(string).length // assume utf8
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}
		Buffer.byteLength = byteLength
	
		function slowToString (encoding, start, end) {
		  var loweredCase = false
	
		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.
	
		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }
	
		  if (end === undefined || end > this.length) {
		    end = this.length
		  }
	
		  if (end <= 0) {
		    return ''
		  }
	
		  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0
		  start >>>= 0
	
		  if (end <= start) {
		    return ''
		  }
	
		  if (!encoding) encoding = 'utf8'
	
		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)
	
		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)
	
		      case 'ascii':
		        return asciiSlice(this, start, end)
	
		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)
	
		      case 'base64':
		        return base64Slice(this, start, end)
	
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)
	
		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase()
		        loweredCase = true
		    }
		  }
		}
	
		// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
		// Buffer instances.
		Buffer.prototype._isBuffer = true
	
		function swap (b, n, m) {
		  var i = b[n]
		  b[n] = b[m]
		  b[m] = i
		}
	
		Buffer.prototype.swap16 = function swap16 () {
		  var len = this.length
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (var i = 0; i < len; i += 2) {
		    swap(this, i, i + 1)
		  }
		  return this
		}
	
		Buffer.prototype.swap32 = function swap32 () {
		  var len = this.length
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (var i = 0; i < len; i += 4) {
		    swap(this, i, i + 3)
		    swap(this, i + 1, i + 2)
		  }
		  return this
		}
	
		Buffer.prototype.swap64 = function swap64 () {
		  var len = this.length
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (var i = 0; i < len; i += 8) {
		    swap(this, i, i + 7)
		    swap(this, i + 1, i + 6)
		    swap(this, i + 2, i + 5)
		    swap(this, i + 3, i + 4)
		  }
		  return this
		}
	
		Buffer.prototype.toString = function toString () {
		  var length = this.length | 0
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		}
	
		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		}
	
		Buffer.prototype.inspect = function inspect () {
		  var str = ''
		  var max = exports.INSPECT_MAX_BYTES
		  if (this.length > 0) {
		    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
		    if (this.length > max) str += ' ... '
		  }
		  return '<Buffer ' + str + '>'
		}
	
		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError('Argument must be a Buffer')
		  }
	
		  if (start === undefined) {
		    start = 0
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0
		  }
		  if (thisStart === undefined) {
		    thisStart = 0
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length
		  }
	
		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }
	
		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }
	
		  start >>>= 0
		  end >>>= 0
		  thisStart >>>= 0
		  thisEnd >>>= 0
	
		  if (this === target) return 0
	
		  var x = thisEnd - thisStart
		  var y = end - start
		  var len = Math.min(x, y)
	
		  var thisCopy = this.slice(thisStart, thisEnd)
		  var targetCopy = target.slice(start, end)
	
		  for (var i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i]
		      y = targetCopy[i]
		      break
		    }
		  }
	
		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		}
	
		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1
	
		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset
		    byteOffset = 0
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff
		  } else if (byteOffset < -0x80000000) {
		    byteOffset = -0x80000000
		  }
		  byteOffset = +byteOffset  // Coerce to Number.
		  if (isNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1)
		  }
	
		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0
		    else return -1
		  }
	
		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding)
		  }
	
		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF // Search for a byte value [0-255]
		    if (Buffer.TYPED_ARRAY_SUPPORT &&
		        typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
		  }
	
		  throw new TypeError('val must be string, number or Buffer')
		}
	
		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  var indexSize = 1
		  var arrLength = arr.length
		  var valLength = val.length
	
		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase()
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2
		      arrLength /= 2
		      valLength /= 2
		      byteOffset /= 2
		    }
		  }
	
		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }
	
		  var i
		  if (dir) {
		    var foundIndex = -1
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex
		        foundIndex = -1
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
		    for (i = byteOffset; i >= 0; i--) {
		      var found = true
		      for (var j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false
		          break
		        }
		      }
		      if (found) return i
		    }
		  }
	
		  return -1
		}
	
		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		}
	
		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		}
	
		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		}
	
		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0
		  var remaining = buf.length - offset
		  if (!length) {
		    length = remaining
		  } else {
		    length = Number(length)
		    if (length > remaining) {
		      length = remaining
		    }
		  }
	
		  // must be an even number of digits
		  var strLen = string.length
		  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
		  if (length > strLen / 2) {
		    length = strLen / 2
		  }
		  for (var i = 0; i < length; ++i) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16)
		    if (isNaN(parsed)) return i
		    buf[offset + i] = parsed
		  }
		  return i
		}
	
		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}
	
		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}
	
		function latin1Write (buf, string, offset, length) {
		  return asciiWrite(buf, string, offset, length)
		}
	
		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}
	
		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}
	
		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8'
		    length = this.length
		    offset = 0
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset
		    length = this.length
		    offset = 0
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset | 0
		    if (isFinite(length)) {
		      length = length | 0
		      if (encoding === undefined) encoding = 'utf8'
		    } else {
		      encoding = length
		      length = undefined
		    }
		  // legacy write(string, encoding, offset, length) - remove in v0.13
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }
	
		  var remaining = this.length - offset
		  if (length === undefined || length > remaining) length = remaining
	
		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }
	
		  if (!encoding) encoding = 'utf8'
	
		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)
	
		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)
	
		      case 'ascii':
		        return asciiWrite(this, string, offset, length)
	
		      case 'latin1':
		      case 'binary':
		        return latin1Write(this, string, offset, length)
	
		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)
	
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)
	
		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}
	
		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		}
	
		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}
	
		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end)
		  var res = []
	
		  var i = start
		  while (i < end) {
		    var firstByte = buf[i]
		    var codePoint = null
		    var bytesPerSequence = (firstByte > 0xEF) ? 4
		      : (firstByte > 0xDF) ? 3
		      : (firstByte > 0xBF) ? 2
		      : 1
	
		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint
	
		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1]
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          fourthByte = buf[i + 3]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint
		            }
		          }
		      }
		    }
	
		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD
		      bytesPerSequence = 1
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
		      codePoint = 0xDC00 | codePoint & 0x3FF
		    }
	
		    res.push(codePoint)
		    i += bytesPerSequence
		  }
	
		  return decodeCodePointsArray(res)
		}
	
		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000
	
		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }
	
		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = ''
		  var i = 0
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    )
		  }
		  return res
		}
	
		function asciiSlice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)
	
		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F)
		  }
		  return ret
		}
	
		function latin1Slice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)
	
		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i])
		  }
		  return ret
		}
	
		function hexSlice (buf, start, end) {
		  var len = buf.length
	
		  if (!start || start < 0) start = 0
		  if (!end || end < 0 || end > len) end = len
	
		  var out = ''
		  for (var i = start; i < end; ++i) {
		    out += toHex(buf[i])
		  }
		  return out
		}
	
		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end)
		  var res = ''
		  for (var i = 0; i < bytes.length; i += 2) {
		    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
		  }
		  return res
		}
	
		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length
		  start = ~~start
		  end = end === undefined ? len : ~~end
	
		  if (start < 0) {
		    start += len
		    if (start < 0) start = 0
		  } else if (start > len) {
		    start = len
		  }
	
		  if (end < 0) {
		    end += len
		    if (end < 0) end = 0
		  } else if (end > len) {
		    end = len
		  }
	
		  if (end < start) end = start
	
		  var newBuf
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    newBuf = this.subarray(start, end)
		    newBuf.__proto__ = Buffer.prototype
		  } else {
		    var sliceLen = end - start
		    newBuf = new Buffer(sliceLen, undefined)
		    for (var i = 0; i < sliceLen; ++i) {
		      newBuf[i] = this[i + start]
		    }
		  }
	
		  return newBuf
		}
	
		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}
	
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }
	
		  return val
		}
	
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length)
		  }
	
		  var val = this[offset + --byteLength]
		  var mul = 1
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul
		  }
	
		  return val
		}
	
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  return this[offset]
		}
	
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return this[offset] | (this[offset + 1] << 8)
		}
	
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return (this[offset] << 8) | this[offset + 1]
		}
	
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
	
		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		}
	
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
	
		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		}
	
		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }
		  mul *= 0x80
	
		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
		  return val
		}
	
		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
		  var i = byteLength
		  var mul = 1
		  var val = this[offset + --i]
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul
		  }
		  mul *= 0x80
	
		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
		  return val
		}
	
		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		}
	
		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset] | (this[offset + 1] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}
	
		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset + 1] | (this[offset] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}
	
		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
	
		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		}
	
		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
	
		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		}
	
		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, true, 23, 4)
		}
	
		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, false, 23, 4)
		}
	
		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, true, 52, 8)
		}
	
		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, false, 52, 8)
		}
	
		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}
	
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1
		    checkInt(this, value, offset, byteLength, maxBytes, 0)
		  }
	
		  var mul = 1
		  var i = 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }
	
		  return offset + byteLength
		}
	
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1
		    checkInt(this, value, offset, byteLength, maxBytes, 0)
		  }
	
		  var i = byteLength - 1
		  var mul = 1
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }
	
		  return offset + byteLength
		}
	
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  this[offset] = (value & 0xff)
		  return offset + 1
		}
	
		function objectWriteUInt16 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
		    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
		      (littleEndian ? i : 1 - i) * 8
		  }
		}
	
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}
	
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}
	
		function objectWriteUInt32 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffffffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
		    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
		  }
		}
	
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset + 3] = (value >>> 24)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 1] = (value >>> 8)
		    this[offset] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}
	
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}
	
		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)
	
		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }
	
		  var i = 0
		  var mul = 1
		  var sub = 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }
	
		  return offset + byteLength
		}
	
		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)
	
		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }
	
		  var i = byteLength - 1
		  var mul = 1
		  var sub = 0
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }
	
		  return offset + byteLength
		}
	
		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  if (value < 0) value = 0xff + value + 1
		  this[offset] = (value & 0xff)
		  return offset + 1
		}
	
		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}
	
		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}
	
		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 3] = (value >>> 24)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}
	
		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (value < 0) value = 0xffffffff + value + 1
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}
	
		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}
	
		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4)
		  return offset + 4
		}
	
		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		}
	
		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		}
	
		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8)
		  return offset + 8
		}
	
		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		}
	
		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		}
	
		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!start) start = 0
		  if (!end && end !== 0) end = this.length
		  if (targetStart >= target.length) targetStart = target.length
		  if (!targetStart) targetStart = 0
		  if (end > 0 && end < start) end = start
	
		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0
	
		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
		  // Are we oob?
		  if (end > this.length) end = this.length
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start
		  }
	
		  var len = end - start
		  var i
	
		  if (this === target && start < targetStart && targetStart < end) {
		    // descending copy from end
		    for (i = len - 1; i >= 0; --i) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
		    // ascending copy from start
		    for (i = 0; i < len; ++i) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, start + len),
		      targetStart
		    )
		  }
	
		  return len
		}
	
		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start
		      start = 0
		      end = this.length
		    } else if (typeof end === 'string') {
		      encoding = end
		      end = this.length
		    }
		    if (val.length === 1) {
		      var code = val.charCodeAt(0)
		      if (code < 256) {
		        val = code
		      }
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255
		  }
	
		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }
	
		  if (end <= start) {
		    return this
		  }
	
		  start = start >>> 0
		  end = end === undefined ? this.length : end >>> 0
	
		  if (!val) val = 0
	
		  var i
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val
		    }
		  } else {
		    var bytes = Buffer.isBuffer(val)
		      ? val
		      : utf8ToBytes(new Buffer(val, encoding).toString())
		    var len = bytes.length
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len]
		    }
		  }
	
		  return this
		}
	
		// HELPER FUNCTIONS
		// ================
	
		var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
		function base64clean (str) {
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '='
		  }
		  return str
		}
	
		function stringtrim (str) {
		  if (str.trim) return str.trim()
		  return str.replace(/^\s+|\s+$/g, '')
		}
	
		function toHex (n) {
		  if (n < 16) return '0' + n.toString(16)
		  return n.toString(16)
		}
	
		function utf8ToBytes (string, units) {
		  units = units || Infinity
		  var codePoint
		  var length = string.length
		  var leadSurrogate = null
		  var bytes = []
	
		  for (var i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i)
	
		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        }
	
		        // valid lead
		        leadSurrogate = codePoint
	
		        continue
		      }
	
		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		        leadSurrogate = codePoint
		        continue
		      }
	
		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		    }
	
		    leadSurrogate = null
	
		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint)
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }
	
		  return bytes
		}
	
		function asciiToBytes (str) {
		  var byteArray = []
		  for (var i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF)
		  }
		  return byteArray
		}
	
		function utf16leToBytes (str, units) {
		  var c, hi, lo
		  var byteArray = []
		  for (var i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break
	
		    c = str.charCodeAt(i)
		    hi = c >> 8
		    lo = c % 256
		    byteArray.push(lo)
		    byteArray.push(hi)
		  }
	
		  return byteArray
		}
	
		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}
	
		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i]
		  }
		  return i
		}
	
		function isnan (val) {
		  return val !== val // eslint-disable-line no-self-compare
		}
	
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		'use strict'
	
		exports.byteLength = byteLength
		exports.toByteArray = toByteArray
		exports.fromByteArray = fromByteArray
	
		var lookup = []
		var revLookup = []
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
		var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i]
		  revLookup[code.charCodeAt(i)] = i
		}
	
		revLookup['-'.charCodeAt(0)] = 62
		revLookup['_'.charCodeAt(0)] = 63
	
		function placeHoldersCount (b64) {
		  var len = b64.length
		  if (len % 4 > 0) {
		    throw new Error('Invalid string. Length must be a multiple of 4')
		  }
	
		  // the number of equal signs (place holders)
		  // if there are two placeholders, than the two characters before it
		  // represent one byte
		  // if there is only one, then the three characters before it represent 2 bytes
		  // this is just a cheap hack to not do indexOf twice
		  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
		}
	
		function byteLength (b64) {
		  // base64 is 4/3 + up to two characters of the original data
		  return b64.length * 3 / 4 - placeHoldersCount(b64)
		}
	
		function toByteArray (b64) {
		  var i, j, l, tmp, placeHolders, arr
		  var len = b64.length
		  placeHolders = placeHoldersCount(b64)
	
		  arr = new Arr(len * 3 / 4 - placeHolders)
	
		  // if there are placeholders, only get up to the last complete 4 chars
		  l = placeHolders > 0 ? len - 4 : len
	
		  var L = 0
	
		  for (i = 0, j = 0; i < l; i += 4, j += 3) {
		    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
		    arr[L++] = (tmp >> 16) & 0xFF
		    arr[L++] = (tmp >> 8) & 0xFF
		    arr[L++] = tmp & 0xFF
		  }
	
		  if (placeHolders === 2) {
		    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
		    arr[L++] = tmp & 0xFF
		  } else if (placeHolders === 1) {
		    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
		    arr[L++] = (tmp >> 8) & 0xFF
		    arr[L++] = tmp & 0xFF
		  }
	
		  return arr
		}
	
		function tripletToBase64 (num) {
		  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
		}
	
		function encodeChunk (uint8, start, end) {
		  var tmp
		  var output = []
		  for (var i = start; i < end; i += 3) {
		    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
		    output.push(tripletToBase64(tmp))
		  }
		  return output.join('')
		}
	
		function fromByteArray (uint8) {
		  var tmp
		  var len = uint8.length
		  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
		  var output = ''
		  var parts = []
		  var maxChunkLength = 16383 // must be multiple of 3
	
		  // go through the array every three bytes, we'll deal with trailing stuff later
		  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
		  }
	
		  // pad the end with zeros, but make sure to not forget the extra bytes
		  if (extraBytes === 1) {
		    tmp = uint8[len - 1]
		    output += lookup[tmp >> 2]
		    output += lookup[(tmp << 4) & 0x3F]
		    output += '=='
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
		    output += lookup[tmp >> 10]
		    output += lookup[(tmp >> 4) & 0x3F]
		    output += lookup[(tmp << 2) & 0x3F]
		    output += '='
		  }
	
		  parts.push(output)
	
		  return parts.join('')
		}
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var nBits = -7
		  var i = isLE ? (nBytes - 1) : 0
		  var d = isLE ? -1 : 1
		  var s = buffer[offset + i]
	
		  i += d
	
		  e = s & ((1 << (-nBits)) - 1)
		  s >>= (-nBits)
		  nBits += eLen
		  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
		  m = e & ((1 << (-nBits)) - 1)
		  e >>= (-nBits)
		  nBits += mLen
		  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
		  if (e === 0) {
		    e = 1 - eBias
		  } else if (e === eMax) {
		    return m ? NaN : ((s ? -1 : 1) * Infinity)
		  } else {
		    m = m + Math.pow(2, mLen)
		    e = e - eBias
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		}
	
		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
		  var i = isLE ? 0 : (nBytes - 1)
		  var d = isLE ? 1 : -1
		  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
		  value = Math.abs(value)
	
		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0
		    e = eMax
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2)
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--
		      c *= 2
		    }
		    if (e + eBias >= 1) {
		      value += rt / c
		    } else {
		      value += rt * Math.pow(2, 1 - eBias)
		    }
		    if (value * c >= 2) {
		      e++
		      c /= 2
		    }
	
		    if (e + eBias >= eMax) {
		      m = 0
		      e = eMax
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen)
		      e = e + eBias
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
		      e = 0
		    }
		  }
	
		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
		  e = (e << mLen) | m
		  eLen += mLen
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
		  buffer[offset + i - d] |= s * 128
		}
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		var toString = {}.toString;
	
		module.exports = Array.isArray || function (arr) {
		  return toString.call(arr) == '[object Array]';
		};
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
		// resolves . and .. elements in a path array with directory names there
		// must be no slashes, empty elements, or device names (c:\) in the array
		// (so also no leading and trailing slashes - it does not distinguish
		// relative and absolute paths)
		function normalizeArray(parts, allowAboveRoot) {
		  // if the path tries to go above the root, `up` ends up > 0
		  var up = 0;
		  for (var i = parts.length - 1; i >= 0; i--) {
		    var last = parts[i];
		    if (last === '.') {
		      parts.splice(i, 1);
		    } else if (last === '..') {
		      parts.splice(i, 1);
		      up++;
		    } else if (up) {
		      parts.splice(i, 1);
		      up--;
		    }
		  }
	
		  // if the path is allowed to go above the root, restore leading ..s
		  if (allowAboveRoot) {
		    for (; up--; up) {
		      parts.unshift('..');
		    }
		  }
	
		  return parts;
		}
	
		// Split a filename into [root, dir, basename, ext], unix version
		// 'root' is just a slash, or nothing.
		var splitPathRe =
		    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
		var splitPath = function(filename) {
		  return splitPathRe.exec(filename).slice(1);
		};
	
		// path.resolve([from ...], to)
		// posix version
		exports.resolve = function() {
		  var resolvedPath = '',
		      resolvedAbsolute = false;
	
		  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
		    var path = (i >= 0) ? arguments[i] : process.cwd();
	
		    // Skip empty and invalid entries
		    if (typeof path !== 'string') {
		      throw new TypeError('Arguments to path.resolve must be strings');
		    } else if (!path) {
		      continue;
		    }
	
		    resolvedPath = path + '/' + resolvedPath;
		    resolvedAbsolute = path.charAt(0) === '/';
		  }
	
		  // At this point the path should be resolved to a full absolute path, but
		  // handle relative paths to be safe (might happen when process.cwd() fails)
	
		  // Normalize the path
		  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
		    return !!p;
		  }), !resolvedAbsolute).join('/');
	
		  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
		};
	
		// path.normalize(path)
		// posix version
		exports.normalize = function(path) {
		  var isAbsolute = exports.isAbsolute(path),
		      trailingSlash = substr(path, -1) === '/';
	
		  // Normalize the path
		  path = normalizeArray(filter(path.split('/'), function(p) {
		    return !!p;
		  }), !isAbsolute).join('/');
	
		  if (!path && !isAbsolute) {
		    path = '.';
		  }
		  if (path && trailingSlash) {
		    path += '/';
		  }
	
		  return (isAbsolute ? '/' : '') + path;
		};
	
		// posix version
		exports.isAbsolute = function(path) {
		  return path.charAt(0) === '/';
		};
	
		// posix version
		exports.join = function() {
		  var paths = Array.prototype.slice.call(arguments, 0);
		  return exports.normalize(filter(paths, function(p, index) {
		    if (typeof p !== 'string') {
		      throw new TypeError('Arguments to path.join must be strings');
		    }
		    return p;
		  }).join('/'));
		};
	
	
		// path.relative(from, to)
		// posix version
		exports.relative = function(from, to) {
		  from = exports.resolve(from).substr(1);
		  to = exports.resolve(to).substr(1);
	
		  function trim(arr) {
		    var start = 0;
		    for (; start < arr.length; start++) {
		      if (arr[start] !== '') break;
		    }
	
		    var end = arr.length - 1;
		    for (; end >= 0; end--) {
		      if (arr[end] !== '') break;
		    }
	
		    if (start > end) return [];
		    return arr.slice(start, end - start + 1);
		  }
	
		  var fromParts = trim(from.split('/'));
		  var toParts = trim(to.split('/'));
	
		  var length = Math.min(fromParts.length, toParts.length);
		  var samePartsLength = length;
		  for (var i = 0; i < length; i++) {
		    if (fromParts[i] !== toParts[i]) {
		      samePartsLength = i;
		      break;
		    }
		  }
	
		  var outputParts = [];
		  for (var i = samePartsLength; i < fromParts.length; i++) {
		    outputParts.push('..');
		  }
	
		  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
		  return outputParts.join('/');
		};
	
		exports.sep = '/';
		exports.delimiter = ':';
	
		exports.dirname = function(path) {
		  var result = splitPath(path),
		      root = result[0],
		      dir = result[1];
	
		  if (!root && !dir) {
		    // No dirname whatsoever
		    return '.';
		  }
	
		  if (dir) {
		    // It has a dirname, strip trailing slash
		    dir = dir.substr(0, dir.length - 1);
		  }
	
		  return root + dir;
		};
	
	
		exports.basename = function(path, ext) {
		  var f = splitPath(path)[2];
		  // TODO: make this comparison case-insensitive on windows?
		  if (ext && f.substr(-1 * ext.length) === ext) {
		    f = f.substr(0, f.length - ext.length);
		  }
		  return f;
		};
	
	
		exports.extname = function(path) {
		  return splitPath(path)[3];
		};
	
		function filter (xs, f) {
		    if (xs.filter) return xs.filter(f);
		    var res = [];
		    for (var i = 0; i < xs.length; i++) {
		        if (f(xs[i], i, xs)) res.push(xs[i]);
		    }
		    return res;
		}
	
		// String.prototype.substr - negative index don't work in IE8
		var substr = 'ab'.substr(-1) === 'b'
		    ? function (str, start, len) { return str.substr(start, len) }
		    : function (str, start, len) {
		        if (start < 0) start = str.length + start;
		        return str.substr(start, len);
		    }
		;
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
		var formatRegExp = /%[sdj%]/g;
		exports.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(' ');
		  }
	
		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x) {
		    if (x === '%%') return '%';
		    if (i >= len) return x;
		    switch (x) {
		      case '%s': return String(args[i++]);
		      case '%d': return Number(args[i++]);
		      case '%j':
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return '[Circular]';
		        }
		      default:
		        return x;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += ' ' + x;
		    } else {
		      str += ' ' + inspect(x);
		    }
		  }
		  return str;
		};
	
	
		// Mark that a method should not be used.
		// Returns a modified function which warns once by default.
		// If --no-deprecation is set, then it is a no-op.
		exports.deprecate = function(fn, msg) {
		  // Allow for deprecating things in the process of starting up.
		  if (isUndefined(global.process)) {
		    return function() {
		      return exports.deprecate(fn, msg).apply(this, arguments);
		    };
		  }
	
		  if (process.noDeprecation === true) {
		    return fn;
		  }
	
		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }
	
		  return deprecated;
		};
	
	
		var debugs = {};
		var debugEnviron;
		exports.debuglog = function(set) {
		  if (isUndefined(debugEnviron))
		    debugEnviron = process.env.NODE_DEBUG || '';
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
		      var pid = process.pid;
		      debugs[set] = function() {
		        var msg = exports.format.apply(exports, arguments);
		        console.error('%s %d: %s', set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {};
		    }
		  }
		  return debugs[set];
		};
	
	
		/**
		 * Echos the value of a value. Trys to print the value out
		 * in the best way possible given the different types.
		 *
		 * @param {Object} obj The object to print out.
		 * @param {Object} opts Optional options object that alters the output.
		 */
		/* legacy: obj, showHidden, depth, colors*/
		function inspect(obj, opts) {
		  // default options
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  // legacy...
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    // legacy...
		    ctx.showHidden = opts;
		  } else if (opts) {
		    // got an "options" object
		    exports._extend(ctx, opts);
		  }
		  // set default options
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports.inspect = inspect;
	
	
		// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
		inspect.colors = {
		  'bold' : [1, 22],
		  'italic' : [3, 23],
		  'underline' : [4, 24],
		  'inverse' : [7, 27],
		  'white' : [37, 39],
		  'grey' : [90, 39],
		  'black' : [30, 39],
		  'blue' : [34, 39],
		  'cyan' : [36, 39],
		  'green' : [32, 39],
		  'magenta' : [35, 39],
		  'red' : [31, 39],
		  'yellow' : [33, 39]
		};
	
		// Don't use 'blue' not visible on cmd.exe
		inspect.styles = {
		  'special': 'cyan',
		  'number': 'yellow',
		  'boolean': 'yellow',
		  'undefined': 'grey',
		  'null': 'bold',
		  'string': 'green',
		  'date': 'magenta',
		  // "name": intentionally not styling
		  'regexp': 'red'
		};
	
	
		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];
	
		  if (style) {
		    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
		           '\u001b[' + inspect.colors[style][1] + 'm';
		  } else {
		    return str;
		  }
		}
	
	
		function stylizeNoColor(str, styleType) {
		  return str;
		}
	
	
		function arrayToHash(array) {
		  var hash = {};
	
		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });
	
		  return hash;
		}
	
	
		function formatValue(ctx, value, recurseTimes) {
		  // Provide a hook for user-specified inspect functions.
		  // Check that value is an object with an inspect function on it
		  if (ctx.customInspect &&
		      value &&
		      isFunction(value.inspect) &&
		      // Filter out the util module, it's inspect function is special
		      value.inspect !== exports.inspect &&
		      // Also filter out any prototype objects using the circular check.
		      !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }
	
		  // Primitive types cannot have properties
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }
	
		  // Look up the keys of the object.
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);
	
		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }
	
		  // IE doesn't make error fields non-enumerable
		  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
		  if (isError(value)
		      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
		    return formatError(value);
		  }
	
		  // Some type of object without properties can be shortcutted.
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ': ' + value.name : '';
		      return ctx.stylize('[Function' + name + ']', 'special');
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), 'date');
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }
	
		  var base = '', array = false, braces = ['{', '}'];
	
		  // Make Array say that they are Array
		  if (isArray(value)) {
		    array = true;
		    braces = ['[', ']'];
		  }
	
		  // Make functions say that they are functions
		  if (isFunction(value)) {
		    var n = value.name ? ': ' + value.name : '';
		    base = ' [Function' + n + ']';
		  }
	
		  // Make RegExps say that they are RegExps
		  if (isRegExp(value)) {
		    base = ' ' + RegExp.prototype.toString.call(value);
		  }
	
		  // Make dates with properties first say the date
		  if (isDate(value)) {
		    base = ' ' + Date.prototype.toUTCString.call(value);
		  }
	
		  // Make error with message first say the error
		  if (isError(value)) {
		    base = ' ' + formatError(value);
		  }
	
		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }
	
		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    } else {
		      return ctx.stylize('[Object]', 'special');
		    }
		  }
	
		  ctx.seen.push(value);
	
		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }
	
		  ctx.seen.pop();
	
		  return reduceToSingleString(output, base, braces);
		}
	
	
		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize('undefined', 'undefined');
		  if (isString(value)) {
		    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
		                                             .replace(/'/g, "\\'")
		                                             .replace(/\\"/g, '"') + '\'';
		    return ctx.stylize(simple, 'string');
		  }
		  if (isNumber(value))
		    return ctx.stylize('' + value, 'number');
		  if (isBoolean(value))
		    return ctx.stylize('' + value, 'boolean');
		  // For some reason typeof null is "object", so special case here.
		  if (isNull(value))
		    return ctx.stylize('null', 'null');
		}
	
	
		function formatError(value) {
		  return '[' + Error.prototype.toString.call(value) + ']';
		}
	
	
		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          String(i), true));
		    } else {
		      output.push('');
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          key, true));
		    }
		  });
		  return output;
		}
	
	
		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize('[Getter/Setter]', 'special');
		    } else {
		      str = ctx.stylize('[Getter]', 'special');
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize('[Setter]', 'special');
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = '[' + key + ']';
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf('\n') > -1) {
		        if (array) {
		          str = str.split('\n').map(function(line) {
		            return '  ' + line;
		          }).join('\n').substr(2);
		        } else {
		          str = '\n' + str.split('\n').map(function(line) {
		            return '   ' + line;
		          }).join('\n');
		        }
		      }
		    } else {
		      str = ctx.stylize('[Circular]', 'special');
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify('' + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.substr(1, name.length - 2);
		      name = ctx.stylize(name, 'name');
		    } else {
		      name = name.replace(/'/g, "\\'")
		                 .replace(/\\"/g, '"')
		                 .replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, 'string');
		    }
		  }
	
		  return name + ': ' + str;
		}
	
	
		function reduceToSingleString(output, base, braces) {
		  var numLinesEst = 0;
		  var length = output.reduce(function(prev, cur) {
		    numLinesEst++;
		    if (cur.indexOf('\n') >= 0) numLinesEst++;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
		  }, 0);
	
		  if (length > 60) {
		    return braces[0] +
		           (base === '' ? '' : base + '\n ') +
		           ' ' +
		           output.join(',\n  ') +
		           ' ' +
		           braces[1];
		  }
	
		  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
		}
	
	
		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.
		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports.isArray = isArray;
	
		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports.isBoolean = isBoolean;
	
		function isNull(arg) {
		  return arg === null;
		}
		exports.isNull = isNull;
	
		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports.isNullOrUndefined = isNullOrUndefined;
	
		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports.isNumber = isNumber;
	
		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports.isString = isString;
	
		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports.isSymbol = isSymbol;
	
		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports.isUndefined = isUndefined;
	
		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === '[object RegExp]';
		}
		exports.isRegExp = isRegExp;
	
		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports.isObject = isObject;
	
		function isDate(d) {
		  return isObject(d) && objectToString(d) === '[object Date]';
		}
		exports.isDate = isDate;
	
		function isError(e) {
		  return isObject(e) &&
		      (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports.isError = isError;
	
		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports.isFunction = isFunction;
	
		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports.isPrimitive = isPrimitive;
	
		exports.isBuffer = __webpack_require__(10);
	
		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}
	
	
		function pad(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}
	
	
		var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
		              'Oct', 'Nov', 'Dec'];
	
		// 26 Feb 16:19:34
		function timestamp() {
		  var d = new Date();
		  var time = [pad(d.getHours()),
		              pad(d.getMinutes()),
		              pad(d.getSeconds())].join(':');
		  return [d.getDate(), months[d.getMonth()], time].join(' ');
		}
	
	
		// log is just a thin wrapper to console.log that prepends a timestamp
		exports.log = function() {
		  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
		};
	
	
		/**
		 * Inherit the prototype methods from one constructor into another.
		 *
		 * The Function.prototype.inherits from lang.js rewritten as a standalone
		 * function (not on Function.prototype). NOTE: If this file is to be loaded
		 * during bootstrapping this function needs to be rewritten using some native
		 * functions as prototype setup using normal JavaScript does not work as
		 * expected during bootstrapping (see mirror.js in r114903).
		 *
		 * @param {function} ctor Constructor function which needs to inherit the
		 *     prototype.
		 * @param {function} superCtor Constructor function to inherit prototype from.
		 */
		exports.inherits = __webpack_require__(11);
	
		exports._extend = function(origin, add) {
		  // Don't do anything if add isn't an object
		  if (!add || !isObject(add)) return origin;
	
		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};
	
		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}
	
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))
	
	/***/ },
	/* 10 */
	/***/ function(module, exports) {
	
		module.exports = function isBuffer(arg) {
		  return arg && typeof arg === 'object'
		    && typeof arg.copy === 'function'
		    && typeof arg.fill === 'function'
		    && typeof arg.readUInt8 === 'function';
		}
	
	/***/ },
	/* 11 */
	/***/ function(module, exports) {
	
		if (typeof Object.create === 'function') {
		  // implementation from standard node.js 'util' module
		  module.exports = function inherits(ctor, superCtor) {
		    ctor.super_ = superCtor
		    ctor.prototype = Object.create(superCtor.prototype, {
		      constructor: {
		        value: ctor,
		        enumerable: false,
		        writable: true,
		        configurable: true
		      }
		    });
		  };
		} else {
		  // old school shim for old browsers
		  module.exports = function inherits(ctor, superCtor) {
		    ctor.super_ = superCtor
		    var TempCtor = function () {}
		    TempCtor.prototype = superCtor.prototype
		    ctor.prototype = new TempCtor()
		    ctor.prototype.constructor = ctor
		  }
		}
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
		 * @license
		 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
		 * Build: `lodash -o ./dist/lodash.compat.js`
		 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
		 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
		 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		 * Available under MIT license <https://lodash.com/license>
		 */
		;(function() {
	
		  /** Used as a safe reference for `undefined` in pre ES5 environments */
		  var undefined;
	
		  /** Used to pool arrays and objects used internally */
		  var arrayPool = [],
		      objectPool = [];
	
		  /** Used to generate unique IDs */
		  var idCounter = 0;
	
		  /** Used internally to indicate various things */
		  var indicatorObject = {};
	
		  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
		  var keyPrefix = +new Date + '';
	
		  /** Used as the size when optimizations are enabled for large arrays */
		  var largeArraySize = 75;
	
		  /** Used as the max size of the `arrayPool` and `objectPool` */
		  var maxPoolSize = 40;
	
		  /** Used to detect and test whitespace */
		  var whitespace = (
		    // whitespace
		    ' \t\x0B\f\xA0\ufeff' +
	
		    // line terminators
		    '\n\r\u2028\u2029' +
	
		    // unicode category "Zs" space separators
		    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
		  );
	
		  /** Used to match empty string literals in compiled template source */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
		  /**
		   * Used to match ES6 template delimiters
		   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
		  /** Used to match regexp flags from their coerced string values */
		  var reFlags = /\w*$/;
	
		  /** Used to detected named functions */
		  var reFuncName = /^\s*function[ \n\r\t]+\w/;
	
		  /** Used to match "interpolate" template delimiters */
		  var reInterpolate = /<%=([\s\S]+?)%>/g;
	
		  /** Used to match leading whitespace and zeros to be removed */
		  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
	
		  /** Used to ensure capturing order of template delimiters */
		  var reNoMatch = /($^)/;
	
		  /** Used to detect functions containing a `this` reference */
		  var reThis = /\bthis\b/;
	
		  /** Used to match unescaped characters in compiled string literals */
		  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
	
		  /** Used to assign default `context` object properties */
		  var contextProps = [
		    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
		    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
		    'parseInt', 'setTimeout'
		  ];
	
		  /** Used to fix the JScript [[DontEnum]] bug */
		  var shadowedProps = [
		    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
		    'toLocaleString', 'toString', 'valueOf'
		  ];
	
		  /** Used to make template sourceURLs easier to identify */
		  var templateCounter = 0;
	
		  /** `Object#toString` result shortcuts */
		  var argsClass = '[object Arguments]',
		      arrayClass = '[object Array]',
		      boolClass = '[object Boolean]',
		      dateClass = '[object Date]',
		      errorClass = '[object Error]',
		      funcClass = '[object Function]',
		      numberClass = '[object Number]',
		      objectClass = '[object Object]',
		      regexpClass = '[object RegExp]',
		      stringClass = '[object String]';
	
		  /** Used to identify object classifications that `_.clone` supports */
		  var cloneableClasses = {};
		  cloneableClasses[funcClass] = false;
		  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
		  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
		  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
		  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
	
		  /** Used as an internal `_.debounce` options object */
		  var debounceOptions = {
		    'leading': false,
		    'maxWait': 0,
		    'trailing': false
		  };
	
		  /** Used as the property descriptor for `__bindData__` */
		  var descriptor = {
		    'configurable': false,
		    'enumerable': false,
		    'value': null,
		    'writable': false
		  };
	
		  /** Used as the data object for `iteratorTemplate` */
		  var iteratorData = {
		    'args': '',
		    'array': null,
		    'bottom': '',
		    'firstArg': '',
		    'init': '',
		    'keys': null,
		    'loop': '',
		    'shadowedProps': null,
		    'support': null,
		    'top': '',
		    'useHas': false
		  };
	
		  /** Used to determine if values are of the language type Object */
		  var objectTypes = {
		    'boolean': false,
		    'function': true,
		    'object': true,
		    'number': false,
		    'string': false,
		    'undefined': false
		  };
	
		  /** Used to escape characters for inclusion in compiled string literals */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\t': 't',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };
	
		  /** Used as a reference to the global object */
		  var root = (objectTypes[typeof window] && window) || this;
	
		  /** Detect free variable `exports` */
		  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
		  /** Detect free variable `module` */
		  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	
		  /** Detect the popular CommonJS extension `module.exports` */
		  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
	
		  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
		  var freeGlobal = objectTypes[typeof global] && global;
		  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
		    root = freeGlobal;
		  }
	
		  /*--------------------------------------------------------------------------*/
	
		  /**
		   * The base implementation of `_.indexOf` without support for binary searches
		   * or `fromIndex` constraints.
		   *
		   * @private
		   * @param {Array} array The array to search.
		   * @param {*} value The value to search for.
		   * @param {number} [fromIndex=0] The index to search from.
		   * @returns {number} Returns the index of the matched value or `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    var index = (fromIndex || 0) - 1,
		        length = array ? array.length : 0;
	
		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }
	
		  /**
		   * An implementation of `_.contains` for cache objects that mimics the return
		   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
		   *
		   * @private
		   * @param {Object} cache The cache object to inspect.
		   * @param {*} value The value to search for.
		   * @returns {number} Returns `0` if `value` is found, else `-1`.
		   */
		  function cacheIndexOf(cache, value) {
		    var type = typeof value;
		    cache = cache.cache;
	
		    if (type == 'boolean' || value == null) {
		      return cache[value] ? 0 : -1;
		    }
		    if (type != 'number' && type != 'string') {
		      type = 'object';
		    }
		    var key = type == 'number' ? value : keyPrefix + value;
		    cache = (cache = cache[type]) && cache[key];
	
		    return type == 'object'
		      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
		      : (cache ? 0 : -1);
		  }
	
		  /**
		   * Adds a given value to the corresponding cache object.
		   *
		   * @private
		   * @param {*} value The value to add to the cache.
		   */
		  function cachePush(value) {
		    var cache = this.cache,
		        type = typeof value;
	
		    if (type == 'boolean' || value == null) {
		      cache[value] = true;
		    } else {
		      if (type != 'number' && type != 'string') {
		        type = 'object';
		      }
		      var key = type == 'number' ? value : keyPrefix + value,
		          typeCache = cache[type] || (cache[type] = {});
	
		      if (type == 'object') {
		        (typeCache[key] || (typeCache[key] = [])).push(value);
		      } else {
		        typeCache[key] = true;
		      }
		    }
		  }
	
		  /**
		   * Used by `_.max` and `_.min` as the default callback when a given
		   * collection is a string value.
		   *
		   * @private
		   * @param {string} value The character to inspect.
		   * @returns {number} Returns the code unit of given character.
		   */
		  function charAtCallback(value) {
		    return value.charCodeAt(0);
		  }
	
		  /**
		   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
		   * them in ascending order.
		   *
		   * @private
		   * @param {Object} a The object to compare to `b`.
		   * @param {Object} b The object to compare to `a`.
		   * @returns {number} Returns the sort order indicator of `1` or `-1`.
		   */
		  function compareAscending(a, b) {
		    var ac = a.criteria,
		        bc = b.criteria,
		        index = -1,
		        length = ac.length;
	
		    while (++index < length) {
		      var value = ac[index],
		          other = bc[index];
	
		      if (value !== other) {
		        if (value > other || typeof value == 'undefined') {
		          return 1;
		        }
		        if (value < other || typeof other == 'undefined') {
		          return -1;
		        }
		      }
		    }
		    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		    // that causes it, under certain circumstances, to return the same value for
		    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
		    //
		    // This also ensures a stable sort in V8 and other engines.
		    // See http://code.google.com/p/v8/issues/detail?id=90
		    return a.index - b.index;
		  }
	
		  /**
		   * Creates a cache object to optimize linear searches of large arrays.
		   *
		   * @private
		   * @param {Array} [array=[]] The array to search.
		   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
		   */
		  function createCache(array) {
		    var index = -1,
		        length = array.length,
		        first = array[0],
		        mid = array[(length / 2) | 0],
		        last = array[length - 1];
	
		    if (first && typeof first == 'object' &&
		        mid && typeof mid == 'object' && last && typeof last == 'object') {
		      return false;
		    }
		    var cache = getObject();
		    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
	
		    var result = getObject();
		    result.array = array;
		    result.cache = cache;
		    result.push = cachePush;
	
		    while (++index < length) {
		      result.push(array[index]);
		    }
		    return result;
		  }
	
		  /**
		   * Used by `template` to escape characters for inclusion in compiled
		   * string literals.
		   *
		   * @private
		   * @param {string} match The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(match) {
		    return '\\' + stringEscapes[match];
		  }
	
		  /**
		   * Gets an array from the array pool or creates a new one if the pool is empty.
		   *
		   * @private
		   * @returns {Array} The array from the pool.
		   */
		  function getArray() {
		    return arrayPool.pop() || [];
		  }
	
		  /**
		   * Gets an object from the object pool or creates a new one if the pool is empty.
		   *
		   * @private
		   * @returns {Object} The object from the pool.
		   */
		  function getObject() {
		    return objectPool.pop() || {
		      'array': null,
		      'cache': null,
		      'criteria': null,
		      'false': false,
		      'index': 0,
		      'null': false,
		      'number': null,
		      'object': null,
		      'push': null,
		      'string': null,
		      'true': false,
		      'undefined': false,
		      'value': null
		    };
		  }
	
		  /**
		   * Checks if `value` is a DOM node in IE < 9.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
		   */
		  function isNode(value) {
		    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
		    // methods that are `typeof` "string" and still can coerce nodes to strings
		    return typeof value.toString != 'function' && typeof (value + '') == 'string';
		  }
	
		  /**
		   * Releases the given array back to the array pool.
		   *
		   * @private
		   * @param {Array} [array] The array to release.
		   */
		  function releaseArray(array) {
		    array.length = 0;
		    if (arrayPool.length < maxPoolSize) {
		      arrayPool.push(array);
		    }
		  }
	
		  /**
		   * Releases the given object back to the object pool.
		   *
		   * @private
		   * @param {Object} [object] The object to release.
		   */
		  function releaseObject(object) {
		    var cache = object.cache;
		    if (cache) {
		      releaseObject(cache);
		    }
		    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
		    if (objectPool.length < maxPoolSize) {
		      objectPool.push(object);
		    }
		  }
	
		  /**
		   * Slices the `collection` from the `start` index up to, but not including,
		   * the `end` index.
		   *
		   * Note: This function is used instead of `Array#slice` to support node lists
		   * in IE < 9 and to ensure dense arrays are returned.
		   *
		   * @private
		   * @param {Array|Object|string} collection The collection to slice.
		   * @param {number} start The start index.
		   * @param {number} end The end index.
		   * @returns {Array} Returns the new array.
		   */
		  function slice(array, start, end) {
		    start || (start = 0);
		    if (typeof end == 'undefined') {
		      end = array ? array.length : 0;
		    }
		    var index = -1,
		        length = end - start || 0,
		        result = Array(length < 0 ? 0 : length);
	
		    while (++index < length) {
		      result[index] = array[start + index];
		    }
		    return result;
		  }
	
		  /*--------------------------------------------------------------------------*/
	
		  /**
		   * Create a new `lodash` function using the given context object.
		   *
		   * @static
		   * @memberOf _
		   * @category Utilities
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns the `lodash` function.
		   */
		  function runInContext(context) {
		    // Avoid issues with some ES3 environments that attempt to use values, named
		    // after built-in constructors like `Object`, for the creation of literals.
		    // ES5 clears this up by stating that literals must use built-in constructors.
		    // See http://es5.github.io/#x11.1.5.
		    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
	
		    /** Native constructor references */
		    var Array = context.Array,
		        Boolean = context.Boolean,
		        Date = context.Date,
		        Error = context.Error,
		        Function = context.Function,
		        Math = context.Math,
		        Number = context.Number,
		        Object = context.Object,
		        RegExp = context.RegExp,
		        String = context.String,
		        TypeError = context.TypeError;
	
		    /**
		     * Used for `Array` method references.
		     *
		     * Normally `Array.prototype` would suffice, however, using an array literal
		     * avoids issues in Narwhal.
		     */
		    var arrayRef = [];
	
		    /** Used for native method references */
		    var errorProto = Error.prototype,
		        objectProto = Object.prototype,
		        stringProto = String.prototype;
	
		    /** Used to restore the original `_` reference in `noConflict` */
		    var oldDash = context._;
	
		    /** Used to resolve the internal [[Class]] of values */
		    var toString = objectProto.toString;
	
		    /** Used to detect if a method is native */
		    var reNative = RegExp('^' +
		      String(toString)
		        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
		        .replace(/toString| for [^\]]+/g, '.*?') + '$'
		    );
	
		    /** Native method shortcuts */
		    var ceil = Math.ceil,
		        clearTimeout = context.clearTimeout,
		        floor = Math.floor,
		        fnToString = Function.prototype.toString,
		        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
		        hasOwnProperty = objectProto.hasOwnProperty,
		        push = arrayRef.push,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        setTimeout = context.setTimeout,
		        splice = arrayRef.splice,
		        unshift = arrayRef.unshift;
	
		    /** Used to set meta data on functions */
		    var defineProperty = (function() {
		      // IE 8 only accepts DOM elements
		      try {
		        var o = {},
		            func = isNative(func = Object.defineProperty) && func,
		            result = func(o, o, o) && func;
		      } catch(e) { }
		      return result;
		    }());
	
		    /* Native method shortcuts for methods with the same name as other `lodash` methods */
		    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
		        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
		        nativeIsFinite = context.isFinite,
		        nativeIsNaN = context.isNaN,
		        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random;
	
		    /** Used to lookup a built-in constructor by [[Class]] */
		    var ctorByClass = {};
		    ctorByClass[arrayClass] = Array;
		    ctorByClass[boolClass] = Boolean;
		    ctorByClass[dateClass] = Date;
		    ctorByClass[funcClass] = Function;
		    ctorByClass[objectClass] = Object;
		    ctorByClass[numberClass] = Number;
		    ctorByClass[regexpClass] = RegExp;
		    ctorByClass[stringClass] = String;
	
		    /** Used to avoid iterating non-enumerable properties in IE < 9 */
		    var nonEnumProps = {};
		    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
		    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
		    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
		    nonEnumProps[objectClass] = { 'constructor': true };
	
		    (function() {
		      var length = shadowedProps.length;
		      while (length--) {
		        var key = shadowedProps[length];
		        for (var className in nonEnumProps) {
		          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
		            nonEnumProps[className][key] = false;
		          }
		        }
		      }
		    }());
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Creates a `lodash` object which wraps the given value to enable intuitive
		     * method chaining.
		     *
		     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
		     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
		     * and `unshift`
		     *
		     * Chaining is supported in custom builds as long as the `value` method is
		     * implicitly or explicitly included in the build.
		     *
		     * The chainable wrapper functions are:
		     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
		     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
		     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
		     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
		     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
		     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
		     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
		     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
		     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
		     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
		     * and `zip`
		     *
		     * The non-chainable wrapper functions are:
		     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
		     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
		     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
		     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
		     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
		     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
		     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
		     * `template`, `unescape`, `uniqueId`, and `value`
		     *
		     * The wrapper functions `first` and `last` return wrapped values when `n` is
		     * provided, otherwise they return unwrapped values.
		     *
		     * Explicit chaining can be enabled by using the `_.chain` method.
		     *
		     * @name _
		     * @constructor
		     * @category Chaining
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns a `lodash` instance.
		     * @example
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // returns an unwrapped value
		     * wrapped.reduce(function(sum, num) {
		     *   return sum + num;
		     * });
		     * // => 6
		     *
		     * // returns a wrapped value
		     * var squares = wrapped.map(function(num) {
		     *   return num * num;
		     * });
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
		      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
		       ? value
		       : new lodashWrapper(value);
		    }
	
		    /**
		     * A fast path for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @param {boolean} chainAll A flag to enable chaining for all methods
		     * @returns {Object} Returns a `lodash` instance.
		     */
		    function lodashWrapper(value, chainAll) {
		      this.__chain__ = !!chainAll;
		      this.__wrapped__ = value;
		    }
		    // ensure `new lodashWrapper` is an instance of `lodash`
		    lodashWrapper.prototype = lodash.prototype;
	
		    /**
		     * An object used to flag environments features.
		     *
		     * @static
		     * @memberOf _
		     * @type Object
		     */
		    var support = lodash.support = {};
	
		    (function() {
		      var ctor = function() { this.x = 1; },
		          object = { '0': 1, 'length': 1 },
		          props = [];
	
		      ctor.prototype = { 'valueOf': 1, 'y': 1 };
		      for (var key in new ctor) { props.push(key); }
		      for (key in arguments) { }
	
		      /**
		       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.argsClass = toString.call(arguments) == argsClass;
	
		      /**
		       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
	
		      /**
		       * Detect if `name` or `message` properties of `Error.prototype` are
		       * enumerable by default. (IE < 9, Safari < 5.1)
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
	
		      /**
		       * Detect if `prototype` properties are enumerable by default.
		       *
		       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
		       * (if the prototype or a property on the prototype has been set)
		       * incorrectly sets a function's `prototype` property [[Enumerable]]
		       * value to `true`.
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
	
		      /**
		       * Detect if functions can be decompiled by `Function#toString`
		       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
	
		      /**
		       * Detect if `Function#name` is supported (all but IE).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.funcNames = typeof Function.name == 'string';
	
		      /**
		       * Detect if `arguments` object indexes are non-enumerable
		       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.nonEnumArgs = key != 0;
	
		      /**
		       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
		       *
		       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
		       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.nonEnumShadows = !/valueOf/.test(props);
	
		      /**
		       * Detect if own properties are iterated after inherited properties (all but IE < 9).
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.ownLast = props[0] != 'x';
	
		      /**
		       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
		       *
		       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
		       * and `splice()` functions that fail to remove the last element, `value[0]`,
		       * of array-like objects even though the `length` property is set to `0`.
		       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
		       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
	
		      /**
		       * Detect lack of support for accessing string characters by index.
		       *
		       * IE < 8 can't access characters by index and IE 8 can only access
		       * characters by index on string literals.
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
	
		      /**
		       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
		       * and that the JS engine errors when attempting to coerce an object to
		       * a string without a `toString` function.
		       *
		       * @memberOf _.support
		       * @type boolean
		       */
		      try {
		        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
		      } catch(e) {
		        support.nodeClass = true;
		      }
		    }(1));
	
		    /**
		     * By default, the template delimiters used by Lo-Dash are similar to those in
		     * embedded Ruby (ERB). Change the following template settings to use alternative
		     * delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type Object
		     */
		    lodash.templateSettings = {
	
		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type RegExp
		       */
		      'escape': /<%-([\s\S]+?)%>/g,
	
		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type RegExp
		       */
		      'evaluate': /<%([\s\S]+?)%>/g,
	
		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type RegExp
		       */
		      'interpolate': reInterpolate,
	
		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type string
		       */
		      'variable': '',
	
		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type Object
		       */
		      'imports': {
	
		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type Function
		         */
		        '_': lodash
		      }
		    };
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * The template used to create iterator functions.
		     *
		     * @private
		     * @param {Object} data The data object used to populate the text.
		     * @returns {string} Returns the interpolated text.
		     */
		    var iteratorTemplate = function(obj) {
	
		      var __p = 'var index, iterable = ' +
		      (obj.firstArg) +
		      ', result = ' +
		      (obj.init) +
		      ';\nif (!iterable) return result;\n' +
		      (obj.top) +
		      ';';
		       if (obj.array) {
		      __p += '\nvar length = iterable.length; index = -1;\nif (' +
		      (obj.array) +
		      ') {  ';
		       if (support.unindexedChars) {
		      __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
		       }
		      __p += '\n  while (++index < length) {\n    ' +
		      (obj.loop) +
		      ';\n  }\n}\nelse {  ';
		       } else if (support.nonEnumArgs) {
		      __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
		      (obj.loop) +
		      ';\n    }\n  } else {  ';
		       }
	
		       if (support.enumPrototypes) {
		      __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
		       }
	
		       if (support.enumErrorProps) {
		      __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
		       }
	
		          var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }
	
		       if (obj.useHas && obj.keys) {
		      __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
		          if (conditions.length) {
		      __p += '    if (' +
		      (conditions.join(' && ')) +
		      ') {\n  ';
		       }
		      __p +=
		      (obj.loop) +
		      ';    ';
		       if (conditions.length) {
		      __p += '\n    }';
		       }
		      __p += '\n  }  ';
		       } else {
		      __p += '\n  for (index in iterable) {\n';
		          if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
		      __p += '    if (' +
		      (conditions.join(' && ')) +
		      ') {\n  ';
		       }
		      __p +=
		      (obj.loop) +
		      ';    ';
		       if (conditions.length) {
		      __p += '\n    }';
		       }
		      __p += '\n  }    ';
		       if (support.nonEnumShadows) {
		      __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
		       for (k = 0; k < 7; k++) {
		      __p += '\n    index = \'' +
		      (obj.shadowedProps[k]) +
		      '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
		              if (!obj.useHas) {
		      __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
		       }
		      __p += ') {\n      ' +
		      (obj.loop) +
		      ';\n    }      ';
		       }
		      __p += '\n  }    ';
		       }
	
		       }
	
		       if (obj.array || support.nonEnumArgs) {
		      __p += '\n}';
		       }
		      __p +=
		      (obj.bottom) +
		      ';\nreturn result';
	
		      return __p
		    };
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * The base implementation of `_.bind` that creates the bound function and
		     * sets its meta data.
		     *
		     * @private
		     * @param {Array} bindData The bind data array.
		     * @returns {Function} Returns the new bound function.
		     */
		    function baseBind(bindData) {
		      var func = bindData[0],
		          partialArgs = bindData[2],
		          thisArg = bindData[4];
	
		      function bound() {
		        // `Function#bind` spec
		        // http://es5.github.io/#x15.3.4.5
		        if (partialArgs) {
		          // avoid `arguments` object deoptimizations by using `slice` instead
		          // of `Array.prototype.slice.call` and not assigning `arguments` to a
		          // variable as a ternary expression
		          var args = slice(partialArgs);
		          push.apply(args, arguments);
		        }
		        // mimic the constructor's `return` behavior
		        // http://es5.github.io/#x13.2.2
		        if (this instanceof bound) {
		          // ensure `new bound` is an instance of `func`
		          var thisBinding = baseCreate(func.prototype),
		              result = func.apply(thisBinding, args || arguments);
		          return isObject(result) ? result : thisBinding;
		        }
		        return func.apply(thisArg, args || arguments);
		      }
		      setBindData(bound, bindData);
		      return bound;
		    }
	
		    /**
		     * The base implementation of `_.clone` without argument juggling or support
		     * for `thisArg` binding.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} [isDeep=false] Specify a deep clone.
		     * @param {Function} [callback] The function to customize cloning values.
		     * @param {Array} [stackA=[]] Tracks traversed source objects.
		     * @param {Array} [stackB=[]] Associates clones with source counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, isDeep, callback, stackA, stackB) {
		      if (callback) {
		        var result = callback(value);
		        if (typeof result != 'undefined') {
		          return result;
		        }
		      }
		      // inspect [[Class]]
		      var isObj = isObject(value);
		      if (isObj) {
		        var className = toString.call(value);
		        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
		          return value;
		        }
		        var ctor = ctorByClass[className];
		        switch (className) {
		          case boolClass:
		          case dateClass:
		            return new ctor(+value);
	
		          case numberClass:
		          case stringClass:
		            return new ctor(value);
	
		          case regexpClass:
		            result = ctor(value.source, reFlags.exec(value));
		            result.lastIndex = value.lastIndex;
		            return result;
		        }
		      } else {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isDeep) {
		        // check for circular references and return corresponding clone
		        var initedStack = !stackA;
		        stackA || (stackA = getArray());
		        stackB || (stackB = getArray());
	
		        var length = stackA.length;
		        while (length--) {
		          if (stackA[length] == value) {
		            return stackB[length];
		          }
		        }
		        result = isArr ? ctor(value.length) : {};
		      }
		      else {
		        result = isArr ? slice(value) : assign({}, value);
		      }
		      // add array properties assigned by `RegExp#exec`
		      if (isArr) {
		        if (hasOwnProperty.call(value, 'index')) {
		          result.index = value.index;
		        }
		        if (hasOwnProperty.call(value, 'input')) {
		          result.input = value.input;
		        }
		      }
		      // exit for shallow clone
		      if (!isDeep) {
		        return result;
		      }
		      // add the source value to the stack of traversed objects
		      // and associate it with its clone
		      stackA.push(value);
		      stackB.push(result);
	
		      // recursively populate clone (susceptible to call stack limits)
		      (isArr ? baseEach : forOwn)(value, function(objValue, key) {
		        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
		      });
	
		      if (initedStack) {
		        releaseArray(stackA);
		        releaseArray(stackB);
		      }
		      return result;
		    }
	
		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} prototype The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    function baseCreate(prototype, properties) {
		      return isObject(prototype) ? nativeCreate(prototype) : {};
		    }
		    // fallback for browsers without `Object.create`
		    if (!nativeCreate) {
		      baseCreate = (function() {
		        function Object() {}
		        return function(prototype) {
		          if (isObject(prototype)) {
		            Object.prototype = prototype;
		            var result = new Object;
		            Object.prototype = null;
		          }
		          return result || context.Object();
		        };
		      }());
		    }
	
		    /**
		     * The base implementation of `_.createCallback` without support for creating
		     * "_.pluck" or "_.where" style callbacks.
		     *
		     * @private
		     * @param {*} [func=identity] The value to convert to a callback.
		     * @param {*} [thisArg] The `this` binding of the created callback.
		     * @param {number} [argCount] The number of arguments the callback accepts.
		     * @returns {Function} Returns a callback function.
		     */
		    function baseCreateCallback(func, thisArg, argCount) {
		      if (typeof func != 'function') {
		        return identity;
		      }
		      // exit early for no `thisArg` or already bound by `Function#bind`
		      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
		        return func;
		      }
		      var bindData = func.__bindData__;
		      if (typeof bindData == 'undefined') {
		        if (support.funcNames) {
		          bindData = !func.name;
		        }
		        bindData = bindData || !support.funcDecomp;
		        if (!bindData) {
		          var source = fnToString.call(func);
		          if (!support.funcNames) {
		            bindData = !reFuncName.test(source);
		          }
		          if (!bindData) {
		            // checks if `func` references the `this` keyword and stores the result
		            bindData = reThis.test(source);
		            setBindData(func, bindData);
		          }
		        }
		      }
		      // exit early if there are no `this` references or `func` is bound
		      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
		        return func;
		      }
		      switch (argCount) {
		        case 1: return function(value) {
		          return func.call(thisArg, value);
		        };
		        case 2: return function(a, b) {
		          return func.call(thisArg, a, b);
		        };
		        case 3: return function(value, index, collection) {
		          return func.call(thisArg, value, index, collection);
		        };
		        case 4: return function(accumulator, value, index, collection) {
		          return func.call(thisArg, accumulator, value, index, collection);
		        };
		      }
		      return bind(func, thisArg);
		    }
	
		    /**
		     * The base implementation of `createWrapper` that creates the wrapper and
		     * sets its meta data.
		     *
		     * @private
		     * @param {Array} bindData The bind data array.
		     * @returns {Function} Returns the new function.
		     */
		    function baseCreateWrapper(bindData) {
		      var func = bindData[0],
		          bitmask = bindData[1],
		          partialArgs = bindData[2],
		          partialRightArgs = bindData[3],
		          thisArg = bindData[4],
		          arity = bindData[5];
	
		      var isBind = bitmask & 1,
		          isBindKey = bitmask & 2,
		          isCurry = bitmask & 4,
		          isCurryBound = bitmask & 8,
		          key = func;
	
		      function bound() {
		        var thisBinding = isBind ? thisArg : this;
		        if (partialArgs) {
		          var args = slice(partialArgs);
		          push.apply(args, arguments);
		        }
		        if (partialRightArgs || isCurry) {
		          args || (args = slice(arguments));
		          if (partialRightArgs) {
		            push.apply(args, partialRightArgs);
		          }
		          if (isCurry && args.length < arity) {
		            bitmask |= 16 & ~32;
		            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
		          }
		        }
		        args || (args = arguments);
		        if (isBindKey) {
		          func = thisBinding[key];
		        }
		        if (this instanceof bound) {
		          thisBinding = baseCreate(func.prototype);
		          var result = func.apply(thisBinding, args);
		          return isObject(result) ? result : thisBinding;
		        }
		        return func.apply(thisBinding, args);
		      }
		      setBindData(bound, bindData);
		      return bound;
		    }
	
		    /**
		     * The base implementation of `_.difference` that accepts a single array
		     * of values to exclude.
		     *
		     * @private
		     * @param {Array} array The array to process.
		     * @param {Array} [values] The array of values to exclude.
		     * @returns {Array} Returns a new array of filtered values.
		     */
		    function baseDifference(array, values) {
		      var index = -1,
		          indexOf = getIndexOf(),
		          length = array ? array.length : 0,
		          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
		          result = [];
	
		      if (isLarge) {
		        var cache = createCache(values);
		        if (cache) {
		          indexOf = cacheIndexOf;
		          values = cache;
		        } else {
		          isLarge = false;
		        }
		      }
		      while (++index < length) {
		        var value = array[index];
		        if (indexOf(values, value) < 0) {
		          result.push(value);
		        }
		      }
		      if (isLarge) {
		        releaseObject(values);
		      }
		      return result;
		    }
	
		    /**
		     * The base implementation of `_.flatten` without support for callback
		     * shorthands or `thisArg` binding.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
		     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
		     * @param {number} [fromIndex=0] The index to start from.
		     * @returns {Array} Returns a new flattened array.
		     */
		    function baseFlatten(array, isShallow, isStrict, fromIndex) {
		      var index = (fromIndex || 0) - 1,
		          length = array ? array.length : 0,
		          result = [];
	
		      while (++index < length) {
		        var value = array[index];
	
		        if (value && typeof value == 'object' && typeof value.length == 'number'
		            && (isArray(value) || isArguments(value))) {
		          // recursively flatten arrays (susceptible to call stack limits)
		          if (!isShallow) {
		            value = baseFlatten(value, isShallow, isStrict);
		          }
		          var valIndex = -1,
		              valLength = value.length,
		              resIndex = result.length;
	
		          result.length += valLength;
		          while (++valIndex < valLength) {
		            result[resIndex++] = value[valIndex];
		          }
		        } else if (!isStrict) {
		          result.push(value);
		        }
		      }
		      return result;
		    }
	
		    /**
		     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
		     * that allows partial "_.where" style comparisons.
		     *
		     * @private
		     * @param {*} a The value to compare.
		     * @param {*} b The other value to compare.
		     * @param {Function} [callback] The function to customize comparing values.
		     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
		     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
		     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
		      // used to indicate that when comparing objects, `a` has at least the properties of `b`
		      if (callback) {
		        var result = callback(a, b);
		        if (typeof result != 'undefined') {
		          return !!result;
		        }
		      }
		      // exit early for identical values
		      if (a === b) {
		        // treat `+0` vs. `-0` as not equal
		        return a !== 0 || (1 / a == 1 / b);
		      }
		      var type = typeof a,
		          otherType = typeof b;
	
		      // exit early for unlike primitive values
		      if (a === a &&
		          !(a && objectTypes[type]) &&
		          !(b && objectTypes[otherType])) {
		        return false;
		      }
		      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
		      // http://es5.github.io/#x15.3.4.4
		      if (a == null || b == null) {
		        return a === b;
		      }
		      // compare [[Class]] names
		      var className = toString.call(a),
		          otherClass = toString.call(b);
	
		      if (className == argsClass) {
		        className = objectClass;
		      }
		      if (otherClass == argsClass) {
		        otherClass = objectClass;
		      }
		      if (className != otherClass) {
		        return false;
		      }
		      switch (className) {
		        case boolClass:
		        case dateClass:
		          // coerce dates and booleans to numbers, dates to milliseconds and booleans
		          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
		          return +a == +b;
	
		        case numberClass:
		          // treat `NaN` vs. `NaN` as equal
		          return (a != +a)
		            ? b != +b
		            // but treat `+0` vs. `-0` as not equal
		            : (a == 0 ? (1 / a == 1 / b) : a == +b);
	
		        case regexpClass:
		        case stringClass:
		          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
		          // treat string primitives and their corresponding object instances as equal
		          return a == String(b);
		      }
		      var isArr = className == arrayClass;
		      if (!isArr) {
		        // unwrap any `lodash` wrapped values
		        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
		            bWrapped = hasOwnProperty.call(b, '__wrapped__');
	
		        if (aWrapped || bWrapped) {
		          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
		        }
		        // exit for functions and DOM nodes
		        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
		          return false;
		        }
		        // in older versions of Opera, `arguments` objects have `Array` constructors
		        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
		            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
	
		        // non `Object` object instances with different constructors are not equal
		        if (ctorA != ctorB &&
		              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
		              ('constructor' in a && 'constructor' in b)
		            ) {
		          return false;
		        }
		      }
		      // assume cyclic structures are equal
		      // the algorithm for detecting cyclic structures is adapted from ES 5.1
		      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
		      var initedStack = !stackA;
		      stackA || (stackA = getArray());
		      stackB || (stackB = getArray());
	
		      var length = stackA.length;
		      while (length--) {
		        if (stackA[length] == a) {
		          return stackB[length] == b;
		        }
		      }
		      var size = 0;
		      result = true;
	
		      // add `a` and `b` to the stack of traversed objects
		      stackA.push(a);
		      stackB.push(b);
	
		      // recursively compare objects and arrays (susceptible to call stack limits)
		      if (isArr) {
		        // compare lengths to determine if a deep comparison is necessary
		        length = a.length;
		        size = b.length;
		        result = size == length;
	
		        if (result || isWhere) {
		          // deep compare the contents, ignoring non-numeric properties
		          while (size--) {
		            var index = length,
		                value = b[size];
	
		            if (isWhere) {
		              while (index--) {
		                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
		                  break;
		                }
		              }
		            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
		              break;
		            }
		          }
		        }
		      }
		      else {
		        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
		        // which, in this case, is more costly
		        forIn(b, function(value, key, b) {
		          if (hasOwnProperty.call(b, key)) {
		            // count the number of properties.
		            size++;
		            // deep compare each property value.
		            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
		          }
		        });
	
		        if (result && !isWhere) {
		          // ensure both objects have the same number of properties
		          forIn(a, function(value, key, a) {
		            if (hasOwnProperty.call(a, key)) {
		              // `size` will be `-1` if `a` has more properties than `b`
		              return (result = --size > -1);
		            }
		          });
		        }
		      }
		      stackA.pop();
		      stackB.pop();
	
		      if (initedStack) {
		        releaseArray(stackA);
		        releaseArray(stackB);
		      }
		      return result;
		    }
	
		    /**
		     * The base implementation of `_.merge` without argument juggling or support
		     * for `thisArg` binding.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {Function} [callback] The function to customize merging properties.
		     * @param {Array} [stackA=[]] Tracks traversed source objects.
		     * @param {Array} [stackB=[]] Associates values with source counterparts.
		     */
		    function baseMerge(object, source, callback, stackA, stackB) {
		      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
		        var found,
		            isArr,
		            result = source,
		            value = object[key];
	
		        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
		          // avoid merging previously merged cyclic sources
		          var stackLength = stackA.length;
		          while (stackLength--) {
		            if ((found = stackA[stackLength] == source)) {
		              value = stackB[stackLength];
		              break;
		            }
		          }
		          if (!found) {
		            var isShallow;
		            if (callback) {
		              result = callback(value, source);
		              if ((isShallow = typeof result != 'undefined')) {
		                value = result;
		              }
		            }
		            if (!isShallow) {
		              value = isArr
		                ? (isArray(value) ? value : [])
		                : (isPlainObject(value) ? value : {});
		            }
		            // add `source` and associated `value` to the stack of traversed objects
		            stackA.push(source);
		            stackB.push(value);
	
		            // recursively merge objects and arrays (susceptible to call stack limits)
		            if (!isShallow) {
		              baseMerge(value, source, callback, stackA, stackB);
		            }
		          }
		        }
		        else {
		          if (callback) {
		            result = callback(value, source);
		            if (typeof result == 'undefined') {
		              result = source;
		            }
		          }
		          if (typeof result != 'undefined') {
		            value = result;
		          }
		        }
		        object[key] = value;
		      });
		    }
	
		    /**
		     * The base implementation of `_.random` without argument juggling or support
		     * for returning floating-point numbers.
		     *
		     * @private
		     * @param {number} min The minimum possible value.
		     * @param {number} max The maximum possible value.
		     * @returns {number} Returns a random number.
		     */
		    function baseRandom(min, max) {
		      return min + floor(nativeRandom() * (max - min + 1));
		    }
	
		    /**
		     * The base implementation of `_.uniq` without support for callback shorthands
		     * or `thisArg` binding.
		     *
		     * @private
		     * @param {Array} array The array to process.
		     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
		     * @param {Function} [callback] The function called per iteration.
		     * @returns {Array} Returns a duplicate-value-free array.
		     */
		    function baseUniq(array, isSorted, callback) {
		      var index = -1,
		          indexOf = getIndexOf(),
		          length = array ? array.length : 0,
		          result = [];
	
		      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
		          seen = (callback || isLarge) ? getArray() : result;
	
		      if (isLarge) {
		        var cache = createCache(seen);
		        indexOf = cacheIndexOf;
		        seen = cache;
		      }
		      while (++index < length) {
		        var value = array[index],
		            computed = callback ? callback(value, index, array) : value;
	
		        if (isSorted
		              ? !index || seen[seen.length - 1] !== computed
		              : indexOf(seen, computed) < 0
		            ) {
		          if (callback || isLarge) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      if (isLarge) {
		        releaseArray(seen.array);
		        releaseObject(seen);
		      } else if (callback) {
		        releaseArray(seen);
		      }
		      return result;
		    }
	
		    /**
		     * Creates a function that aggregates a collection, creating an object composed
		     * of keys generated from the results of running each element of the collection
		     * through a callback. The given `setter` function sets the keys and values
		     * of the composed object.
		     *
		     * @private
		     * @param {Function} setter The setter function.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter) {
		      return function(collection, callback, thisArg) {
		        var result = {};
		        callback = lodash.createCallback(callback, thisArg, 3);
	
		        if (isArray(collection)) {
		          var index = -1,
		              length = collection.length;
	
		          while (++index < length) {
		            var value = collection[index];
		            setter(result, value, callback(value, index, collection), collection);
		          }
		        } else {
		          baseEach(collection, function(value, key, collection) {
		            setter(result, value, callback(value, key, collection), collection);
		          });
		        }
		        return result;
		      };
		    }
	
		    /**
		     * Creates a function that, when called, either curries or invokes `func`
		     * with an optional `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to reference.
		     * @param {number} bitmask The bitmask of method flags to compose.
		     *  The bitmask may be composed of the following flags:
		     *  1 - `_.bind`
		     *  2 - `_.bindKey`
		     *  4 - `_.curry`
		     *  8 - `_.curry` (bound)
		     *  16 - `_.partial`
		     *  32 - `_.partialRight`
		     * @param {Array} [partialArgs] An array of arguments to prepend to those
		     *  provided to the new function.
		     * @param {Array} [partialRightArgs] An array of arguments to append to those
		     *  provided to the new function.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new function.
		     */
		    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
		      var isBind = bitmask & 1,
		          isBindKey = bitmask & 2,
		          isCurry = bitmask & 4,
		          isCurryBound = bitmask & 8,
		          isPartial = bitmask & 16,
		          isPartialRight = bitmask & 32;
	
		      if (!isBindKey && !isFunction(func)) {
		        throw new TypeError;
		      }
		      if (isPartial && !partialArgs.length) {
		        bitmask &= ~16;
		        isPartial = partialArgs = false;
		      }
		      if (isPartialRight && !partialRightArgs.length) {
		        bitmask &= ~32;
		        isPartialRight = partialRightArgs = false;
		      }
		      var bindData = func && func.__bindData__;
		      if (bindData && bindData !== true) {
		        // clone `bindData`
		        bindData = slice(bindData);
		        if (bindData[2]) {
		          bindData[2] = slice(bindData[2]);
		        }
		        if (bindData[3]) {
		          bindData[3] = slice(bindData[3]);
		        }
		        // set `thisBinding` is not previously bound
		        if (isBind && !(bindData[1] & 1)) {
		          bindData[4] = thisArg;
		        }
		        // set if previously bound but not currently (subsequent curried functions)
		        if (!isBind && bindData[1] & 1) {
		          bitmask |= 8;
		        }
		        // set curried arity if not yet set
		        if (isCurry && !(bindData[1] & 4)) {
		          bindData[5] = arity;
		        }
		        // append partial left arguments
		        if (isPartial) {
		          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
		        }
		        // append partial right arguments
		        if (isPartialRight) {
		          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
		        }
		        // merge flags
		        bindData[1] |= bitmask;
		        return createWrapper.apply(null, bindData);
		      }
		      // fast path for `_.bind`
		      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
		      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
		    }
	
		    /**
		     * Creates compiled iteration functions.
		     *
		     * @private
		     * @param {...Object} [options] The compile options object(s).
		     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
		     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
		     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
		     * @param {string} [options.args] A comma separated string of iteration function arguments.
		     * @param {string} [options.top] Code to execute before the iteration branches.
		     * @param {string} [options.loop] Code to execute in the object loop.
		     * @param {string} [options.bottom] Code to execute after the iteration branches.
		     * @returns {Function} Returns the compiled function.
		     */
		    function createIterator() {
		      // data properties
		      iteratorData.shadowedProps = shadowedProps;
	
		      // iterator options
		      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
		      iteratorData.init = 'iterable';
		      iteratorData.useHas = true;
	
		      // merge options into a template data object
		      for (var object, index = 0; object = arguments[index]; index++) {
		        for (var key in object) {
		          iteratorData[key] = object[key];
		        }
		      }
		      var args = iteratorData.args;
		      iteratorData.firstArg = /^[^,]+/.exec(args)[0];
	
		      // create the function factory
		      var factory = Function(
		          'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
		          'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
		          'objectTypes, nonEnumProps, stringClass, stringProto, toString',
		        'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
		      );
	
		      // return the compiled function
		      return factory(
		        baseCreateCallback, errorClass, errorProto, hasOwnProperty,
		        indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
		        objectTypes, nonEnumProps, stringClass, stringProto, toString
		      );
		    }
	
		    /**
		     * Used by `escape` to convert characters to HTML entities.
		     *
		     * @private
		     * @param {string} match The matched character to escape.
		     * @returns {string} Returns the escaped character.
		     */
		    function escapeHtmlChar(match) {
		      return htmlEscapes[match];
		    }
	
		    /**
		     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
		     * customized, this method returns the custom method, otherwise it returns
		     * the `baseIndexOf` function.
		     *
		     * @private
		     * @returns {Function} Returns the "indexOf" function.
		     */
		    function getIndexOf() {
		      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
		      return result;
		    }
	
		    /**
		     * Checks if `value` is a native function.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
		     */
		    function isNative(value) {
		      return typeof value == 'function' && reNative.test(value);
		    }
	
		    /**
		     * Sets `this` binding data on a given function.
		     *
		     * @private
		     * @param {Function} func The function to set data on.
		     * @param {Array} value The data array to set.
		     */
		    var setBindData = !defineProperty ? noop : function(func, value) {
		      descriptor.value = value;
		      defineProperty(func, '__bindData__', descriptor);
		      descriptor.value = null;
		    };
	
		    /**
		     * A fallback implementation of `isPlainObject` which checks if a given value
		     * is an object created by the `Object` constructor, assuming objects created
		     * by the `Object` constructor have no inherited enumerable properties and that
		     * there are no `Object.prototype` extensions.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     */
		    function shimIsPlainObject(value) {
		      var ctor,
		          result;
	
		      // avoid non Object objects, `arguments` objects, and DOM elements
		      if (!(value && toString.call(value) == objectClass) ||
		          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
		          (!support.argsClass && isArguments(value)) ||
		          (!support.nodeClass && isNode(value))) {
		        return false;
		      }
		      // IE < 9 iterates inherited properties before own properties. If the first
		      // iterated property is an object's own property then there are no inherited
		      // enumerable properties.
		      if (support.ownLast) {
		        forIn(value, function(value, key, object) {
		          result = hasOwnProperty.call(object, key);
		          return false;
		        });
		        return result !== false;
		      }
		      // In most environments an object's own properties are iterated before
		      // its inherited properties. If the last iterated property is an object's
		      // own property then there are no inherited enumerable properties.
		      forIn(value, function(value, key) {
		        result = key;
		      });
		      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
		    }
	
		    /**
		     * Used by `unescape` to convert HTML entities to characters.
		     *
		     * @private
		     * @param {string} match The matched character to unescape.
		     * @returns {string} Returns the unescaped character.
		     */
		    function unescapeHtmlChar(match) {
		      return htmlUnescapes[match];
		    }
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Checks if `value` is an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
		     * @example
		     *
		     * (function() { return _.isArguments(arguments); })(1, 2, 3);
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    function isArguments(value) {
		      return value && typeof value == 'object' && typeof value.length == 'number' &&
		        toString.call(value) == argsClass || false;
		    }
		    // fallback for browsers that can't detect `arguments` objects by [[Class]]
		    if (!support.argsClass) {
		      isArguments = function(value) {
		        return value && typeof value == 'object' && typeof value.length == 'number' &&
		          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
		      };
		    }
	
		    /**
		     * Checks if `value` is an array.
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
		     * @example
		     *
		     * (function() { return _.isArray(arguments); })();
		     * // => false
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     */
		    var isArray = nativeIsArray || function(value) {
		      return value && typeof value == 'object' && typeof value.length == 'number' &&
		        toString.call(value) == arrayClass || false;
		    };
	
		    /**
		     * A fallback implementation of `Object.keys` which produces an array of the
		     * given object's own enumerable property names.
		     *
		     * @private
		     * @type Function
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns an array of property names.
		     */
		    var shimKeys = createIterator({
		      'args': 'object',
		      'init': '[]',
		      'top': 'if (!(objectTypes[typeof object])) return result',
		      'loop': 'result.push(index)'
		    });
	
		    /**
		     * Creates an array composed of the own enumerable property names of an object.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns an array of property names.
		     * @example
		     *
		     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
		     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
		     */
		    var keys = !nativeKeys ? shimKeys : function(object) {
		      if (!isObject(object)) {
		        return [];
		      }
		      if ((support.enumPrototypes && typeof object == 'function') ||
		          (support.nonEnumArgs && object.length && isArguments(object))) {
		        return shimKeys(object);
		      }
		      return nativeKeys(object);
		    };
	
		    /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
		    var eachIteratorOptions = {
		      'args': 'collection, callback, thisArg',
		      'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
		      'array': "typeof length == 'number'",
		      'keys': keys,
		      'loop': 'if (callback(iterable[index], index, collection) === false) return result'
		    };
	
		    /** Reusable iterator options for `assign` and `defaults` */
		    var defaultsIteratorOptions = {
		      'args': 'object, source, guard',
		      'top':
		        'var args = arguments,\n' +
		        '    argsIndex = 0,\n' +
		        "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
		        'while (++argsIndex < argsLength) {\n' +
		        '  iterable = args[argsIndex];\n' +
		        '  if (iterable && objectTypes[typeof iterable]) {',
		      'keys': keys,
		      'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
		      'bottom': '  }\n}'
		    };
	
		    /** Reusable iterator options for `forIn` and `forOwn` */
		    var forOwnIteratorOptions = {
		      'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
		      'array': false
		    };
	
		    /**
		     * Used to convert characters to HTML entities:
		     *
		     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
		     * don't require escaping in HTML and have no special meaning unless they're part
		     * of a tag or an unquoted attribute value.
		     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
		     */
		    var htmlEscapes = {
		      '&': '&amp;',
		      '<': '&lt;',
		      '>': '&gt;',
		      '"': '&quot;',
		      "'": '&#39;'
		    };
	
		    /** Used to convert HTML entities to characters */
		    var htmlUnescapes = invert(htmlEscapes);
	
		    /** Used to match HTML entities and HTML characters */
		    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
		        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
	
		    /**
		     * A function compiled to iterate `arguments` objects, arrays, objects, and
		     * strings consistenly across environments, executing the callback for each
		     * element in the collection. The callback is bound to `thisArg` and invoked
		     * with three arguments; (value, index|key, collection). Callbacks may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @type Function
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array|Object|string} Returns `collection`.
		     */
		    var baseEach = createIterator(eachIteratorOptions);
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Assigns own enumerable properties of source object(s) to the destination
		     * object. Subsequent sources will overwrite property assignments of previous
		     * sources. If a callback is provided it will be executed to produce the
		     * assigned values. The callback is bound to `thisArg` and invoked with two
		     * arguments; (objectValue, sourceValue).
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @alias extend
		     * @category Objects
		     * @param {Object} object The destination object.
		     * @param {...Object} [source] The source objects.
		     * @param {Function} [callback] The function to customize assigning values.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns the destination object.
		     * @example
		     *
		     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
		     * // => { 'name': 'fred', 'employer': 'slate' }
		     *
		     * var defaults = _.partialRight(_.assign, function(a, b) {
		     *   return typeof a == 'undefined' ? b : a;
		     * });
		     *
		     * var object = { 'name': 'barney' };
		     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
		     * // => { 'name': 'barney', 'employer': 'slate' }
		     */
		    var assign = createIterator(defaultsIteratorOptions, {
		      'top':
		        defaultsIteratorOptions.top.replace(';',
		          ';\n' +
		          "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
		          '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
		          "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
		          '  callback = args[--argsLength];\n' +
		          '}'
		        ),
		      'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
		    });
	
		    /**
		     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
		     * be cloned, otherwise they will be assigned by reference. If a callback
		     * is provided it will be executed to produce the cloned values. If the
		     * callback returns `undefined` cloning will be handled by the method instead.
		     * The callback is bound to `thisArg` and invoked with one argument; (value).
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to clone.
		     * @param {boolean} [isDeep=false] Specify a deep clone.
		     * @param {Function} [callback] The function to customize cloning values.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the cloned value.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * var shallow = _.clone(characters);
		     * shallow[0] === characters[0];
		     * // => true
		     *
		     * var deep = _.clone(characters, true);
		     * deep[0] === characters[0];
		     * // => false
		     *
		     * _.mixin({
		     *   'clone': _.partialRight(_.clone, function(value) {
		     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
		     *   })
		     * });
		     *
		     * var clone = _.clone(document.body);
		     * clone.childNodes.length;
		     * // => 0
		     */
		    function clone(value, isDeep, callback, thisArg) {
		      // allows working with "Collections" methods without using their `index`
		      // and `collection` arguments for `isDeep` and `callback`
		      if (typeof isDeep != 'boolean' && isDeep != null) {
		        thisArg = callback;
		        callback = isDeep;
		        isDeep = false;
		      }
		      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
		    }
	
		    /**
		     * Creates a deep clone of `value`. If a callback is provided it will be
		     * executed to produce the cloned values. If the callback returns `undefined`
		     * cloning will be handled by the method instead. The callback is bound to
		     * `thisArg` and invoked with one argument; (value).
		     *
		     * Note: This method is loosely based on the structured clone algorithm. Functions
		     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
		     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
		     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to deep clone.
		     * @param {Function} [callback] The function to customize cloning values.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the deep cloned value.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * var deep = _.cloneDeep(characters);
		     * deep[0] === characters[0];
		     * // => false
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'node': element
		     * };
		     *
		     * var clone = _.cloneDeep(view, function(value) {
		     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
		     * });
		     *
		     * clone.node == view.node;
		     * // => false
		     */
		    function cloneDeep(value, callback, thisArg) {
		      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
		    }
	
		    /**
		     * Creates an object that inherits from the given `prototype` object. If a
		     * `properties` object is provided its own enumerable properties are assigned
		     * to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties ? assign(result, properties) : result;
		    }
	
		    /**
		     * Assigns own enumerable properties of source object(s) to the destination
		     * object for all destination properties that resolve to `undefined`. Once a
		     * property is set, additional defaults of the same property will be ignored.
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @category Objects
		     * @param {Object} object The destination object.
		     * @param {...Object} [source] The source objects.
		     * @param- {Object} [guard] Allows working with `_.reduce` without using its
		     *  `key` and `object` arguments as sources.
		     * @returns {Object} Returns the destination object.
		     * @example
		     *
		     * var object = { 'name': 'barney' };
		     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
		     * // => { 'name': 'barney', 'employer': 'slate' }
		     */
		    var defaults = createIterator(defaultsIteratorOptions);
	
		    /**
		     * This method is like `_.findIndex` except that it returns the key of the
		     * first element that passes the callback check, instead of the element itself.
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to search.
		     * @param {Function|Object|string} [callback=identity] The function called per
		     *  iteration. If a property name or object is provided it will be used to
		     *  create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
		     * @example
		     *
		     * var characters = {
		     *   'barney': {  'age': 36, 'blocked': false },
		     *   'fred': {    'age': 40, 'blocked': true },
		     *   'pebbles': { 'age': 1,  'blocked': false }
		     * };
		     *
		     * _.findKey(characters, function(chr) {
		     *   return chr.age < 40;
		     * });
		     * // => 'barney' (property order is not guaranteed across environments)
		     *
		     * // using "_.where" callback shorthand
		     * _.findKey(characters, { 'age': 1 });
		     * // => 'pebbles'
		     *
		     * // using "_.pluck" callback shorthand
		     * _.findKey(characters, 'blocked');
		     * // => 'fred'
		     */
		    function findKey(object, callback, thisArg) {
		      var result;
		      callback = lodash.createCallback(callback, thisArg, 3);
		      forOwn(object, function(value, key, object) {
		        if (callback(value, key, object)) {
		          result = key;
		          return false;
		        }
		      });
		      return result;
		    }
	
		    /**
		     * This method is like `_.findKey` except that it iterates over elements
		     * of a `collection` in the opposite order.
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to search.
		     * @param {Function|Object|string} [callback=identity] The function called per
		     *  iteration. If a property name or object is provided it will be used to
		     *  create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
		     * @example
		     *
		     * var characters = {
		     *   'barney': {  'age': 36, 'blocked': true },
		     *   'fred': {    'age': 40, 'blocked': false },
		     *   'pebbles': { 'age': 1,  'blocked': true }
		     * };
		     *
		     * _.findLastKey(characters, function(chr) {
		     *   return chr.age < 40;
		     * });
		     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
		     *
		     * // using "_.where" callback shorthand
		     * _.findLastKey(characters, { 'age': 40 });
		     * // => 'fred'
		     *
		     * // using "_.pluck" callback shorthand
		     * _.findLastKey(characters, 'blocked');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, callback, thisArg) {
		      var result;
		      callback = lodash.createCallback(callback, thisArg, 3);
		      forOwnRight(object, function(value, key, object) {
		        if (callback(value, key, object)) {
		          result = key;
		          return false;
		        }
		      });
		      return result;
		    }
	
		    /**
		     * Iterates over own and inherited enumerable properties of an object,
		     * executing the callback for each property. The callback is bound to `thisArg`
		     * and invoked with three arguments; (value, key, object). Callbacks may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @category Objects
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * Shape.prototype.move = function(x, y) {
		     *   this.x += x;
		     *   this.y += y;
		     * };
		     *
		     * _.forIn(new Shape, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
		     */
		    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
		      'useHas': false
		    });
	
		    /**
		     * This method is like `_.forIn` except that it iterates over elements
		     * of a `collection` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * Shape.prototype.move = function(x, y) {
		     *   this.x += x;
		     *   this.y += y;
		     * };
		     *
		     * _.forInRight(new Shape, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
		     */
		    function forInRight(object, callback, thisArg) {
		      var pairs = [];
	
		      forIn(object, function(value, key) {
		        pairs.push(key, value);
		      });
	
		      var length = pairs.length;
		      callback = baseCreateCallback(callback, thisArg, 3);
		      while (length--) {
		        if (callback(pairs[length--], pairs[length], object) === false) {
		          break;
		        }
		      }
		      return object;
		    }
	
		    /**
		     * Iterates over own enumerable properties of an object, executing the callback
		     * for each property. The callback is bound to `thisArg` and invoked with three
		     * arguments; (value, key, object). Callbacks may exit iteration early by
		     * explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @category Objects
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
		     *   console.log(key);
		     * });
		     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
		     */
		    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
	
		    /**
		     * This method is like `_.forOwn` except that it iterates over elements
		     * of a `collection` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
		     *   console.log(key);
		     * });
		     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
		     */
		    function forOwnRight(object, callback, thisArg) {
		      var props = keys(object),
		          length = props.length;
	
		      callback = baseCreateCallback(callback, thisArg, 3);
		      while (length--) {
		        var key = props[length];
		        if (callback(object[key], key, object) === false) {
		          break;
		        }
		      }
		      return object;
		    }
	
		    /**
		     * Creates a sorted array of property names of all enumerable properties,
		     * own and inherited, of `object` that have function values.
		     *
		     * @static
		     * @memberOf _
		     * @alias methods
		     * @category Objects
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns an array of property names that have function values.
		     * @example
		     *
		     * _.functions(_);
		     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
		     */
		    function functions(object) {
		      var result = [];
		      forIn(object, function(value, key) {
		        if (isFunction(value)) {
		          result.push(key);
		        }
		      });
		      return result.sort();
		    }
	
		    /**
		     * Checks if the specified property name exists as a direct property of `object`,
		     * instead of an inherited property.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to inspect.
		     * @param {string} key The name of the property to check.
		     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
		     * @example
		     *
		     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
		     * // => true
		     */
		    function has(object, key) {
		      return object ? hasOwnProperty.call(object, key) : false;
		    }
	
		    /**
		     * Creates an object composed of the inverted keys and values of the given object.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the created inverted object.
		     * @example
		     *
		     * _.invert({ 'first': 'fred', 'second': 'barney' });
		     * // => { 'fred': 'first', 'barney': 'second' }
		     */
		    function invert(object) {
		      var index = -1,
		          props = keys(object),
		          length = props.length,
		          result = {};
	
		      while (++index < length) {
		        var key = props[index];
		        result[object[key]] = key;
		      }
		      return result;
		    }
	
		    /**
		     * Checks if `value` is a boolean value.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
		     * @example
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        value && typeof value == 'object' && toString.call(value) == boolClass || false;
		    }
	
		    /**
		     * Checks if `value` is a date.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     */
		    function isDate(value) {
		      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
		    }
	
		    /**
		     * Checks if `value` is a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     */
		    function isElement(value) {
		      return value && value.nodeType === 1 || false;
		    }
	
		    /**
		     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
		     * length of `0` and objects with no own enumerable properties are considered
		     * "empty".
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Array|Object|string} value The value to inspect.
		     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({});
		     * // => true
		     *
		     * _.isEmpty('');
		     * // => true
		     */
		    function isEmpty(value) {
		      var result = true;
		      if (!value) {
		        return result;
		      }
		      var className = toString.call(value),
		          length = value.length;
	
		      if ((className == arrayClass || className == stringClass ||
		          (support.argsClass ? className == argsClass : isArguments(value))) ||
		          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
		        return !length;
		      }
		      forOwn(value, function() {
		        return (result = false);
		      });
		      return result;
		    }
	
		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent to each other. If a callback is provided it will be executed
		     * to compare values. If the callback returns `undefined` comparisons will
		     * be handled by the method instead. The callback is bound to `thisArg` and
		     * invoked with two arguments; (a, b).
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} a The value to compare.
		     * @param {*} b The other value to compare.
		     * @param {Function} [callback] The function to customize comparing values.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'name': 'fred' };
		     * var copy = { 'name': 'fred' };
		     *
		     * object == copy;
		     * // => false
		     *
		     * _.isEqual(object, copy);
		     * // => true
		     *
		     * var words = ['hello', 'goodbye'];
		     * var otherWords = ['hi', 'goodbye'];
		     *
		     * _.isEqual(words, otherWords, function(a, b) {
		     *   var reGreet = /^(?:hello|hi)$/i,
		     *       aGreet = _.isString(a) && reGreet.test(a),
		     *       bGreet = _.isString(b) && reGreet.test(b);
		     *
		     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
		     * });
		     * // => true
		     */
		    function isEqual(a, b, callback, thisArg) {
		      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
		    }
	
		    /**
		     * Checks if `value` is, or can be coerced to, a finite number.
		     *
		     * Note: This is not the same as native `isFinite` which will return true for
		     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
		     * @example
		     *
		     * _.isFinite(-101);
		     * // => true
		     *
		     * _.isFinite('10');
		     * // => true
		     *
		     * _.isFinite(true);
		     * // => false
		     *
		     * _.isFinite('');
		     * // => false
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     */
		    function isFinite(value) {
		      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
		    }
	
		    /**
		     * Checks if `value` is a function.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     */
		    function isFunction(value) {
		      return typeof value == 'function';
		    }
		    // fallback for older versions of Chrome and Safari
		    if (isFunction(/x/)) {
		      isFunction = function(value) {
		        return typeof value == 'function' && toString.call(value) == funcClass;
		      };
		    }
	
		    /**
		     * Checks if `value` is the language type of Object.
		     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(1);
		     * // => false
		     */
		    function isObject(value) {
		      // check if the value is the ECMAScript language type of Object
		      // http://es5.github.io/#x8
		      // and avoid a V8 bug
		      // http://code.google.com/p/v8/issues/detail?id=2291
		      return !!(value && objectTypes[typeof value]);
		    }
	
		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * Note: This is not the same as native `isNaN` which will return `true` for
		     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // `NaN` as a primitive is the only value that is not equal to itself
		      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
		      return isNumber(value) && value != +value;
		    }
	
		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(undefined);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }
	
		    /**
		     * Checks if `value` is a number.
		     *
		     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
		     * @example
		     *
		     * _.isNumber(8.4 * 5);
		     * // => true
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        value && typeof value == 'object' && toString.call(value) == numberClass || false;
		    }
	
		    /**
		     * Checks if `value` is an object created by the `Object` constructor.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * _.isPlainObject(new Shape);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     */
		    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
		      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
		        return false;
		      }
		      var valueOf = value.valueOf,
		          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
	
		      return objProto
		        ? (value == objProto || getPrototypeOf(value) == objProto)
		        : shimIsPlainObject(value);
		    };
	
		    /**
		     * Checks if `value` is a regular expression.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
		     * @example
		     *
		     * _.isRegExp(/fred/);
		     * // => true
		     */
		    function isRegExp(value) {
		      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
		    }
	
		    /**
		     * Checks if `value` is a string.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
		     * @example
		     *
		     * _.isString('fred');
		     * // => true
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        value && typeof value == 'object' && toString.call(value) == stringClass || false;
		    }
	
		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     */
		    function isUndefined(value) {
		      return typeof value == 'undefined';
		    }
	
		    /**
		     * Creates an object with the same keys as `object` and values generated by
		     * running each own enumerable property of `object` through the callback.
		     * The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, key, object).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
		     * @example
		     *
		     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
		     * // => { 'a': 3, 'b': 6, 'c': 9 }
		     *
		     * var characters = {
		     *   'fred': { 'name': 'fred', 'age': 40 },
		     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
		     * };
		     *
		     * // using "_.pluck" callback shorthand
		     * _.mapValues(characters, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 }
		     */
		    function mapValues(object, callback, thisArg) {
		      var result = {};
		      callback = lodash.createCallback(callback, thisArg, 3);
	
		      forOwn(object, function(value, key, object) {
		        result[key] = callback(value, key, object);
		      });
		      return result;
		    }
	
		    /**
		     * Recursively merges own enumerable properties of the source object(s), that
		     * don't resolve to `undefined` into the destination object. Subsequent sources
		     * will overwrite property assignments of previous sources. If a callback is
		     * provided it will be executed to produce the merged values of the destination
		     * and source properties. If the callback returns `undefined` merging will
		     * be handled by the method instead. The callback is bound to `thisArg` and
		     * invoked with two arguments; (objectValue, sourceValue).
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The destination object.
		     * @param {...Object} [source] The source objects.
		     * @param {Function} [callback] The function to customize merging properties.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns the destination object.
		     * @example
		     *
		     * var names = {
		     *   'characters': [
		     *     { 'name': 'barney' },
		     *     { 'name': 'fred' }
		     *   ]
		     * };
		     *
		     * var ages = {
		     *   'characters': [
		     *     { 'age': 36 },
		     *     { 'age': 40 }
		     *   ]
		     * };
		     *
		     * _.merge(names, ages);
		     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
		     *
		     * var food = {
		     *   'fruits': ['apple'],
		     *   'vegetables': ['beet']
		     * };
		     *
		     * var otherFood = {
		     *   'fruits': ['banana'],
		     *   'vegetables': ['carrot']
		     * };
		     *
		     * _.merge(food, otherFood, function(a, b) {
		     *   return _.isArray(a) ? a.concat(b) : undefined;
		     * });
		     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
		     */
		    function merge(object) {
		      var args = arguments,
		          length = 2;
	
		      if (!isObject(object)) {
		        return object;
		      }
		      // allows working with `_.reduce` and `_.reduceRight` without using
		      // their `index` and `collection` arguments
		      if (typeof args[2] != 'number') {
		        length = args.length;
		      }
		      if (length > 3 && typeof args[length - 2] == 'function') {
		        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
		      } else if (length > 2 && typeof args[length - 1] == 'function') {
		        callback = args[--length];
		      }
		      var sources = slice(arguments, 1, length),
		          index = -1,
		          stackA = getArray(),
		          stackB = getArray();
	
		      while (++index < length) {
		        baseMerge(object, sources[index], callback, stackA, stackB);
		      }
		      releaseArray(stackA);
		      releaseArray(stackB);
		      return object;
		    }
	
		    /**
		     * Creates a shallow clone of `object` excluding the specified properties.
		     * Property names may be specified as individual arguments or as arrays of
		     * property names. If a callback is provided it will be executed for each
		     * property of `object` omitting the properties the callback returns truey
		     * for. The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The source object.
		     * @param {Function|...string|string[]} [callback] The properties to omit or the
		     *  function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns an object without the omitted properties.
		     * @example
		     *
		     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
		     * // => { 'name': 'fred' }
		     *
		     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
		     *   return typeof value == 'number';
		     * });
		     * // => { 'name': 'fred' }
		     */
		    function omit(object, callback, thisArg) {
		      var result = {};
		      if (typeof callback != 'function') {
		        var props = [];
		        forIn(object, function(value, key) {
		          props.push(key);
		        });
		        props = baseDifference(props, baseFlatten(arguments, true, false, 1));
	
		        var index = -1,
		            length = props.length;
	
		        while (++index < length) {
		          var key = props[index];
		          result[key] = object[key];
		        }
		      } else {
		        callback = lodash.createCallback(callback, thisArg, 3);
		        forIn(object, function(value, key, object) {
		          if (!callback(value, key, object)) {
		            result[key] = value;
		          }
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Creates a two dimensional array of an object's key-value pairs,
		     * i.e. `[[key1, value1], [key2, value2]]`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns new array of key-value pairs.
		     * @example
		     *
		     * _.pairs({ 'barney': 36, 'fred': 40 });
		     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
		     */
		    function pairs(object) {
		      var index = -1,
		          props = keys(object),
		          length = props.length,
		          result = Array(length);
	
		      while (++index < length) {
		        var key = props[index];
		        result[index] = [key, object[key]];
		      }
		      return result;
		    }
	
		    /**
		     * Creates a shallow clone of `object` composed of the specified properties.
		     * Property names may be specified as individual arguments or as arrays of
		     * property names. If a callback is provided it will be executed for each
		     * property of `object` picking the properties the callback returns truey
		     * for. The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The source object.
		     * @param {Function|...string|string[]} [callback] The function called per
		     *  iteration or property names to pick, specified as individual property
		     *  names or arrays of property names.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns an object composed of the picked properties.
		     * @example
		     *
		     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
		     * // => { 'name': 'fred' }
		     *
		     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
		     *   return key.charAt(0) != '_';
		     * });
		     * // => { 'name': 'fred' }
		     */
		    function pick(object, callback, thisArg) {
		      var result = {};
		      if (typeof callback != 'function') {
		        var index = -1,
		            props = baseFlatten(arguments, true, false, 1),
		            length = isObject(object) ? props.length : 0;
	
		        while (++index < length) {
		          var key = props[index];
		          if (key in object) {
		            result[key] = object[key];
		          }
		        }
		      } else {
		        callback = lodash.createCallback(callback, thisArg, 3);
		        forIn(object, function(value, key, object) {
		          if (callback(value, key, object)) {
		            result[key] = value;
		          }
		        });
		      }
		      return result;
		    }
	
		    /**
		     * An alternative to `_.reduce` this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable properties through a callback, with each callback execution
		     * potentially mutating the `accumulator` object. The callback is bound to
		     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
		     * Callbacks may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Array|Object} object The object to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
		     *   num *= num;
		     *   if (num % 2) {
		     *     return result.push(num) < 3;
		     *   }
		     * });
		     * // => [1, 9, 25]
		     *
		     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
		     *   result[key] = num * 3;
		     * });
		     * // => { 'a': 3, 'b': 6, 'c': 9 }
		     */
		    function transform(object, callback, accumulator, thisArg) {
		      var isArr = isArray(object);
		      if (accumulator == null) {
		        if (isArr) {
		          accumulator = [];
		        } else {
		          var ctor = object && object.constructor,
		              proto = ctor && ctor.prototype;
	
		          accumulator = baseCreate(proto);
		        }
		      }
		      if (callback) {
		        callback = lodash.createCallback(callback, thisArg, 4);
		        (isArr ? baseEach : forOwn)(object, function(value, index, object) {
		          return callback(accumulator, value, index, object);
		        });
		      }
		      return accumulator;
		    }
	
		    /**
		     * Creates an array composed of the own enumerable property values of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @category Objects
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns an array of property values.
		     * @example
		     *
		     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
		     * // => [1, 2, 3] (property order is not guaranteed across environments)
		     */
		    function values(object) {
		      var index = -1,
		          props = keys(object),
		          length = props.length,
		          result = Array(length);
	
		      while (++index < length) {
		        result[index] = object[props[index]];
		      }
		      return result;
		    }
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Creates an array of elements from the specified indexes, or keys, of the
		     * `collection`. Indexes may be specified as individual arguments or as arrays
		     * of indexes.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
		     *   to retrieve, specified as individual indexes or arrays of indexes.
		     * @returns {Array} Returns a new array of elements corresponding to the
		     *  provided indexes.
		     * @example
		     *
		     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
		     * // => ['a', 'c', 'e']
		     *
		     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
		     * // => ['fred', 'pebbles']
		     */
		    function at(collection) {
		      var args = arguments,
		          index = -1,
		          props = baseFlatten(args, true, false, 1),
		          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
		          result = Array(length);
	
		      if (support.unindexedChars && isString(collection)) {
		        collection = collection.split('');
		      }
		      while(++index < length) {
		        result[index] = collection[props[index]];
		      }
		      return result;
		    }
	
		    /**
		     * Checks if a given value is present in a collection using strict equality
		     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
		     * offset from the end of the collection.
		     *
		     * @static
		     * @memberOf _
		     * @alias include
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {*} target The value to check for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
		     * @example
		     *
		     * _.contains([1, 2, 3], 1);
		     * // => true
		     *
		     * _.contains([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
		     * // => true
		     *
		     * _.contains('pebbles', 'eb');
		     * // => true
		     */
		    function contains(collection, target, fromIndex) {
		      var index = -1,
		          indexOf = getIndexOf(),
		          length = collection ? collection.length : 0,
		          result = false;
	
		      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
		      if (isArray(collection)) {
		        result = indexOf(collection, target, fromIndex) > -1;
		      } else if (typeof length == 'number') {
		        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
		      } else {
		        baseEach(collection, function(value) {
		          if (++index >= fromIndex) {
		            return !(result = value === target);
		          }
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` through the callback. The corresponding value
		     * of each key is the number of times the key was returned by the callback.
		     * The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
		     * // => { '4': 1, '6': 2 }
		     *
		     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
		     * // => { '4': 1, '6': 2 }
		     *
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
		    });
	
		    /**
		     * Checks if the given callback returns truey value for **all** elements of
		     * a collection. The callback is bound to `thisArg` and invoked with three
		     * arguments; (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias all
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {boolean} Returns `true` if all elements passed the callback check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes']);
		     * // => false
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.every(characters, 'age');
		     * // => true
		     *
		     * // using "_.where" callback shorthand
		     * _.every(characters, { 'age': 36 });
		     * // => false
		     */
		    function every(collection, callback, thisArg) {
		      var result = true;
		      callback = lodash.createCallback(callback, thisArg, 3);
	
		      if (isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          if (!(result = !!callback(collection[index], index, collection))) {
		            break;
		          }
		        }
		      } else {
		        baseEach(collection, function(value, index, collection) {
		          return (result = !!callback(value, index, collection));
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Iterates over elements of a collection, returning an array of all elements
		     * the callback returns truey for. The callback is bound to `thisArg` and
		     * invoked with three arguments; (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias select
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new array of elements that passed the callback check.
		     * @example
		     *
		     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
		     * // => [2, 4, 6]
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36, 'blocked': false },
		     *   { 'name': 'fred',   'age': 40, 'blocked': true }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.filter(characters, 'blocked');
		     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
		     *
		     * // using "_.where" callback shorthand
		     * _.filter(characters, { 'age': 36 });
		     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
		     */
		    function filter(collection, callback, thisArg) {
		      var result = [];
		      callback = lodash.createCallback(callback, thisArg, 3);
	
		      if (isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          var value = collection[index];
		          if (callback(value, index, collection)) {
		            result.push(value);
		          }
		        }
		      } else {
		        baseEach(collection, function(value, index, collection) {
		          if (callback(value, index, collection)) {
		            result.push(value);
		          }
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Iterates over elements of a collection, returning the first element that
		     * the callback returns truey for. The callback is bound to `thisArg` and
		     * invoked with three arguments; (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias detect, findWhere
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the found element, else `undefined`.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'age': 36, 'blocked': false },
		     *   { 'name': 'fred',    'age': 40, 'blocked': true },
		     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
		     * ];
		     *
		     * _.find(characters, function(chr) {
		     *   return chr.age < 40;
		     * });
		     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
		     *
		     * // using "_.where" callback shorthand
		     * _.find(characters, { 'age': 1 });
		     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
		     *
		     * // using "_.pluck" callback shorthand
		     * _.find(characters, 'blocked');
		     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
		     */
		    function find(collection, callback, thisArg) {
		      callback = lodash.createCallback(callback, thisArg, 3);
	
		      if (isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          var value = collection[index];
		          if (callback(value, index, collection)) {
		            return value;
		          }
		        }
		      } else {
		        var result;
		        baseEach(collection, function(value, index, collection) {
		          if (callback(value, index, collection)) {
		            result = value;
		            return false;
		          }
		        });
		        return result;
		      }
		    }
	
		    /**
		     * This method is like `_.find` except that it iterates over elements
		     * of a `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the found element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(num) {
		     *   return num % 2 == 1;
		     * });
		     * // => 3
		     */
		    function findLast(collection, callback, thisArg) {
		      var result;
		      callback = lodash.createCallback(callback, thisArg, 3);
		      forEachRight(collection, function(value, index, collection) {
		        if (callback(value, index, collection)) {
		          result = value;
		          return false;
		        }
		      });
		      return result;
		    }
	
		    /**
		     * Iterates over elements of a collection, executing the callback for each
		     * element. The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, index|key, collection). Callbacks may exit iteration early by
		     * explicitly returning `false`.
		     *
		     * Note: As with other "Collections" methods, objects with a `length` property
		     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
		     * may be used for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @alias each
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array|Object|string} Returns `collection`.
		     * @example
		     *
		     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
		     * // => logs each number and returns '1,2,3'
		     *
		     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
		     * // => logs each number and returns the object (property order is not guaranteed across environments)
		     */
		    function forEach(collection, callback, thisArg) {
		      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          if (callback(collection[index], index, collection) === false) {
		            break;
		          }
		        }
		      } else {
		        baseEach(collection, callback, thisArg);
		      }
		      return collection;
		    }
	
		    /**
		     * This method is like `_.forEach` except that it iterates over elements
		     * of a `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @alias eachRight
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array|Object|string} Returns `collection`.
		     * @example
		     *
		     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
		     * // => logs each number from right to left and returns '3,2,1'
		     */
		    function forEachRight(collection, callback, thisArg) {
		      var iterable = collection,
		          length = collection ? collection.length : 0;
	
		      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
		      if (isArray(collection)) {
		        while (length--) {
		          if (callback(collection[length], length, collection) === false) {
		            break;
		          }
		        }
		      } else {
		        if (typeof length != 'number') {
		          var props = keys(collection);
		          length = props.length;
		        } else if (support.unindexedChars && isString(collection)) {
		          iterable = collection.split('');
		        }
		        baseEach(collection, function(value, key, collection) {
		          key = props ? props[--length] : --length;
		          return callback(iterable[key], key, collection);
		        });
		      }
		      return collection;
		    }
	
		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of a collection through the callback. The corresponding value
		     * of each key is an array of the elements responsible for generating the key.
		     * The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
		     * // => { '4': [4.2], '6': [6.1, 6.4] }
		     *
		     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
		     * // => { '4': [4.2], '6': [6.1, 6.4] }
		     *
		     * // using "_.pluck" callback shorthand
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
		    });
	
		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of the collection through the given callback. The corresponding
		     * value of each key is the last element responsible for generating the key.
		     * The callback is bound to `thisArg` and invoked with three arguments;
		     * (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var keys = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.indexBy(keys, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     */
		    var indexBy = createAggregator(function(result, value, key) {
		      result[key] = value;
		    });
	
		    /**
		     * Invokes the method named by `methodName` on each element in the `collection`
		     * returning an array of the results of each invoked method. Additional arguments
		     * will be provided to each invoked method. If `methodName` is a function it
		     * will be invoked for, and `this` bound to, each element in the `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|string} methodName The name of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [arg] Arguments to invoke the method with.
		     * @returns {Array} Returns a new array of the results of each invoked method.
		     * @example
		     *
		     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invoke([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    function invoke(collection, methodName) {
		      var args = slice(arguments, 2),
		          index = -1,
		          isFunc = typeof methodName == 'function',
		          length = collection ? collection.length : 0,
		          result = Array(typeof length == 'number' ? length : 0);
	
		      forEach(collection, function(value) {
		        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
		      });
		      return result;
		    }
	
		    /**
		     * Creates an array of values by running each element in the collection
		     * through the callback. The callback is bound to `thisArg` and invoked with
		     * three arguments; (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias collect
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new array of the results of each `callback` execution.
		     * @example
		     *
		     * _.map([1, 2, 3], function(num) { return num * 3; });
		     * // => [3, 6, 9]
		     *
		     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
		     * // => [3, 6, 9] (property order is not guaranteed across environments)
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.map(characters, 'name');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, callback, thisArg) {
		      var index = -1,
		          length = collection ? collection.length : 0,
		          result = Array(typeof length == 'number' ? length : 0);
	
		      callback = lodash.createCallback(callback, thisArg, 3);
		      if (isArray(collection)) {
		        while (++index < length) {
		          result[index] = callback(collection[index], index, collection);
		        }
		      } else {
		        baseEach(collection, function(value, key, collection) {
		          result[++index] = callback(value, key, collection);
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Retrieves the maximum value of a collection. If the collection is empty or
		     * falsey `-Infinity` is returned. If a callback is provided it will be executed
		     * for each value in the collection to generate the criterion by which the value
		     * is ranked. The callback is bound to `thisArg` and invoked with three
		     * arguments; (value, index, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * _.max(characters, function(chr) { return chr.age; });
		     * // => { 'name': 'fred', 'age': 40 };
		     *
		     * // using "_.pluck" callback shorthand
		     * _.max(characters, 'age');
		     * // => { 'name': 'fred', 'age': 40 };
		     */
		    function max(collection, callback, thisArg) {
		      var computed = -Infinity,
		          result = computed;
	
		      // allows working with functions like `_.map` without using
		      // their `index` argument as a callback
		      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
		        callback = null;
		      }
		      if (callback == null && isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          var value = collection[index];
		          if (value > result) {
		            result = value;
		          }
		        }
		      } else {
		        callback = (callback == null && isString(collection))
		          ? charAtCallback
		          : lodash.createCallback(callback, thisArg, 3);
	
		        baseEach(collection, function(value, index, collection) {
		          var current = callback(value, index, collection);
		          if (current > computed) {
		            computed = current;
		            result = value;
		          }
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Retrieves the minimum value of a collection. If the collection is empty or
		     * falsey `Infinity` is returned. If a callback is provided it will be executed
		     * for each value in the collection to generate the criterion by which the value
		     * is ranked. The callback is bound to `thisArg` and invoked with three
		     * arguments; (value, index, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * _.min(characters, function(chr) { return chr.age; });
		     * // => { 'name': 'barney', 'age': 36 };
		     *
		     * // using "_.pluck" callback shorthand
		     * _.min(characters, 'age');
		     * // => { 'name': 'barney', 'age': 36 };
		     */
		    function min(collection, callback, thisArg) {
		      var computed = Infinity,
		          result = computed;
	
		      // allows working with functions like `_.map` without using
		      // their `index` argument as a callback
		      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
		        callback = null;
		      }
		      if (callback == null && isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          var value = collection[index];
		          if (value < result) {
		            result = value;
		          }
		        }
		      } else {
		        callback = (callback == null && isString(collection))
		          ? charAtCallback
		          : lodash.createCallback(callback, thisArg, 3);
	
		        baseEach(collection, function(value, index, collection) {
		          var current = callback(value, index, collection);
		          if (current < computed) {
		            computed = current;
		            result = value;
		          }
		        });
		      }
		      return result;
		    }
	
		    /**
		     * Retrieves the value of a specified property from all elements in the collection.
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {string} property The name of the property to pluck.
		     * @returns {Array} Returns a new array of property values.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * _.pluck(characters, 'name');
		     * // => ['barney', 'fred']
		     */
		    var pluck = map;
	
		    /**
		     * Reduces a collection to a value which is the accumulated result of running
		     * each element in the collection through the callback, where each successive
		     * callback execution consumes the return value of the previous execution. If
		     * `accumulator` is not provided the first element of the collection will be
		     * used as the initial `accumulator` value. The callback is bound to `thisArg`
		     * and invoked with four arguments; (accumulator, value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @alias foldl, inject
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [accumulator] Initial value of the accumulator.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * var sum = _.reduce([1, 2, 3], function(sum, num) {
		     *   return sum + num;
		     * });
		     * // => 6
		     *
		     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
		     *   result[key] = num * 3;
		     *   return result;
		     * }, {});
		     * // => { 'a': 3, 'b': 6, 'c': 9 }
		     */
		    function reduce(collection, callback, accumulator, thisArg) {
		      var noaccum = arguments.length < 3;
		      callback = lodash.createCallback(callback, thisArg, 4);
	
		      if (isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        if (noaccum) {
		          accumulator = collection[++index];
		        }
		        while (++index < length) {
		          accumulator = callback(accumulator, collection[index], index, collection);
		        }
		      } else {
		        baseEach(collection, function(value, index, collection) {
		          accumulator = noaccum
		            ? (noaccum = false, value)
		            : callback(accumulator, value, index, collection)
		        });
		      }
		      return accumulator;
		    }
	
		    /**
		     * This method is like `_.reduce` except that it iterates over elements
		     * of a `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @alias foldr
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function} [callback=identity] The function called per iteration.
		     * @param {*} [accumulator] Initial value of the accumulator.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * var list = [[0, 1], [2, 3], [4, 5]];
		     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, callback, accumulator, thisArg) {
		      var noaccum = arguments.length < 3;
		      callback = lodash.createCallback(callback, thisArg, 4);
		      forEachRight(collection, function(value, index, collection) {
		        accumulator = noaccum
		          ? (noaccum = false, value)
		          : callback(accumulator, value, index, collection);
		      });
		      return accumulator;
		    }
	
		    /**
		     * The opposite of `_.filter` this method returns the elements of a
		     * collection that the callback does **not** return truey for.
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new array of elements that failed the callback check.
		     * @example
		     *
		     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
		     * // => [1, 3, 5]
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36, 'blocked': false },
		     *   { 'name': 'fred',   'age': 40, 'blocked': true }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.reject(characters, 'blocked');
		     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
		     *
		     * // using "_.where" callback shorthand
		     * _.reject(characters, { 'age': 36 });
		     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
		     */
		    function reject(collection, callback, thisArg) {
		      callback = lodash.createCallback(callback, thisArg, 3);
		      return filter(collection, function(value, index, collection) {
		        return !callback(value, index, collection);
		      });
		    }
	
		    /**
		     * Retrieves a random element or `n` random elements from a collection.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to sample.
		     * @param {number} [n] The number of elements to sample.
		     * @param- {Object} [guard] Allows working with functions like `_.map`
		     *  without using their `index` arguments as `n`.
		     * @returns {Array} Returns the random sample(s) of `collection`.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     *
		     * _.sample([1, 2, 3, 4], 2);
		     * // => [3, 1]
		     */
		    function sample(collection, n, guard) {
		      if (collection && typeof collection.length != 'number') {
		        collection = values(collection);
		      } else if (support.unindexedChars && isString(collection)) {
		        collection = collection.split('');
		      }
		      if (n == null || guard) {
		        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
		      }
		      var result = shuffle(collection);
		      result.length = nativeMin(nativeMax(0, n), result.length);
		      return result;
		    }
	
		    /**
		     * Creates an array of shuffled values, using a version of the Fisher-Yates
		     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to shuffle.
		     * @returns {Array} Returns a new shuffled collection.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4, 5, 6]);
		     * // => [4, 1, 6, 3, 5, 2]
		     */
		    function shuffle(collection) {
		      var index = -1,
		          length = collection ? collection.length : 0,
		          result = Array(typeof length == 'number' ? length : 0);
	
		      forEach(collection, function(value) {
		        var rand = baseRandom(0, ++index);
		        result[index] = result[rand];
		        result[rand] = value;
		      });
		      return result;
		    }
	
		    /**
		     * Gets the size of the `collection` by returning `collection.length` for arrays
		     * and array-like objects or the number of own enumerable properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @returns {number} Returns `collection.length` or number of own enumerable properties.
		     * @example
		     *
		     * _.size([1, 2]);
		     * // => 2
		     *
		     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
		     * // => 3
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      var length = collection ? collection.length : 0;
		      return typeof length == 'number' ? length : keys(collection).length;
		    }
	
		    /**
		     * Checks if the callback returns a truey value for **any** element of a
		     * collection. The function returns as soon as it finds a passing value and
		     * does not iterate over the entire collection. The callback is bound to
		     * `thisArg` and invoked with three arguments; (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias any
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {boolean} Returns `true` if any element passed the callback check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36, 'blocked': false },
		     *   { 'name': 'fred',   'age': 40, 'blocked': true }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.some(characters, 'blocked');
		     * // => true
		     *
		     * // using "_.where" callback shorthand
		     * _.some(characters, { 'age': 1 });
		     * // => false
		     */
		    function some(collection, callback, thisArg) {
		      var result;
		      callback = lodash.createCallback(callback, thisArg, 3);
	
		      if (isArray(collection)) {
		        var index = -1,
		            length = collection.length;
	
		        while (++index < length) {
		          if ((result = callback(collection[index], index, collection))) {
		            break;
		          }
		        }
		      } else {
		        baseEach(collection, function(value, index, collection) {
		          return !(result = callback(value, index, collection));
		        });
		      }
		      return !!result;
		    }
	
		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection through the callback. This method
		     * performs a stable sort, that is, it will preserve the original sort order
		     * of equal elements. The callback is bound to `thisArg` and invoked with
		     * three arguments; (value, index|key, collection).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an array of property names is provided for `callback` the collection
		     * will be sorted by each property value.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Array|Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new array of sorted elements.
		     * @example
		     *
		     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
		     * // => [3, 1, 2]
		     *
		     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
		     * // => [3, 1, 2]
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'age': 36 },
		     *   { 'name': 'fred',    'age': 40 },
		     *   { 'name': 'barney',  'age': 26 },
		     *   { 'name': 'fred',    'age': 30 }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.map(_.sortBy(characters, 'age'), _.values);
		     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
		     *
		     * // sorting by multiple properties
		     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
		     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
		     */
		    function sortBy(collection, callback, thisArg) {
		      var index = -1,
		          isArr = isArray(callback),
		          length = collection ? collection.length : 0,
		          result = Array(typeof length == 'number' ? length : 0);
	
		      if (!isArr) {
		        callback = lodash.createCallback(callback, thisArg, 3);
		      }
		      forEach(collection, function(value, key, collection) {
		        var object = result[++index] = getObject();
		        if (isArr) {
		          object.criteria = map(callback, function(key) { return value[key]; });
		        } else {
		          (object.criteria = getArray())[0] = callback(value, key, collection);
		        }
		        object.index = index;
		        object.value = value;
		      });
	
		      length = result.length;
		      result.sort(compareAscending);
		      while (length--) {
		        var object = result[length];
		        result[length] = object.value;
		        if (!isArr) {
		          releaseArray(object.criteria);
		        }
		        releaseObject(object);
		      }
		      return result;
		    }
	
		    /**
		     * Converts the `collection` to an array.
		     *
		     * @static
		     * @memberOf _
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to convert.
		     * @returns {Array} Returns the new converted array.
		     * @example
		     *
		     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
		     * // => [2, 3, 4]
		     */
		    function toArray(collection) {
		      if (collection && typeof collection.length == 'number') {
		        return (support.unindexedChars && isString(collection))
		          ? collection.split('')
		          : slice(collection);
		      }
		      return values(collection);
		    }
	
		    /**
		     * Performs a deep comparison of each element in a `collection` to the given
		     * `properties` object, returning an array of all elements that have equivalent
		     * property values.
		     *
		     * @static
		     * @memberOf _
		     * @type Function
		     * @category Collections
		     * @param {Array|Object|string} collection The collection to iterate over.
		     * @param {Object} props The object of property values to filter by.
		     * @returns {Array} Returns a new array of elements that have the given properties.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
		     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
		     * ];
		     *
		     * _.where(characters, { 'age': 36 });
		     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
		     *
		     * _.where(characters, { 'pets': ['dino'] });
		     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
		     */
		    var where = filter;
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are all falsey.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns a new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array ? array.length : 0,
		          result = [];
	
		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result.push(value);
		        }
		      }
		      return result;
		    }
	
		    /**
		     * Creates an array excluding all values of the provided arrays using strict
		     * equality for comparisons, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to process.
		     * @param {...Array} [values] The arrays of values to exclude.
		     * @returns {Array} Returns a new array of filtered values.
		     * @example
		     *
		     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
		     * // => [1, 3, 4]
		     */
		    function difference(array) {
		      return baseDifference(array, baseFlatten(arguments, true, true, 1));
		    }
	
		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element that passes the callback check, instead of the element itself.
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to search.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'age': 36, 'blocked': false },
		     *   { 'name': 'fred',    'age': 40, 'blocked': true },
		     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
		     * ];
		     *
		     * _.findIndex(characters, function(chr) {
		     *   return chr.age < 20;
		     * });
		     * // => 2
		     *
		     * // using "_.where" callback shorthand
		     * _.findIndex(characters, { 'age': 36 });
		     * // => 0
		     *
		     * // using "_.pluck" callback shorthand
		     * _.findIndex(characters, 'blocked');
		     * // => 1
		     */
		    function findIndex(array, callback, thisArg) {
		      var index = -1,
		          length = array ? array.length : 0;
	
		      callback = lodash.createCallback(callback, thisArg, 3);
		      while (++index < length) {
		        if (callback(array[index], index, array)) {
		          return index;
		        }
		      }
		      return -1;
		    }
	
		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of a `collection` from right to left.
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to search.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'age': 36, 'blocked': true },
		     *   { 'name': 'fred',    'age': 40, 'blocked': false },
		     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
		     * ];
		     *
		     * _.findLastIndex(characters, function(chr) {
		     *   return chr.age > 30;
		     * });
		     * // => 1
		     *
		     * // using "_.where" callback shorthand
		     * _.findLastIndex(characters, { 'age': 36 });
		     * // => 0
		     *
		     * // using "_.pluck" callback shorthand
		     * _.findLastIndex(characters, 'blocked');
		     * // => 2
		     */
		    function findLastIndex(array, callback, thisArg) {
		      var length = array ? array.length : 0;
		      callback = lodash.createCallback(callback, thisArg, 3);
		      while (length--) {
		        if (callback(array[length], length, array)) {
		          return length;
		        }
		      }
		      return -1;
		    }
	
		    /**
		     * Gets the first element or first `n` elements of an array. If a callback
		     * is provided elements at the beginning of the array are returned as long
		     * as the callback returns truey. The callback is bound to `thisArg` and
		     * invoked with three arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias head, take
		     * @category Arrays
		     * @param {Array} array The array to query.
		     * @param {Function|Object|number|string} [callback] The function called
		     *  per element or the number of elements to return. If a property name or
		     *  object is provided it will be used to create a "_.pluck" or "_.where"
		     *  style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the first element(s) of `array`.
		     * @example
		     *
		     * _.first([1, 2, 3]);
		     * // => 1
		     *
		     * _.first([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.first([1, 2, 3], function(num) {
		     *   return num < 3;
		     * });
		     * // => [1, 2]
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
		     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
		     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.first(characters, 'blocked');
		     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
		     *
		     * // using "_.where" callback shorthand
		     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
		     * // => ['barney', 'fred']
		     */
		    function first(array, callback, thisArg) {
		      var n = 0,
		          length = array ? array.length : 0;
	
		      if (typeof callback != 'number' && callback != null) {
		        var index = -1;
		        callback = lodash.createCallback(callback, thisArg, 3);
		        while (++index < length && callback(array[index], index, array)) {
		          n++;
		        }
		      } else {
		        n = callback;
		        if (n == null || thisArg) {
		          return array ? array[0] : undefined;
		        }
		      }
		      return slice(array, 0, nativeMin(nativeMax(0, n), length));
		    }
	
		    /**
		     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
		     * is truey, the array will only be flattened a single level. If a callback
		     * is provided each element of the array is passed through the callback before
		     * flattening. The callback is bound to `thisArg` and invoked with three
		     * arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to flatten.
		     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2], [3, [[4]]]]);
		     * // => [1, 2, 3, 4];
		     *
		     * _.flatten([1, [2], [3, [[4]]]], true);
		     * // => [1, 2, 3, [[4]]];
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
		     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.flatten(characters, 'pets');
		     * // => ['hoppy', 'baby puss', 'dino']
		     */
		    function flatten(array, isShallow, callback, thisArg) {
		      // juggle arguments
		      if (typeof isShallow != 'boolean' && isShallow != null) {
		        thisArg = callback;
		        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
		        isShallow = false;
		      }
		      if (callback != null) {
		        array = map(array, callback, thisArg);
		      }
		      return baseFlatten(array, isShallow);
		    }
	
		    /**
		     * Gets the index at which the first occurrence of `value` is found using
		     * strict equality for comparisons, i.e. `===`. If the array is already sorted
		     * providing `true` for `fromIndex` will run a faster binary search.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to search.
		     * @param {*} value The value to search for.
		     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
		     *  to perform a binary search on a sorted array.
		     * @returns {number} Returns the index of the matched value or `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
		     * // => 1
		     *
		     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
		     * // => 4
		     *
		     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
		     * // => 2
		     */
		    function indexOf(array, value, fromIndex) {
		      if (typeof fromIndex == 'number') {
		        var length = array ? array.length : 0;
		        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
		      } else if (fromIndex) {
		        var index = sortedIndex(array, value);
		        return array[index] === value ? index : -1;
		      }
		      return baseIndexOf(array, value, fromIndex);
		    }
	
		    /**
		     * Gets all but the last element or last `n` elements of an array. If a
		     * callback is provided elements at the end of the array are excluded from
		     * the result as long as the callback returns truey. The callback is bound
		     * to `thisArg` and invoked with three arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to query.
		     * @param {Function|Object|number|string} [callback=1] The function called
		     *  per element or the number of elements to exclude. If a property name or
		     *  object is provided it will be used to create a "_.pluck" or "_.where"
		     *  style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.initial([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.initial([1, 2, 3], function(num) {
		     *   return num > 1;
		     * });
		     * // => [1]
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
		     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
		     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.initial(characters, 'blocked');
		     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
		     *
		     * // using "_.where" callback shorthand
		     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
		     * // => ['barney', 'fred']
		     */
		    function initial(array, callback, thisArg) {
		      var n = 0,
		          length = array ? array.length : 0;
	
		      if (typeof callback != 'number' && callback != null) {
		        var index = length;
		        callback = lodash.createCallback(callback, thisArg, 3);
		        while (index-- && callback(array[index], index, array)) {
		          n++;
		        }
		      } else {
		        n = (callback == null || thisArg) ? 1 : callback || n;
		      }
		      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
		    }
	
		    /**
		     * Creates an array of unique values present in all provided arrays using
		     * strict equality for comparisons, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {...Array} [array] The arrays to inspect.
		     * @returns {Array} Returns an array of shared values.
		     * @example
		     *
		     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
		     * // => [1, 2]
		     */
		    function intersection() {
		      var args = [],
		          argsIndex = -1,
		          argsLength = arguments.length,
		          caches = getArray(),
		          indexOf = getIndexOf(),
		          trustIndexOf = indexOf === baseIndexOf,
		          seen = getArray();
	
		      while (++argsIndex < argsLength) {
		        var value = arguments[argsIndex];
		        if (isArray(value) || isArguments(value)) {
		          args.push(value);
		          caches.push(trustIndexOf && value.length >= largeArraySize &&
		            createCache(argsIndex ? args[argsIndex] : seen));
		        }
		      }
		      var array = args[0],
		          index = -1,
		          length = array ? array.length : 0,
		          result = [];
	
		      outer:
		      while (++index < length) {
		        var cache = caches[0];
		        value = array[index];
	
		        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
		          argsIndex = argsLength;
		          (cache || seen).push(value);
		          while (--argsIndex) {
		            cache = caches[argsIndex];
		            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		      }
		      while (argsLength--) {
		        cache = caches[argsLength];
		        if (cache) {
		          releaseObject(cache);
		        }
		      }
		      releaseArray(caches);
		      releaseArray(seen);
		      return result;
		    }
	
		    /**
		     * Gets the last element or last `n` elements of an array. If a callback is
		     * provided elements at the end of the array are returned as long as the
		     * callback returns truey. The callback is bound to `thisArg` and invoked
		     * with three arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to query.
		     * @param {Function|Object|number|string} [callback] The function called
		     *  per element or the number of elements to return. If a property name or
		     *  object is provided it will be used to create a "_.pluck" or "_.where"
		     *  style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {*} Returns the last element(s) of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     *
		     * _.last([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.last([1, 2, 3], function(num) {
		     *   return num > 1;
		     * });
		     * // => [2, 3]
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
		     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
		     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.pluck(_.last(characters, 'blocked'), 'name');
		     * // => ['fred', 'pebbles']
		     *
		     * // using "_.where" callback shorthand
		     * _.last(characters, { 'employer': 'na' });
		     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
		     */
		    function last(array, callback, thisArg) {
		      var n = 0,
		          length = array ? array.length : 0;
	
		      if (typeof callback != 'number' && callback != null) {
		        var index = length;
		        callback = lodash.createCallback(callback, thisArg, 3);
		        while (index-- && callback(array[index], index, array)) {
		          n++;
		        }
		      } else {
		        n = callback;
		        if (n == null || thisArg) {
		          return array ? array[length - 1] : undefined;
		        }
		      }
		      return slice(array, nativeMax(0, length - n));
		    }
	
		    /**
		     * Gets the index at which the last occurrence of `value` is found using strict
		     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
		     * as the offset from the end of the collection.
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to search.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value or `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
		     * // => 4
		     *
		     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var index = array ? array.length : 0;
		      if (typeof fromIndex == 'number') {
		        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
		      }
		      while (index--) {
		        if (array[index] === value) {
		          return index;
		        }
		      }
		      return -1;
		    }
	
		    /**
		     * Removes all provided values from the given array using strict equality for
		     * comparisons, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to modify.
		     * @param {...*} [value] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3, 1, 2, 3];
		     * _.pull(array, 2, 3);
		     * console.log(array);
		     * // => [1, 1]
		     */
		    function pull(array) {
		      var args = arguments,
		          argsIndex = 0,
		          argsLength = args.length,
		          length = array ? array.length : 0;
	
		      while (++argsIndex < argsLength) {
		        var index = -1,
		            value = args[argsIndex];
		        while (++index < length) {
		          if (array[index] === value) {
		            splice.call(array, index--, 1);
		            length--;
		          }
		        }
		      }
		      return array;
		    }
	
		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to but not including `end`. If `start` is less than `stop` a
		     * zero-length range is created unless a negative `step` is specified.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns a new range array.
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    function range(start, end, step) {
		      start = +start || 0;
		      step = typeof step == 'number' ? step : (+step || 1);
	
		      if (end == null) {
		        end = start;
		        start = 0;
		      }
		      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
		      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
		      var index = -1,
		          length = nativeMax(0, ceil((end - start) / (step || 1))),
		          result = Array(length);
	
		      while (++index < length) {
		        result[index] = start;
		        start += step;
		      }
		      return result;
		    }
	
		    /**
		     * Removes all elements from an array that the callback returns truey for
		     * and returns an array of removed elements. The callback is bound to `thisArg`
		     * and invoked with three arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to modify.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4, 5, 6];
		     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
		     *
		     * console.log(array);
		     * // => [1, 3, 5]
		     *
		     * console.log(evens);
		     * // => [2, 4, 6]
		     */
		    function remove(array, callback, thisArg) {
		      var index = -1,
		          length = array ? array.length : 0,
		          result = [];
	
		      callback = lodash.createCallback(callback, thisArg, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (callback(value, index, array)) {
		          result.push(value);
		          splice.call(array, index--, 1);
		          length--;
		        }
		      }
		      return result;
		    }
	
		    /**
		     * The opposite of `_.initial` this method gets all but the first element or
		     * first `n` elements of an array. If a callback function is provided elements
		     * at the beginning of the array are excluded from the result as long as the
		     * callback returns truey. The callback is bound to `thisArg` and invoked
		     * with three arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias drop, tail
		     * @category Arrays
		     * @param {Array} array The array to query.
		     * @param {Function|Object|number|string} [callback=1] The function called
		     *  per element or the number of elements to exclude. If a property name or
		     *  object is provided it will be used to create a "_.pluck" or "_.where"
		     *  style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a slice of `array`.
		     * @example
		     *
		     * _.rest([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.rest([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.rest([1, 2, 3], function(num) {
		     *   return num < 3;
		     * });
		     * // => [3]
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
		     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
		     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
		     * ];
		     *
		     * // using "_.pluck" callback shorthand
		     * _.pluck(_.rest(characters, 'blocked'), 'name');
		     * // => ['fred', 'pebbles']
		     *
		     * // using "_.where" callback shorthand
		     * _.rest(characters, { 'employer': 'slate' });
		     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
		     */
		    function rest(array, callback, thisArg) {
		      if (typeof callback != 'number' && callback != null) {
		        var n = 0,
		            index = -1,
		            length = array ? array.length : 0;
	
		        callback = lodash.createCallback(callback, thisArg, 3);
		        while (++index < length && callback(array[index], index, array)) {
		          n++;
		        }
		      } else {
		        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
		      }
		      return slice(array, n);
		    }
	
		    /**
		     * Uses a binary search to determine the smallest index at which a value
		     * should be inserted into a given sorted array in order to maintain the sort
		     * order of the array. If a callback is provided it will be executed for
		     * `value` and each element of `array` to compute their sort ranking. The
		     * callback is bound to `thisArg` and invoked with one argument; (value).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([20, 30, 50], 40);
		     * // => 2
		     *
		     * // using "_.pluck" callback shorthand
		     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
		     * // => 2
		     *
		     * var dict = {
		     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
		     * };
		     *
		     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
		     *   return dict.wordToNumber[word];
		     * });
		     * // => 2
		     *
		     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
		     *   return this.wordToNumber[word];
		     * }, dict);
		     * // => 2
		     */
		    function sortedIndex(array, value, callback, thisArg) {
		      var low = 0,
		          high = array ? array.length : low;
	
		      // explicitly reference `identity` for better inlining in Firefox
		      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
		      value = callback(value);
	
		      while (low < high) {
		        var mid = (low + high) >>> 1;
		        (callback(array[mid]) < value)
		          ? low = mid + 1
		          : high = mid;
		      }
		      return low;
		    }
	
		    /**
		     * Creates an array of unique values, in order, of the provided arrays using
		     * strict equality for comparisons, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {...Array} [array] The arrays to inspect.
		     * @returns {Array} Returns an array of combined values.
		     * @example
		     *
		     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
		     * // => [1, 2, 3, 5, 4]
		     */
		    function union() {
		      return baseUniq(baseFlatten(arguments, true, true));
		    }
	
		    /**
		     * Creates a duplicate-value-free version of an array using strict equality
		     * for comparisons, i.e. `===`. If the array is sorted, providing
		     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
		     * each element of `array` is passed through the callback before uniqueness
		     * is computed. The callback is bound to `thisArg` and invoked with three
		     * arguments; (value, index, array).
		     *
		     * If a property name is provided for `callback` the created "_.pluck" style
		     * callback will return the property value of the given element.
		     *
		     * If an object is provided for `callback` the created "_.where" style callback
		     * will return `true` for elements that have the properties of the given object,
		     * else `false`.
		     *
		     * @static
		     * @memberOf _
		     * @alias unique
		     * @category Arrays
		     * @param {Array} array The array to process.
		     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
		     * @param {Function|Object|string} [callback=identity] The function called
		     *  per iteration. If a property name or object is provided it will be used
		     *  to create a "_.pluck" or "_.where" style callback, respectively.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns a duplicate-value-free array.
		     * @example
		     *
		     * _.uniq([1, 2, 1, 3, 1]);
		     * // => [1, 2, 3]
		     *
		     * _.uniq([1, 1, 2, 2, 3], true);
		     * // => [1, 2, 3]
		     *
		     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
		     * // => ['A', 'b', 'C']
		     *
		     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
		     * // => [1, 2.5, 3]
		     *
		     * // using "_.pluck" callback shorthand
		     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniq(array, isSorted, callback, thisArg) {
		      // juggle arguments
		      if (typeof isSorted != 'boolean' && isSorted != null) {
		        thisArg = callback;
		        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
		        isSorted = false;
		      }
		      if (callback != null) {
		        callback = lodash.createCallback(callback, thisArg, 3);
		      }
		      return baseUniq(array, isSorted, callback);
		    }
	
		    /**
		     * Creates an array excluding all provided values using strict equality for
		     * comparisons, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {Array} array The array to filter.
		     * @param {...*} [value] The values to exclude.
		     * @returns {Array} Returns a new array of filtered values.
		     * @example
		     *
		     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
		     * // => [2, 3, 4]
		     */
		    function without(array) {
		      return baseDifference(array, slice(arguments, 1));
		    }
	
		    /**
		     * Creates an array that is the symmetric difference of the provided arrays.
		     * See http://en.wikipedia.org/wiki/Symmetric_difference.
		     *
		     * @static
		     * @memberOf _
		     * @category Arrays
		     * @param {...Array} [array] The arrays to inspect.
		     * @returns {Array} Returns an array of values.
		     * @example
		     *
		     * _.xor([1, 2, 3], [5, 2, 1, 4]);
		     * // => [3, 5, 4]
		     *
		     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
		     * // => [1, 4, 5]
		     */
		    function xor() {
		      var index = -1,
		          length = arguments.length;
	
		      while (++index < length) {
		        var array = arguments[index];
		        if (isArray(array) || isArguments(array)) {
		          var result = result
		            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
		            : array;
		        }
		      }
		      return result || [];
		    }
	
		    /**
		     * Creates an array of grouped elements, the first of which contains the first
		     * elements of the given arrays, the second of which contains the second
		     * elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @alias unzip
		     * @category Arrays
		     * @param {...Array} [array] Arrays to process.
		     * @returns {Array} Returns a new array of grouped elements.
		     * @example
		     *
		     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
		     * // => [['fred', 30, true], ['barney', 40, false]]
		     */
		    function zip() {
		      var array = arguments.length > 1 ? arguments : arguments[0],
		          index = -1,
		          length = array ? max(pluck(array, 'length')) : 0,
		          result = Array(length < 0 ? 0 : length);
	
		      while (++index < length) {
		        result[index] = pluck(array, index);
		      }
		      return result;
		    }
	
		    /**
		     * Creates an object composed from arrays of `keys` and `values`. Provide
		     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
		     * or two arrays, one of `keys` and one of corresponding `values`.
		     *
		     * @static
		     * @memberOf _
		     * @alias object
		     * @category Arrays
		     * @param {Array} keys The array of keys.
		     * @param {Array} [values=[]] The array of values.
		     * @returns {Object} Returns an object composed of the given keys and
		     *  corresponding values.
		     * @example
		     *
		     * _.zipObject(['fred', 'barney'], [30, 40]);
		     * // => { 'fred': 30, 'barney': 40 }
		     */
		    function zipObject(keys, values) {
		      var index = -1,
		          length = keys ? keys.length : 0,
		          result = {};
	
		      if (!values && length && !isArray(keys[0])) {
		        values = [];
		      }
		      while (++index < length) {
		        var key = keys[index];
		        if (values) {
		          result[key] = values[index];
		        } else if (key) {
		          result[key[0]] = key[1];
		        }
		      }
		      return result;
		    }
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Creates a function that executes `func`, with  the `this` binding and
		     * arguments of the created function, only after being called `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {number} n The number of times the function must be called before
		     *  `func` is executed.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('Done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => logs 'Done saving!', after all saves have completed
		     */
		    function after(n, func) {
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }
	
		    /**
		     * Creates a function that, when called, invokes `func` with the `this`
		     * binding of `thisArg` and prepends any additional `bind` arguments to those
		     * provided to the bound function.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to bind.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {...*} [arg] Arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var func = function(greeting) {
		     *   return greeting + ' ' + this.name;
		     * };
		     *
		     * func = _.bind(func, { 'name': 'fred' }, 'hi');
		     * func();
		     * // => 'hi fred'
		     */
		    function bind(func, thisArg) {
		      return arguments.length > 2
		        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
		        : createWrapper(func, 1, null, null, thisArg);
		    }
	
		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method. Method names may be specified as individual arguments or as arrays
		     * of method names. If no method names are provided all the function properties
		     * of `object` will be bound.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...string} [methodName] The object method names to
		     *  bind, specified as individual method names or arrays of method names.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'onClick': function() { console.log('clicked ' + this.label); }
		     * };
		     *
		     * _.bindAll(view);
		     * jQuery('#docs').on('click', view.onClick);
		     * // => logs 'clicked docs', when the button is clicked
		     */
		    function bindAll(object) {
		      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
		          index = -1,
		          length = funcs.length;
	
		      while (++index < length) {
		        var key = funcs[index];
		        object[key] = createWrapper(object[key], 1, null, null, object);
		      }
		      return object;
		    }
	
		    /**
		     * Creates a function that, when called, invokes the method at `object[key]`
		     * and prepends any additional `bindKey` arguments to those provided to the bound
		     * function. This method differs from `_.bind` by allowing bound functions to
		     * reference methods that will be redefined or don't yet exist.
		     * See http://michaux.ca/articles/lazy-function-definition-pattern.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Object} object The object the method belongs to.
		     * @param {string} key The key of the method.
		     * @param {...*} [arg] Arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'name': 'fred',
		     *   'greet': function(greeting) {
		     *     return greeting + ' ' + this.name;
		     *   }
		     * };
		     *
		     * var func = _.bindKey(object, 'greet', 'hi');
		     * func();
		     * // => 'hi fred'
		     *
		     * object.greet = function(greeting) {
		     *   return greeting + 'ya ' + this.name + '!';
		     * };
		     *
		     * func();
		     * // => 'hiya fred!'
		     */
		    function bindKey(object, key) {
		      return arguments.length > 2
		        ? createWrapper(key, 19, slice(arguments, 2), null, object)
		        : createWrapper(key, 3, null, null, object);
		    }
	
		    /**
		     * Creates a function that is the composition of the provided functions,
		     * where each function consumes the return value of the function that follows.
		     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
		     * Each function is executed with the `this` binding of the composed function.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {...Function} [func] Functions to compose.
		     * @returns {Function} Returns the new composed function.
		     * @example
		     *
		     * var realNameMap = {
		     *   'pebbles': 'penelope'
		     * };
		     *
		     * var format = function(name) {
		     *   name = realNameMap[name.toLowerCase()] || name;
		     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
		     * };
		     *
		     * var greet = function(formatted) {
		     *   return 'Hiya ' + formatted + '!';
		     * };
		     *
		     * var welcome = _.compose(greet, format);
		     * welcome('pebbles');
		     * // => 'Hiya Penelope!'
		     */
		    function compose() {
		      var funcs = arguments,
		          length = funcs.length;
	
		      while (length--) {
		        if (!isFunction(funcs[length])) {
		          throw new TypeError;
		        }
		      }
		      return function() {
		        var args = arguments,
		            length = funcs.length;
	
		        while (length--) {
		          args = [funcs[length].apply(this, args)];
		        }
		        return args[0];
		      };
		    }
	
		    /**
		     * Creates a function which accepts one or more arguments of `func` that when
		     * invoked either executes `func` returning its result, if all `func` arguments
		     * have been provided, or returns a function that accepts one or more of the
		     * remaining `func` arguments, and so on. The arity of `func` can be specified
		     * if `func.length` is not sufficient.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var curried = _.curry(function(a, b, c) {
		     *   console.log(a + b + c);
		     * });
		     *
		     * curried(1)(2)(3);
		     * // => 6
		     *
		     * curried(1, 2)(3);
		     * // => 6
		     *
		     * curried(1, 2, 3);
		     * // => 6
		     */
		    function curry(func, arity) {
		      arity = typeof arity == 'number' ? arity : (+arity || func.length);
		      return createWrapper(func, 4, null, null, null, arity);
		    }
	
		    /**
		     * Creates a function that will delay the execution of `func` until after
		     * `wait` milliseconds have elapsed since the last time it was invoked.
		     * Provide an options object to indicate that `func` should be invoked on
		     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
		     * to the debounced function will return the result of the last `func` call.
		     *
		     * Note: If `leading` and `trailing` options are `true` `func` will be called
		     * on the trailing edge of the timeout only if the the debounced function is
		     * invoked more than once during the `wait` timeout.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to debounce.
		     * @param {number} wait The number of milliseconds to delay.
		     * @param {Object} [options] The options object.
		     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
		     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
		     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // avoid costly calculations while the window size is in flux
		     * var lazyLayout = _.debounce(calculateLayout, 150);
		     * jQuery(window).on('resize', lazyLayout);
		     *
		     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
		     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * });
		     *
		     * // ensure `batchLog` is executed once after 1 second of debounced calls
		     * var source = new EventSource('/stream');
		     * source.addEventListener('message', _.debounce(batchLog, 250, {
		     *   'maxWait': 1000
		     * }, false);
		     */
		    function debounce(func, wait, options) {
		      var args,
		          maxTimeoutId,
		          result,
		          stamp,
		          thisArg,
		          timeoutId,
		          trailingCall,
		          lastCalled = 0,
		          maxWait = false,
		          trailing = true;
	
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      wait = nativeMax(0, wait) || 0;
		      if (options === true) {
		        var leading = true;
		        trailing = false;
		      } else if (isObject(options)) {
		        leading = options.leading;
		        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
		        trailing = 'trailing' in options ? options.trailing : trailing;
		      }
		      var delayed = function() {
		        var remaining = wait - (now() - stamp);
		        if (remaining <= 0) {
		          if (maxTimeoutId) {
		            clearTimeout(maxTimeoutId);
		          }
		          var isCalled = trailingCall;
		          maxTimeoutId = timeoutId = trailingCall = undefined;
		          if (isCalled) {
		            lastCalled = now();
		            result = func.apply(thisArg, args);
		            if (!timeoutId && !maxTimeoutId) {
		              args = thisArg = null;
		            }
		          }
		        } else {
		          timeoutId = setTimeout(delayed, remaining);
		        }
		      };
	
		      var maxDelayed = function() {
		        if (timeoutId) {
		          clearTimeout(timeoutId);
		        }
		        maxTimeoutId = timeoutId = trailingCall = undefined;
		        if (trailing || (maxWait !== wait)) {
		          lastCalled = now();
		          result = func.apply(thisArg, args);
		          if (!timeoutId && !maxTimeoutId) {
		            args = thisArg = null;
		          }
		        }
		      };
	
		      return function() {
		        args = arguments;
		        stamp = now();
		        thisArg = this;
		        trailingCall = trailing && (timeoutId || !leading);
	
		        if (maxWait === false) {
		          var leadingCall = leading && !timeoutId;
		        } else {
		          if (!maxTimeoutId && !leading) {
		            lastCalled = stamp;
		          }
		          var remaining = maxWait - (stamp - lastCalled),
		              isCalled = remaining <= 0;
	
		          if (isCalled) {
		            if (maxTimeoutId) {
		              maxTimeoutId = clearTimeout(maxTimeoutId);
		            }
		            lastCalled = stamp;
		            result = func.apply(thisArg, args);
		          }
		          else if (!maxTimeoutId) {
		            maxTimeoutId = setTimeout(maxDelayed, remaining);
		          }
		        }
		        if (isCalled && timeoutId) {
		          timeoutId = clearTimeout(timeoutId);
		        }
		        else if (!timeoutId && wait !== maxWait) {
		          timeoutId = setTimeout(delayed, wait);
		        }
		        if (leadingCall) {
		          isCalled = true;
		          result = func.apply(thisArg, args);
		        }
		        if (isCalled && !timeoutId && !maxTimeoutId) {
		          args = thisArg = null;
		        }
		        return result;
		      };
		    }
	
		    /**
		     * Defers executing the `func` function until the current call stack has cleared.
		     * Additional arguments will be provided to `func` when it is invoked.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to defer.
		     * @param {...*} [arg] Arguments to invoke the function with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) { console.log(text); }, 'deferred');
		     * // logs 'deferred' after one or more milliseconds
		     */
		    function defer(func) {
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      var args = slice(arguments, 1);
		      return setTimeout(function() { func.apply(undefined, args); }, 1);
		    }
	
		    /**
		     * Executes the `func` function after `wait` milliseconds. Additional arguments
		     * will be provided to `func` when it is invoked.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay execution.
		     * @param {...*} [arg] Arguments to invoke the function with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) { console.log(text); }, 1000, 'later');
		     * // => logs 'later' after one second
		     */
		    function delay(func, wait) {
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      var args = slice(arguments, 2);
		      return setTimeout(function() { func.apply(undefined, args); }, wait);
		    }
	
		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided it will be used to determine the cache key for storing the result
		     * based on the arguments provided to the memoized function. By default, the
		     * first argument provided to the memoized function is used as the cache key.
		     * The `func` is executed with the `this` binding of the memoized function.
		     * The result cache is exposed as the `cache` property on the memoized function.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] A function used to resolve the cache key.
		     * @returns {Function} Returns the new memoizing function.
		     * @example
		     *
		     * var fibonacci = _.memoize(function(n) {
		     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
		     * });
		     *
		     * fibonacci(9)
		     * // => 34
		     *
		     * var data = {
		     *   'fred': { 'name': 'fred', 'age': 40 },
		     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
		     * };
		     *
		     * // modifying the result cache
		     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
		     * get('pebbles');
		     * // => { 'name': 'pebbles', 'age': 1 }
		     *
		     * get.cache.pebbles.name = 'penelope';
		     * get('pebbles');
		     * // => { 'name': 'penelope', 'age': 1 }
		     */
		    function memoize(func, resolver) {
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      var memoized = function() {
		        var cache = memoized.cache,
		            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
	
		        return hasOwnProperty.call(cache, key)
		          ? cache[key]
		          : (cache[key] = func.apply(this, arguments));
		      }
		      memoized.cache = {};
		      return memoized;
		    }
	
		    /**
		     * Creates a function that is restricted to execute `func` once. Repeat calls to
		     * the function will return the value of the first call. The `func` is executed
		     * with the `this` binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // `initialize` executes `createApplication` once
		     */
		    function once(func) {
		      var ran,
		          result;
	
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      return function() {
		        if (ran) {
		          return result;
		        }
		        ran = true;
		        result = func.apply(this, arguments);
	
		        // clear the `func` variable so the function may be garbage collected
		        func = null;
		        return result;
		      };
		    }
	
		    /**
		     * Creates a function that, when called, invokes `func` with any additional
		     * `partial` arguments prepended to those provided to the new function. This
		     * method is similar to `_.bind` except it does **not** alter the `this` binding.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [arg] Arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * var greet = function(greeting, name) { return greeting + ' ' + name; };
		     * var hi = _.partial(greet, 'hi');
		     * hi('fred');
		     * // => 'hi fred'
		     */
		    function partial(func) {
		      return createWrapper(func, 16, slice(arguments, 1));
		    }
	
		    /**
		     * This method is like `_.partial` except that `partial` arguments are
		     * appended to those provided to the new function.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [arg] Arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
		     *
		     * var options = {
		     *   'variable': 'data',
		     *   'imports': { 'jq': $ }
		     * };
		     *
		     * defaultsDeep(options, _.templateSettings);
		     *
		     * options.variable
		     * // => 'data'
		     *
		     * options.imports
		     * // => { '_': _, 'jq': $ }
		     */
		    function partialRight(func) {
		      return createWrapper(func, 32, null, slice(arguments, 1));
		    }
	
		    /**
		     * Creates a function that, when executed, will only call the `func` function
		     * at most once per every `wait` milliseconds. Provide an options object to
		     * indicate that `func` should be invoked on the leading and/or trailing edge
		     * of the `wait` timeout. Subsequent calls to the throttled function will
		     * return the result of the last `func` call.
		     *
		     * Note: If `leading` and `trailing` options are `true` `func` will be called
		     * on the trailing edge of the timeout only if the the throttled function is
		     * invoked more than once during the `wait` timeout.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {Function} func The function to throttle.
		     * @param {number} wait The number of milliseconds to throttle executions to.
		     * @param {Object} [options] The options object.
		     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // avoid excessively updating the position while scrolling
		     * var throttled = _.throttle(updatePosition, 100);
		     * jQuery(window).on('scroll', throttled);
		     *
		     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
		     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
		     *   'trailing': false
		     * }));
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;
	
		      if (!isFunction(func)) {
		        throw new TypeError;
		      }
		      if (options === false) {
		        leading = false;
		      } else if (isObject(options)) {
		        leading = 'leading' in options ? options.leading : leading;
		        trailing = 'trailing' in options ? options.trailing : trailing;
		      }
		      debounceOptions.leading = leading;
		      debounceOptions.maxWait = wait;
		      debounceOptions.trailing = trailing;
	
		      return debounce(func, wait, debounceOptions);
		    }
	
		    /**
		     * Creates a function that provides `value` to the wrapper function as its
		     * first argument. Additional arguments provided to the function are appended
		     * to those provided to the wrapper function. The wrapper is executed with
		     * the `this` binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @category Functions
		     * @param {*} value The value to wrap.
		     * @param {Function} wrapper The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('Fred, Wilma, & Pebbles');
		     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      return createWrapper(wrapper, 16, [value]);
		    }
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var object = { 'name': 'fred' };
		     * var getter = _.constant(object);
		     * getter() === object;
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }
	
		    /**
		     * Produces a callback bound to an optional `thisArg`. If `func` is a property
		     * name the created callback will return the property value for a given element.
		     * If `func` is an object the created callback will return `true` for elements
		     * that contain the equivalent object properties, otherwise it will return `false`.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {*} [func=identity] The value to convert to a callback.
		     * @param {*} [thisArg] The `this` binding of the created callback.
		     * @param {number} [argCount] The number of arguments the callback accepts.
		     * @returns {Function} Returns a callback function.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * // wrap to create custom callback shorthands
		     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
		     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
		     *   return !match ? func(callback, thisArg) : function(object) {
		     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
		     *   };
		     * });
		     *
		     * _.filter(characters, 'age__gt38');
		     * // => [{ 'name': 'fred', 'age': 40 }]
		     */
		    function createCallback(func, thisArg, argCount) {
		      var type = typeof func;
		      if (func == null || type == 'function') {
		        return baseCreateCallback(func, thisArg, argCount);
		      }
		      // handle "_.pluck" style callback shorthands
		      if (type != 'object') {
		        return property(func);
		      }
		      var props = keys(func),
		          key = props[0],
		          a = func[key];
	
		      // handle "_.where" style callback shorthands
		      if (props.length == 1 && a === a && !isObject(a)) {
		        // fast path the common case of providing an object with a single
		        // property containing a primitive value
		        return function(object) {
		          var b = object[key];
		          return a === b && (a !== 0 || (1 / a == 1 / b));
		        };
		      }
		      return function(object) {
		        var length = props.length,
		            result = false;
	
		        while (length--) {
		          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
		            break;
		          }
		        }
		        return result;
		      };
		    }
	
		    /**
		     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
		     * corresponding HTML entities.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {string} string The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('Fred, Wilma, & Pebbles');
		     * // => 'Fred, Wilma, &amp; Pebbles'
		     */
		    function escape(string) {
		      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
		    }
	
		    /**
		     * This method returns the first argument provided to it.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'name': 'fred' };
		     * _.identity(object) === object;
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }
	
		    /**
		     * Adds function properties of a source object to the destination object.
		     * If `object` is a function methods will be added to its prototype as well.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {Function|Object} [object=lodash] object The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options] The options object.
		     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
		     * @example
		     *
		     * function capitalize(string) {
		     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
		     * }
		     *
		     * _.mixin({ 'capitalize': capitalize });
		     * _.capitalize('fred');
		     * // => 'Fred'
		     *
		     * _('fred').capitalize().value();
		     * // => 'Fred'
		     *
		     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
		     * _('fred').capitalize();
		     * // => 'Fred'
		     */
		    function mixin(object, source, options) {
		      var chain = true,
		          methodNames = source && functions(source);
	
		      if (!source || (!options && !methodNames.length)) {
		        if (options == null) {
		          options = source;
		        }
		        ctor = lodashWrapper;
		        source = object;
		        object = lodash;
		        methodNames = functions(source);
		      }
		      if (options === false) {
		        chain = false;
		      } else if (isObject(options) && 'chain' in options) {
		        chain = options.chain;
		      }
		      var ctor = object,
		          isFunc = isFunction(ctor);
	
		      forEach(methodNames, function(methodName) {
		        var func = object[methodName] = source[methodName];
		        if (isFunc) {
		          ctor.prototype[methodName] = function() {
		            var chainAll = this.__chain__,
		                value = this.__wrapped__,
		                args = [value];
	
		            push.apply(args, arguments);
		            var result = func.apply(object, args);
		            if (chain || chainAll) {
		              if (value === result && isObject(result)) {
		                return this;
		              }
		              result = new ctor(result);
		              result.__chain__ = chainAll;
		            }
		            return result;
		          };
		        }
		      });
		    }
	
		    /**
		     * Reverts the '_' variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      context._ = oldDash;
		      return this;
		    }
	
		    /**
		     * A no-operation function.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @example
		     *
		     * var object = { 'name': 'fred' };
		     * _.noop(object) === undefined;
		     * // => true
		     */
		    function noop() {
		      // no operation performed
		    }
	
		    /**
		     * Gets the number of milliseconds that have elapsed since the Unix epoch
		     * (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @example
		     *
		     * var stamp = _.now();
		     * _.defer(function() { console.log(_.now() - stamp); });
		     * // => logs the number of milliseconds it took for the deferred function to be called
		     */
		    var now = isNative(now = Date.now) && now || function() {
		      return new Date().getTime();
		    };
	
		    /**
		     * Converts the given value into an integer of the specified radix.
		     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
		     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
		     * implementations. See http://es5.github.io/#E.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {string} value The value to parse.
		     * @param {number} [radix] The radix used to interpret the value to parse.
		     * @returns {number} Returns the new integer value.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     */
		    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
		      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
		      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
		    };
	
		    /**
		     * Creates a "_.pluck" style function, which returns the `key` value of a
		     * given object.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {string} key The name of the property to retrieve.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'fred',   'age': 40 },
		     *   { 'name': 'barney', 'age': 36 }
		     * ];
		     *
		     * var getName = _.property('name');
		     *
		     * _.map(characters, getName);
		     * // => ['barney', 'fred']
		     *
		     * _.sortBy(characters, getName);
		     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
		     */
		    function property(key) {
		      return function(object) {
		        return object[key];
		      };
		    }
	
		    /**
		     * Produces a random number between `min` and `max` (inclusive). If only one
		     * argument is provided a number between `0` and the given number will be
		     * returned. If `floating` is truey or either `min` or `max` are floats a
		     * floating-point number will be returned instead of an integer.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {number} [min=0] The minimum possible value.
		     * @param {number} [max=1] The maximum possible value.
		     * @param {boolean} [floating=false] Specify returning a floating-point number.
		     * @returns {number} Returns a random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(min, max, floating) {
		      var noMin = min == null,
		          noMax = max == null;
	
		      if (floating == null) {
		        if (typeof min == 'boolean' && noMax) {
		          floating = min;
		          min = 1;
		        }
		        else if (!noMax && typeof max == 'boolean') {
		          floating = max;
		          noMax = true;
		        }
		      }
		      if (noMin && noMax) {
		        max = 1;
		      }
		      min = +min || 0;
		      if (noMax) {
		        max = min;
		        min = 0;
		      } else {
		        max = +max || 0;
		      }
		      if (floating || min % 1 || max % 1) {
		        var rand = nativeRandom();
		        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
		      }
		      return baseRandom(min, max);
		    }
	
		    /**
		     * Resolves the value of property `key` on `object`. If `key` is a function
		     * it will be invoked with the `this` binding of `object` and its result returned,
		     * else the property value is returned. If `object` is falsey then `undefined`
		     * is returned.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {Object} object The object to inspect.
		     * @param {string} key The name of the property to resolve.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = {
		     *   'cheese': 'crumpets',
		     *   'stuff': function() {
		     *     return 'nonsense';
		     *   }
		     * };
		     *
		     * _.result(object, 'cheese');
		     * // => 'crumpets'
		     *
		     * _.result(object, 'stuff');
		     * // => 'nonsense'
		     */
		    function result(object, key) {
		      if (object) {
		        var value = object[key];
		        return isFunction(value) ? object[key]() : value;
		      }
		    }
	
		    /**
		     * A micro-templating method that handles arbitrary delimiters, preserves
		     * whitespace, and correctly escapes quotes within interpolated code.
		     *
		     * Note: In the development build, `_.template` utilizes sourceURLs for easier
		     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
		     *
		     * For more information on precompiling templates see:
		     * https://lodash.com/custom-builds
		     *
		     * For more information on Chrome extension sandboxes see:
		     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {string} text The template text.
		     * @param {Object} data The data object used to populate the text.
		     * @param {Object} [options] The options object.
		     * @param {RegExp} [options.escape] The "escape" delimiter.
		     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
		     * @param {Object} [options.imports] An object to import into the template as local variables.
		     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
		     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
		     * @param {string} [variable] The data object variable name.
		     * @returns {Function|string} Returns a compiled function when no `data` object
		     *  is given, else it returns the interpolated text.
		     * @example
		     *
		     * // using the "interpolate" delimiter to create a compiled template
		     * var compiled = _.template('hello <%= name %>');
		     * compiled({ 'name': 'fred' });
		     * // => 'hello fred'
		     *
		     * // using the "escape" delimiter to escape HTML in data property values
		     * _.template('<b><%- value %></b>', { 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // using the "evaluate" delimiter to generate HTML
		     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
		     * _.template(list, { 'people': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
		     * _.template('hello ${ name }', { 'name': 'pebbles' });
		     * // => 'hello pebbles'
		     *
		     * // using the internal `print` function in "evaluate" delimiters
		     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // using a custom template delimiters
		     * _.templateSettings = {
		     *   'interpolate': /{{([\s\S]+?)}}/g
		     * };
		     *
		     * _.template('hello {{ name }}!', { 'name': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // using the `imports` option to import jQuery
		     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
		     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // using the `sourceURL` option to specify a custom sourceURL for the template
		     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
		     *
		     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
		     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     *   var __t, __p = '', __e = _.escape;
		     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
		     *   return __p;
		     * }
		     *
		     * // using the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and a stack trace
		     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(text, data, options) {
		      // based on John Resig's `tmpl` implementation
		      // http://ejohn.org/blog/javascript-micro-templating/
		      // and Laura Doktorova's doT.js
		      // https://github.com/olado/doT
		      var settings = lodash.templateSettings;
		      text = String(text || '');
	
		      // avoid missing dependencies when `iteratorTemplate` is not defined
		      options = defaults({}, options, settings);
	
		      var imports = defaults({}, options.imports, settings.imports),
		          importsKeys = keys(imports),
		          importsValues = values(imports);
	
		      var isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";
	
		      // compile the regexp to match each delimiter
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');
	
		      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);
	
		        // escape characters that cannot be included in string literals
		        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
		        // replace delimiters with snippets
		        if (escapeValue) {
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;
	
		        // the JS engine embedded in Adobe products requires returning the `match`
		        // string in order to produce the correct `offset` value
		        return match;
		      });
	
		      source += "';\n";
	
		      // if `variable` is not specified, wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain
		      var variable = options.variable,
		          hasVariable = variable;
	
		      if (!hasVariable) {
		        variable = 'obj';
		        source = 'with (' + variable + ') {\n' + source + '\n}\n';
		      }
		      // cleanup code by stripping empty strings
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');
	
		      // frame code as the function body
		      source = 'function(' + variable + ') {\n' +
		        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
		        "var __t, __p = '', __e = _.escape" +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';
	
		      // Use a sourceURL for easier debugging.
		      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
		      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
	
		      try {
		        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
		      } catch(e) {
		        e.source = source;
		        throw e;
		      }
		      if (data) {
		        return result(data);
		      }
		      // provide the compiled function's source by its `toString` method, in
		      // supported environments, or the `source` property as a convenience for
		      // inlining compiled templates during the build process
		      result.source = source;
		      return result;
		    }
	
		    /**
		     * Executes the callback `n` times, returning an array of the results
		     * of each callback execution. The callback is bound to `thisArg` and invoked
		     * with one argument; (index).
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {number} n The number of times to execute the callback.
		     * @param {Function} callback The function called per iteration.
		     * @param {*} [thisArg] The `this` binding of `callback`.
		     * @returns {Array} Returns an array of the results of each `callback` execution.
		     * @example
		     *
		     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
		     * // => [3, 6, 4]
		     *
		     * _.times(3, function(n) { mage.castSpell(n); });
		     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
		     *
		     * _.times(3, function(n) { this.cast(n); }, mage);
		     * // => also calls `mage.castSpell(n)` three times
		     */
		    function times(n, callback, thisArg) {
		      n = (n = +n) > -1 ? n : 0;
		      var index = -1,
		          result = Array(n);
	
		      callback = baseCreateCallback(callback, thisArg, 1);
		      while (++index < n) {
		        result[index] = callback(index);
		      }
		      return result;
		    }
	
		    /**
		     * The inverse of `_.escape` this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
		     * corresponding characters.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {string} string The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('Fred, Barney &amp; Pebbles');
		     * // => 'Fred, Barney & Pebbles'
		     */
		    function unescape(string) {
		      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
		    }
	
		    /**
		     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
		     *
		     * @static
		     * @memberOf _
		     * @category Utilities
		     * @param {string} [prefix] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return String(prefix == null ? '' : prefix) + id;
		    }
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * Creates a `lodash` object that wraps the given value with explicit
		     * method chaining enabled.
		     *
		     * @static
		     * @memberOf _
		     * @category Chaining
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney',  'age': 36 },
		     *   { 'name': 'fred',    'age': 40 },
		     *   { 'name': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _.chain(characters)
		     *     .sortBy('age')
		     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
		     *     .first()
		     *     .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      value = new lodashWrapper(value);
		      value.__chain__ = true;
		      return value;
		    }
	
		    /**
		     * Invokes `interceptor` with the `value` as the first argument and then
		     * returns `value`. The purpose of this method is to "tap into" a method
		     * chain in order to perform operations on intermediate results within
		     * the chain.
		     *
		     * @static
		     * @memberOf _
		     * @category Chaining
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3, 4])
		     *  .tap(function(array) { array.pop(); })
		     *  .reverse()
		     *  .value();
		     * // => [3, 2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }
	
		    /**
		     * Enables explicit method chaining on the wrapper object.
		     *
		     * @name chain
		     * @memberOf _
		     * @category Chaining
		     * @returns {*} Returns the wrapper object.
		     * @example
		     *
		     * var characters = [
		     *   { 'name': 'barney', 'age': 36 },
		     *   { 'name': 'fred',   'age': 40 }
		     * ];
		     *
		     * // without explicit chaining
		     * _(characters).first();
		     * // => { 'name': 'barney', 'age': 36 }
		     *
		     * // with explicit chaining
		     * _(characters).chain()
		     *   .first()
		     *   .pick('age')
		     *   .value();
		     * // => { 'age': 36 }
		     */
		    function wrapperChain() {
		      this.__chain__ = true;
		      return this;
		    }
	
		    /**
		     * Produces the `toString` result of the wrapped value.
		     *
		     * @name toString
		     * @memberOf _
		     * @category Chaining
		     * @returns {string} Returns the string result.
		     * @example
		     *
		     * _([1, 2, 3]).toString();
		     * // => '1,2,3'
		     */
		    function wrapperToString() {
		      return String(this.__wrapped__);
		    }
	
		    /**
		     * Extracts the wrapped value.
		     *
		     * @name valueOf
		     * @memberOf _
		     * @alias value
		     * @category Chaining
		     * @returns {*} Returns the wrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).valueOf();
		     * // => [1, 2, 3]
		     */
		    function wrapperValueOf() {
		      return this.__wrapped__;
		    }
	
		    /*--------------------------------------------------------------------------*/
	
		    // add functions that return wrapped values when chaining
		    lodash.after = after;
		    lodash.assign = assign;
		    lodash.at = at;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.chain = chain;
		    lodash.compact = compact;
		    lodash.compose = compose;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.createCallback = createCallback;
		    lodash.curry = curry;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.filter = filter;
		    lodash.flatten = flatten;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.functions = functions;
		    lodash.groupBy = groupBy;
		    lodash.indexBy = indexBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.invert = invert;
		    lodash.invoke = invoke;
		    lodash.keys = keys;
		    lodash.map = map;
		    lodash.mapValues = mapValues;
		    lodash.max = max;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.min = min;
		    lodash.omit = omit;
		    lodash.once = once;
		    lodash.pairs = pairs;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.pick = pick;
		    lodash.pluck = pluck;
		    lodash.property = property;
		    lodash.pull = pull;
		    lodash.range = range;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.shuffle = shuffle;
		    lodash.sortBy = sortBy;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.times = times;
		    lodash.toArray = toArray;
		    lodash.transform = transform;
		    lodash.union = union;
		    lodash.uniq = uniq;
		    lodash.values = values;
		    lodash.where = where;
		    lodash.without = without;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
	
		    // add aliases
		    lodash.collect = map;
		    lodash.drop = rest;
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.extend = assign;
		    lodash.methods = functions;
		    lodash.object = zipObject;
		    lodash.select = filter;
		    lodash.tail = rest;
		    lodash.unique = uniq;
		    lodash.unzip = zip;
	
		    // add functions to `lodash.prototype`
		    mixin(lodash);
	
		    /*--------------------------------------------------------------------------*/
	
		    // add functions that return unwrapped values when chaining
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.contains = contains;
		    lodash.escape = escape;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.has = has;
		    lodash.identity = identity;
		    lodash.indexOf = indexOf;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isBoolean = isBoolean;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isNaN = isNaN;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isString = isString;
		    lodash.isUndefined = isUndefined;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.mixin = mixin;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.result = result;
		    lodash.runInContext = runInContext;
		    lodash.size = size;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.template = template;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
	
		    // add aliases
		    lodash.all = every;
		    lodash.any = some;
		    lodash.detect = find;
		    lodash.findWhere = find;
		    lodash.foldl = reduce;
		    lodash.foldr = reduceRight;
		    lodash.include = contains;
		    lodash.inject = reduce;
	
		    mixin(function() {
		      var source = {}
		      forOwn(lodash, function(func, methodName) {
		        if (!lodash.prototype[methodName]) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }(), false);
	
		    /*--------------------------------------------------------------------------*/
	
		    // add functions capable of returning wrapped and unwrapped values when chaining
		    lodash.first = first;
		    lodash.last = last;
		    lodash.sample = sample;
	
		    // add aliases
		    lodash.take = first;
		    lodash.head = first;
	
		    forOwn(lodash, function(func, methodName) {
		      var callbackable = methodName !== 'sample';
		      if (!lodash.prototype[methodName]) {
		        lodash.prototype[methodName]= function(n, guard) {
		          var chainAll = this.__chain__,
		              result = func(this.__wrapped__, n, guard);
	
		          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
		            ? result
		            : new lodashWrapper(result, chainAll);
		        };
		      }
		    });
	
		    /*--------------------------------------------------------------------------*/
	
		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type string
		     */
		    lodash.VERSION = '2.4.2';
	
		    // add "Chaining" functions to the wrapper
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.toString = wrapperToString;
		    lodash.prototype.value = wrapperValueOf;
		    lodash.prototype.valueOf = wrapperValueOf;
	
		    // add `Array` functions that return unwrapped values
		    baseEach(['join', 'pop', 'shift'], function(methodName) {
		      var func = arrayRef[methodName];
		      lodash.prototype[methodName] = function() {
		        var chainAll = this.__chain__,
		            result = func.apply(this.__wrapped__, arguments);
	
		        return chainAll
		          ? new lodashWrapper(result, chainAll)
		          : result;
		      };
		    });
	
		    // add `Array` functions that return the existing wrapped value
		    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
		      var func = arrayRef[methodName];
		      lodash.prototype[methodName] = function() {
		        func.apply(this.__wrapped__, arguments);
		        return this;
		      };
		    });
	
		    // add `Array` functions that return new wrapped values
		    baseEach(['concat', 'slice', 'splice'], function(methodName) {
		      var func = arrayRef[methodName];
		      lodash.prototype[methodName] = function() {
		        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
		      };
		    });
	
		    // avoid array-like object bugs with `Array#shift` and `Array#splice`
		    // in IE < 9, Firefox < 10, Narwhal, and RingoJS
		    if (!support.spliceObjects) {
		      baseEach(['pop', 'shift', 'splice'], function(methodName) {
		        var func = arrayRef[methodName],
		            isSplice = methodName == 'splice';
	
		        lodash.prototype[methodName] = function() {
		          var chainAll = this.__chain__,
		              value = this.__wrapped__,
		              result = func.apply(value, arguments);
	
		          if (value.length === 0) {
		            delete value[0];
		          }
		          return (chainAll || isSplice)
		            ? new lodashWrapper(result, chainAll)
		            : result;
		        };
		      });
		    }
	
		    return lodash;
		  }
	
		  /*--------------------------------------------------------------------------*/
	
		  // expose Lo-Dash
		  var _ = runInContext();
	
		  // some AMD build optimizers like r.js check for condition patterns like the following:
		  if (true) {
		    // Expose Lo-Dash to the global object even when an AMD loader is present in
		    // case Lo-Dash is loaded with a RequireJS shim config.
		    // See http://requirejs.org/docs/api.html#config-shim
		    root._ = _;
	
		    // define as an anonymous module so, through path mapping, it can be
		    // referenced as the "underscore" module
		    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
		      return _;
		    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  }
		  // check for `exports` after `define` in case a build optimizer adds an `exports` object
		  else if (freeExports && freeModule) {
		    // in Node.js or RingoJS
		    if (moduleExports) {
		      (freeModule.exports = _)._ = _;
		    }
		    // in Narwhal or Rhino -require
		    else {
		      freeExports._ = _;
		    }
		  }
		  else {
		    // in a browser or Rhino
		    root._ = _;
		  }
		}.call(this));
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)(module), (function() { return this; }())))
	
	/***/ },
	/* 13 */
	/***/ function(module, exports) {
	
		module.exports = function(module) {
			if(!module.webpackPolyfill) {
				module.deprecate = function() {};
				module.paths = [];
				// module.parent = undefined by default
				module.children = [];
				module.webpackPolyfill = 1;
			}
			return module;
		}
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/**
		 * lodash (Custom Build) <https://lodash.com/>
		 * Build: `lodash modularize exports="npm" -o ./`
		 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
		 * Released under MIT license <https://lodash.com/license>
		 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
		 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		 */
	
		/** Used as the `TypeError` message for "Functions" methods. */
		var FUNC_ERROR_TEXT = 'Expected a function';
	
		/** Used to stand-in for `undefined` hash values. */
		var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
		/** Used as references for various `Number` constants. */
		var INFINITY = 1 / 0;
	
		/** `Object#toString` result references. */
		var funcTag = '[object Function]',
		    genTag = '[object GeneratorFunction]',
		    symbolTag = '[object Symbol]';
	
		/** Used to match property names within property paths. */
		var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		    reIsPlainProp = /^\w*$/,
		    reLeadingDot = /^\./,
		    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
		/**
		 * Used to match `RegExp`
		 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		 */
		var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
		/** Used to match backslashes in property paths. */
		var reEscapeChar = /\\(\\)?/g;
	
		/** Used to detect host constructors (Safari). */
		var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
		/** Detect free variable `global` from Node.js. */
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
		/** Detect free variable `self`. */
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
		/** Used as a reference to the global object. */
		var root = freeGlobal || freeSelf || Function('return this')();
	
		/**
		 * Gets the value at `key` of `object`.
		 *
		 * @private
		 * @param {Object} [object] The object to query.
		 * @param {string} key The key of the property to get.
		 * @returns {*} Returns the property value.
		 */
		function getValue(object, key) {
		  return object == null ? undefined : object[key];
		}
	
		/**
		 * Checks if `value` is a host object in IE < 9.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
		 */
		function isHostObject(value) {
		  // Many host objects are `Object` objects that can coerce to strings
		  // despite having improperly defined `toString` methods.
		  var result = false;
		  if (value != null && typeof value.toString != 'function') {
		    try {
		      result = !!(value + '');
		    } catch (e) {}
		  }
		  return result;
		}
	
		/** Used for built-in method references. */
		var arrayProto = Array.prototype,
		    funcProto = Function.prototype,
		    objectProto = Object.prototype;
	
		/** Used to detect overreaching core-js shims. */
		var coreJsData = root['__core-js_shared__'];
	
		/** Used to detect methods masquerading as native. */
		var maskSrcKey = (function() {
		  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		  return uid ? ('Symbol(src)_1.' + uid) : '';
		}());
	
		/** Used to resolve the decompiled source of functions. */
		var funcToString = funcProto.toString;
	
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
	
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
	
		/** Used to detect if a method is native. */
		var reIsNative = RegExp('^' +
		  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		);
	
		/** Built-in value references. */
		var Symbol = root.Symbol,
		    splice = arrayProto.splice;
	
		/* Built-in method references that are verified to be native. */
		var Map = getNative(root, 'Map'),
		    nativeCreate = getNative(Object, 'create');
	
		/** Used to convert symbols to primitives and strings. */
		var symbolProto = Symbol ? Symbol.prototype : undefined,
		    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
		/**
		 * Creates a hash object.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function Hash(entries) {
		  var index = -1,
		      length = entries ? entries.length : 0;
	
		  this.clear();
		  while (++index < length) {
		    var entry = entries[index];
		    this.set(entry[0], entry[1]);
		  }
		}
	
		/**
		 * Removes all key-value entries from the hash.
		 *
		 * @private
		 * @name clear
		 * @memberOf Hash
		 */
		function hashClear() {
		  this.__data__ = nativeCreate ? nativeCreate(null) : {};
		}
	
		/**
		 * Removes `key` and its value from the hash.
		 *
		 * @private
		 * @name delete
		 * @memberOf Hash
		 * @param {Object} hash The hash to modify.
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function hashDelete(key) {
		  return this.has(key) && delete this.__data__[key];
		}
	
		/**
		 * Gets the hash value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf Hash
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function hashGet(key) {
		  var data = this.__data__;
		  if (nativeCreate) {
		    var result = data[key];
		    return result === HASH_UNDEFINED ? undefined : result;
		  }
		  return hasOwnProperty.call(data, key) ? data[key] : undefined;
		}
	
		/**
		 * Checks if a hash value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf Hash
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function hashHas(key) {
		  var data = this.__data__;
		  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
		}
	
		/**
		 * Sets the hash `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf Hash
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the hash instance.
		 */
		function hashSet(key, value) {
		  var data = this.__data__;
		  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
		  return this;
		}
	
		// Add methods to `Hash`.
		Hash.prototype.clear = hashClear;
		Hash.prototype['delete'] = hashDelete;
		Hash.prototype.get = hashGet;
		Hash.prototype.has = hashHas;
		Hash.prototype.set = hashSet;
	
		/**
		 * Creates an list cache object.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function ListCache(entries) {
		  var index = -1,
		      length = entries ? entries.length : 0;
	
		  this.clear();
		  while (++index < length) {
		    var entry = entries[index];
		    this.set(entry[0], entry[1]);
		  }
		}
	
		/**
		 * Removes all key-value entries from the list cache.
		 *
		 * @private
		 * @name clear
		 * @memberOf ListCache
		 */
		function listCacheClear() {
		  this.__data__ = [];
		}
	
		/**
		 * Removes `key` and its value from the list cache.
		 *
		 * @private
		 * @name delete
		 * @memberOf ListCache
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function listCacheDelete(key) {
		  var data = this.__data__,
		      index = assocIndexOf(data, key);
	
		  if (index < 0) {
		    return false;
		  }
		  var lastIndex = data.length - 1;
		  if (index == lastIndex) {
		    data.pop();
		  } else {
		    splice.call(data, index, 1);
		  }
		  return true;
		}
	
		/**
		 * Gets the list cache value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf ListCache
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function listCacheGet(key) {
		  var data = this.__data__,
		      index = assocIndexOf(data, key);
	
		  return index < 0 ? undefined : data[index][1];
		}
	
		/**
		 * Checks if a list cache value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf ListCache
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function listCacheHas(key) {
		  return assocIndexOf(this.__data__, key) > -1;
		}
	
		/**
		 * Sets the list cache `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf ListCache
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the list cache instance.
		 */
		function listCacheSet(key, value) {
		  var data = this.__data__,
		      index = assocIndexOf(data, key);
	
		  if (index < 0) {
		    data.push([key, value]);
		  } else {
		    data[index][1] = value;
		  }
		  return this;
		}
	
		// Add methods to `ListCache`.
		ListCache.prototype.clear = listCacheClear;
		ListCache.prototype['delete'] = listCacheDelete;
		ListCache.prototype.get = listCacheGet;
		ListCache.prototype.has = listCacheHas;
		ListCache.prototype.set = listCacheSet;
	
		/**
		 * Creates a map cache object to store key-value pairs.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function MapCache(entries) {
		  var index = -1,
		      length = entries ? entries.length : 0;
	
		  this.clear();
		  while (++index < length) {
		    var entry = entries[index];
		    this.set(entry[0], entry[1]);
		  }
		}
	
		/**
		 * Removes all key-value entries from the map.
		 *
		 * @private
		 * @name clear
		 * @memberOf MapCache
		 */
		function mapCacheClear() {
		  this.__data__ = {
		    'hash': new Hash,
		    'map': new (Map || ListCache),
		    'string': new Hash
		  };
		}
	
		/**
		 * Removes `key` and its value from the map.
		 *
		 * @private
		 * @name delete
		 * @memberOf MapCache
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function mapCacheDelete(key) {
		  return getMapData(this, key)['delete'](key);
		}
	
		/**
		 * Gets the map value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf MapCache
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function mapCacheGet(key) {
		  return getMapData(this, key).get(key);
		}
	
		/**
		 * Checks if a map value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf MapCache
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function mapCacheHas(key) {
		  return getMapData(this, key).has(key);
		}
	
		/**
		 * Sets the map `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf MapCache
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the map cache instance.
		 */
		function mapCacheSet(key, value) {
		  getMapData(this, key).set(key, value);
		  return this;
		}
	
		// Add methods to `MapCache`.
		MapCache.prototype.clear = mapCacheClear;
		MapCache.prototype['delete'] = mapCacheDelete;
		MapCache.prototype.get = mapCacheGet;
		MapCache.prototype.has = mapCacheHas;
		MapCache.prototype.set = mapCacheSet;
	
		/**
		 * Gets the index at which the `key` is found in `array` of key-value pairs.
		 *
		 * @private
		 * @param {Array} array The array to inspect.
		 * @param {*} key The key to search for.
		 * @returns {number} Returns the index of the matched value, else `-1`.
		 */
		function assocIndexOf(array, key) {
		  var length = array.length;
		  while (length--) {
		    if (eq(array[length][0], key)) {
		      return length;
		    }
		  }
		  return -1;
		}
	
		/**
		 * The base implementation of `_.get` without support for default values.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path of the property to get.
		 * @returns {*} Returns the resolved value.
		 */
		function baseGet(object, path) {
		  path = isKey(path, object) ? [path] : castPath(path);
	
		  var index = 0,
		      length = path.length;
	
		  while (object != null && index < length) {
		    object = object[toKey(path[index++])];
		  }
		  return (index && index == length) ? object : undefined;
		}
	
		/**
		 * The base implementation of `_.isNative` without bad shim checks.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a native function,
		 *  else `false`.
		 */
		function baseIsNative(value) {
		  if (!isObject(value) || isMasked(value)) {
		    return false;
		  }
		  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
		  return pattern.test(toSource(value));
		}
	
		/**
		 * The base implementation of `_.toString` which doesn't convert nullish
		 * values to empty strings.
		 *
		 * @private
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 */
		function baseToString(value) {
		  // Exit early for strings to avoid a performance hit in some environments.
		  if (typeof value == 'string') {
		    return value;
		  }
		  if (isSymbol(value)) {
		    return symbolToString ? symbolToString.call(value) : '';
		  }
		  var result = (value + '');
		  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		}
	
		/**
		 * Casts `value` to a path array if it's not one.
		 *
		 * @private
		 * @param {*} value The value to inspect.
		 * @returns {Array} Returns the cast property path array.
		 */
		function castPath(value) {
		  return isArray(value) ? value : stringToPath(value);
		}
	
		/**
		 * Gets the data for `map`.
		 *
		 * @private
		 * @param {Object} map The map to query.
		 * @param {string} key The reference key.
		 * @returns {*} Returns the map data.
		 */
		function getMapData(map, key) {
		  var data = map.__data__;
		  return isKeyable(key)
		    ? data[typeof key == 'string' ? 'string' : 'hash']
		    : data.map;
		}
	
		/**
		 * Gets the native function at `key` of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {string} key The key of the method to get.
		 * @returns {*} Returns the function if it's native, else `undefined`.
		 */
		function getNative(object, key) {
		  var value = getValue(object, key);
		  return baseIsNative(value) ? value : undefined;
		}
	
		/**
		 * Checks if `value` is a property name and not a property path.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @param {Object} [object] The object to query keys on.
		 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		 */
		function isKey(value, object) {
		  if (isArray(value)) {
		    return false;
		  }
		  var type = typeof value;
		  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		      value == null || isSymbol(value)) {
		    return true;
		  }
		  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		    (object != null && value in Object(object));
		}
	
		/**
		 * Checks if `value` is suitable for use as unique object key.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		 */
		function isKeyable(value) {
		  var type = typeof value;
		  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		    ? (value !== '__proto__')
		    : (value === null);
		}
	
		/**
		 * Checks if `func` has its source masked.
		 *
		 * @private
		 * @param {Function} func The function to check.
		 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		 */
		function isMasked(func) {
		  return !!maskSrcKey && (maskSrcKey in func);
		}
	
		/**
		 * Converts `string` to a property path array.
		 *
		 * @private
		 * @param {string} string The string to convert.
		 * @returns {Array} Returns the property path array.
		 */
		var stringToPath = memoize(function(string) {
		  string = toString(string);
	
		  var result = [];
		  if (reLeadingDot.test(string)) {
		    result.push('');
		  }
		  string.replace(rePropName, function(match, number, quote, string) {
		    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
		  });
		  return result;
		});
	
		/**
		 * Converts `value` to a string key if it's not a string or symbol.
		 *
		 * @private
		 * @param {*} value The value to inspect.
		 * @returns {string|symbol} Returns the key.
		 */
		function toKey(value) {
		  if (typeof value == 'string' || isSymbol(value)) {
		    return value;
		  }
		  var result = (value + '');
		  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		}
	
		/**
		 * Converts `func` to its source code.
		 *
		 * @private
		 * @param {Function} func The function to process.
		 * @returns {string} Returns the source code.
		 */
		function toSource(func) {
		  if (func != null) {
		    try {
		      return funcToString.call(func);
		    } catch (e) {}
		    try {
		      return (func + '');
		    } catch (e) {}
		  }
		  return '';
		}
	
		/**
		 * Creates a function that memoizes the result of `func`. If `resolver` is
		 * provided, it determines the cache key for storing the result based on the
		 * arguments provided to the memoized function. By default, the first argument
		 * provided to the memoized function is used as the map cache key. The `func`
		 * is invoked with the `this` binding of the memoized function.
		 *
		 * **Note:** The cache is exposed as the `cache` property on the memoized
		 * function. Its creation may be customized by replacing the `_.memoize.Cache`
		 * constructor with one whose instances implement the
		 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
		 * method interface of `delete`, `get`, `has`, and `set`.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Function
		 * @param {Function} func The function to have its output memoized.
		 * @param {Function} [resolver] The function to resolve the cache key.
		 * @returns {Function} Returns the new memoized function.
		 * @example
		 *
		 * var object = { 'a': 1, 'b': 2 };
		 * var other = { 'c': 3, 'd': 4 };
		 *
		 * var values = _.memoize(_.values);
		 * values(object);
		 * // => [1, 2]
		 *
		 * values(other);
		 * // => [3, 4]
		 *
		 * object.a = 2;
		 * values(object);
		 * // => [1, 2]
		 *
		 * // Modify the result cache.
		 * values.cache.set(object, ['a', 'b']);
		 * values(object);
		 * // => ['a', 'b']
		 *
		 * // Replace `_.memoize.Cache`.
		 * _.memoize.Cache = WeakMap;
		 */
		function memoize(func, resolver) {
		  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
		    throw new TypeError(FUNC_ERROR_TEXT);
		  }
		  var memoized = function() {
		    var args = arguments,
		        key = resolver ? resolver.apply(this, args) : args[0],
		        cache = memoized.cache;
	
		    if (cache.has(key)) {
		      return cache.get(key);
		    }
		    var result = func.apply(this, args);
		    memoized.cache = cache.set(key, result);
		    return result;
		  };
		  memoized.cache = new (memoize.Cache || MapCache);
		  return memoized;
		}
	
		// Assign cache to `_.memoize`.
		memoize.Cache = MapCache;
	
		/**
		 * Performs a
		 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		 * comparison between two values to determine if they are equivalent.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to compare.
		 * @param {*} other The other value to compare.
		 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		 * @example
		 *
		 * var object = { 'a': 1 };
		 * var other = { 'a': 1 };
		 *
		 * _.eq(object, object);
		 * // => true
		 *
		 * _.eq(object, other);
		 * // => false
		 *
		 * _.eq('a', 'a');
		 * // => true
		 *
		 * _.eq('a', Object('a'));
		 * // => false
		 *
		 * _.eq(NaN, NaN);
		 * // => true
		 */
		function eq(value, other) {
		  return value === other || (value !== value && other !== other);
		}
	
		/**
		 * Checks if `value` is classified as an `Array` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		 * @example
		 *
		 * _.isArray([1, 2, 3]);
		 * // => true
		 *
		 * _.isArray(document.body.children);
		 * // => false
		 *
		 * _.isArray('abc');
		 * // => false
		 *
		 * _.isArray(_.noop);
		 * // => false
		 */
		var isArray = Array.isArray;
	
		/**
		 * Checks if `value` is classified as a `Function` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		 * @example
		 *
		 * _.isFunction(_);
		 * // => true
		 *
		 * _.isFunction(/abc/);
		 * // => false
		 */
		function isFunction(value) {
		  // The use of `Object#toString` avoids issues with the `typeof` operator
		  // in Safari 8-9 which returns 'object' for typed array and other constructors.
		  var tag = isObject(value) ? objectToString.call(value) : '';
		  return tag == funcTag || tag == genTag;
		}
	
		/**
		 * Checks if `value` is the
		 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		 * @example
		 *
		 * _.isObject({});
		 * // => true
		 *
		 * _.isObject([1, 2, 3]);
		 * // => true
		 *
		 * _.isObject(_.noop);
		 * // => true
		 *
		 * _.isObject(null);
		 * // => false
		 */
		function isObject(value) {
		  var type = typeof value;
		  return !!value && (type == 'object' || type == 'function');
		}
	
		/**
		 * Checks if `value` is object-like. A value is object-like if it's not `null`
		 * and has a `typeof` result of "object".
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		 * @example
		 *
		 * _.isObjectLike({});
		 * // => true
		 *
		 * _.isObjectLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isObjectLike(_.noop);
		 * // => false
		 *
		 * _.isObjectLike(null);
		 * // => false
		 */
		function isObjectLike(value) {
		  return !!value && typeof value == 'object';
		}
	
		/**
		 * Checks if `value` is classified as a `Symbol` primitive or object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		 * @example
		 *
		 * _.isSymbol(Symbol.iterator);
		 * // => true
		 *
		 * _.isSymbol('abc');
		 * // => false
		 */
		function isSymbol(value) {
		  return typeof value == 'symbol' ||
		    (isObjectLike(value) && objectToString.call(value) == symbolTag);
		}
	
		/**
		 * Converts `value` to a string. An empty string is returned for `null`
		 * and `undefined` values. The sign of `-0` is preserved.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 * @example
		 *
		 * _.toString(null);
		 * // => ''
		 *
		 * _.toString(-0);
		 * // => '-0'
		 *
		 * _.toString([1, 2, 3]);
		 * // => '1,2,3'
		 */
		function toString(value) {
		  return value == null ? '' : baseToString(value);
		}
	
		/**
		 * Gets the value at `path` of `object`. If the resolved value is
		 * `undefined`, the `defaultValue` is returned in its place.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.7.0
		 * @category Object
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path of the property to get.
		 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		 * @returns {*} Returns the resolved value.
		 * @example
		 *
		 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		 *
		 * _.get(object, 'a[0].b.c');
		 * // => 3
		 *
		 * _.get(object, ['a', '0', 'b', 'c']);
		 * // => 3
		 *
		 * _.get(object, 'a.b.c', 'default');
		 * // => 'default'
		 */
		function get(object, path, defaultValue) {
		  var result = object == null ? undefined : baseGet(object, path);
		  return result === undefined ? defaultValue : result;
		}
	
		module.exports = get;
	
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 15 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/**
		 * lodash (Custom Build) <https://lodash.com/>
		 * Build: `lodash modularize exports="npm" -o ./`
		 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
		 * Released under MIT license <https://lodash.com/license>
		 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
		 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		 */
	
		/** Used as references for various `Number` constants. */
		var INFINITY = 1 / 0;
	
		/** `Object#toString` result references. */
		var symbolTag = '[object Symbol]';
	
		/** Used to match leading and trailing whitespace. */
		var reTrimEnd = /\s+$/;
	
		/** Used to compose unicode character classes. */
		var rsAstralRange = '\\ud800-\\udfff',
		    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
		    rsComboSymbolsRange = '\\u20d0-\\u20f0',
		    rsVarRange = '\\ufe0e\\ufe0f';
	
		/** Used to compose unicode capture groups. */
		var rsAstral = '[' + rsAstralRange + ']',
		    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
		    rsFitz = '\\ud83c[\\udffb-\\udfff]',
		    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		    rsNonAstral = '[^' + rsAstralRange + ']',
		    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		    rsZWJ = '\\u200d';
	
		/** Used to compose unicode regexes. */
		var reOptMod = rsModifier + '?',
		    rsOptVar = '[' + rsVarRange + ']?',
		    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		    rsSeq = rsOptVar + reOptMod + rsOptJoin,
		    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
		/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
		/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
	
		/** Detect free variable `global` from Node.js. */
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
		/** Detect free variable `self`. */
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
		/** Used as a reference to the global object. */
		var root = freeGlobal || freeSelf || Function('return this')();
	
		/**
		 * Converts an ASCII `string` to an array.
		 *
		 * @private
		 * @param {string} string The string to convert.
		 * @returns {Array} Returns the converted array.
		 */
		function asciiToArray(string) {
		  return string.split('');
		}
	
		/**
		 * The base implementation of `_.findIndex` and `_.findLastIndex` without
		 * support for iteratee shorthands.
		 *
		 * @private
		 * @param {Array} array The array to inspect.
		 * @param {Function} predicate The function invoked per iteration.
		 * @param {number} fromIndex The index to search from.
		 * @param {boolean} [fromRight] Specify iterating from right to left.
		 * @returns {number} Returns the index of the matched value, else `-1`.
		 */
		function baseFindIndex(array, predicate, fromIndex, fromRight) {
		  var length = array.length,
		      index = fromIndex + (fromRight ? 1 : -1);
	
		  while ((fromRight ? index-- : ++index < length)) {
		    if (predicate(array[index], index, array)) {
		      return index;
		    }
		  }
		  return -1;
		}
	
		/**
		 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		 *
		 * @private
		 * @param {Array} array The array to inspect.
		 * @param {*} value The value to search for.
		 * @param {number} fromIndex The index to search from.
		 * @returns {number} Returns the index of the matched value, else `-1`.
		 */
		function baseIndexOf(array, value, fromIndex) {
		  if (value !== value) {
		    return baseFindIndex(array, baseIsNaN, fromIndex);
		  }
		  var index = fromIndex - 1,
		      length = array.length;
	
		  while (++index < length) {
		    if (array[index] === value) {
		      return index;
		    }
		  }
		  return -1;
		}
	
		/**
		 * The base implementation of `_.isNaN` without support for number objects.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		 */
		function baseIsNaN(value) {
		  return value !== value;
		}
	
		/**
		 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		 * that is not found in the character symbols.
		 *
		 * @private
		 * @param {Array} strSymbols The string symbols to inspect.
		 * @param {Array} chrSymbols The character symbols to find.
		 * @returns {number} Returns the index of the last unmatched string symbol.
		 */
		function charsEndIndex(strSymbols, chrSymbols) {
		  var index = strSymbols.length;
	
		  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		  return index;
		}
	
		/**
		 * Checks if `string` contains Unicode symbols.
		 *
		 * @private
		 * @param {string} string The string to inspect.
		 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
		 */
		function hasUnicode(string) {
		  return reHasUnicode.test(string);
		}
	
		/**
		 * Converts `string` to an array.
		 *
		 * @private
		 * @param {string} string The string to convert.
		 * @returns {Array} Returns the converted array.
		 */
		function stringToArray(string) {
		  return hasUnicode(string)
		    ? unicodeToArray(string)
		    : asciiToArray(string);
		}
	
		/**
		 * Converts a Unicode `string` to an array.
		 *
		 * @private
		 * @param {string} string The string to convert.
		 * @returns {Array} Returns the converted array.
		 */
		function unicodeToArray(string) {
		  return string.match(reUnicode) || [];
		}
	
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
	
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
	
		/** Built-in value references. */
		var Symbol = root.Symbol;
	
		/** Used to convert symbols to primitives and strings. */
		var symbolProto = Symbol ? Symbol.prototype : undefined,
		    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
		/**
		 * The base implementation of `_.slice` without an iteratee call guard.
		 *
		 * @private
		 * @param {Array} array The array to slice.
		 * @param {number} [start=0] The start position.
		 * @param {number} [end=array.length] The end position.
		 * @returns {Array} Returns the slice of `array`.
		 */
		function baseSlice(array, start, end) {
		  var index = -1,
		      length = array.length;
	
		  if (start < 0) {
		    start = -start > length ? 0 : (length + start);
		  }
		  end = end > length ? length : end;
		  if (end < 0) {
		    end += length;
		  }
		  length = start > end ? 0 : ((end - start) >>> 0);
		  start >>>= 0;
	
		  var result = Array(length);
		  while (++index < length) {
		    result[index] = array[index + start];
		  }
		  return result;
		}
	
		/**
		 * The base implementation of `_.toString` which doesn't convert nullish
		 * values to empty strings.
		 *
		 * @private
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 */
		function baseToString(value) {
		  // Exit early for strings to avoid a performance hit in some environments.
		  if (typeof value == 'string') {
		    return value;
		  }
		  if (isSymbol(value)) {
		    return symbolToString ? symbolToString.call(value) : '';
		  }
		  var result = (value + '');
		  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		}
	
		/**
		 * Casts `array` to a slice if it's needed.
		 *
		 * @private
		 * @param {Array} array The array to inspect.
		 * @param {number} start The start position.
		 * @param {number} [end=array.length] The end position.
		 * @returns {Array} Returns the cast slice.
		 */
		function castSlice(array, start, end) {
		  var length = array.length;
		  end = end === undefined ? length : end;
		  return (!start && end >= length) ? array : baseSlice(array, start, end);
		}
	
		/**
		 * Checks if `value` is object-like. A value is object-like if it's not `null`
		 * and has a `typeof` result of "object".
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		 * @example
		 *
		 * _.isObjectLike({});
		 * // => true
		 *
		 * _.isObjectLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isObjectLike(_.noop);
		 * // => false
		 *
		 * _.isObjectLike(null);
		 * // => false
		 */
		function isObjectLike(value) {
		  return !!value && typeof value == 'object';
		}
	
		/**
		 * Checks if `value` is classified as a `Symbol` primitive or object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		 * @example
		 *
		 * _.isSymbol(Symbol.iterator);
		 * // => true
		 *
		 * _.isSymbol('abc');
		 * // => false
		 */
		function isSymbol(value) {
		  return typeof value == 'symbol' ||
		    (isObjectLike(value) && objectToString.call(value) == symbolTag);
		}
	
		/**
		 * Converts `value` to a string. An empty string is returned for `null`
		 * and `undefined` values. The sign of `-0` is preserved.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 * @example
		 *
		 * _.toString(null);
		 * // => ''
		 *
		 * _.toString(-0);
		 * // => '-0'
		 *
		 * _.toString([1, 2, 3]);
		 * // => '1,2,3'
		 */
		function toString(value) {
		  return value == null ? '' : baseToString(value);
		}
	
		/**
		 * Removes trailing whitespace or specified characters from `string`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category String
		 * @param {string} [string=''] The string to trim.
		 * @param {string} [chars=whitespace] The characters to trim.
		 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		 * @returns {string} Returns the trimmed string.
		 * @example
		 *
		 * _.trimEnd('  abc  ');
		 * // => '  abc'
		 *
		 * _.trimEnd('-_-abc-_-', '_-');
		 * // => '-_-abc'
		 */
		function trimEnd(string, chars, guard) {
		  string = toString(string);
		  if (string && (guard || chars === undefined)) {
		    return string.replace(reTrimEnd, '');
		  }
		  if (!string || !(chars = baseToString(chars))) {
		    return string;
		  }
		  var strSymbols = stringToArray(string),
		      end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
	
		  return castSlice(strSymbols, 0, end).join('');
		}
	
		module.exports = trimEnd;
	
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = ConnectionAbstract;
	
		var _ = __webpack_require__(3);
		var EventEmitter = __webpack_require__(17).EventEmitter;
		var Log = __webpack_require__(18);
		var Host = __webpack_require__(28);
		var errors = __webpack_require__(29);
	
		/**
		 * Abstract class used for Connection classes
		 * @class ConnectionAbstract
		 * @constructor
		 */
		function ConnectionAbstract(host, config) {
		  config = config || {};
		  EventEmitter.call(this);
	
		  this.log = config.log || new Log();
		  this.pingTimeout = config.pingTimeout || 3000;
	
		  if (!host) {
		    throw new TypeError('Missing host');
		  } else if (host instanceof Host) {
		    this.host = host;
		  } else {
		    throw new TypeError('Invalid host');
		  }
	
		  _.makeBoundMethods(this);
		}
		_.inherits(ConnectionAbstract, EventEmitter);
	
		/**
		 * Make a request using this connection. Must be overridden by Connection classes, which can add whatever keys to
		 * params that they like. These are just the basics.
		 *
		 * @param [params] {Object} - The parameters for the request
		 * @param params.path {String} - The path for which you are requesting
		 * @param params.method {String} - The HTTP method for the request (GET, HEAD, etc.)
		 * @param params.requestTimeout {Integer} - The amount of time in milliseconds that this request should be allowed to run for.
		 * @param cb {Function} - A callback to be called once with `cb(err, responseBody, responseStatus)`
		 */
		ConnectionAbstract.prototype.request = function () {
		  throw new Error('Connection#request must be overwritten by the Connector');
		};
	
		ConnectionAbstract.prototype.ping = function (params, cb) {
		  if (typeof params === 'function') {
		    cb = params;
		    params = null;
		  } else {
		    cb = typeof cb === 'function' ? cb : null;
		  }
	
		  var requestTimeout = this.pingTimeout;
		  var requestTimeoutId;
		  var aborted;
		  var abort;
	
		  if (params && params.hasOwnProperty('requestTimeout')) {
		    requestTimeout = params.requestTimeout;
		  }
	
		  abort = this.request(_.defaults(params || {}, {
		    path: '/',
		    method: 'HEAD'
		  }), function (err) {
		    if (aborted) {
		      return;
		    }
		    clearTimeout(requestTimeoutId);
		    if (cb) {
		      cb(err);
		    }
		  });
	
		  if (requestTimeout) {
		    requestTimeoutId = setTimeout(function () {
		      if (abort) {
		        abort();
		      }
		      aborted = true;
		      if (cb) {
		        cb(new errors.RequestTimeout('Ping Timeout after ' + requestTimeout + 'ms'));
		      }
		    }, requestTimeout);
		  }
		};
	
		ConnectionAbstract.prototype.setStatus = function (status) {
		  var origStatus = this.status;
		  this.status = status;
	
		  this.emit('status set', status, origStatus, this);
	
		  if (status === 'closed') {
		    this.removeAllListeners();
		  }
		};
	
	
	/***/ },
	/* 17 */
	/***/ function(module, exports) {
	
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
		function EventEmitter() {
		  this._events = this._events || {};
		  this._maxListeners = this._maxListeners || undefined;
		}
		module.exports = EventEmitter;
	
		// Backwards-compat with node 0.10.x
		EventEmitter.EventEmitter = EventEmitter;
	
		EventEmitter.prototype._events = undefined;
		EventEmitter.prototype._maxListeners = undefined;
	
		// By default EventEmitters will print a warning if more than 10 listeners are
		// added to it. This is a useful default which helps finding memory leaks.
		EventEmitter.defaultMaxListeners = 10;
	
		// Obviously not all Emitters should be limited to 10. This function allows
		// that to be increased. Set to zero for unlimited.
		EventEmitter.prototype.setMaxListeners = function(n) {
		  if (!isNumber(n) || n < 0 || isNaN(n))
		    throw TypeError('n must be a positive number');
		  this._maxListeners = n;
		  return this;
		};
	
		EventEmitter.prototype.emit = function(type) {
		  var er, handler, len, args, i, listeners;
	
		  if (!this._events)
		    this._events = {};
	
		  // If there is no 'error' event listener then throw.
		  if (type === 'error') {
		    if (!this._events.error ||
		        (isObject(this._events.error) && !this._events.error.length)) {
		      er = arguments[1];
		      if (er instanceof Error) {
		        throw er; // Unhandled 'error' event
		      } else {
		        // At least give some kind of context to the user
		        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
		        err.context = er;
		        throw err;
		      }
		    }
		  }
	
		  handler = this._events[type];
	
		  if (isUndefined(handler))
		    return false;
	
		  if (isFunction(handler)) {
		    switch (arguments.length) {
		      // fast cases
		      case 1:
		        handler.call(this);
		        break;
		      case 2:
		        handler.call(this, arguments[1]);
		        break;
		      case 3:
		        handler.call(this, arguments[1], arguments[2]);
		        break;
		      // slower
		      default:
		        args = Array.prototype.slice.call(arguments, 1);
		        handler.apply(this, args);
		    }
		  } else if (isObject(handler)) {
		    args = Array.prototype.slice.call(arguments, 1);
		    listeners = handler.slice();
		    len = listeners.length;
		    for (i = 0; i < len; i++)
		      listeners[i].apply(this, args);
		  }
	
		  return true;
		};
	
		EventEmitter.prototype.addListener = function(type, listener) {
		  var m;
	
		  if (!isFunction(listener))
		    throw TypeError('listener must be a function');
	
		  if (!this._events)
		    this._events = {};
	
		  // To avoid recursion in the case that type === "newListener"! Before
		  // adding it to the listeners, first emit "newListener".
		  if (this._events.newListener)
		    this.emit('newListener', type,
		              isFunction(listener.listener) ?
		              listener.listener : listener);
	
		  if (!this._events[type])
		    // Optimize the case of one listener. Don't need the extra array object.
		    this._events[type] = listener;
		  else if (isObject(this._events[type]))
		    // If we've already got an array, just append.
		    this._events[type].push(listener);
		  else
		    // Adding the second element, need to change to array.
		    this._events[type] = [this._events[type], listener];
	
		  // Check for listener leak
		  if (isObject(this._events[type]) && !this._events[type].warned) {
		    if (!isUndefined(this._maxListeners)) {
		      m = this._maxListeners;
		    } else {
		      m = EventEmitter.defaultMaxListeners;
		    }
	
		    if (m && m > 0 && this._events[type].length > m) {
		      this._events[type].warned = true;
		      console.error('(node) warning: possible EventEmitter memory ' +
		                    'leak detected. %d listeners added. ' +
		                    'Use emitter.setMaxListeners() to increase limit.',
		                    this._events[type].length);
		      if (typeof console.trace === 'function') {
		        // not supported in IE 10
		        console.trace();
		      }
		    }
		  }
	
		  return this;
		};
	
		EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
		EventEmitter.prototype.once = function(type, listener) {
		  if (!isFunction(listener))
		    throw TypeError('listener must be a function');
	
		  var fired = false;
	
		  function g() {
		    this.removeListener(type, g);
	
		    if (!fired) {
		      fired = true;
		      listener.apply(this, arguments);
		    }
		  }
	
		  g.listener = listener;
		  this.on(type, g);
	
		  return this;
		};
	
		// emits a 'removeListener' event iff the listener was removed
		EventEmitter.prototype.removeListener = function(type, listener) {
		  var list, position, length, i;
	
		  if (!isFunction(listener))
		    throw TypeError('listener must be a function');
	
		  if (!this._events || !this._events[type])
		    return this;
	
		  list = this._events[type];
		  length = list.length;
		  position = -1;
	
		  if (list === listener ||
		      (isFunction(list.listener) && list.listener === listener)) {
		    delete this._events[type];
		    if (this._events.removeListener)
		      this.emit('removeListener', type, listener);
	
		  } else if (isObject(list)) {
		    for (i = length; i-- > 0;) {
		      if (list[i] === listener ||
		          (list[i].listener && list[i].listener === listener)) {
		        position = i;
		        break;
		      }
		    }
	
		    if (position < 0)
		      return this;
	
		    if (list.length === 1) {
		      list.length = 0;
		      delete this._events[type];
		    } else {
		      list.splice(position, 1);
		    }
	
		    if (this._events.removeListener)
		      this.emit('removeListener', type, listener);
		  }
	
		  return this;
		};
	
		EventEmitter.prototype.removeAllListeners = function(type) {
		  var key, listeners;
	
		  if (!this._events)
		    return this;
	
		  // not listening for removeListener, no need to emit
		  if (!this._events.removeListener) {
		    if (arguments.length === 0)
		      this._events = {};
		    else if (this._events[type])
		      delete this._events[type];
		    return this;
		  }
	
		  // emit removeListener for all listeners on all events
		  if (arguments.length === 0) {
		    for (key in this._events) {
		      if (key === 'removeListener') continue;
		      this.removeAllListeners(key);
		    }
		    this.removeAllListeners('removeListener');
		    this._events = {};
		    return this;
		  }
	
		  listeners = this._events[type];
	
		  if (isFunction(listeners)) {
		    this.removeListener(type, listeners);
		  } else if (listeners) {
		    // LIFO order
		    while (listeners.length)
		      this.removeListener(type, listeners[listeners.length - 1]);
		  }
		  delete this._events[type];
	
		  return this;
		};
	
		EventEmitter.prototype.listeners = function(type) {
		  var ret;
		  if (!this._events || !this._events[type])
		    ret = [];
		  else if (isFunction(this._events[type]))
		    ret = [this._events[type]];
		  else
		    ret = this._events[type].slice();
		  return ret;
		};
	
		EventEmitter.prototype.listenerCount = function(type) {
		  if (this._events) {
		    var evlistener = this._events[type];
	
		    if (isFunction(evlistener))
		      return 1;
		    else if (evlistener)
		      return evlistener.length;
		  }
		  return 0;
		};
	
		EventEmitter.listenerCount = function(emitter, type) {
		  return emitter.listenerCount(type);
		};
	
		function isFunction(arg) {
		  return typeof arg === 'function';
		}
	
		function isNumber(arg) {
		  return typeof arg === 'number';
		}
	
		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
	
		function isUndefined(arg) {
		  return arg === void 0;
		}
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {var _ = __webpack_require__(3);
		var url = __webpack_require__(19);
		var EventEmitter = __webpack_require__(17).EventEmitter;
	
		/**
		 * Log bridge, which is an [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)
		 * that sends events to one or more outputs/loggers. Setup these loggers by
		 * specifying their config as the first argument, or by passing it to addOutput().
		 *
		 * @class Log
		 * @uses Loggers.Stdio
		 * @constructor
		 * @param {object} config
		 * @param {string|Object|ArrayOfStrings|ArrayOfObjects} config.log - Either the level
		 *  to setup a single logger, a full config object for a logger, or an array of
		 *  config objects to use for creating log outputs.
		 * @param {string|array} config.log.level|config.log.levels - One or more keys in Log.levels (error, warning, etc.)
		 * @param {string} config.log.type - The name of the logger to use for this output
		 */
		function Log(config) {
		  config = config || {};
		  if (!config.log) return;
	
		  var i;
		  var outputs;
	
		  if (_.isArrayOfStrings(config.log)) {
		    outputs = [{
		      levels: config.log
		    }];
		  } else {
		    outputs = _.createArray(config.log, function (val) {
		      if (_.isPlainObject(val)) {
		        return val;
		      }
		      if (typeof val === 'string') {
		        return {
		          level: val
		        };
		      }
		    });
		  }
	
		  if (!outputs) {
		    throw new TypeError('Invalid logging output config. Expected either a log level, array of log levels, ' +
		      'a logger config object, or an array of logger config objects.');
		  }
	
		  for (i = 0; i < outputs.length; i++) {
		    this.addOutput(outputs[i]);
		  }
		}
		_.inherits(Log, EventEmitter);
	
		Log.loggers = __webpack_require__(25);
	
		Log.prototype.close = function () {
		  this.emit('closing');
		  if (this.listenerCount()) {
		    console.error('Something is still listening for log events, but the logger is closing.'); // eslint-disable-line no-console
		    this.clearAllListeners();
		  }
		};
	
		if (EventEmitter.prototype.listenerCount) {
		  // If the event emitter implements it's own listenerCount method
		  // we don't need to (newer nodes do this).
		  Log.prototype.listenerCount = EventEmitter.prototype.listenerCount;
		}
		else if (EventEmitter.listenerCount) {
		  // some versions of node expose EventEmitter::listenerCount
		  // which is more efficient the getting all listeners of a
		  // specific type
		  Log.prototype.listenerCount = function (event) {
		    return EventEmitter.listenerCount(this, event);
		  };
		}
		else {
		  // all other versions of node expose a #listeners() method, which returns
		  // and array we have to count
		  Log.prototype.listenerCount = function (event) {
		    return this.listeners(event).length;
		  };
		}
	
		/**
		 * Levels observed by the loggers, ordered by rank
		 *
		 * @property levels
		 * @type Array
		 * @static
		 */
		Log.levels = [
		  /**
		   * Event fired for error level log entries
		   * @event error
		   * @param {Error} error - The error object to log
		   */
		  'error',
		  /**
		   * Event fired for "warning" level log entries, which usually represent things
		   * like correctly formatted error responses from ES (400, ...) and recoverable
		   * errors (one node unresponsive)
		   *
		   * @event warning
		   * @param {String} message - A message to be logged
		   */
		  'warning',
		  /**
		   * Event fired for "info" level log entries, which usually describe what a
		   * client is doing (sniffing etc)
		   *
		   * @event info
		   * @param {String} message - A message to be logged
		   */
		  'info',
		  /**
		   * Event fired for "debug" level log entries, which will describe requests sent,
		   * including their url (no data, response codes, or exec times)
		   *
		   * @event debug
		   * @param {String} message - A message to be logged
		   */
		  'debug',
		  /**
		   * Event fired for "trace" level log entries, which provide detailed information
		   * about each request made from a client, including reponse codes, execution times,
		   * and a full curl command that can be copied and pasted into a terminal
		   *
		   * @event trace
		   * @param {String} method method, , body, responseStatus, responseBody
		   * @param {String} url - The url the request was made to
		   * @param {String} body - The body of the request
		   * @param {Integer} responseStatus - The status code returned from the response
		   * @param {String} responseBody - The body of the response
		   */
		  'trace'
		];
	
		/**
		 * Converts a log config value (string or array) to an array of level names which
		 * it represents
		 *
		 * @method parseLevels
		 * @static
		 * @private
		 * @param  {String|ArrayOfStrings} input - Cound be a string to specify the max
		 *   level, or an array of exact levels
		 * @return {Array} -
		 */
		Log.parseLevels = function (input) {
		  switch (typeof input) {
		    case 'string':
		      var i = _.indexOf(Log.levels, input);
		      if (i >= 0) {
		        return Log.levels.slice(0, i + 1);
		      }
		    /* fall through */
		    case 'object':
		      if (_.isArray(input)) {
		        var valid = _.intersection(input, Log.levels);
		        if (valid.length === input.length) {
		          return valid;
		        }
		      }
		    /* fall through */
		    default:
		      throw new TypeError('invalid logging level ' + input + '. Expected zero or more of these options: ' +
		      Log.levels.join(', '));
		  }
		};
	
		/**
		 * Combine the array-like param into a simple string
		 *
		 * @method join
		 * @static
		 * @private
		 * @param  {*} arrayish - An array like object that can be itterated by _.each
		 * @return {String} - The final string.
		 */
		Log.join = function (arrayish) {
		  return _.map(arrayish, function (item) {
		    if (_.isPlainObject(item)) {
		      return JSON.stringify(item, null, 2) + '\n';
		    } else {
		      return item.toString();
		    }
		  }).join(' ');
		};
	
		/**
		 * Create a new logger, based on the config.
		 *
		 * @method addOutput
		 * @param {object} config - An object with config options for the logger.
		 * @param {String} [config.type=stdio] - The name of an output/logger. Options
		 *   can be found in the `src/loggers` directory.
		 * @param {String|ArrayOfStrings} [config.level|config.levels=warning] - The levels to output
		 *   to this logger, when an array is specified no levels other than the ones
		 *   specified will be listened to. When a string is specified, that and all lower
		 *   levels will be logged.
		 * @return {Logger}
		 */
		Log.prototype.addOutput = function (config) {
		  config = config || {};
	
		  // force "levels" key
		  config.levels = Log.parseLevels(config.levels || config.level || 'warning');
		  delete config.level;
	
		  var Logger = _.funcEnum(config, 'type', Log.loggers, process.browser ? 'console' : 'stdio');
		  return new Logger(this, config);
		};
	
		/**
		 * Log an error
		 *
		 * @method error
		 * @param  {Error|String} error  The Error to log
		 * @return {Boolean} - True if any outputs accepted the message
		 */
		Log.prototype.error = function (e) {
		  if (this.listenerCount('error')) {
		    return this.emit('error', e instanceof Error ? e : new Error(e));
		  }
		};
	
	
		/**
		 * Log a warning message
		 *
		 * @method warning
		 * @param  {*} msg* - Any amount of messages that will be joined before logged
		 * @return {Boolean} - True if any outputs accepted the message
		 */
		Log.prototype.warning = function (/* ...msg */) {
		  if (this.listenerCount('warning')) {
		    return this.emit('warning', Log.join(arguments));
		  }
		};
	
	
		/**
		 * Log useful info about what's going on
		 *
		 * @method info
		 * @param  {*} msg* - Any amount of messages that will be joined before logged
		 * @return {Boolean} - True if any outputs accepted the message
		 */
		Log.prototype.info = function (/* ...msg */) {
		  if (this.listenerCount('info')) {
		    return this.emit('info', Log.join(arguments));
		  }
		};
	
		/**
		 * Log a debug level message
		 *
		 * @method debug
		 * @param  {*} msg* - Any amount of messages that will be joined before logged
		 * @return {Boolean} - True if any outputs accepted the message
		 */
		Log.prototype.debug = function (/* ...msg */) {
		  if (this.listenerCount('debug')) {
		    return this.emit('debug', Log.join(arguments));
		  }
		};
	
		/**
		 * Log a trace level message
		 *
		 * @method trace
		 * @param {String} method - HTTP request method
		 * @param {String|Object} requestUrl - URL requested. If the value is an object,
		 *   it is expected to be the return value of Node's url.parse()
		 * @param {String} body - The request's body
		 * @param {String} responseBody - body returned from ES
		 * @param {String} responseStatus - HTTP status code
		 * @return {Boolean} - True if any outputs accepted the message
		 */
		Log.prototype.trace = function (method, requestUrl, body, responseBody, responseStatus) {
		  if (this.listenerCount('trace')) {
		    return this.emit('trace', Log.normalizeTraceArgs(method, requestUrl, body, responseBody, responseStatus));
		  }
		};
	
		Log.normalizeTraceArgs = function (method, requestUrl, body, responseBody, responseStatus) {
		  if (typeof requestUrl === 'string') {
		    requestUrl = url.parse(requestUrl, true, true);
		  } else {
		    requestUrl = _.clone(requestUrl);
		    if (requestUrl.path) {
		      requestUrl.query = url.parse(requestUrl.path, true, false).query;
		    }
		    if (!requestUrl.pathname && requestUrl.path) {
		      requestUrl.pathname = requestUrl.path.split('?').shift();
		    }
		  }
	
		  delete requestUrl.auth;
	
		  return {
		    method: method,
		    url: url.format(requestUrl),
		    body: body,
		    status: responseStatus,
		    response: responseBody
		  };
		};
	
		module.exports = Log;
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
		'use strict';
	
		var punycode = __webpack_require__(20);
		var util = __webpack_require__(21);
	
		exports.parse = urlParse;
		exports.resolve = urlResolve;
		exports.resolveObject = urlResolveObject;
		exports.format = urlFormat;
	
		exports.Url = Url;
	
		function Url() {
		  this.protocol = null;
		  this.slashes = null;
		  this.auth = null;
		  this.host = null;
		  this.port = null;
		  this.hostname = null;
		  this.hash = null;
		  this.search = null;
		  this.query = null;
		  this.pathname = null;
		  this.path = null;
		  this.href = null;
		}
	
		// Reference: RFC 3986, RFC 1808, RFC 2396
	
		// define these here so at least they only have to be
		// compiled once on the first module load.
		var protocolPattern = /^([a-z0-9.+-]+:)/i,
		    portPattern = /:[0-9]*$/,
	
		    // Special case for a simple path URL
		    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
		    // RFC 2396: characters reserved for delimiting URLs.
		    // We actually just auto-escape these.
		    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
		    // RFC 2396: characters not allowed for various reasons.
		    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
		    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
		    autoEscape = ['\''].concat(unwise),
		    // Characters that are never ever allowed in a hostname.
		    // Note that any invalid chars are also handled, but these
		    // are the ones that are *expected* to be seen, so we fast-path
		    // them.
		    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
		    hostEndingChars = ['/', '?', '#'],
		    hostnameMaxLen = 255,
		    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
		    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
		    // protocols that can allow "unsafe" and "unwise" chars.
		    unsafeProtocol = {
		      'javascript': true,
		      'javascript:': true
		    },
		    // protocols that never have a hostname.
		    hostlessProtocol = {
		      'javascript': true,
		      'javascript:': true
		    },
		    // protocols that always contain a // bit.
		    slashedProtocol = {
		      'http': true,
		      'https': true,
		      'ftp': true,
		      'gopher': true,
		      'file': true,
		      'http:': true,
		      'https:': true,
		      'ftp:': true,
		      'gopher:': true,
		      'file:': true
		    },
		    querystring = __webpack_require__(22);
	
		function urlParse(url, parseQueryString, slashesDenoteHost) {
		  if (url && util.isObject(url) && url instanceof Url) return url;
	
		  var u = new Url;
		  u.parse(url, parseQueryString, slashesDenoteHost);
		  return u;
		}
	
		Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
		  if (!util.isString(url)) {
		    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
		  }
	
		  // Copy chrome, IE, opera backslash-handling behavior.
		  // Back slashes before the query string get converted to forward slashes
		  // See: https://code.google.com/p/chromium/issues/detail?id=25916
		  var queryIndex = url.indexOf('?'),
		      splitter =
		          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
		      uSplit = url.split(splitter),
		      slashRegex = /\\/g;
		  uSplit[0] = uSplit[0].replace(slashRegex, '/');
		  url = uSplit.join(splitter);
	
		  var rest = url;
	
		  // trim before proceeding.
		  // This is to support parse stuff like "  http://foo.com  \n"
		  rest = rest.trim();
	
		  if (!slashesDenoteHost && url.split('#').length === 1) {
		    // Try fast path regexp
		    var simplePath = simplePathPattern.exec(rest);
		    if (simplePath) {
		      this.path = rest;
		      this.href = rest;
		      this.pathname = simplePath[1];
		      if (simplePath[2]) {
		        this.search = simplePath[2];
		        if (parseQueryString) {
		          this.query = querystring.parse(this.search.substr(1));
		        } else {
		          this.query = this.search.substr(1);
		        }
		      } else if (parseQueryString) {
		        this.search = '';
		        this.query = {};
		      }
		      return this;
		    }
		  }
	
		  var proto = protocolPattern.exec(rest);
		  if (proto) {
		    proto = proto[0];
		    var lowerProto = proto.toLowerCase();
		    this.protocol = lowerProto;
		    rest = rest.substr(proto.length);
		  }
	
		  // figure out if it's got a host
		  // user@server is *always* interpreted as a hostname, and url
		  // resolution will treat //foo/bar as host=foo,path=bar because that's
		  // how the browser resolves relative URLs.
		  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
		    var slashes = rest.substr(0, 2) === '//';
		    if (slashes && !(proto && hostlessProtocol[proto])) {
		      rest = rest.substr(2);
		      this.slashes = true;
		    }
		  }
	
		  if (!hostlessProtocol[proto] &&
		      (slashes || (proto && !slashedProtocol[proto]))) {
	
		    // there's a hostname.
		    // the first instance of /, ?, ;, or # ends the host.
		    //
		    // If there is an @ in the hostname, then non-host chars *are* allowed
		    // to the left of the last @ sign, unless some host-ending character
		    // comes *before* the @-sign.
		    // URLs are obnoxious.
		    //
		    // ex:
		    // http://a@b@c/ => user:a@b host:c
		    // http://a@b?@c => user:a host:c path:/?@c
	
		    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
		    // Review our test case against browsers more comprehensively.
	
		    // find the first instance of any hostEndingChars
		    var hostEnd = -1;
		    for (var i = 0; i < hostEndingChars.length; i++) {
		      var hec = rest.indexOf(hostEndingChars[i]);
		      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
		        hostEnd = hec;
		    }
	
		    // at this point, either we have an explicit point where the
		    // auth portion cannot go past, or the last @ char is the decider.
		    var auth, atSign;
		    if (hostEnd === -1) {
		      // atSign can be anywhere.
		      atSign = rest.lastIndexOf('@');
		    } else {
		      // atSign must be in auth portion.
		      // http://a@b/c@d => host:b auth:a path:/c@d
		      atSign = rest.lastIndexOf('@', hostEnd);
		    }
	
		    // Now we have a portion which is definitely the auth.
		    // Pull that off.
		    if (atSign !== -1) {
		      auth = rest.slice(0, atSign);
		      rest = rest.slice(atSign + 1);
		      this.auth = decodeURIComponent(auth);
		    }
	
		    // the host is the remaining to the left of the first non-host char
		    hostEnd = -1;
		    for (var i = 0; i < nonHostChars.length; i++) {
		      var hec = rest.indexOf(nonHostChars[i]);
		      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
		        hostEnd = hec;
		    }
		    // if we still have not hit it, then the entire thing is a host.
		    if (hostEnd === -1)
		      hostEnd = rest.length;
	
		    this.host = rest.slice(0, hostEnd);
		    rest = rest.slice(hostEnd);
	
		    // pull out port.
		    this.parseHost();
	
		    // we've indicated that there is a hostname,
		    // so even if it's empty, it has to be present.
		    this.hostname = this.hostname || '';
	
		    // if hostname begins with [ and ends with ]
		    // assume that it's an IPv6 address.
		    var ipv6Hostname = this.hostname[0] === '[' &&
		        this.hostname[this.hostname.length - 1] === ']';
	
		    // validate a little.
		    if (!ipv6Hostname) {
		      var hostparts = this.hostname.split(/\./);
		      for (var i = 0, l = hostparts.length; i < l; i++) {
		        var part = hostparts[i];
		        if (!part) continue;
		        if (!part.match(hostnamePartPattern)) {
		          var newpart = '';
		          for (var j = 0, k = part.length; j < k; j++) {
		            if (part.charCodeAt(j) > 127) {
		              // we replace non-ASCII char with a temporary placeholder
		              // we need this to make sure size of hostname is not
		              // broken by replacing non-ASCII by nothing
		              newpart += 'x';
		            } else {
		              newpart += part[j];
		            }
		          }
		          // we test again with ASCII char only
		          if (!newpart.match(hostnamePartPattern)) {
		            var validParts = hostparts.slice(0, i);
		            var notHost = hostparts.slice(i + 1);
		            var bit = part.match(hostnamePartStart);
		            if (bit) {
		              validParts.push(bit[1]);
		              notHost.unshift(bit[2]);
		            }
		            if (notHost.length) {
		              rest = '/' + notHost.join('.') + rest;
		            }
		            this.hostname = validParts.join('.');
		            break;
		          }
		        }
		      }
		    }
	
		    if (this.hostname.length > hostnameMaxLen) {
		      this.hostname = '';
		    } else {
		      // hostnames are always lower case.
		      this.hostname = this.hostname.toLowerCase();
		    }
	
		    if (!ipv6Hostname) {
		      // IDNA Support: Returns a punycoded representation of "domain".
		      // It only converts parts of the domain name that
		      // have non-ASCII characters, i.e. it doesn't matter if
		      // you call it with a domain that already is ASCII-only.
		      this.hostname = punycode.toASCII(this.hostname);
		    }
	
		    var p = this.port ? ':' + this.port : '';
		    var h = this.hostname || '';
		    this.host = h + p;
		    this.href += this.host;
	
		    // strip [ and ] from the hostname
		    // the host field still retains them, though
		    if (ipv6Hostname) {
		      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
		      if (rest[0] !== '/') {
		        rest = '/' + rest;
		      }
		    }
		  }
	
		  // now rest is set to the post-host stuff.
		  // chop off any delim chars.
		  if (!unsafeProtocol[lowerProto]) {
	
		    // First, make 100% sure that any "autoEscape" chars get
		    // escaped, even if encodeURIComponent doesn't think they
		    // need to be.
		    for (var i = 0, l = autoEscape.length; i < l; i++) {
		      var ae = autoEscape[i];
		      if (rest.indexOf(ae) === -1)
		        continue;
		      var esc = encodeURIComponent(ae);
		      if (esc === ae) {
		        esc = escape(ae);
		      }
		      rest = rest.split(ae).join(esc);
		    }
		  }
	
	
		  // chop off from the tail first.
		  var hash = rest.indexOf('#');
		  if (hash !== -1) {
		    // got a fragment string.
		    this.hash = rest.substr(hash);
		    rest = rest.slice(0, hash);
		  }
		  var qm = rest.indexOf('?');
		  if (qm !== -1) {
		    this.search = rest.substr(qm);
		    this.query = rest.substr(qm + 1);
		    if (parseQueryString) {
		      this.query = querystring.parse(this.query);
		    }
		    rest = rest.slice(0, qm);
		  } else if (parseQueryString) {
		    // no query string, but parseQueryString still requested
		    this.search = '';
		    this.query = {};
		  }
		  if (rest) this.pathname = rest;
		  if (slashedProtocol[lowerProto] &&
		      this.hostname && !this.pathname) {
		    this.pathname = '/';
		  }
	
		  //to support http.request
		  if (this.pathname || this.search) {
		    var p = this.pathname || '';
		    var s = this.search || '';
		    this.path = p + s;
		  }
	
		  // finally, reconstruct the href based on what has been validated.
		  this.href = this.format();
		  return this;
		};
	
		// format a parsed object into a url string
		function urlFormat(obj) {
		  // ensure it's an object, and not a string url.
		  // If it's an obj, this is a no-op.
		  // this way, you can call url_format() on strings
		  // to clean up potentially wonky urls.
		  if (util.isString(obj)) obj = urlParse(obj);
		  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
		  return obj.format();
		}
	
		Url.prototype.format = function() {
		  var auth = this.auth || '';
		  if (auth) {
		    auth = encodeURIComponent(auth);
		    auth = auth.replace(/%3A/i, ':');
		    auth += '@';
		  }
	
		  var protocol = this.protocol || '',
		      pathname = this.pathname || '',
		      hash = this.hash || '',
		      host = false,
		      query = '';
	
		  if (this.host) {
		    host = auth + this.host;
		  } else if (this.hostname) {
		    host = auth + (this.hostname.indexOf(':') === -1 ?
		        this.hostname :
		        '[' + this.hostname + ']');
		    if (this.port) {
		      host += ':' + this.port;
		    }
		  }
	
		  if (this.query &&
		      util.isObject(this.query) &&
		      Object.keys(this.query).length) {
		    query = querystring.stringify(this.query);
		  }
	
		  var search = this.search || (query && ('?' + query)) || '';
	
		  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
		  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
		  // unless they had them to begin with.
		  if (this.slashes ||
		      (!protocol || slashedProtocol[protocol]) && host !== false) {
		    host = '//' + (host || '');
		    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
		  } else if (!host) {
		    host = '';
		  }
	
		  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
		  if (search && search.charAt(0) !== '?') search = '?' + search;
	
		  pathname = pathname.replace(/[?#]/g, function(match) {
		    return encodeURIComponent(match);
		  });
		  search = search.replace('#', '%23');
	
		  return protocol + host + pathname + search + hash;
		};
	
		function urlResolve(source, relative) {
		  return urlParse(source, false, true).resolve(relative);
		}
	
		Url.prototype.resolve = function(relative) {
		  return this.resolveObject(urlParse(relative, false, true)).format();
		};
	
		function urlResolveObject(source, relative) {
		  if (!source) return relative;
		  return urlParse(source, false, true).resolveObject(relative);
		}
	
		Url.prototype.resolveObject = function(relative) {
		  if (util.isString(relative)) {
		    var rel = new Url();
		    rel.parse(relative, false, true);
		    relative = rel;
		  }
	
		  var result = new Url();
		  var tkeys = Object.keys(this);
		  for (var tk = 0; tk < tkeys.length; tk++) {
		    var tkey = tkeys[tk];
		    result[tkey] = this[tkey];
		  }
	
		  // hash is always overridden, no matter what.
		  // even href="" will remove it.
		  result.hash = relative.hash;
	
		  // if the relative url is empty, then there's nothing left to do here.
		  if (relative.href === '') {
		    result.href = result.format();
		    return result;
		  }
	
		  // hrefs like //foo/bar always cut to the protocol.
		  if (relative.slashes && !relative.protocol) {
		    // take everything except the protocol from relative
		    var rkeys = Object.keys(relative);
		    for (var rk = 0; rk < rkeys.length; rk++) {
		      var rkey = rkeys[rk];
		      if (rkey !== 'protocol')
		        result[rkey] = relative[rkey];
		    }
	
		    //urlParse appends trailing / to urls like http://www.example.com
		    if (slashedProtocol[result.protocol] &&
		        result.hostname && !result.pathname) {
		      result.path = result.pathname = '/';
		    }
	
		    result.href = result.format();
		    return result;
		  }
	
		  if (relative.protocol && relative.protocol !== result.protocol) {
		    // if it's a known url protocol, then changing
		    // the protocol does weird things
		    // first, if it's not file:, then we MUST have a host,
		    // and if there was a path
		    // to begin with, then we MUST have a path.
		    // if it is file:, then the host is dropped,
		    // because that's known to be hostless.
		    // anything else is assumed to be absolute.
		    if (!slashedProtocol[relative.protocol]) {
		      var keys = Object.keys(relative);
		      for (var v = 0; v < keys.length; v++) {
		        var k = keys[v];
		        result[k] = relative[k];
		      }
		      result.href = result.format();
		      return result;
		    }
	
		    result.protocol = relative.protocol;
		    if (!relative.host && !hostlessProtocol[relative.protocol]) {
		      var relPath = (relative.pathname || '').split('/');
		      while (relPath.length && !(relative.host = relPath.shift()));
		      if (!relative.host) relative.host = '';
		      if (!relative.hostname) relative.hostname = '';
		      if (relPath[0] !== '') relPath.unshift('');
		      if (relPath.length < 2) relPath.unshift('');
		      result.pathname = relPath.join('/');
		    } else {
		      result.pathname = relative.pathname;
		    }
		    result.search = relative.search;
		    result.query = relative.query;
		    result.host = relative.host || '';
		    result.auth = relative.auth;
		    result.hostname = relative.hostname || relative.host;
		    result.port = relative.port;
		    // to support http.request
		    if (result.pathname || result.search) {
		      var p = result.pathname || '';
		      var s = result.search || '';
		      result.path = p + s;
		    }
		    result.slashes = result.slashes || relative.slashes;
		    result.href = result.format();
		    return result;
		  }
	
		  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
		      isRelAbs = (
		          relative.host ||
		          relative.pathname && relative.pathname.charAt(0) === '/'
		      ),
		      mustEndAbs = (isRelAbs || isSourceAbs ||
		                    (result.host && relative.pathname)),
		      removeAllDots = mustEndAbs,
		      srcPath = result.pathname && result.pathname.split('/') || [],
		      relPath = relative.pathname && relative.pathname.split('/') || [],
		      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
		  // if the url is a non-slashed url, then relative
		  // links like ../.. should be able
		  // to crawl up to the hostname, as well.  This is strange.
		  // result.protocol has already been set by now.
		  // Later on, put the first path part into the host field.
		  if (psychotic) {
		    result.hostname = '';
		    result.port = null;
		    if (result.host) {
		      if (srcPath[0] === '') srcPath[0] = result.host;
		      else srcPath.unshift(result.host);
		    }
		    result.host = '';
		    if (relative.protocol) {
		      relative.hostname = null;
		      relative.port = null;
		      if (relative.host) {
		        if (relPath[0] === '') relPath[0] = relative.host;
		        else relPath.unshift(relative.host);
		      }
		      relative.host = null;
		    }
		    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
		  }
	
		  if (isRelAbs) {
		    // it's absolute.
		    result.host = (relative.host || relative.host === '') ?
		                  relative.host : result.host;
		    result.hostname = (relative.hostname || relative.hostname === '') ?
		                      relative.hostname : result.hostname;
		    result.search = relative.search;
		    result.query = relative.query;
		    srcPath = relPath;
		    // fall through to the dot-handling below.
		  } else if (relPath.length) {
		    // it's relative
		    // throw away the existing file, and take the new path instead.
		    if (!srcPath) srcPath = [];
		    srcPath.pop();
		    srcPath = srcPath.concat(relPath);
		    result.search = relative.search;
		    result.query = relative.query;
		  } else if (!util.isNullOrUndefined(relative.search)) {
		    // just pull out the search.
		    // like href='?foo'.
		    // Put this after the other two cases because it simplifies the booleans
		    if (psychotic) {
		      result.hostname = result.host = srcPath.shift();
		      //occationaly the auth can get stuck only in host
		      //this especially happens in cases like
		      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
		      var authInHost = result.host && result.host.indexOf('@') > 0 ?
		                       result.host.split('@') : false;
		      if (authInHost) {
		        result.auth = authInHost.shift();
		        result.host = result.hostname = authInHost.shift();
		      }
		    }
		    result.search = relative.search;
		    result.query = relative.query;
		    //to support http.request
		    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
		      result.path = (result.pathname ? result.pathname : '') +
		                    (result.search ? result.search : '');
		    }
		    result.href = result.format();
		    return result;
		  }
	
		  if (!srcPath.length) {
		    // no path at all.  easy.
		    // we've already handled the other stuff above.
		    result.pathname = null;
		    //to support http.request
		    if (result.search) {
		      result.path = '/' + result.search;
		    } else {
		      result.path = null;
		    }
		    result.href = result.format();
		    return result;
		  }
	
		  // if a url ENDs in . or .., then it must get a trailing slash.
		  // however, if it ends in anything else non-slashy,
		  // then it must NOT get a trailing slash.
		  var last = srcPath.slice(-1)[0];
		  var hasTrailingSlash = (
		      (result.host || relative.host || srcPath.length > 1) &&
		      (last === '.' || last === '..') || last === '');
	
		  // strip single dots, resolve double dots to parent dir
		  // if the path tries to go above the root, `up` ends up > 0
		  var up = 0;
		  for (var i = srcPath.length; i >= 0; i--) {
		    last = srcPath[i];
		    if (last === '.') {
		      srcPath.splice(i, 1);
		    } else if (last === '..') {
		      srcPath.splice(i, 1);
		      up++;
		    } else if (up) {
		      srcPath.splice(i, 1);
		      up--;
		    }
		  }
	
		  // if the path is allowed to go above the root, restore leading ..s
		  if (!mustEndAbs && !removeAllDots) {
		    for (; up--; up) {
		      srcPath.unshift('..');
		    }
		  }
	
		  if (mustEndAbs && srcPath[0] !== '' &&
		      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
		    srcPath.unshift('');
		  }
	
		  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
		    srcPath.push('');
		  }
	
		  var isAbsolute = srcPath[0] === '' ||
		      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
		  // put the host back
		  if (psychotic) {
		    result.hostname = result.host = isAbsolute ? '' :
		                                    srcPath.length ? srcPath.shift() : '';
		    //occationaly the auth can get stuck only in host
		    //this especially happens in cases like
		    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
		    var authInHost = result.host && result.host.indexOf('@') > 0 ?
		                     result.host.split('@') : false;
		    if (authInHost) {
		      result.auth = authInHost.shift();
		      result.host = result.hostname = authInHost.shift();
		    }
		  }
	
		  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
		  if (mustEndAbs && !isAbsolute) {
		    srcPath.unshift('');
		  }
	
		  if (!srcPath.length) {
		    result.pathname = null;
		    result.path = null;
		  } else {
		    result.pathname = srcPath.join('/');
		  }
	
		  //to support request.http
		  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
		    result.path = (result.pathname ? result.pathname : '') +
		                  (result.search ? result.search : '');
		  }
		  result.auth = relative.auth || result.auth;
		  result.slashes = result.slashes || relative.slashes;
		  result.href = result.format();
		  return result;
		};
	
		Url.prototype.parseHost = function() {
		  var host = this.host;
		  var port = portPattern.exec(host);
		  if (port) {
		    port = port[0];
		    if (port !== ':') {
		      this.port = port.substr(1);
		    }
		    host = host.substr(0, host.length - port.length);
		  }
		  if (host) this.hostname = host;
		};
	
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
		;(function(root) {
	
			/** Detect free variables */
			var freeExports = typeof exports == 'object' && exports &&
				!exports.nodeType && exports;
			var freeModule = typeof module == 'object' && module &&
				!module.nodeType && module;
			var freeGlobal = typeof global == 'object' && global;
			if (
				freeGlobal.global === freeGlobal ||
				freeGlobal.window === freeGlobal ||
				freeGlobal.self === freeGlobal
			) {
				root = freeGlobal;
			}
	
			/**
			 * The `punycode` object.
			 * @name punycode
			 * @type Object
			 */
			var punycode,
	
			/** Highest positive signed 32-bit float value */
			maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
			/** Bootstring parameters */
			base = 36,
			tMin = 1,
			tMax = 26,
			skew = 38,
			damp = 700,
			initialBias = 72,
			initialN = 128, // 0x80
			delimiter = '-', // '\x2D'
	
			/** Regular expressions */
			regexPunycode = /^xn--/,
			regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
			regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
			/** Error messages */
			errors = {
				'overflow': 'Overflow: input needs wider integers to process',
				'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
				'invalid-input': 'Invalid input'
			},
	
			/** Convenience shortcuts */
			baseMinusTMin = base - tMin,
			floor = Math.floor,
			stringFromCharCode = String.fromCharCode,
	
			/** Temporary variable */
			key;
	
			/*--------------------------------------------------------------------------*/
	
			/**
			 * A generic error utility function.
			 * @private
			 * @param {String} type The error type.
			 * @returns {Error} Throws a `RangeError` with the applicable error message.
			 */
			function error(type) {
				throw RangeError(errors[type]);
			}
	
			/**
			 * A generic `Array#map` utility function.
			 * @private
			 * @param {Array} array The array to iterate over.
			 * @param {Function} callback The function that gets called for every array
			 * item.
			 * @returns {Array} A new array of values returned by the callback function.
			 */
			function map(array, fn) {
				var length = array.length;
				var result = [];
				while (length--) {
					result[length] = fn(array[length]);
				}
				return result;
			}
	
			/**
			 * A simple `Array#map`-like wrapper to work with domain name strings or email
			 * addresses.
			 * @private
			 * @param {String} domain The domain name or email address.
			 * @param {Function} callback The function that gets called for every
			 * character.
			 * @returns {Array} A new string of characters returned by the callback
			 * function.
			 */
			function mapDomain(string, fn) {
				var parts = string.split('@');
				var result = '';
				if (parts.length > 1) {
					// In email addresses, only the domain name should be punycoded. Leave
					// the local part (i.e. everything up to `@`) intact.
					result = parts[0] + '@';
					string = parts[1];
				}
				// Avoid `split(regex)` for IE8 compatibility. See #17.
				string = string.replace(regexSeparators, '\x2E');
				var labels = string.split('.');
				var encoded = map(labels, fn).join('.');
				return result + encoded;
			}
	
			/**
			 * Creates an array containing the numeric code points of each Unicode
			 * character in the string. While JavaScript uses UCS-2 internally,
			 * this function will convert a pair of surrogate halves (each of which
			 * UCS-2 exposes as separate characters) into a single code point,
			 * matching UTF-16.
			 * @see `punycode.ucs2.encode`
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode.ucs2
			 * @name decode
			 * @param {String} string The Unicode input string (UCS-2).
			 * @returns {Array} The new array of code points.
			 */
			function ucs2decode(string) {
				var output = [],
				    counter = 0,
				    length = string.length,
				    value,
				    extra;
				while (counter < length) {
					value = string.charCodeAt(counter++);
					if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
						// high surrogate, and there is a next character
						extra = string.charCodeAt(counter++);
						if ((extra & 0xFC00) == 0xDC00) { // low surrogate
							output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
						} else {
							// unmatched surrogate; only append this code unit, in case the next
							// code unit is the high surrogate of a surrogate pair
							output.push(value);
							counter--;
						}
					} else {
						output.push(value);
					}
				}
				return output;
			}
	
			/**
			 * Creates a string based on an array of numeric code points.
			 * @see `punycode.ucs2.decode`
			 * @memberOf punycode.ucs2
			 * @name encode
			 * @param {Array} codePoints The array of numeric code points.
			 * @returns {String} The new Unicode string (UCS-2).
			 */
			function ucs2encode(array) {
				return map(array, function(value) {
					var output = '';
					if (value > 0xFFFF) {
						value -= 0x10000;
						output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
						value = 0xDC00 | value & 0x3FF;
					}
					output += stringFromCharCode(value);
					return output;
				}).join('');
			}
	
			/**
			 * Converts a basic code point into a digit/integer.
			 * @see `digitToBasic()`
			 * @private
			 * @param {Number} codePoint The basic numeric code point value.
			 * @returns {Number} The numeric value of a basic code point (for use in
			 * representing integers) in the range `0` to `base - 1`, or `base` if
			 * the code point does not represent a value.
			 */
			function basicToDigit(codePoint) {
				if (codePoint - 48 < 10) {
					return codePoint - 22;
				}
				if (codePoint - 65 < 26) {
					return codePoint - 65;
				}
				if (codePoint - 97 < 26) {
					return codePoint - 97;
				}
				return base;
			}
	
			/**
			 * Converts a digit/integer into a basic code point.
			 * @see `basicToDigit()`
			 * @private
			 * @param {Number} digit The numeric value of a basic code point.
			 * @returns {Number} The basic code point whose value (when used for
			 * representing integers) is `digit`, which needs to be in the range
			 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
			 * used; else, the lowercase form is used. The behavior is undefined
			 * if `flag` is non-zero and `digit` has no uppercase form.
			 */
			function digitToBasic(digit, flag) {
				//  0..25 map to ASCII a..z or A..Z
				// 26..35 map to ASCII 0..9
				return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
			}
	
			/**
			 * Bias adaptation function as per section 3.4 of RFC 3492.
			 * http://tools.ietf.org/html/rfc3492#section-3.4
			 * @private
			 */
			function adapt(delta, numPoints, firstTime) {
				var k = 0;
				delta = firstTime ? floor(delta / damp) : delta >> 1;
				delta += floor(delta / numPoints);
				for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
					delta = floor(delta / baseMinusTMin);
				}
				return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
			}
	
			/**
			 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
			 * symbols.
			 * @memberOf punycode
			 * @param {String} input The Punycode string of ASCII-only symbols.
			 * @returns {String} The resulting string of Unicode symbols.
			 */
			function decode(input) {
				// Don't use UCS-2
				var output = [],
				    inputLength = input.length,
				    out,
				    i = 0,
				    n = initialN,
				    bias = initialBias,
				    basic,
				    j,
				    index,
				    oldi,
				    w,
				    k,
				    digit,
				    t,
				    /** Cached calculation results */
				    baseMinusT;
	
				// Handle the basic code points: let `basic` be the number of input code
				// points before the last delimiter, or `0` if there is none, then copy
				// the first basic code points to the output.
	
				basic = input.lastIndexOf(delimiter);
				if (basic < 0) {
					basic = 0;
				}
	
				for (j = 0; j < basic; ++j) {
					// if it's not a basic code point
					if (input.charCodeAt(j) >= 0x80) {
						error('not-basic');
					}
					output.push(input.charCodeAt(j));
				}
	
				// Main decoding loop: start just after the last delimiter if any basic code
				// points were copied; start at the beginning otherwise.
	
				for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
					// `index` is the index of the next character to be consumed.
					// Decode a generalized variable-length integer into `delta`,
					// which gets added to `i`. The overflow checking is easier
					// if we increase `i` as we go, then subtract off its starting
					// value at the end to obtain `delta`.
					for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
						if (index >= inputLength) {
							error('invalid-input');
						}
	
						digit = basicToDigit(input.charCodeAt(index++));
	
						if (digit >= base || digit > floor((maxInt - i) / w)) {
							error('overflow');
						}
	
						i += digit * w;
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
						if (digit < t) {
							break;
						}
	
						baseMinusT = base - t;
						if (w > floor(maxInt / baseMinusT)) {
							error('overflow');
						}
	
						w *= baseMinusT;
	
					}
	
					out = output.length + 1;
					bias = adapt(i - oldi, out, oldi == 0);
	
					// `i` was supposed to wrap around from `out` to `0`,
					// incrementing `n` each time, so we'll fix that now:
					if (floor(i / out) > maxInt - n) {
						error('overflow');
					}
	
					n += floor(i / out);
					i %= out;
	
					// Insert `n` at position `i` of the output
					output.splice(i++, 0, n);
	
				}
	
				return ucs2encode(output);
			}
	
			/**
			 * Converts a string of Unicode symbols (e.g. a domain name label) to a
			 * Punycode string of ASCII-only symbols.
			 * @memberOf punycode
			 * @param {String} input The string of Unicode symbols.
			 * @returns {String} The resulting Punycode string of ASCII-only symbols.
			 */
			function encode(input) {
				var n,
				    delta,
				    handledCPCount,
				    basicLength,
				    bias,
				    j,
				    m,
				    q,
				    k,
				    t,
				    currentValue,
				    output = [],
				    /** `inputLength` will hold the number of code points in `input`. */
				    inputLength,
				    /** Cached calculation results */
				    handledCPCountPlusOne,
				    baseMinusT,
				    qMinusT;
	
				// Convert the input in UCS-2 to Unicode
				input = ucs2decode(input);
	
				// Cache the length
				inputLength = input.length;
	
				// Initialize the state
				n = initialN;
				delta = 0;
				bias = initialBias;
	
				// Handle the basic code points
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue < 0x80) {
						output.push(stringFromCharCode(currentValue));
					}
				}
	
				handledCPCount = basicLength = output.length;
	
				// `handledCPCount` is the number of code points that have been handled;
				// `basicLength` is the number of basic code points.
	
				// Finish the basic string - if it is not empty - with a delimiter
				if (basicLength) {
					output.push(delimiter);
				}
	
				// Main encoding loop:
				while (handledCPCount < inputLength) {
	
					// All non-basic code points < n have been handled already. Find the next
					// larger one:
					for (m = maxInt, j = 0; j < inputLength; ++j) {
						currentValue = input[j];
						if (currentValue >= n && currentValue < m) {
							m = currentValue;
						}
					}
	
					// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
					// but guard against overflow
					handledCPCountPlusOne = handledCPCount + 1;
					if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
						error('overflow');
					}
	
					delta += (m - n) * handledCPCountPlusOne;
					n = m;
	
					for (j = 0; j < inputLength; ++j) {
						currentValue = input[j];
	
						if (currentValue < n && ++delta > maxInt) {
							error('overflow');
						}
	
						if (currentValue == n) {
							// Represent delta as a generalized variable-length integer
							for (q = delta, k = base; /* no condition */; k += base) {
								t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
								if (q < t) {
									break;
								}
								qMinusT = q - t;
								baseMinusT = base - t;
								output.push(
									stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
								);
								q = floor(qMinusT / baseMinusT);
							}
	
							output.push(stringFromCharCode(digitToBasic(q, 0)));
							bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
							delta = 0;
							++handledCPCount;
						}
					}
	
					++delta;
					++n;
	
				}
				return output.join('');
			}
	
			/**
			 * Converts a Punycode string representing a domain name or an email address
			 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
			 * it doesn't matter if you call it on a string that has already been
			 * converted to Unicode.
			 * @memberOf punycode
			 * @param {String} input The Punycoded domain name or email address to
			 * convert to Unicode.
			 * @returns {String} The Unicode representation of the given Punycode
			 * string.
			 */
			function toUnicode(input) {
				return mapDomain(input, function(string) {
					return regexPunycode.test(string)
						? decode(string.slice(4).toLowerCase())
						: string;
				});
			}
	
			/**
			 * Converts a Unicode string representing a domain name or an email address to
			 * Punycode. Only the non-ASCII parts of the domain name will be converted,
			 * i.e. it doesn't matter if you call it with a domain that's already in
			 * ASCII.
			 * @memberOf punycode
			 * @param {String} input The domain name or email address to convert, as a
			 * Unicode string.
			 * @returns {String} The Punycode representation of the given domain name or
			 * email address.
			 */
			function toASCII(input) {
				return mapDomain(input, function(string) {
					return regexNonASCII.test(string)
						? 'xn--' + encode(string)
						: string;
				});
			}
	
			/*--------------------------------------------------------------------------*/
	
			/** Define the public API */
			punycode = {
				/**
				 * A string representing the current Punycode.js version number.
				 * @memberOf punycode
				 * @type String
				 */
				'version': '1.3.2',
				/**
				 * An object of methods to convert from JavaScript's internal character
				 * representation (UCS-2) to Unicode code points, and back.
				 * @see <https://mathiasbynens.be/notes/javascript-encoding>
				 * @memberOf punycode
				 * @type Object
				 */
				'ucs2': {
					'decode': ucs2decode,
					'encode': ucs2encode
				},
				'decode': decode,
				'encode': encode,
				'toASCII': toASCII,
				'toUnicode': toUnicode
			};
	
			/** Expose `punycode` */
			// Some AMD build optimizers, like r.js, check for specific condition patterns
			// like the following:
			if (
				true
			) {
				!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
					return punycode;
				}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if (freeExports && freeModule) {
				if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
					freeModule.exports = punycode;
				} else { // in Narwhal or RingoJS v0.7.0-
					for (key in punycode) {
						punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
					}
				}
			} else { // in Rhino or a web browser
				root.punycode = punycode;
			}
	
		}(this));
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)(module), (function() { return this; }())))
	
	/***/ },
	/* 21 */
	/***/ function(module, exports) {
	
		'use strict';
	
		module.exports = {
		  isString: function(arg) {
		    return typeof(arg) === 'string';
		  },
		  isObject: function(arg) {
		    return typeof(arg) === 'object' && arg !== null;
		  },
		  isNull: function(arg) {
		    return arg === null;
		  },
		  isNullOrUndefined: function(arg) {
		    return arg == null;
		  }
		};
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.decode = exports.parse = __webpack_require__(23);
		exports.encode = exports.stringify = __webpack_require__(24);
	
	
	/***/ },
	/* 23 */
	/***/ function(module, exports) {
	
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
		'use strict';
	
		// If obj.hasOwnProperty has been overridden, then calling
		// obj.hasOwnProperty(prop) will break.
		// See: https://github.com/joyent/node/issues/1707
		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}
	
		module.exports = function(qs, sep, eq, options) {
		  sep = sep || '&';
		  eq = eq || '=';
		  var obj = {};
	
		  if (typeof qs !== 'string' || qs.length === 0) {
		    return obj;
		  }
	
		  var regexp = /\+/g;
		  qs = qs.split(sep);
	
		  var maxKeys = 1000;
		  if (options && typeof options.maxKeys === 'number') {
		    maxKeys = options.maxKeys;
		  }
	
		  var len = qs.length;
		  // maxKeys <= 0 means that we should not limit keys count
		  if (maxKeys > 0 && len > maxKeys) {
		    len = maxKeys;
		  }
	
		  for (var i = 0; i < len; ++i) {
		    var x = qs[i].replace(regexp, '%20'),
		        idx = x.indexOf(eq),
		        kstr, vstr, k, v;
	
		    if (idx >= 0) {
		      kstr = x.substr(0, idx);
		      vstr = x.substr(idx + 1);
		    } else {
		      kstr = x;
		      vstr = '';
		    }
	
		    k = decodeURIComponent(kstr);
		    v = decodeURIComponent(vstr);
	
		    if (!hasOwnProperty(obj, k)) {
		      obj[k] = v;
		    } else if (Array.isArray(obj[k])) {
		      obj[k].push(v);
		    } else {
		      obj[k] = [obj[k], v];
		    }
		  }
	
		  return obj;
		};
	
	
	/***/ },
	/* 24 */
	/***/ function(module, exports) {
	
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
		'use strict';
	
		var stringifyPrimitive = function(v) {
		  switch (typeof v) {
		    case 'string':
		      return v;
	
		    case 'boolean':
		      return v ? 'true' : 'false';
	
		    case 'number':
		      return isFinite(v) ? v : '';
	
		    default:
		      return '';
		  }
		};
	
		module.exports = function(obj, sep, eq, name) {
		  sep = sep || '&';
		  eq = eq || '=';
		  if (obj === null) {
		    obj = undefined;
		  }
	
		  if (typeof obj === 'object') {
		    return Object.keys(obj).map(function(k) {
		      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
		      if (Array.isArray(obj[k])) {
		        return obj[k].map(function(v) {
		          return ks + encodeURIComponent(stringifyPrimitive(v));
		        }).join(sep);
		      } else {
		        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
		      }
		    }).join(sep);
	
		  }
	
		  if (!name) return '';
		  return encodeURIComponent(stringifyPrimitive(name)) + eq +
		         encodeURIComponent(stringifyPrimitive(obj));
		};
	
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = {
		  console: __webpack_require__(26)
		};
	
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Special version of the Stream logger, which logs errors and warnings to stderr and all other
		 * levels to stdout.
		 *
		 * @class Loggers.Console
		 * @extends LoggerAbstract
		 * @constructor
		 * @param {Object} config - The configuration for the Logger
		 * @param {string} config.level - The highest log level for this logger to output.
		 * @param {Log} bridge - The object that triggers logging events, which we will record
		 */
	
		module.exports = Console;
	
		var LoggerAbstract = __webpack_require__(27);
		var _ = __webpack_require__(3);
	
		function Console(log, config) {
		  LoggerAbstract.call(this, log, config);
	
		  // config/state
		  this.color = _.has(config, 'color') ? !!config.color : true;
		}
		_.inherits(Console, LoggerAbstract);
	
		/**
		 * Override the LoggerAbstract's setup listeners to do a little extra setup
		 *
		 * @param  {Array} levels - The levels that we should be listeneing for
		 */
		Console.prototype.setupListeners = function (levels) {
		  // call the super method
		  LoggerAbstract.prototype.setupListeners.call(this, levels);
		};
	
		Console.prototype.write = function (label, message, to) {
		  if (console[to]) {
		    console[to](this.format(label, message));
		  }
		};
	
		/**
		 * Handler for the bridges "error" event
		 *
		 * @method onError
		 * @private
		 * @param  {Error} e - The Error object to log
		 * @return {undefined}
		 */
		Console.prototype.onError = _.handler(function (e) {
		  var to = console.error ? 'error' : 'log';
		  this.write(e.name === 'Error' ? 'ERROR' : e.name, e.stack || e.message, to);
		});
	
		/**
		 * Handler for the bridges "warning" event
		 *
		 * @method onWarning
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		Console.prototype.onWarning = _.handler(function (msg) {
		  this.write('WARNING', msg, console.warn ? 'warn' : 'log');
		});
	
		/**
		 * Handler for the bridges "info" event
		 *
		 * @method onInfo
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		Console.prototype.onInfo = _.handler(function (msg) {
		  this.write('INFO', msg, console.info ? 'info' : 'log');
		});
	
		/**
		 * Handler for the bridges "debug" event
		 *
		 * @method onDebug
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		Console.prototype.onDebug = _.handler(function (msg) {
		  this.write('DEBUG', msg, console.debug ? 'debug' : 'log');
		});
		/**
		 * Handler for the bridges "trace" event
		 *
		 * @method onTrace
		 * @private
		 * @return {undefined}
		 */
		Console.prototype.onTrace = _.handler(function (msg) {
		  this.write('TRACE', this._formatTraceMessage(msg), 'log');
		});
	
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		var _ = __webpack_require__(3);
	
		/**
		 * Abstract class providing common functionality to loggers
		 * @param {[type]} log [description]
		 * @param {[type]} config [description]
		 */
		function LoggerAbstract(log, config) {
		  this.log = log;
		  this.listeningLevels = [];
	
		  _.makeBoundMethods(this);
	
		  // when the log closes, remove our event listeners
		  this.log.once('closing', this.bound.cleanUpListeners);
	
		  this.setupListeners(config.levels);
		}
	
		function padNumToTen(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}
	
		/**
		 * Create a timestamp string used in the format function. Defers to Log.timestamp if it is defined,
		 * Also, feel free to override this at the logger level.
		 * @return {String} - Timestamp in ISO 8601 UTC
		 */
		LoggerAbstract.prototype.timestamp = function () {
		  var d = new Date();
		  return d.getUTCFullYear() + '-' +
		    padNumToTen(d.getUTCMonth() + 1) + '-' +
		    padNumToTen(d.getUTCDate()) + 'T' +
		    padNumToTen(d.getUTCHours()) + ':' +
		    padNumToTen(d.getUTCMinutes()) + ':' +
		    padNumToTen(d.getUTCSeconds()) + 'Z';
		};
	
		function indent(text, spaces) {
		  var space = _.repeat(' ', spaces || 2);
		  return (text || '').split(/\r?\n/).map(function (line) {
		    return space + line;
		  }).join('\n');
		}
	
		LoggerAbstract.prototype.format = function (label, message) {
		  return label + ': ' + this.timestamp() + '\n' + indent(message) + '\n\n';
		};
	
		LoggerAbstract.prototype.write = function () {
		  throw new Error('This should be overwritten by the logger');
		};
	
		/**
		 * Clear the current event listeners and then re-listen for events based on the level specified
		 *
		 * @method setupListeners
		 * @private
		 * @param  {Integer} level - The max log level that this logger should listen to
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.setupListeners = function (levels) {
		  this.cleanUpListeners();
	
		  this.listeningLevels = [];
	
		  _.each(levels, _.bind(function (level) {
		    var fnName = 'on' + _.ucfirst(level);
		    if (this.bound[fnName]) {
		      this.listeningLevels.push(level);
		      this.log.on(level, this.bound[fnName]);
		    } else {
		      throw new Error('Unable to listen for level "' + level + '"');
		    }
		  }, this));
		};
	
		/**
		 * Clear the current event listeners
		 *
		 * @method cleanUpListeners
		 * @private
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.cleanUpListeners = _.handler(function () {
		  _.each(this.listeningLevels, _.bind(function (level) {
		    this.log.removeListener(level, this.bound['on' + _.ucfirst(level)]);
		  }, this));
		});
	
		/**
		 * Handler for the logs "error" event
		 *
		 * @method onError
		 * @private
		 * @param  {Error} e - The Error object to log
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.onError = _.handler(function (e) {
		  this.write((e.name === 'Error' ? 'ERROR' : e.name), e.stack);
		});
	
		/**
		 * Handler for the logs "warning" event
		 *
		 * @method onWarning
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.onWarning = _.handler(function (msg) {
		  this.write('WARNING', msg);
		});
	
		/**
		 * Handler for the logs "info" event
		 *
		 * @method onInfo
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.onInfo = _.handler(function (msg) {
		  this.write('INFO', msg);
		});
	
		/**
		 * Handler for the logs "debug" event
		 *
		 * @method onDebug
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.onDebug = _.handler(function (msg) {
		  this.write('DEBUG', msg);
		});
	
		/**
		 * Handler for the logs "trace" event
		 *
		 * @method onTrace
		 * @private
		 * @param  {String} msg - The message to be logged
		 * @return {undefined}
		 */
		LoggerAbstract.prototype.onTrace = _.handler(function (requestDetails) {
		  this.write('TRACE', this._formatTraceMessage(requestDetails));
		});
	
		LoggerAbstract.prototype._formatTraceMessage = function (req) {
		  return '-> ' + req.method + ' ' + req.url + '\n' +
		    this._prettyJson(req.body) + '\n' +
		    '<- ' + req.status + '\n' +
		    this._prettyJson(req.response);
		/*
		-> GET https://sldfkjsdlfksjdf:9200/slsdkfjlxckvxhclks?sdlkj=sdlfkje
		{
		  asdflksjdf
		}
	
		<- 502
		{
		  sldfksjdlf
		}
		*/
		};
	
		LoggerAbstract.prototype._prettyJson = function (body) {
		  try {
		    if (typeof body === 'string') {
		      body = JSON.parse(body);
		    }
		    return JSON.stringify(body, null, '  ').replace(/'/g, '\\u0027');
		  } catch (e) {
		    return typeof body === 'string' ? body : '';
		  }
		};
	
		module.exports = LoggerAbstract;
	
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(Buffer) {/**
		 * Class to wrap URLS, formatting them and maintaining their separate details
		 * @type {[type]}
		 */
		module.exports = Host;
	
		var url = __webpack_require__(19);
		var qs = __webpack_require__(22);
		var _ = __webpack_require__(3);
	
		var startsWithProtocolRE = /^([a-z]+:)?\/\//;
		var defaultProto = 'http:';
		var btoa;
	
		if (typeof window !== 'undefined' && typeof window.location !== 'undefined') {
		  defaultProto = window.location.protocol;
		  btoa = window.btoa;
		}
	
		btoa = btoa || function (data) {
		  return (new Buffer(data, 'utf8')).toString('base64');
		};
	
		var urlParseFields = [
		  'protocol', 'hostname', 'pathname', 'port', 'auth', 'query'
		];
	
		var simplify = ['host', 'path'];
	
		var sslDefaults = {
		  pfx: null,
		  key: null,
		  passphrase: null,
		  cert: null,
		  ca: null,
		  ciphers: null,
		  rejectUnauthorized: false,
		  secureProtocol: null
		};
	
		// simple reference used when formatting as a url
		// and defines when parsing from a string
		Host.defaultPorts = {
		  http: 80,
		  https: 443
		};
	
		function Host(config, globalConfig) {
		  config = _.clone(config || {});
		  globalConfig = globalConfig || {};
	
		  // defaults
		  this.protocol = 'http';
		  this.host = 'localhost';
		  this.path = '';
		  this.port = 9200;
		  this.query = null;
		  this.headers = null;
		  this.suggestCompression = !!globalConfig.suggestCompression;
	
		  this.ssl = _.defaults({}, config.ssl || {}, globalConfig.ssl || {}, sslDefaults);
	
		  if (typeof config === 'string') {
		    var firstColon = config.indexOf(':');
		    var firstSlash = config.indexOf('/');
		    var noSlash = firstSlash === -1;
		    var portNoPath = firstColon > -1 && noSlash;
		    var portWithPath = !portNoPath && firstColon < firstSlash;
		    if ((noSlash || portNoPath || portWithPath) && !startsWithProtocolRE.test(config)) {
		      config = defaultProto + '//' + config;
		    }
		    config = _.pick(url.parse(config, false, true), urlParseFields);
		    // default logic for the port is to use 9200 for the default. When a string is specified though,
		    // we will use the default from the protocol of the string.
		    if (!config.port) {
		      var proto = config.protocol || 'http';
		      if (proto.charAt(proto.length - 1) === ':') {
		        proto = proto.substring(0, proto.length - 1);
		      }
		      if (Host.defaultPorts[proto]) {
		        config.port = Host.defaultPorts[proto];
		      }
		    }
		  }
	
		  if (_.isObject(config)) {
		    // move hostname/portname to host/port semi-intelligently.
		    _.each(simplify, function (to) {
		      var from = to + 'name';
		      if (config[from] && config[to]) {
		        if (config[to].indexOf(config[from]) === 0) {
		          config[to] = config[from];
		        }
		      } else if (config[from]) {
		        config[to] = config[from];
		      }
		      delete config[from];
		    });
		  } else {
		    config = {};
		  }
	
		  if (!config.auth && globalConfig.httpAuth) {
		    config.auth = globalConfig.httpAuth
		  }
	
		  if (config.auth) {
		    config.headers = config.headers || {};
		    config.headers.Authorization = 'Basic ' + btoa(config.auth);
		    delete config.auth;
		  }
	
		  _.forOwn(config, _.bind(function (val, prop) {
		    if (val != null) this[prop] = _.clone(val);
		  }, this));
	
		  // make sure the query string is parsed
		  if (this.query === null) {
		    // majority case
		    this.query = {};
		  } else if (!_.isPlainObject(this.query)) {
		    this.query = qs.parse(this.query);
		  }
	
		  // make sure that the port is a number
		  if (_.isNumeric(this.port)) {
		    this.port = parseInt(this.port, 10);
		  } else {
		    this.port = 9200;
		  }
	
		  // make sure the path starts with a leading slash
		  if (this.path === '/') {
		    this.path = '';
		  } else if (this.path && this.path.charAt(0) !== '/') {
		    this.path = '/' + (this.path || '');
		  }
	
		  // strip trailing ':' on the protocol (when config comes from url.parse)
		  if (this.protocol.substr(-1) === ':') {
		    this.protocol = this.protocol.substring(0, this.protocol.length - 1);
		  }
		}
	
		Host.prototype.makeUrl = function (params) {
		  params = params || {};
		  // build the port
		  var port = '';
		  if (this.port !== Host.defaultPorts[this.protocol]) {
		    // add an actual port
		    port = ':' + this.port;
		  }
	
		  // build the path
		  var path = '' + (this.path || '') + (params.path || '');
	
		  // if path doesn't start with '/' add it.
		  if (path.charAt(0) !== '/') {
		    path = '/' + path;
		  }
	
		  // build the query string
		  var query = qs.stringify(this.getQuery(params.query));
	
		  if (this.host) {
		    return this.protocol + '://' + this.host + port + path + (query ? '?' + query : '');
		  } else {
		    return path + (query ? '?' + query : '');
		  }
		};
	
		function objectPropertyGetter(prop, preOverride) {
		  return function (overrides) {
		    if (preOverride) {
		      overrides = preOverride.call(this, overrides);
		    }
	
		    var obj = this[prop];
		    if (!obj && !overrides) {
		      return null;
		    }
	
		    if (overrides) {
		      obj = _.assign({}, obj, overrides);
		    }
	
		    return _.size(obj) ? obj : null;
		  };
		}
	
		Host.prototype.getHeaders = objectPropertyGetter('headers', function (overrides) {
		  if (!this.suggestCompression) {
		    return overrides;
		  }
	
		  return _.defaults(overrides || {}, {
		    'Accept-Encoding': 'gzip,deflate'
		  });
		});
	
		Host.prototype.getQuery = objectPropertyGetter('query', function (query) {
		  return typeof query === 'string' ? qs.parse(query) : query;
		});
	
		Host.prototype.toString = function () {
		  return this.makeUrl();
		};
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
		var _ = __webpack_require__(3);
		var errors = module.exports;
	
		var canCapture = (typeof Error.captureStackTrace === 'function');
		var canStack = !!(new Error()).stack;
	
		function ErrorAbstract(msg, constructor, metadata) {
		  this.message = msg;
	
		  Error.call(this, this.message);
	
		  if (canCapture) {
		    Error.captureStackTrace(this, constructor);
		  }
		  else if (canStack) {
		    this.stack = (new Error()).stack;
		  }
		  else {
		    this.stack = '';
		  }
	
		  if (metadata) {
		    _.assign(this, metadata);
	
		    this.toString = function () {
		      return msg + ' :: ' + JSON.stringify(metadata);
		    };
	
		    this.toJSON = function () {
		      return _.assign({
		        msg: msg
		      }, metadata);
		    };
		  }
		}
		errors._Abstract = ErrorAbstract;
		_.inherits(ErrorAbstract, Error);
	
		/**
		 * Connection Error
		 * @param {String} [msg] - An error message that will probably end up in a log.
		 */
		errors.ConnectionFault = function ConnectionFault(msg) {
		  ErrorAbstract.call(this, msg || 'Connection Failure', errors.ConnectionFault);
		};
		_.inherits(errors.ConnectionFault, ErrorAbstract);
	
		/**
		 * No Living Connections
		 * @param {String} [msg] - An error message that will probably end up in a log.
		 */
		errors.NoConnections = function NoConnections(msg) {
		  ErrorAbstract.call(this, msg || 'No Living connections', errors.NoConnections);
		};
		_.inherits(errors.NoConnections, ErrorAbstract);
	
		/**
		 * Generic Error
		 * @param {String} [msg] - An error message that will probably end up in a log.
		 */
		errors.Generic = function Generic(msg, metadata) {
		  ErrorAbstract.call(this, msg || 'Generic Error', errors.Generic, metadata);
		};
		_.inherits(errors.Generic, ErrorAbstract);
	
		/**
		 * Request Timeout Error
		 * @param {String} [msg] - An error message that will probably end up in a log.
		 */
		errors.RequestTimeout = function RequestTimeout(msg) {
		  ErrorAbstract.call(this, msg || 'Request Timeout', errors.RequestTimeout);
		};
		_.inherits(errors.RequestTimeout, ErrorAbstract);
	
	
		/**
		 * Request Body could not be parsed
		 * @param {String} [msg] - An error message that will probably end up in a log.
		 */
		errors.Serialization = function Serialization(msg) {
		  ErrorAbstract.call(this, msg || 'Unable to parse/serialize body', errors.Serialization);
		};
		_.inherits(errors.Serialization, ErrorAbstract);
	
	
		/**
		 * Thrown when a browser compatability issue is detected (cough, IE, cough)
		 */
		errors.RequestTypeError = function RequestTypeError(feature) {
		  ErrorAbstract.call(this, 'Cross-domain AJAX requests ' + feature + ' are not supported', errors.RequestTypeError);
		};
		_.inherits(errors.RequestTypeError, ErrorAbstract);
	
		var statusCodes = [
		  [300, 'Multiple Choices'],
		  [301, 'Moved Permanently'],
		  [302, 'Found'],
		  [303, 'See Other'],
		  [304, 'Not Modified'],
		  [305, 'Use Proxy'],
		  [307, 'Temporary Redirect'],
		  [308, 'Permanent Redirect'],
		  [400, 'Bad Request'],
		  [401, 'Authentication Exception'],
		  [402, 'Payment Required'],
		  [403, ['Authorization Exception', 'Forbidden']],
		  [404, 'Not Found'],
		  [405, 'Method Not Allowed'],
		  [406, 'Not Acceptable'],
		  [407, 'Proxy Authentication Required'],
		  [408, 'Request Timeout'],
		  [409, 'Conflict'],
		  [410, 'Gone'],
		  [411, 'Length Required'],
		  [412, 'Precondition Failed'],
		  [413, 'Request Entity Too Large'],
		  [414, 'Request URIToo Long'],
		  [415, 'Unsupported Media Type'],
		  [416, 'Requested Range Not Satisfiable'],
		  [417, 'Expectation Failed'],
		  [418, 'Im ATeapot'],
		  [421, 'Too Many Connections From This IP'],
		  [426, 'Upgrade Required'],
		  [429, 'Too Many Requests'],
		  [450, 'Blocked By Windows Parental Controls'],
		  [494, 'Request Header Too Large'],
		  [497, 'HTTPTo HTTPS'],
		  [499, 'Client Closed Request'],
		  [500, 'Internal Server Error'],
		  [501, 'Not Implemented'],
		  [502, 'Bad Gateway'],
		  [503, 'Service Unavailable'],
		  [504, 'Gateway Timeout'],
		  [505, 'HTTPVersion Not Supported'],
		  [506, 'Variant Also Negotiates'],
		  [510, 'Not Extended']
		];
	
		_.each(statusCodes, function createStatusCodeError(tuple) {
		  var status = tuple[0];
		  var names = tuple[1];
		  var allNames = [].concat(names, status);
		  var primaryName = allNames[0];
		  var className = _.studlyCase(primaryName);
		  allNames = _.uniq(allNames.concat(className));
	
		  function StatusCodeError(msg, metadata) {
		    this.status = status;
		    this.displayName = className;
	
		    var esErrObject = null;
		    if (_.isPlainObject(msg)) {
		      esErrObject = msg;
		      msg = null;
		    }
	
		    if (!esErrObject) {
		      // errors from es now come in two forms, an error string < 2.0 and
		      // an object >= 2.0
		      // TODO: remove after dropping support for < 2.0
		      ErrorAbstract.call(this, msg || primaryName, StatusCodeError, metadata);
		      return this;
		    }
	
		    msg = [].concat(esErrObject.root_cause || []).reduce(function (memo, cause) {
		      if (memo) memo += ' (and) ';
	
		      memo += '[' + cause.type + '] ' + cause.reason;
	
		      var extraData = _.omit(cause, ['type', 'reason']);
		      if (_.size(extraData)) {
		        memo += ', with ' + prettyPrint(extraData);
		      }
	
		      return memo;
		    }, '');
	
		    if (!msg) {
		      if (esErrObject.type) msg += '[' + esErrObject.type + '] ';
		      if (esErrObject.reason) msg += esErrObject.reason;
		    }
	
		    ErrorAbstract.call(this, msg || primaryName, StatusCodeError, metadata);
		    return this;
		  }
		  _.inherits(StatusCodeError, ErrorAbstract);
	
		  allNames.forEach(function (name) {
		    errors[name] = StatusCodeError;
		  });
		});
	
	
		function prettyPrint(data) {
		  const path = []
		  return (function print(v) {
		    if (typeof v === 'object') {
		      if (path.indexOf(v) > -1) return '[circular]'
		      path.push(v)
		      try {
		        return '{ ' + _.map(v, function (subv, name) {
		          return name + '=' + print(subv)
		        }).join(' & ') + ' }'
		      } finally {
		        path.pop()
		      }
		    } else {
		      return JSON.stringify(v)
		    }
		  }(data))
		}
	
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * A client that makes requests to Elasticsearch via a {{#crossLink "Transport"}}Transport{{/crossLink}}
		 *
		 * Initializing a client might look something like:
		 *
		 * ```
		 * var client = new es.Client({
		 *   hosts: [
		 *     'es1.net:9200',
		 *     {
		 *       host: 'es2.net',
		 *       port: 9200
		 *     }
		 *   ],
		 *   sniffOnStart: true,
		 *   log: {
		 *     type: 'file',
		 *     level: 'warning'
		 *   }
		 * });
		 * ```
		 *
		 * @class Client
		 * @constructor
		 */
	
		module.exports = Client;
	
		var Transport = __webpack_require__(31);
		var clientAction = __webpack_require__(46);
		var _ = __webpack_require__(3);
	
		function Client(config) {
		  config = config || {};
	
		  if (config.__reused) {
		    throw new Error('Do not reuse objects to configure the elasticsearch Client class: ' +
		      'https://github.com/elasticsearch/elasticsearch-js/issues/33');
		  } else {
		    config.__reused = true;
		  }
	
		  function EsApiClient() {
		    // our client will log minimally by default
		    if (!config.hasOwnProperty('log')) {
		      config.log = 'warning';
		    }
	
		    if (!config.hosts && !config.host) {
		      config.host = 'http://localhost:9200';
		    }
	
		    this.close = function () {
		      this.transport.close();
		    };
	
		    this.transport = new Transport(config);
	
		    _.each(EsApiClient.prototype, _.bind(function (Fn, prop) {
		      if (Fn.prototype instanceof clientAction.ApiNamespace) {
		        this[prop] = new Fn(this.transport, this);
		      }
		    }, this));
	
		    delete this._namespaces;
		  }
	
	
		  EsApiClient.prototype = _.funcEnum(config, 'apiVersion', Client.apis, '_default');
		  if (!config.sniffEndpoint && EsApiClient.prototype === Client.apis['0.90']) {
		    config.sniffEndpoint = '/_cluster/nodes';
		  }
	
		  var Constructor = EsApiClient;
	
		  if (config.plugins) {
		    Constructor.prototype = _.cloneDeep(Constructor.prototype);
	
		    _.each(config.plugins, function (setup) {
		      Constructor = setup(Constructor, config, {
		        apis: __webpack_require__(47),
		        connectors: __webpack_require__(39),
		        loggers: __webpack_require__(25),
		        selectors: __webpack_require__(36),
		        serializers: __webpack_require__(42),
		        Client: __webpack_require__(30),
		        clientAction: clientAction,
		        Connection: __webpack_require__(16),
		        ConnectionPool: __webpack_require__(35),
		        Errors: __webpack_require__(29),
		        Host: __webpack_require__(28),
		        Log: __webpack_require__(18),
		        Logger: __webpack_require__(27),
		        NodesToHost: __webpack_require__(45),
		        Transport: __webpack_require__(31),
		        utils: __webpack_require__(3)
		      }) || Constructor;
		    });
		  }
	
		  return new Constructor();
		}
	
		Client.apis = __webpack_require__(47);
	
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Class that manages making request, called by all of the API methods.
		 * @type {[type]}
		 */
		module.exports = Transport;
	
		var _ = __webpack_require__(3);
		var errors = __webpack_require__(29);
		var Host = __webpack_require__(28);
		var patchSniffOnConnectionFault = __webpack_require__(32);
		var findCommonProtocol = __webpack_require__(33);
	
		function Transport(config) {
		  var self = this;
		  config = self._config = config || {};
	
		  var LogClass = (typeof config.log === 'function') ? config.log : __webpack_require__(18);
		  config.log = self.log = new LogClass(config);
	
		  // setup the connection pool
		  var ConnectionPool = _.funcEnum(config, 'connectionPool', Transport.connectionPools, 'main');
		  self.connectionPool = new ConnectionPool(config);
	
		  // setup the serializer
		  var Serializer = _.funcEnum(config, 'serializer', Transport.serializers, 'json');
		  self.serializer = new Serializer(config);
	
		  // setup the nodesToHostCallback
		  self.nodesToHostCallback = _.funcEnum(config, 'nodesToHostCallback', Transport.nodesToHostCallbacks, 'main');
	
		  // setup max retries
		  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3;
	
		  // setup endpoint to use for sniffing
		  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint') ? config.sniffEndpoint : '/_nodes/_all/http';
	
		  // setup requestTimeout default
		  self.requestTimeout = config.hasOwnProperty('requestTimeout') ? config.requestTimeout : 30000;
	
		  if (config.hasOwnProperty('defer')) {
		    self.defer = config.defer;
		  }
	
		  // randomizeHosts option
		  var randomizeHosts = config.hasOwnProperty('randomizeHosts') ? !!config.randomizeHosts : true;
	
		  if (config.host) {
		    config.hosts = config.host;
		  }
	
		  if (config.hosts) {
		    var hostsConfig = _.createArray(config.hosts, function (val) {
		      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {
		        return val;
		      }
		    });
	
		    if (!hostsConfig) {
		      throw new TypeError('Invalid hosts config. Expected a URL, an array of urls, a host config object, ' +
		        'or an array of host config objects.');
		    }
	
		    if (randomizeHosts) {
		      hostsConfig = _.shuffle(hostsConfig);
		    }
	
		    self.setHosts(hostsConfig);
		  }
	
		  if (config.hasOwnProperty('sniffedNodesProtocol')) {
		    self.sniffedNodesProtocol = config.sniffedNodesProtocol || null;
		  } else {
		    self.sniffedNodesProtocol = findCommonProtocol(self.connectionPool.getAllHosts()) || null;
		  }
	
		  if (config.sniffOnStart) {
		    self.sniff();
		  }
	
		  if (config.sniffInterval) {
		    self._timeout(function doSniff() {
		      self.sniff();
		      self._timeout(doSniff, config.sniffInterval);
		    }, config.sniffInterval);
		  }
	
		  if (config.sniffOnConnectionFault) {
		    patchSniffOnConnectionFault(self);
		  }
		}
	
		Transport.connectionPools = {
		  main: __webpack_require__(35)
		};
	
		Transport.serializers = __webpack_require__(42);
	
		Transport.nodesToHostCallbacks = {
		  main: __webpack_require__(45)
		};
	
		Transport.prototype.defer = function () {
		  if (typeof Promise === 'undefined') {
		    throw new Error(
		      'No Promise implementation found. In order for elasticsearch-js to create promises ' +
		      'either specify the `defer` configuration or include a global Promise shim'
		    )
		  }
	
		  var defer = {};
		  defer.promise = new Promise(function (resolve, reject) {
		    defer.resolve = resolve;
		    defer.reject = reject;
		  });
		  return defer;
		};
	
		/**
		 * Perform a request with the client's transport
		 *
		 * @method request
		 * @todo async body writing
		 * @todo abort
		 * @todo access to custom headers, modifying of request in general
		 * @param {object} params
		 * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)
		 * @param {Number} params.maxRetries - number of times to re-run request if the
		 *   original node chosen can not be connected to.
		 * @param {string} [params.path="/"] - URL pathname. Do not include query string.
		 * @param {string|object} [params.query] - Query string.
		 * @param {String} params.method - The HTTP method for the request
		 * @param {String} params.body - The body of the HTTP request
		 * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)
		 */
		Transport.prototype.request = function (params, cb) {
		  var self = this;
		  var remainingRetries = this.maxRetries;
		  var requestTimeout = this.requestTimeout;
	
		  var connection; // set in sendReqWithConnection
		  var aborted = false; // several connector will respond with an error when the request is aborted
		  var requestAborter; // an abort function, returned by connection#request()
		  var requestTimeoutId; // the id of the ^timeout
		  var ret; // the object returned to the user, might be a promise
		  var defer; // the defer object, will be set when we are using promises.
	
		  var body = params.body;
		  var headers = !params.headers ? {} : _.transform(params.headers, function (headers, val, name) {
		    headers[String(name).toLowerCase()] = val;
		  });
	
		  self.log.debug('starting request', params);
	
		  // determine the response based on the presense of a callback
		  if (typeof cb === 'function') {
		    // handle callbacks within a domain
		    if (process.domain) {
		      cb = process.domain.bind(cb);
		    }
		    ret = {
		      abort: abortRequest
		    };
		  } else {
		    defer = this.defer();
		    ret = defer.promise;
		    ret.abort = abortRequest;
		  }
	
		  if (body && params.method === 'GET') {
		    _.nextTick(respond, new TypeError('Body can not be sent with method "GET"'));
		    return ret;
		  }
	
		  // serialize the body
		  if (body) {
		    var serializer = self.serializer;
		    var serializeFn = serializer[params.bulkBody ? 'bulkBody' : 'serialize'];
	
		    body = serializeFn.call(serializer, body);
		    if (!headers['content-type']) {
		      headers['content-type'] = serializeFn.contentType;
		    }
		  }
	
		  if (params.hasOwnProperty('maxRetries')) {
		    remainingRetries = params.maxRetries;
		  }
	
		  if (params.hasOwnProperty('requestTimeout')) {
		    requestTimeout = params.requestTimeout;
		  }
	
		  params.req = {
		    method: params.method,
		    path: params.path || '/',
		    query: params.query,
		    body: body,
		    headers: headers
		  };
	
		  function sendReqWithConnection(err, _connection) {
		    if (aborted) {
		      return;
		    }
	
		    if (err) {
		      respond(err);
		    } else if (_connection) {
		      connection = _connection;
		      requestAborter = connection.request(params.req, checkRespForFailure);
		    } else {
		      self.log.warning('No living connections');
		      respond(new errors.NoConnections());
		    }
		  }
	
		  function checkRespForFailure(err, body, status, headers) {
		    if (aborted) {
		      return;
		    }
	
		    requestAborter = void 0;
	
		    if (err instanceof errors.RequestTypeError) {
		      self.log.error('Connection refused to execute the request', err);
		      respond(err, body, status, headers);
		      return;
		    }
	
		    if (err) {
		      connection.setStatus('dead');
	
		      var errMsg = err.message || '';
	
		      errMsg =
		        '\n' +
		        params.req.method +
		        ' ' +
		        connection.host.makeUrl(params.req) +
		        (errMsg.length ? ' => ' : '') +
		        errMsg
		      ;
	
		      if (remainingRetries) {
		        remainingRetries--;
		        self.log.error('Request error, retrying' + errMsg);
		        self.connectionPool.select(sendReqWithConnection);
		      } else {
		        self.log.error('Request complete with error' + errMsg);
		        respond(new errors.ConnectionFault(err));
		      }
		    } else {
		      self.log.debug('Request complete');
		      respond(void 0, body, status, headers);
		    }
		  }
	
		  function respond(err, body, status, headers) {
		    if (aborted) {
		      return;
		    }
	
		    self._timeout(requestTimeoutId);
		    var parsedBody;
		    var isJson = !headers || (headers['content-type'] && ~headers['content-type'].indexOf('application/json'));
	
		    if (!err && body) {
		      if (isJson) {
		        parsedBody = self.serializer.deserialize(body);
		        if (parsedBody == null) {
		          err = new errors.Serialization();
		          parsedBody = body;
		        }
		      } else {
		        parsedBody = body;
		      }
		    }
	
		    // does the response represent an error?
		    if (
		      (!err || err instanceof errors.Serialization)
		      && (status < 200 || status >= 300)
		      && (!params.ignore || !_.include(params.ignore, status))
		    ) {
	
		      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);
		      errorMetadata.statusCode = status;
		      errorMetadata.response = body;
	
		      if (status === 401 && headers && headers['www-authenticate']) {
		        errorMetadata.wwwAuthenticateDirective = headers['www-authenticate'];
		      }
	
		      if (errors[status]) {
		        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);
		      } else {
		        err = new errors.Generic('unknown error', errorMetadata);
		      }
		    }
	
		    // can we cast notfound to false?
		    if (params.castExists) {
		      if (err && err instanceof errors.NotFound) {
		        parsedBody = false;
		        err = void 0;
		      } else {
		        parsedBody = !err;
		      }
		    }
	
		    // how do we send the response?
		    if (typeof cb === 'function') {
		      if (err) {
		        cb(err, parsedBody, status);
		      } else {
		        cb(void 0, parsedBody, status);
		      }
		    } else if (err) {
		      err.body = parsedBody;
		      err.status = status;
		      defer.reject(err);
		    } else {
		      defer.resolve(parsedBody);
		    }
		  }
	
		  function abortRequest() {
		    if (aborted) {
		      return;
		    }
	
		    aborted = true;
		    remainingRetries = 0;
		    self._timeout(requestTimeoutId);
		    if (typeof requestAborter === 'function') {
		      requestAborter();
		    }
		  }
	
		  if (requestTimeout && requestTimeout !== Infinity) {
		    requestTimeoutId = this._timeout(function () {
		      respond(new errors.RequestTimeout('Request Timeout after ' + requestTimeout + 'ms'));
		      abortRequest();
		    }, requestTimeout);
		  }
	
		  if (connection) {
		    sendReqWithConnection(void 0, connection);
		  } else {
		    self.connectionPool.select(sendReqWithConnection);
		  }
	
		  return ret;
		};
	
		Transport.prototype._timeout = function (cb, delay) {
		  if (this.closed) return;
	
		  var id;
		  var timers = this._timers || (this._timers = []);
	
		  if ('function' !== typeof cb) {
		    id = cb;
		    cb = void 0;
		  }
	
		  if (cb) {
		    // set the timer
		    id = setTimeout(function () {
		      _.pull(timers, id);
		      cb();
		    }, delay);
	
		    timers.push(id);
		    return id;
		  }
	
		  if (id) {
		    clearTimeout(id);
	
		    var i = this._timers.indexOf(id);
		    if (i !== -1) {
		      this._timers.splice(i, 1);
		    }
		  }
		};
	
		/**
		 * Ask an ES node for a list of all the nodes, add/remove nodes from the connection
		 * pool as appropriate
		 *
		 * @param  {Function} cb - Function to call back once complete
		 */
		Transport.prototype.sniff = function (cb) {
		  var self = this;
		  var nodesToHostCallback = this.nodesToHostCallback;
		  var log = this.log;
		  var sniffedNodesProtocol = this.sniffedNodesProtocol;
	
		  // make cb a function if it isn't
		  cb = typeof cb === 'function' ? cb : _.noop;
	
		  this.request({
		    path: this.sniffEndpoint,
		    query: {
		      filter_path: [
		        'nodes.*.http.publish_address',
		        'nodes.*.name',
		        'nodes.*.hostname',
		        'nodes.*.host',
		        'nodes.*.version',
		      ].join(','),
		    },
		    method: 'GET'
		  }, function (err, resp, status) {
		    if (!err && resp && resp.nodes) {
		      var hostsConfigs;
	
		      try {
		        hostsConfigs = nodesToHostCallback(resp.nodes);
		      } catch (e) {
		        log.error(new Error('Unable to convert node list from ' + this.sniffEndpoint +
		          ' to hosts durring sniff. Encountered error:\n' + (e.stack || e.message)));
		        return;
		      }
	
		      _.forEach(hostsConfigs, function (hostConfig) {
		        if (sniffedNodesProtocol) hostConfig.protocol = sniffedNodesProtocol;
		      });
	
		      self.setHosts(hostsConfigs);
		    }
		    cb(err, resp, status);
		  });
		};
	
		/**
		 * Set the host list that the transport should use.
		 *
		 * @param {Array<HostConfig>} hostsConfigs - an array of Hosts, or configuration objects
		 *                                         that will be used to create Host objects.
		 */
		Transport.prototype.setHosts = function (hostsConfigs) {
		  var globalConfig = this._config;
		  this.connectionPool.setHosts(_.map(hostsConfigs, function (conf) {
		    return (conf instanceof Host) ? conf : new Host(conf, globalConfig);
		  }));
		};
	
		/**
		 * Close the Transport, which closes the logs and connection pool
		 * @return {[type]} [description]
		 */
		Transport.prototype.close = function () {
		  this.log.close();
		  this.closed = true;
		  _.each(this._timers, clearTimeout);
		  this._timers = null;
		  this.connectionPool.close();
		};
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
		var _ = __webpack_require__(3);
	
	
		/**
		 * Patch the transport's connection pool to schedule a sniff after a connection fails.
		 * When a connection fails for the first time it will schedule a sniff 1 second in the
		 * future, and increase the timeout based on the deadTimeout algorithm chosen by the
		 * connectionPool, and the number of times the sniff has failed.
		 *
		 * @param  {Transport} transport - the transport that will be using this behavior
		 * @return {undefined}
		 */
		module.exports = function setupSniffOnConnectionFault(transport) {
		  var failures = 0;
		  var pool = transport.connectionPool;
		  var originalOnDied = pool._onConnectionDied;
	
		  // do the actual sniff, if the sniff is unable to
		  // connect to a node this function will be called again by the connectionPool
		  var work = function () {
		    work.timerId = transport._timeout(work.timerId);
		    transport.sniff();
		  };
	
		  // create a function that will count down to a
		  // point n milliseconds into the future
		  var countdownTo = function (ms) {
		    var start = _.now();
		    return function () {
		      return start - ms;
		    };
		  };
	
		  // overwrite the function, but still call it
		  pool._onConnectionDied = function (connection, wasAlreadyDead) {
		    var ret = originalOnDied.call(pool, connection, wasAlreadyDead);
	
		    // clear the failures if this is the first failure we have seen
		    failures = work.timerId ? failures + 1 : 0;
	
		    var ms = pool.calcDeadTimeout(failures, 1000);
	
		    if (work.timerId && ms < work.timerId && work.countdown()) {
		      // clear the timer
		      work.timerId = transport._timeout(work.timerId);
		    }
	
		    if (!work.timerId) {
		      work.timerId = transport._timeout(work, ms);
		      work.countdown = countdownTo(ms);
		    }
	
		    return ret;
		  };
	
		  pool._onConnectionDied.restore = function () {
		    pool._onConnectionDied = originalOnDied;
		  };
		};
	
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isEmpty = __webpack_require__(34);
	
		module.exports = function (hosts) {
		  if (isEmpty(hosts)) return false;
	
		  var commonProtocol = hosts.shift().protocol;
		  for (var i = 0; i < hosts.length; i++) {
		    if (commonProtocol !== hosts[i].protocol) {
		      return false;
		    }
		  }
	
		  return commonProtocol;
		}
	
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global, module) {/**
		 * lodash (Custom Build) <https://lodash.com/>
		 * Build: `lodash modularize exports="npm" -o ./`
		 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
		 * Released under MIT license <https://lodash.com/license>
		 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
		 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		 */
	
		/** Used as references for various `Number` constants. */
		var MAX_SAFE_INTEGER = 9007199254740991;
	
		/** `Object#toString` result references. */
		var argsTag = '[object Arguments]',
		    funcTag = '[object Function]',
		    genTag = '[object GeneratorFunction]',
		    mapTag = '[object Map]',
		    objectTag = '[object Object]',
		    promiseTag = '[object Promise]',
		    setTag = '[object Set]',
		    weakMapTag = '[object WeakMap]';
	
		var dataViewTag = '[object DataView]';
	
		/**
		 * Used to match `RegExp`
		 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		 */
		var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
		/** Used to detect host constructors (Safari). */
		var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
		/** Detect free variable `global` from Node.js. */
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
		/** Detect free variable `self`. */
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
		/** Used as a reference to the global object. */
		var root = freeGlobal || freeSelf || Function('return this')();
	
		/** Detect free variable `exports`. */
		var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
		/** Detect free variable `module`. */
		var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;
	
		/**
		 * Gets the value at `key` of `object`.
		 *
		 * @private
		 * @param {Object} [object] The object to query.
		 * @param {string} key The key of the property to get.
		 * @returns {*} Returns the property value.
		 */
		function getValue(object, key) {
		  return object == null ? undefined : object[key];
		}
	
		/**
		 * Checks if `value` is a host object in IE < 9.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
		 */
		function isHostObject(value) {
		  // Many host objects are `Object` objects that can coerce to strings
		  // despite having improperly defined `toString` methods.
		  var result = false;
		  if (value != null && typeof value.toString != 'function') {
		    try {
		      result = !!(value + '');
		    } catch (e) {}
		  }
		  return result;
		}
	
		/**
		 * Creates a unary function that invokes `func` with its argument transformed.
		 *
		 * @private
		 * @param {Function} func The function to wrap.
		 * @param {Function} transform The argument transform.
		 * @returns {Function} Returns the new function.
		 */
		function overArg(func, transform) {
		  return function(arg) {
		    return func(transform(arg));
		  };
		}
	
		/** Used for built-in method references. */
		var funcProto = Function.prototype,
		    objectProto = Object.prototype;
	
		/** Used to detect overreaching core-js shims. */
		var coreJsData = root['__core-js_shared__'];
	
		/** Used to detect methods masquerading as native. */
		var maskSrcKey = (function() {
		  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		  return uid ? ('Symbol(src)_1.' + uid) : '';
		}());
	
		/** Used to resolve the decompiled source of functions. */
		var funcToString = funcProto.toString;
	
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
	
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
	
		/** Used to detect if a method is native. */
		var reIsNative = RegExp('^' +
		  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		);
	
		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
		    nativeKeys = overArg(Object.keys, Object);
	
		/* Built-in method references that are verified to be native. */
		var DataView = getNative(root, 'DataView'),
		    Map = getNative(root, 'Map'),
		    Promise = getNative(root, 'Promise'),
		    Set = getNative(root, 'Set'),
		    WeakMap = getNative(root, 'WeakMap');
	
		/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
		var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
	
		/** Used to detect maps, sets, and weakmaps. */
		var dataViewCtorString = toSource(DataView),
		    mapCtorString = toSource(Map),
		    promiseCtorString = toSource(Promise),
		    setCtorString = toSource(Set),
		    weakMapCtorString = toSource(WeakMap);
	
		/**
		 * The base implementation of `getTag`.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {string} Returns the `toStringTag`.
		 */
		function baseGetTag(value) {
		  return objectToString.call(value);
		}
	
		/**
		 * The base implementation of `_.isNative` without bad shim checks.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a native function,
		 *  else `false`.
		 */
		function baseIsNative(value) {
		  if (!isObject(value) || isMasked(value)) {
		    return false;
		  }
		  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
		  return pattern.test(toSource(value));
		}
	
		/**
		 * Gets the native function at `key` of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {string} key The key of the method to get.
		 * @returns {*} Returns the function if it's native, else `undefined`.
		 */
		function getNative(object, key) {
		  var value = getValue(object, key);
		  return baseIsNative(value) ? value : undefined;
		}
	
		/**
		 * Gets the `toStringTag` of `value`.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {string} Returns the `toStringTag`.
		 */
		var getTag = baseGetTag;
	
		// Fallback for data views, maps, sets, and weak maps in IE 11,
		// for data views in Edge < 14, and promises in Node.js.
		if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		    (Map && getTag(new Map) != mapTag) ||
		    (Promise && getTag(Promise.resolve()) != promiseTag) ||
		    (Set && getTag(new Set) != setTag) ||
		    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		  getTag = function(value) {
		    var result = objectToString.call(value),
		        Ctor = result == objectTag ? value.constructor : undefined,
		        ctorString = Ctor ? toSource(Ctor) : undefined;
	
		    if (ctorString) {
		      switch (ctorString) {
		        case dataViewCtorString: return dataViewTag;
		        case mapCtorString: return mapTag;
		        case promiseCtorString: return promiseTag;
		        case setCtorString: return setTag;
		        case weakMapCtorString: return weakMapTag;
		      }
		    }
		    return result;
		  };
		}
	
		/**
		 * Checks if `func` has its source masked.
		 *
		 * @private
		 * @param {Function} func The function to check.
		 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		 */
		function isMasked(func) {
		  return !!maskSrcKey && (maskSrcKey in func);
		}
	
		/**
		 * Checks if `value` is likely a prototype object.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		 */
		function isPrototype(value) {
		  var Ctor = value && value.constructor,
		      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
		  return value === proto;
		}
	
		/**
		 * Converts `func` to its source code.
		 *
		 * @private
		 * @param {Function} func The function to process.
		 * @returns {string} Returns the source code.
		 */
		function toSource(func) {
		  if (func != null) {
		    try {
		      return funcToString.call(func);
		    } catch (e) {}
		    try {
		      return (func + '');
		    } catch (e) {}
		  }
		  return '';
		}
	
		/**
		 * Checks if `value` is likely an `arguments` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		 *  else `false`.
		 * @example
		 *
		 * _.isArguments(function() { return arguments; }());
		 * // => true
		 *
		 * _.isArguments([1, 2, 3]);
		 * // => false
		 */
		function isArguments(value) {
		  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
		  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
		    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
		}
	
		/**
		 * Checks if `value` is classified as an `Array` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		 * @example
		 *
		 * _.isArray([1, 2, 3]);
		 * // => true
		 *
		 * _.isArray(document.body.children);
		 * // => false
		 *
		 * _.isArray('abc');
		 * // => false
		 *
		 * _.isArray(_.noop);
		 * // => false
		 */
		var isArray = Array.isArray;
	
		/**
		 * Checks if `value` is array-like. A value is considered array-like if it's
		 * not a function and has a `value.length` that's an integer greater than or
		 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		 * @example
		 *
		 * _.isArrayLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isArrayLike(document.body.children);
		 * // => true
		 *
		 * _.isArrayLike('abc');
		 * // => true
		 *
		 * _.isArrayLike(_.noop);
		 * // => false
		 */
		function isArrayLike(value) {
		  return value != null && isLength(value.length) && !isFunction(value);
		}
	
		/**
		 * This method is like `_.isArrayLike` except that it also checks if `value`
		 * is an object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an array-like object,
		 *  else `false`.
		 * @example
		 *
		 * _.isArrayLikeObject([1, 2, 3]);
		 * // => true
		 *
		 * _.isArrayLikeObject(document.body.children);
		 * // => true
		 *
		 * _.isArrayLikeObject('abc');
		 * // => false
		 *
		 * _.isArrayLikeObject(_.noop);
		 * // => false
		 */
		function isArrayLikeObject(value) {
		  return isObjectLike(value) && isArrayLike(value);
		}
	
		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;
	
		/**
		 * Checks if `value` is an empty object, collection, map, or set.
		 *
		 * Objects are considered empty if they have no own enumerable string keyed
		 * properties.
		 *
		 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		 * jQuery-like collections are considered empty if they have a `length` of `0`.
		 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		 * @example
		 *
		 * _.isEmpty(null);
		 * // => true
		 *
		 * _.isEmpty(true);
		 * // => true
		 *
		 * _.isEmpty(1);
		 * // => true
		 *
		 * _.isEmpty([1, 2, 3]);
		 * // => false
		 *
		 * _.isEmpty({ 'a': 1 });
		 * // => false
		 */
		function isEmpty(value) {
		  if (isArrayLike(value) &&
		      (isArray(value) || typeof value == 'string' ||
		        typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
		    return !value.length;
		  }
		  var tag = getTag(value);
		  if (tag == mapTag || tag == setTag) {
		    return !value.size;
		  }
		  if (nonEnumShadows || isPrototype(value)) {
		    return !nativeKeys(value).length;
		  }
		  for (var key in value) {
		    if (hasOwnProperty.call(value, key)) {
		      return false;
		    }
		  }
		  return true;
		}
	
		/**
		 * Checks if `value` is classified as a `Function` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		 * @example
		 *
		 * _.isFunction(_);
		 * // => true
		 *
		 * _.isFunction(/abc/);
		 * // => false
		 */
		function isFunction(value) {
		  // The use of `Object#toString` avoids issues with the `typeof` operator
		  // in Safari 8-9 which returns 'object' for typed array and other constructors.
		  var tag = isObject(value) ? objectToString.call(value) : '';
		  return tag == funcTag || tag == genTag;
		}
	
		/**
		 * Checks if `value` is a valid array-like length.
		 *
		 * **Note:** This method is loosely based on
		 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
		 * @example
		 *
		 * _.isLength(3);
		 * // => true
		 *
		 * _.isLength(Number.MIN_VALUE);
		 * // => false
		 *
		 * _.isLength(Infinity);
		 * // => false
		 *
		 * _.isLength('3');
		 * // => false
		 */
		function isLength(value) {
		  return typeof value == 'number' &&
		    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		}
	
		/**
		 * Checks if `value` is the
		 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		 * @example
		 *
		 * _.isObject({});
		 * // => true
		 *
		 * _.isObject([1, 2, 3]);
		 * // => true
		 *
		 * _.isObject(_.noop);
		 * // => true
		 *
		 * _.isObject(null);
		 * // => false
		 */
		function isObject(value) {
		  var type = typeof value;
		  return !!value && (type == 'object' || type == 'function');
		}
	
		/**
		 * Checks if `value` is object-like. A value is object-like if it's not `null`
		 * and has a `typeof` result of "object".
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		 * @example
		 *
		 * _.isObjectLike({});
		 * // => true
		 *
		 * _.isObjectLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isObjectLike(_.noop);
		 * // => false
		 *
		 * _.isObjectLike(null);
		 * // => false
		 */
		function isObjectLike(value) {
		  return !!value && typeof value == 'object';
		}
	
		/**
		 * This method returns `false`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.13.0
		 * @category Util
		 * @returns {boolean} Returns `false`.
		 * @example
		 *
		 * _.times(2, _.stubFalse);
		 * // => [false, false]
		 */
		function stubFalse() {
		  return false;
		}
	
		module.exports = isEmpty;
	
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(13)(module)))
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Manager of connections to a node(s), capable of ensuring that connections are clear and living
		 * before providing them to the application
		 *
		 * @class ConnectionPool
		 * @constructor
		 * @param {Object} config - The config object passed to the transport.
		 */
	
		module.exports = ConnectionPool;
	
		var _ = __webpack_require__(3);
		var Log = __webpack_require__(18);
	
		function ConnectionPool(config) {
		  config = config || {};
		  _.makeBoundMethods(this);
	
		  if (!config.log) {
		    this.log = new Log();
		    config.log = this.log;
		  } else {
		    this.log = config.log;
		  }
	
		  // we will need this when we create connections down the road
		  this._config = config;
	
		  // get the selector config var
		  this.selector = _.funcEnum(config, 'selector', ConnectionPool.selectors, ConnectionPool.defaultSelector);
	
		  // get the connection class
		  this.Connection = _.funcEnum(config, 'connectionClass', ConnectionPool.connectionClasses,
		    ConnectionPool.defaultConnectionClass);
	
		  // time that connections will wait before being revived
		  this.deadTimeout = config.hasOwnProperty('deadTimeout') ? config.deadTimeout : 60000;
		  this.maxDeadTimeout = config.hasOwnProperty('maxDeadTimeout') ? config.maxDeadTimeout : 18e5;
		  this.calcDeadTimeout = _.funcEnum(config, 'calcDeadTimeout', ConnectionPool.calcDeadTimeoutOptions, 'exponential');
	
		  // a map of connections to their "id" property, used when sniffing
		  this.index = {};
	
		  this._conns = {
		    alive: [],
		    dead: []
		  };
	
		  // information about timeouts for dead connections
		  this._timeouts = [];
		}
	
		// selector options
		ConnectionPool.selectors = __webpack_require__(36);
		ConnectionPool.defaultSelector = 'roundRobin';
	
		// get the connection options
		ConnectionPool.connectionClasses = __webpack_require__(39);
		ConnectionPool.defaultConnectionClass = ConnectionPool.connectionClasses._default;
		delete ConnectionPool.connectionClasses._default;
	
		// the function that calculates timeouts based on attempts
		ConnectionPool.calcDeadTimeoutOptions = {
		  flat: function (attempt, baseTimeout) {
		    return baseTimeout;
		  },
		  exponential: function (attempt, baseTimeout) {
		    return Math.min(baseTimeout * 2 * Math.pow(2, (attempt * 0.5 - 1)), this.maxDeadTimeout);
		  }
		};
	
		/**
		 * Selects a connection from the list using the this.selector
		 * Features:
		 *  - detects if the selector is async or not
		 *  - sync selectors should still return asynchronously
		 *  - catches errors in sync selectors
		 *  - automatically selects the first dead connection when there no living connections
		 *
		 * @param  {Function} cb [description]
		 * @return {[type]}      [description]
		 */
		ConnectionPool.prototype.select = function (cb) {
		  if (this._conns.alive.length) {
		    if (this.selector.length > 1) {
		      this.selector(this._conns.alive, cb);
		    } else {
		      try {
		        _.nextTick(cb, void 0, this.selector(this._conns.alive));
		      } catch (e) {
		        cb(e);
		      }
		    }
		  } else if (this._timeouts.length) {
		    this._selectDeadConnection(cb);
		  } else {
		    _.nextTick(cb, void 0);
		  }
		};
	
		/**
		 * Handler for the "set status" event emitted but the connections. It will move
		 * the connection to it's proper connection list (unless it was closed).
		 *
		 * @param  {String} status - the connection's new status
		 * @param  {String} oldStatus - the connection's old status
		 * @param  {ConnectionAbstract} connection - the connection object itself
		 */
		ConnectionPool.prototype.onStatusSet = _.handler(function (status, oldStatus, connection) {
		  var index;
	
		  var died = (status === 'dead');
		  var wasAlreadyDead = (died && oldStatus === 'dead');
		  var revived = (!died && oldStatus === 'dead');
		  var noChange = (oldStatus === status);
		  var from = this._conns[oldStatus];
		  var to = this._conns[status];
	
		  if (noChange && !died) {
		    return true;
		  }
	
		  if (from !== to) {
		    if (_.isArray(from)) {
		      index = from.indexOf(connection);
		      if (index !== -1) {
		        from.splice(index, 1);
		      }
		    }
	
		    if (_.isArray(to)) {
		      index = to.indexOf(connection);
		      if (index === -1) {
		        to.push(connection);
		      }
		    }
		  }
	
		  if (died) {
		    this._onConnectionDied(connection, wasAlreadyDead);
		  }
	
		  if (revived) {
		    this._onConnectionRevived(connection);
		  }
		});
	
		/**
		 * Handler used to clear the times created when a connection dies
		 * @param  {ConnectionAbstract} connection
		 */
		ConnectionPool.prototype._onConnectionRevived = function (connection) {
		  var timeout;
		  for (var i = 0; i < this._timeouts.length; i++) {
		    if (this._timeouts[i].conn === connection) {
		      timeout = this._timeouts[i];
		      if (timeout.id) {
		        clearTimeout(timeout.id);
		      }
		      this._timeouts.splice(i, 1);
		      break;
		    }
		  }
		};
	
		/**
		 * Handler used to update or create a timeout for the connection which has died
		 * @param  {ConnectionAbstract} connection
		 * @param  {Boolean} alreadyWasDead - If the connection was preivously dead this must be set to true
		 */
		ConnectionPool.prototype._onConnectionDied = function (connection, alreadyWasDead) {
		  var timeout;
		  if (alreadyWasDead) {
		    for (var i = 0; i < this._timeouts.length; i++) {
		      if (this._timeouts[i].conn === connection) {
		        timeout = this._timeouts[i];
		        break;
		      }
		    }
		  } else {
		    timeout = {
		      conn: connection,
		      attempt: 0,
		      revive: function (cb) {
		        timeout.attempt++;
		        connection.ping(function (err) {
		          connection.setStatus(err ? 'dead' : 'alive');
		          if (cb && typeof cb === 'function') {
		            cb(err);
		          }
		        });
		      }
		    };
		    this._timeouts.push(timeout);
		  }
	
		  if (timeout.id) {
		    clearTimeout(timeout.id);
		  }
	
		  var ms = this.calcDeadTimeout(timeout.attempt, this.deadTimeout);
		  timeout.id = setTimeout(timeout.revive, ms);
		  timeout.runAt = _.now() + ms;
		};
	
		ConnectionPool.prototype._selectDeadConnection = function (cb) {
		  var orderedTimeouts = _.sortBy(this._timeouts, 'runAt');
		  var log = this.log;
	
		  process.nextTick(function next() {
		    var timeout = orderedTimeouts.shift();
		    if (!timeout) {
		      cb(void 0);
		      return;
		    }
	
		    if (!timeout.conn) {
		      next();
		      return;
		    }
	
		    if (timeout.conn.status === 'dead') {
		      timeout.revive(function (err) {
		        if (err) {
		          log.warning('Unable to revive connection: ' + timeout.conn.id);
		          process.nextTick(next);
		        } else {
		          cb(void 0, timeout.conn);
		        }
		      });
		    } else {
		      cb(void 0, timeout.conn);
		    }
		  });
		};
	
		/**
		 * Returns a random list of nodes from the living connections up to the limit.
		 * If there are no living connections it will fall back to the dead connections.
		 * If there are no dead connections it will return nothing.
		 *
		 * This is used for testing (when we just want the one existing node)
		 * and sniffing, where using the selector to get all of the living connections
		 * is not reasonable.
		 *
		 * @param {string} [status] - optional status of the connection to fetch
		 * @param {Number} [limit] - optional limit on the number of connections to return
		 */
		ConnectionPool.prototype.getConnections = function (status, limit) {
		  var list;
		  if (status) {
		    list = this._conns[status];
		  } else {
		    list = this._conns[this._conns.alive.length ? 'alive' : 'dead'];
		  }
	
		  if (limit == null) {
		    return list.slice(0);
		  } else {
		    return _.shuffle(list).slice(0, limit);
		  }
		};
	
		/**
		 * Add a single connection to the pool and change it's status to "alive".
		 * The connection should inherit from ConnectionAbstract
		 *
		 * @param {ConnectionAbstract} connection - The connection to add
		 */
		ConnectionPool.prototype.addConnection = function (connection) {
		  if (!connection.id) {
		    connection.id = connection.host.toString();
		  }
	
		  if (!this.index[connection.id]) {
		    this.log.info('Adding connection to', connection.id);
		    this.index[connection.id] = connection;
		    connection.on('status set', this.bound.onStatusSet);
		    connection.setStatus('alive');
		  }
		};
	
		/**
		 * Remove a connection from the pool, and set it's status to "closed".
		 *
		 * @param  {ConnectionAbstract} connection - The connection to remove/close
		 */
		ConnectionPool.prototype.removeConnection = function (connection) {
		  if (!connection.id) {
		    connection.id = connection.host.toString();
		  }
	
		  if (this.index[connection.id]) {
		    delete this.index[connection.id];
		    connection.setStatus('closed');
		    connection.removeListener('status set', this.bound.onStatusSet);
		  }
		};
	
		/**
		 * Override the internal node list. All connections that are not in the new host
		 * list are closed and removed. Non-unique hosts are ignored.
		 *
		 * @param {Host[]} hosts - An array of Host instances.
		 */
		ConnectionPool.prototype.setHosts = function (hosts) {
		  var connection;
		  var i;
		  var id;
		  var host;
		  var toRemove = _.clone(this.index);
	
		  for (i = 0; i < hosts.length; i++) {
		    host = hosts[i];
		    id = host.toString();
		    if (this.index[id]) {
		      delete toRemove[id];
		    } else {
		      connection = new this.Connection(host, this._config);
		      connection.id = id;
		      this.addConnection(connection);
		    }
		  }
	
		  var removeIds = _.keys(toRemove);
		  for (i = 0; i < removeIds.length; i++) {
		    this.removeConnection(this.index[removeIds[i]]);
		  }
		};
	
		ConnectionPool.prototype.getAllHosts = function () {
		  return _.values(this.index).map(function (connection) {
		    return connection.host;
		  });
		};
	
		/**
		 * Close the conncetion pool, as well as all of it's connections
		 */
		ConnectionPool.prototype.close = function () {
		  this.setHosts([]);
		};
		ConnectionPool.prototype.empty = ConnectionPool.prototype.close;
	
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = {
		  random: __webpack_require__(37),
		  roundRobin: __webpack_require__(38)
		};
	
	
	/***/ },
	/* 37 */
	/***/ function(module, exports) {
	
		/**
		 * Selects a connection randomly
		 *
		 * @module selectors
		 * @type {Function}
		 * @param {Array} connection - The list of connections to choose from
		 * @return {Connection} - The selected connection
		 */
		module.exports = function RandomSelector(connections) {
		  return connections[Math.floor(Math.random() * connections.length)];
		};
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports) {
	
		/**
		 * Selects a connection the simplest way possible, Round Robin
		 *
		 * @module selectors
		 * @type {Function}
		 * @param {Array} connections - The list of connections that this selector needs to choose from
		 * @return {Connection} - The selected connection
		 */
		module.exports = function (connections) {
		  var connection = connections[0];
		  connections.push(connections.shift());
		  return connection;
		};
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
		var opts = {
		  xhr: __webpack_require__(40),
		  jquery: __webpack_require__(41),
		  angular: __webpack_require__(2)
		};
		var _ = __webpack_require__(3);
	
		// remove modules that have been ignored by browserify
		_.each(opts, function (conn, name) {
		  if (typeof conn !== 'function') {
		    delete opts[name];
		  }
		});
	
		// custom _default specification
		if (opts.xhr) {
		  opts._default = 'xhr';
		} else if (opts.angular) {
		  opts._default = 'angular';
		} else {
		  opts._default = 'jquery';
		}
	
		module.exports = opts;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports) {
	
		// empty (null-loader)
	
	/***/ },
	/* 41 */
	/***/ function(module, exports) {
	
		// empty (null-loader)
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = {
		  angular: __webpack_require__(43),
		  json: __webpack_require__(44)
		};
	
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* global angular */
		var _ = __webpack_require__(3);
		var JsonSerializer = __webpack_require__(44);
	
		function AngularSerializer() {}
		_.inherits(AngularSerializer, JsonSerializer);
	
		// mimic the JsonSerializer's encode method, but use angular's toJson instead
		AngularSerializer.prototype.encode = function (val) {
		  switch (typeof val) {
		    case 'string':
		      return val;
		    case 'object':
		      if (val) return angular.toJson(val);
		    /* falls through */
		    default:
		      return;
		  }
		};
	
		module.exports = AngularSerializer;
	
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Simple JSON serializer
		 * @type {[type]}
		 */
		module.exports = Json;
	
		var _ = __webpack_require__(3);
	
		function Json() {}
	
		/**
		 * Converts a value into a string, or an error
		 * @param  {*} val - Any value, methods are stripped and
		 * see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify about other params
		 * @return {String|Error} - A string is always returned, unless an error occured. then it will be that error.
		 */
		Json.prototype.serialize = function (val, replacer, spaces) {
		  switch (typeof val) {
		    case 'string':
		      return val;
		    case 'object':
		      if (val) {
		        return JSON.stringify(val, replacer, spaces);
		      }
		    /* falls through */
		    default:
		      return;
		  }
		};
	
		Json.prototype.serialize.contentType = 'application/json';
	
		/**
		 * Parse a JSON string, if it is already parsed it is ignored
		 * @param  {String} str - the string to parse
		 * @return {[type]}
		 */
		Json.prototype.deserialize = function (str) {
		  if (typeof str === 'string') {
		    try {
		      return JSON.parse(str);
		    } catch (e) {}
		  }
		};
	
		Json.prototype.bulkBody = function (val) {
		  var body = '', i;
	
		  if (_.isArray(val)) {
		    for (i = 0; i < val.length; i++) {
		      body += this.serialize(val[i]) + '\n';
		    }
		  } else if (typeof val === 'string') {
		    // make sure the string ends in a new line
		    body = val + (val[val.length - 1] === '\n' ? '' : '\n');
		  } else {
		    throw new TypeError('Bulk body should either be an Array of commands/string, or a String');
		  }
	
		  return body;
		};
	
		Json.prototype.bulkBody.contentType = 'application/x-ndjson';
	
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		var _ = __webpack_require__(3);
	
		var extractHostPartsRE1x = /\[(?:(.*)\/)?(.+?):(\d+)\]/;
	
		function makeNodeParser(hostProp) {
		  return function (nodes) {
		    return _.transform(nodes, function (hosts, node, id) {
		      var address = _.get(node, hostProp)
		      if (!address) return;
	
		      var host = {
		        host: undefined,
		        port: undefined,
		        _meta: {
		          id: id,
		          name: node.name,
		          version: node.version
		        }
		      };
	
		      var malformedError = new Error(
		        'Malformed ' + hostProp + '.' +
		        ' Got ' + JSON.stringify(address) +
		        ' and expected it to match "{hostname?}/{ip}:{port}".'
		      );
	
		      var matches1x = extractHostPartsRE1x.exec(address);
		      if (matches1x) {
		        host.host = matches1x[1] || matches1x[2];
		        host.port = parseInt(matches1x[3], 10);
		        hosts.push(host);
		        return;
		      }
	
		      if (address.indexOf('/') > -1) {
		        var withHostParts = address.split('/');
		        if (withHostParts.length !== 2) throw malformedError;
	
		        host.host = withHostParts.shift();
		        address = withHostParts.shift();
		      }
	
		      if (address.indexOf(':') < 0) {
		        throw malformedError;
		      }
	
		      var addressParts = address.split(':');
		      if (addressParts.length !== 2) {
		        throw malformedError;
		      }
	
		      host.host = host.host || addressParts[0];
		      host.port = parseInt(addressParts[1], 10);
		      hosts.push(host);
		    }, []);
		  };
		}
	
		module.exports = makeNodeParser('http.publish_address');
	
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		
		var _ = __webpack_require__(3);
	
		/**
		 * Constructs a client action factory that uses specific defaults
		 * @type {Function}
		 */
		exports.makeFactoryWithModifier = makeFactoryWithModifier;
	
		/**
		 * Constructs a function that can be called to make a request to ES
		 * @type {Function}
		 */
		exports.factory = makeFactoryWithModifier();
	
		/**
		 * Constructs a proxy to another api method
		 * @type {Function}
		 */
		exports.proxyFactory = exports.factory.proxy;
	
		// export so that we can test this
		exports._resolveUrl = resolveUrl;
	
		exports.ApiNamespace = function () {};
		exports.namespaceFactory = function () {
		  function ClientNamespace(transport, client) {
		    this.transport = transport;
		    this.client = client;
		  }
	
		  ClientNamespace.prototype = new exports.ApiNamespace();
	
		  return ClientNamespace;
		};
	
		function makeFactoryWithModifier(modifier) {
		  modifier = modifier || _.identity;
	
		  var factory = function (spec) {
		    spec = modifier(spec);
	
		    if (!_.isPlainObject(spec.params)) {
		      spec.params = {};
		    }
	
		    if (!spec.method) {
		      spec.method = 'GET';
		    }
	
		    function action(params, cb) {
		      if (typeof params === 'function') {
		        cb = params;
		        params = {};
		      } else {
		        params = params || {};
		        cb = typeof cb === 'function' ? cb : null;
		      }
	
		      try {
		        return exec(this.transport, spec, _.clone(params), cb);
		      } catch (e) {
		        if (typeof cb === 'function') {
		          _.nextTick(cb, e);
		        } else {
		          var def = this.transport.defer();
		          def.reject(e);
		          return def.promise;
		        }
		      }
		    }
	
		    action.spec = spec;
	
		    return action;
		  };
	
		  factory.proxy = function (fn, spec) {
		    return function (params, cb) {
		      if (typeof params === 'function') {
		        cb = params;
		        params = {};
		      } else {
		        params = params || {};
		        cb = typeof cb === 'function' ? cb : null;
		      }
	
		      if (spec.transform) {
		        spec.transform(params);
		      }
	
		      return fn.call(this, params, cb);
		    };
		  };
	
		  return factory;
		}
	
		var castType = {
		  'enum': function validSelection(param, val, name) {
		    if (_.isString(val) && val.indexOf(',') > -1) {
		      val = commaSepList(val);
		    }
	
		    if (_.isArray(val)) {
		      return val.map(function (v) {
		        return validSelection(param, v, name);
		      }).join(',');
		    }
	
		    for (var i = 0; i < param.options.length; i++) {
		      if (param.options[i] === String(val)) {
		        return param.options[i];
		      }
		    }
		    throw new TypeError('Invalid ' + name + ': expected ' + (
		      param.options.length > 1
		      ? 'one of ' + param.options.join(',')
		      : param.options[0]
		    ));
		  },
		  duration: function (param, val, name) {
		    if (_.isNumeric(val) || _.isInterval(val)) {
		      return val;
		    } else {
		      throw new TypeError(
		        'Invalid ' + name + ': expected a number or interval ' +
		        '(an integer followed by one of M, w, d, h, m, s, y or ms).'
		      );
		    }
		  },
		  list: function (param, val, name) {
		    switch (typeof val) {
		      case 'number':
		      case 'boolean':
		        return '' + val;
		      case 'string':
		        val = commaSepList(val);
		      /* falls through */
		      case 'object':
		        if (_.isArray(val)) {
		          return val.join(',');
		        }
		      /* falls through */
		      default:
		        throw new TypeError('Invalid ' + name + ': expected be a comma separated list, array, number or string.');
		    }
		  },
		  'boolean': function (param, val) {
		    val = _.isString(val) ? val.toLowerCase() : val;
		    return (val === 'no' || val === 'off') ? false : !!val;
		  },
		  number: function (param, val, name) {
		    if (_.isNumeric(val)) {
		      return val * 1;
		    } else {
		      throw new TypeError('Invalid ' + name + ': expected a number.');
		    }
		  },
		  string: function (param, val, name) {
		    switch (typeof val) {
		      case 'number':
		      case 'string':
		        return '' + val;
		      default:
		        throw new TypeError('Invalid ' + name + ': expected a string.');
		    }
		  },
		  time: function (param, val, name) {
		    if (typeof val === 'string') {
		      return val;
		    }
		    else if (_.isNumeric(val)) {
		      return '' + val;
		    }
		    else if (val instanceof Date) {
		      return '' + val.getTime();
		    }
		    else {
		      throw new TypeError('Invalid ' + name + ': expected some sort of time.');
		    }
		  }
		};
	
		function resolveUrl(url, params) {
		  var vars = {}, i, key;
	
		  if (url.req) {
		    // url has required params
		    if (!url.reqParamKeys) {
		      // create cached key list on demand
		      url.reqParamKeys = _.keys(url.req);
		    }
	
		    for (i = 0; i < url.reqParamKeys.length; i ++) {
		      key = url.reqParamKeys[i];
		      if (!params.hasOwnProperty(key) || params[key] == null) {
		        // missing a required param
		        return false;
		      } else {
		        // cast of copy required param
		        if (castType[url.req[key].type]) {
		          vars[key] = castType[url.req[key].type](url.req[key], params[key], key);
		        } else {
		          vars[key] = params[key];
		        }
		      }
		    }
		  }
	
		  if (url.opt) {
		    // url has optional params
		    if (!url.optParamKeys) {
		      url.optParamKeys = _.keys(url.opt);
		    }
	
		    for (i = 0; i < url.optParamKeys.length; i ++) {
		      key = url.optParamKeys[i];
		      if (params[key]) {
		        if (castType[url.opt[key].type] || params[key] == null) {
		          vars[key] = castType[url.opt[key].type](url.opt[key], params[key], key);
		        } else {
		          vars[key] = params[key];
		        }
		      } else {
		        vars[key] = url.opt[key]['default'];
		      }
		    }
		  }
	
		  if (!url.template) {
		    // compile the template on demand
		    url.template = _.template(url.fmt);
		  }
	
		  return url.template(_.transform(vars, function (note, val, name) {
		    // encode each value
		    note[name] = encodeURIComponent(val);
		    // remove it from the params so that it isn't sent to the final request
		    delete params[name];
		  }, {}));
		}
	
	
		function exec(transport, spec, params, cb) {
		  var request = {
		    method: spec.method
		  };
		  var query = {};
		  var i;
	
		  // pass the timeout from the spec
		  if (spec.requestTimeout) {
		    request.requestTimeout = spec.requestTimeout;
		  }
	
		  if (!params.body && spec.paramAsBody) {
		    if (typeof spec.paramAsBody === 'object') {
		      params.body = {};
		      params.body[spec.paramAsBody.body] = params[spec.paramAsBody.param];
		    } else {
		      params.body = params[spec.paramAsBody];
		    }
	
		    delete params[spec.paramAsBody];
		  }
	
		  // verify that we have the body if needed
		  if (spec.needsBody && !params.body) {
		    throw new TypeError('A request body is required.');
		  }
	
		  // control params
		  if (spec.bulkBody) {
		    request.bulkBody = true;
		  }
	
		  if (spec.method === 'HEAD') {
		    request.castExists = true;
		  }
	
		  // pick the url
		  if (spec.url) {
		    // only one url option
		    request.path = resolveUrl(spec.url, params);
		  } else {
		    for (i = 0; i < spec.urls.length; i++) {
		      if (request.path = resolveUrl(spec.urls[i], params)) {
		        break;
		      }
		    }
		  }
	
		  if (!request.path) {
		    // there must have been some mimimun requirements that were not met
		    var minUrl = spec.url || spec.urls[spec.urls.length - 1];
		    throw new TypeError('Unable to build a path with those params. Supply at least ' + _.keys(minUrl.req).join(', '));
		  }
	
		  // build the query string
		  if (!spec.paramKeys) {
		    // build a key list on demand
		    spec.paramKeys = _.keys(spec.params);
		    spec.requireParamKeys = _.transform(spec.params, function (req, param, key) {
		      if (param.required) {
		        req.push(key);
		      }
		    }, []);
		  }
	
		  for (var key in params) {
		    if (params.hasOwnProperty(key) && params[key] != null) {
		      switch (key) {
		        case 'body':
		        case 'headers':
		        case 'requestTimeout':
		        case 'maxRetries':
		          request[key] = params[key];
		          break;
		        case 'ignore':
		          request.ignore = _.isArray(params[key]) ? params[key] : [params[key]];
		          break;
		        case 'method':
		          request.method = _.toUpperString(params[key]);
		          break;
		        default:
		          var paramSpec = spec.params[key];
		          if (paramSpec) {
		          // param keys don't always match the param name, in those cases it's stored in the param def as "name"
		            paramSpec.name = paramSpec.name || key;
		            if (params[key] != null) {
		              if (castType[paramSpec.type]) {
		                query[paramSpec.name] = castType[paramSpec.type](paramSpec, params[key], key);
		              } else {
		                query[paramSpec.name] = params[key];
		              }
	
		              if (paramSpec['default'] && query[paramSpec.name] === paramSpec['default']) {
		                delete query[paramSpec.name];
		              }
		            }
		          } else {
		            query[key] = params[key];
		          }
		      }
		    }
		  }
	
		  for (i = 0; i < spec.requireParamKeys.length; i ++) {
		    if (!query.hasOwnProperty(spec.requireParamKeys[i])) {
		      throw new TypeError('Missing required parameter ' + spec.requireParamKeys[i]);
		    }
		  }
	
		  request.query = query;
	
		  return transport.request(request, cb);
		}
	
		function commaSepList(str) {
		  return str.split(',').map(function (i) {
		    return i.trim();
		  });
		}
	
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = {
		  '_default': __webpack_require__(48),
		  '5.2': __webpack_require__(48),
		  '5.1': __webpack_require__(49),
		  '5.0': __webpack_require__(50),
		  '2.4': __webpack_require__(51),
		  '1.7': __webpack_require__(52),
		  '5.x': __webpack_require__(53),
		  '5.3': __webpack_require__(54),
		  'master': __webpack_require__(55)
		};
	
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - Default list of fields to exclude from the returned _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - Default list of fields to extract and return from the _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-string,`String`>>} params.health - A health status ("green", "yellow", or "red" to filter only indices matching the specified health status
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    health: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ]
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Return the full node ID instead of the shortened version (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    fullId: {
		      type: 'boolean',
		      name: 'full_id'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/snapshots/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/snapshots'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.tasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-number,`Number`>>} params.parentTask - Return tasks with specified parent task id. Set to -1 to return all.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.tasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'number',
		      name: 'parent_task'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/tasks'
		  }
		});
	
		/**
		 * Perform a [cat.templates](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>} params.name - A pattern that returned template names must match
		 */
		api.cat.prototype.templates = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/templates/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/templates'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.threadPool](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.size - The multiplier in which to display values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.threadPoolPatterns - A comma-separated list of regular-expressions to filter the thread pools in the output
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    size: {
		      type: 'enum',
		      options: [
		        '',
		        'k',
		        'm',
		        'g',
		        't',
		        'p'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/thread_pool/<%=threadPoolPatterns%>',
		      req: {
		        threadPoolPatterns: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/thread_pool'
		    }
		  ]
		});
	
		/**
		 * Perform a [clearScroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.allocationExplain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-allocation-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeYesDecisions - Return 'YES' decisions in explanation (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDiskInfo - Return information about disk usage and shard sizes (default: false)
		 */
		api.cluster.prototype.allocationExplain = ca({
		  params: {
		    includeYesDecisions: {
		      type: 'boolean',
		      name: 'include_yes_decisions'
		    },
		    includeDiskInfo: {
		      type: 'boolean',
		      name: 'include_disk_info'
		    }
		  },
		  url: {
		    fmt: '/_cluster/allocation/explain'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default clusters setting.
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-string,`String`>>} params.waitForEvents - Wait until all currently queued events with the given priority are processed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForNoRelocatingShards - Whether to wait until there are no relocating shards in the cluster
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForEvents: {
		      type: 'enum',
		      options: [
		        'immediate',
		        'urgent',
		        'high',
		        'normal',
		        'low',
		        'languid'
		      ],
		      name: 'wait_for_events'
		    },
		    waitForNoRelocatingShards: {
		      type: 'boolean',
		      name: 'wait_for_no_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.retryFailed - Retries allocation of shards that are blocked due to too many subsequent allocation failures
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    retryFailed: {
		      type: 'boolean',
		      name: 'retry_failed'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_create',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the delete-by-query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the delete-by-query is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [deleteScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getSource](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilter - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filter - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - With `true`, outputs more advanced details. (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.attributes - A comma-separated list of token attributes to output, this parameter works only with `explain=true`
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilter: {
		      type: 'list',
		      name: 'char_filter'
		    },
		    field: {
		      type: 'string'
		    },
		    filter: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'list'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    attributes: {
		      type: 'list'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for before the operation returns.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_mapping/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=all] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'all',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preserveExisting - Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    preserveExisting: {
		      type: 'boolean',
		      name: 'preserve_existing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.rollover](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-rollover-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the newly created rollover index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.alias - The name of the alias to rollover
		 * @param {<<api-param-type-string,`String`>>} params.newIndex - The name of the rollover index
		 */
		api.indices.prototype.rollover = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=alias%>/_rollover/<%=newIndex%>',
		      req: {
		        alias: {
		          type: 'string'
		        },
		        newIndex: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=alias%>/_rollover',
		      req: {
		        alias: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shrink](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shrink-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the shrunken index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the source index to shrink
		 * @param {<<api-param-type-string,`String`>>} params.target - The name of the target index to shrink into
		 */
		api.indices.prototype.shrink = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_shrink/<%=target%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      target: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		api.ingest = namespace();
	
		/**
		 * Perform a [ingest.deletePipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.deletePipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [ingest.getPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.id - Comma separated list of pipeline ids. Wildcards supported
		 */
		api.ingest.prototype.getPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline'
		    }
		  ]
		});
	
		/**
		 * Perform a [ingest.putPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.putPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [ingest.simulate](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Verbose mode. Display data output for each processor in executed pipeline
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.simulate = ca({
		  params: {
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>/_simulate',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline/_simulate'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mget](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.maxConcurrentSearches - Controls the maximum number of concurrent searches the multi search api will execute
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    maxConcurrentSearches: {
		      type: 'number',
		      name: 'max_concurrent_searches'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearchTemplate = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch/template'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at index, node or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'indices',
		        'node',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.docvalueFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    docvalueFields: {
		      type: 'list',
		      name: 'docvalue_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.profile - Specify whether to profile the query execution
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    profile: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified task id (node_id:task_number)
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.get = ca({
		  params: {
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_tasks/<%=taskId%>',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [tasks.list](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.groupBy=nodes] - Group tasks by nodes or parent/child relationships
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    groupBy: {
		      type: 'enum',
		      'default': 'nodes',
		      options: [
		        'nodes',
		        'parents'
		      ],
		      name: 'group_by'
		    }
		  },
		  url: {
		    fmt: '/_tasks'
		  }
		});
	
		/**
		 * Perform a [termvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: painless)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the update by query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - Ingest pipeline to set on index requests made by this action. (default: none)
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the update by query operation is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    pipeline: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - Default list of fields to exclude from the returned _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - Default list of fields to extract and return from the _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-string,`String`>>} params.health - A health status ("green", "yellow", or "red" to filter only indices matching the specified health status
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    health: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ]
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Return the full node ID instead of the shortened version (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    fullId: {
		      type: 'boolean',
		      name: 'full_id'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/snapshots/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/snapshots'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.tasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-number,`Number`>>} params.parentTask - Return tasks with specified parent task id. Set to -1 to return all.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.tasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'number',
		      name: 'parent_task'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/tasks'
		  }
		});
	
		/**
		 * Perform a [cat.templates](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>} params.name - A pattern that returned template names must match
		 */
		api.cat.prototype.templates = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/templates/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/templates'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.threadPool](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.size - The multiplier in which to display values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.threadPoolPatterns - A comma-separated list of regular-expressions to filter the thread pools in the output
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    size: {
		      type: 'enum',
		      options: [
		        '',
		        'k',
		        'm',
		        'g',
		        't',
		        'p'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/thread_pool/<%=threadPoolPatterns%>',
		      req: {
		        threadPoolPatterns: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/thread_pool'
		    }
		  ]
		});
	
		/**
		 * Perform a [clearScroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.allocationExplain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-allocation-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeYesDecisions - Return 'YES' decisions in explanation (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDiskInfo - Return information about disk usage and shard sizes (default: false)
		 */
		api.cluster.prototype.allocationExplain = ca({
		  params: {
		    includeYesDecisions: {
		      type: 'boolean',
		      name: 'include_yes_decisions'
		    },
		    includeDiskInfo: {
		      type: 'boolean',
		      name: 'include_disk_info'
		    }
		  },
		  url: {
		    fmt: '/_cluster/allocation/explain'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default clusters setting.
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-string,`String`>>} params.waitForEvents - Wait until all currently queued events with the given priority are processed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForNoRelocatingShards - Whether to wait until there are no relocating shards in the cluster
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForEvents: {
		      type: 'enum',
		      options: [
		        'immediate',
		        'urgent',
		        'high',
		        'normal',
		        'low',
		        'languid'
		      ],
		      name: 'wait_for_events'
		    },
		    waitForNoRelocatingShards: {
		      type: 'boolean',
		      name: 'wait_for_no_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.retryFailed - Retries allocation of shards that are blocked due to too many subsequent allocation failures
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    retryFailed: {
		      type: 'boolean',
		      name: 'retry_failed'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_create',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the delete-by-query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the delete-by-query is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'integer',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [deleteScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getSource](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilter - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filter - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - With `true`, outputs more advanced details. (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.attributes - A comma-separated list of token attributes to output, this parameter works only with `explain=true`
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilter: {
		      type: 'list',
		      name: 'char_filter'
		    },
		    field: {
		      type: 'string'
		    },
		    filter: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'list'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    attributes: {
		      type: 'list'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for before the operation returns.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_mapping/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=all] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'all',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preserveExisting - Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    preserveExisting: {
		      type: 'boolean',
		      name: 'preserve_existing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.rollover](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-rollover-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the newly created rollover index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.alias - The name of the alias to rollover
		 * @param {<<api-param-type-string,`String`>>} params.newIndex - The name of the rollover index
		 */
		api.indices.prototype.rollover = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=alias%>/_rollover/<%=newIndex%>',
		      req: {
		        alias: {
		          type: 'string'
		        },
		        newIndex: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=alias%>/_rollover',
		      req: {
		        alias: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shrink](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shrink-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the shrunken index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the source index to shrink
		 * @param {<<api-param-type-string,`String`>>} params.target - The name of the target index to shrink into
		 */
		api.indices.prototype.shrink = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_shrink/<%=target%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      target: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		api.ingest = namespace();
	
		/**
		 * Perform a [ingest.deletePipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.deletePipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [ingest.getPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.id - Comma separated list of pipeline ids. Wildcards supported
		 */
		api.ingest.prototype.getPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline'
		    }
		  ]
		});
	
		/**
		 * Perform a [ingest.putPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.putPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [ingest.simulate](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Verbose mode. Display data output for each processor in executed pipeline
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.simulate = ca({
		  params: {
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>/_simulate',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline/_simulate'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mget](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.maxConcurrentSearches - Controls the maximum number of concurrent searches the multi search api will execute
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    maxConcurrentSearches: {
		      type: 'number',
		      name: 'max_concurrent_searches'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearchTemplate = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch/template'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at index, node or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'indices',
		        'node',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'integer',
		      'default': 1
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.docvalueFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    docvalueFields: {
		      type: 'list',
		      name: 'docvalue_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.profile - Specify whether to profile the query execution
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    profile: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified task id (node_id:task_number)
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.get = ca({
		  params: {
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_tasks/<%=taskId%>',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [tasks.list](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.groupBy=nodes] - Group tasks by nodes or parent/child relationships
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    groupBy: {
		      type: 'enum',
		      'default': 'nodes',
		      options: [
		        'nodes',
		        'parents'
		      ],
		      name: 'group_by'
		    }
		  },
		  url: {
		    fmt: '/_tasks'
		  }
		});
	
		/**
		 * Perform a [termvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: painless)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the update by query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - Ingest pipeline to set on index requests made by this action. (default: none)
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the update by query operation is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    pipeline: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'integer',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - Default list of fields to exclude from the returned _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - Default list of fields to extract and return from the _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-string,`String`>>} params.health - A health status ("green", "yellow", or "red" to filter only indices matching the specified health status
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    health: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ]
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Return the full node ID instead of the shortened version (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    fullId: {
		      type: 'boolean',
		      name: 'full_id'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/snapshots/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/snapshots'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.tasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-number,`Number`>>} params.parentTask - Return tasks with specified parent task id. Set to -1 to return all.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.tasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'number',
		      name: 'parent_task'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/tasks'
		  }
		});
	
		/**
		 * Perform a [cat.threadPool](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.size - The multiplier in which to display values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.threadPoolPatterns - A comma-separated list of regular-expressions to filter the thread pools in the output
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    size: {
		      type: 'enum',
		      options: [
		        '',
		        'k',
		        'm',
		        'g',
		        't',
		        'p'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/thread_pool/<%=threadPoolPatterns%>',
		      req: {
		        threadPoolPatterns: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/thread_pool'
		    }
		  ]
		});
	
		/**
		 * Perform a [clearScroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.allocationExplain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-allocation-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeYesDecisions - Return 'YES' decisions in explanation (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDiskInfo - Return information about disk usage and shard sizes (default: false)
		 */
		api.cluster.prototype.allocationExplain = ca({
		  params: {
		    includeYesDecisions: {
		      type: 'boolean',
		      name: 'include_yes_decisions'
		    },
		    includeDiskInfo: {
		      type: 'boolean',
		      name: 'include_disk_info'
		    }
		  },
		  url: {
		    fmt: '/_cluster/allocation/explain'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default clusters setting.
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-string,`String`>>} params.waitForEvents - Wait until all currently queued events with the given priority are processed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForNoRelocatingShards - Whether to wait until there are no relocating shards in the cluster
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForEvents: {
		      type: 'enum',
		      options: [
		        'immediate',
		        'urgent',
		        'high',
		        'normal',
		        'low',
		        'languid'
		      ],
		      name: 'wait_for_events'
		    },
		    waitForNoRelocatingShards: {
		      type: 'boolean',
		      name: 'wait_for_no_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.retryFailed - Retries allocation of shards that are blocked due to too many subsequent allocation failures
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    retryFailed: {
		      type: 'boolean',
		      name: 'retry_failed'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_create',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the delete-by-query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the delete-by-query is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means set no throttle as does "unlimited" which is the only non-float this accepts.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [deleteScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getSource](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilter - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filter - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - With `true`, outputs more advanced details. (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.attributes - A comma-separated list of token attributes to output, this parameter works only with `explain=true`
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilter: {
		      type: 'list',
		      name: 'char_filter'
		    },
		    field: {
		      type: 'string'
		    },
		    filter: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'list'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    attributes: {
		      type: 'list'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for before the operation returns.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_mapping/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=all] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'all',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preserveExisting - Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    preserveExisting: {
		      type: 'boolean',
		      name: 'preserve_existing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.rollover](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-rollover-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the newly created rollover index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.alias - The name of the alias to rollover
		 * @param {<<api-param-type-string,`String`>>} params.newIndex - The name of the rollover index
		 */
		api.indices.prototype.rollover = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=alias%>/_rollover/<%=newIndex%>',
		      req: {
		        alias: {
		          type: 'string'
		        },
		        newIndex: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=alias%>/_rollover',
		      req: {
		        alias: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shrink](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shrink-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the shrunken index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the source index to shrink
		 * @param {<<api-param-type-string,`String`>>} params.target - The name of the target index to shrink into
		 */
		api.indices.prototype.shrink = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_shrink/<%=target%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      target: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		api.ingest = namespace();
	
		/**
		 * Perform a [ingest.deletePipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.deletePipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [ingest.getPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.id - Comma separated list of pipeline ids. Wildcards supported
		 */
		api.ingest.prototype.getPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline'
		    }
		  ]
		});
	
		/**
		 * Perform a [ingest.putPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.putPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [ingest.simulate](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Verbose mode. Display data output for each processor in executed pipeline
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.simulate = ca({
		  params: {
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>/_simulate',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline/_simulate'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mget](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.maxConcurrentSearches - Controls the maximum number of concurrent searches the multi search api will execute
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    maxConcurrentSearches: {
		      type: 'number',
		      name: 'max_concurrent_searches'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearchTemplate = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch/template'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at index, node or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'indices',
		        'node',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means set no throttle as does "unlimited" which is the only non-float this accepts.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.docvalueFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    docvalueFields: {
		      type: 'list',
		      name: 'docvalue_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified task id (node_id:task_number)
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.get = ca({
		  params: {
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_tasks/<%=taskId%>',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [tasks.list](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.groupBy=nodes] - Group tasks by nodes or parent/child relationships
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    groupBy: {
		      type: 'enum',
		      'default': 'nodes',
		      options: [
		        'nodes',
		        'parents'
		      ],
		      name: 'group_by'
		    }
		  },
		  url: {
		    fmt: '/_tasks'
		  }
		});
	
		/**
		 * Perform a [termvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: groovy)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the update by query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - Ingest pipeline to set on index requests made by this action. (default: none)
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the update by query operation is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means set no throttle as does "unlimited" which is the only non-float this accepts.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    pipeline: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/snapshots/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [cat.threadPool](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Enables displaying the complete node ids
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fullId: {
		      type: 'boolean',
		      'default': false,
		      name: 'full_id'
		    }
		  },
		  url: {
		    fmt: '/_cat/thread_pool'
		  }
		});
	
		/**
		 * Perform a [clearScroll](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-number,`Number`>>} params.waitForRelocatingShards - Wait until the specified number of relocating shards is finished
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'number',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForRelocatingShards: {
		      type: 'number',
		      name: 'wait_for_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Specific write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteScript](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getSource](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the affected shards after performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilters - Deprecated : A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilter - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filters - Deprecated : A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filter - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - With `true`, outputs more advanced details. (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.attributes - A comma-separated list of token attributes to output, this parameter works only with `explain=true`
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilters: {
		      type: 'list',
		      name: 'char_filters'
		    },
		    charFilter: {
		      type: 'list',
		      name: 'char_filter'
		    },
		    field: {
		      type: 'string'
		    },
		    filters: {
		      type: 'list'
		    },
		    filter: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'list'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    attributes: {
		      type: 'list'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.delete](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteWarmer](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-warmers.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.
		 */
		api.indices.prototype.deleteWarmer = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    name: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_warmer/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_warmers',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAliases](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to filter
		 */
		api.indices.prototype.getAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_aliases/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_aliases',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return version and creation date values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getWarmer](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-warmers.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the warmer (supports wildcards); leave empty to get all warmers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.getWarmer = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_warmer',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_warmer/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_warmer'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.optimize](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-optimize.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.optimize = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_optimize',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_optimize'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putWarmer](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-warmers.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify whether the request to be warmed should use the request cache, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the warmer
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types
		 */
		api.indices.prototype.putWarmer = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_warmer/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.stats](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		/**
		 * Perform a [mget](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch',
		        'count',
		        'scan'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at node, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'node',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  params: {
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  params: {
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. 0 means set no throttle.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. 0 means set no throttle. As does "unlimited". Otherwise it must be a float.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/2.4/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the field data representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch',
		        'count',
		        'scan'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchExists](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.searchExists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/exists',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/exists',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/exists'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch',
		        'count',
		        'scan'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/tasks.html#_task_cancellation) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified id
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.list](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/tasks.html#_current_tasks_information) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks'
		    }
		  ]
		});
	
		/**
		 * Perform a [termvectors](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dfs - Specifies if distributed frequencies should be returned instead shard frequencies.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    dfs: {
		      type: 'boolean',
		      'default': false,
		      required: false
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: groovy)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.script - The URL-encoded script definition (instead of using request body)
		 * @param {<<api-param-type-string,`String`>>} params.scriptId - The id of a stored script
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.scriptedUpsert - True if the script referenced in script or script_id should be called to perform inserts - defaults to false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    fields: {
		      type: 'list'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    script: {
		      type: 'string'
		    },
		    scriptId: {
		      type: 'string',
		      name: 'script_id'
		    },
		    scriptedUpsert: {
		      type: 'boolean',
		      name: 'scripted_upsert'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the field data representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the reindex hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. 0 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](https://www.elastic.co/guide/en/elasticsearch/reference/2.4/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the affected shards after performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca.proxy(api.index, {
		  transform: function (params) {
		    params.op_type = 'create';
		  }
		});
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'nodes', 'snapshot'];
	
		/**
		 * Perform a [bulk](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} [params.replication=sync] - Explicitely set the replication type
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    replication: {
		      type: 'enum',
		      'default': 'sync',
		      options: [
		        'sync',
		        'async'
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.segments](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.v=true] - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': true
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.threadPool](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Enables displaying the complete node ids
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fullId: {
		      type: 'boolean',
		      'default': false,
		      name: 'full_id'
		    }
		  },
		  url: {
		    fmt: '/_cat/thread_pool'
		  }
		});
	
		/**
		 * Perform a [clearScroll](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-number,`Number`>>} params.waitForRelocatingShards - Wait until the specified number of relocating shards is finished
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'number',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForRelocatingShards: {
		      type: 'number',
		      name: 'wait_for_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Specific write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} [params.replication=sync] - Specific replication type
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    replication: {
		      type: 'enum',
		      'default': 'sync',
		      options: [
		        'sync',
		        'async'
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Specific write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} [params.replication=sync] - Specific replication type
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the operation
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    replication: {
		      type: 'enum',
		      'default': 'sync',
		      options: [
		        'sync',
		        'async'
		      ]
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteScript](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getSource](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  params: {
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} [params.replication=sync] - Specific replication type
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    replication: {
		      type: 'enum',
		      'default': 'sync',
		      options: [
		        'sync',
		        'async'
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilters - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filters - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilters: {
		      type: 'list',
		      name: 'char_filters'
		    },
		    field: {
		      type: 'string'
		    },
		    filters: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'string'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.filter - Clear filter caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.filterCache - Clear filter caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.filterKeys - A comma-separated list of keys to clear when using the `filter_cache` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.id - Clear ID caches for parent/child
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.idCache - Clear ID caches for parent/child
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.queryCache - Clear query cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    filter: {
		      type: 'boolean'
		    },
		    filterCache: {
		      type: 'boolean',
		      name: 'filter_cache'
		    },
		    filterKeys: {
		      type: 'boolean',
		      name: 'filter_keys'
		    },
		    id: {
		      type: 'boolean'
		    },
		    idCache: {
		      type: 'boolean',
		      name: 'id_cache'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    queryCache: {
		      type: 'boolean',
		      name: 'query_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.delete](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-delete-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to delete (supports wildcards); use `_all` to delete all document types in the specified indices.
		 */
		api.indices.prototype.deleteMapping = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/_mapping',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-warmers.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.
		 */
		api.indices.prototype.deleteWarmer = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    name: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_warmer/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 */
		api.indices.prototype.flushSynced = ca({
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAliases](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to filter
		 */
		api.indices.prototype.getAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_aliases/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_aliases',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.field - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=field%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        field: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=field%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        field: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=field%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        field: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=field%>',
		      req: {
		        field: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-warmers.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the warmer (supports wildcards); leave empty to get all warmers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.getWarmer = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_warmer',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_warmer/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_warmer'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.optimize](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-optimize.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a merge operation to run, even if there is a single segment in the index (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.optimize = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    },
		    force: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_optimize',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_optimize'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreConflicts - Specify whether to ignore conflicts while updating the mapping (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    ignoreConflicts: {
		      type: 'boolean',
		      name: 'ignore_conflicts'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-warmers.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the warmer
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types
		 */
		api.indices.prototype.putWarmer = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_warmer/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_warmer/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.stats](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'filter_cache',
		            'flush',
		            'get',
		            'id_cache',
		            'indexing',
		            'merge',
		            'percolate',
		            'query_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'filter_cache',
		            'flush',
		            'get',
		            'id_cache',
		            'indexing',
		            'merge',
		            'percolate',
		            'query_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.status](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-status.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recovery - Return information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.snapshot - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.status = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    recovery: {
		      type: 'boolean'
		    },
		    snapshot: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_status',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](http://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		/**
		 * Perform a [mget](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mlt](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-more-like-this.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.boostTerms - The boost factor
		 * @param {<<api-param-type-number,`Number`>>} params.maxDocFreq - The word occurrence frequency as count: words with higher occurrence in the corpus will be ignored
		 * @param {<<api-param-type-number,`Number`>>} params.maxQueryTerms - The maximum query terms to be included in the generated query
		 * @param {<<api-param-type-number,`Number`>>} params.maxWordLength - The minimum length of the word: longer words will be ignored
		 * @param {<<api-param-type-number,`Number`>>} params.minDocFreq - The word occurrence frequency as count: words with lower occurrence in the corpus will be ignored
		 * @param {<<api-param-type-number,`Number`>>} params.minTermFreq - The term frequency as percent: terms with lower occurence in the source document will be ignored
		 * @param {<<api-param-type-number,`Number`>>} params.minWordLength - The minimum length of the word: shorter words will be ignored
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.mltFields - Specific fields to perform the query against
		 * @param {<<api-param-type-number,`Number`>>} params.percentTermsToMatch - How many terms have to match in order to consider the document a match (default: 0.3)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-number,`Number`>>} params.searchFrom - The offset from which to return results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.searchIndices - A comma-separated list of indices to perform the query against (default: the index containing the document)
		 * @param {<<api-param-type-string,`String`>>} params.searchScroll - A scroll search request definition
		 * @param {<<api-param-type-number,`Number`>>} params.searchSize - The number of documents to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>} params.searchSource - A specific search request definition (instead of using the request body)
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Specific search type (eg. `dfs_then_fetch`, `count`, etc)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.searchTypes - A comma-separated list of types to perform the query against (default: the same type as the document)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stopWords - A list of stop words to be ignored
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.mlt = ca({
		  params: {
		    boostTerms: {
		      type: 'number',
		      name: 'boost_terms'
		    },
		    maxDocFreq: {
		      type: 'number',
		      name: 'max_doc_freq'
		    },
		    maxQueryTerms: {
		      type: 'number',
		      name: 'max_query_terms'
		    },
		    maxWordLength: {
		      type: 'number',
		      name: 'max_word_length'
		    },
		    minDocFreq: {
		      type: 'number',
		      name: 'min_doc_freq'
		    },
		    minTermFreq: {
		      type: 'number',
		      name: 'min_term_freq'
		    },
		    minWordLength: {
		      type: 'number',
		      name: 'min_word_length'
		    },
		    mltFields: {
		      type: 'list',
		      name: 'mlt_fields'
		    },
		    percentTermsToMatch: {
		      type: 'number',
		      name: 'percent_terms_to_match'
		    },
		    routing: {
		      type: 'string'
		    },
		    searchFrom: {
		      type: 'number',
		      name: 'search_from'
		    },
		    searchIndices: {
		      type: 'list',
		      name: 'search_indices'
		    },
		    searchScroll: {
		      type: 'string',
		      name: 'search_scroll'
		    },
		    searchSize: {
		      type: 'number',
		      name: 'search_size'
		    },
		    searchSource: {
		      type: 'string',
		      name: 'search_source'
		    },
		    searchType: {
		      type: 'string',
		      name: 'search_type'
		    },
		    searchTypes: {
		      type: 'list',
		      name: 'search_types'
		    },
		    stopWords: {
		      type: 'list',
		      name: 'stop_words'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_mlt',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch',
		        'count',
		        'scan'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'network',
		            'transport',
		            'http',
		            'plugins'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'network',
		            'transport',
		            'http',
		            'plugins'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.shutdown](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-shutdown.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.delay - Set the delay for the operation (default: 1s)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.exit - Exit the JVM as well (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to perform the operation on; use `_local` to perform the operation on the node you're connected to, leave empty to perform the operation on all nodes
		 */
		api.nodes.prototype.shutdown = ca({
		  params: {
		    delay: {
		      type: 'time'
		    },
		    exit: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/nodes/<%=nodeId%>/_shutdown',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shutdown'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [nodes.stats](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.human - Whether to return time and byte values in human-readable format.
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at node, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    human: {
		      type: 'boolean',
		      'default': false
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'node',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'network',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'filter_cache',
		            'flush',
		            'get',
		            'id_cache',
		            'indexing',
		            'merge',
		            'percolate',
		            'query_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'network',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'network',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'filter_cache',
		            'flush',
		            'get',
		            'id_cache',
		            'indexing',
		            'merge',
		            'percolate',
		            'query_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'network',
		            'os',
		            'process',
		            'thread_pool',
		            'transport'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](http://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  params: {
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_scripts/<%=lang%>/<%=id%>',
		    req: {
		      lang: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  params: {
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [scroll](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the field data representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.queryCache - Specify if query cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch',
		        'count',
		        'scan'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    queryCache: {
		      type: 'boolean',
		      name: 'query_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchExists](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/search-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.searchExists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    lowercaseExpandedTerms: {
		      type: 'boolean',
		      name: 'lowercase_expanded_terms'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/exists',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/exists',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/exists'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch',
		        'count',
		        'scan'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.7/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [termvector](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document.
		 */
		api.termvector = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvector',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvector',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: groovy)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} [params.replication=sync] - Specific replication type
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.script - The URL-encoded script definition (instead of using request body)
		 * @param {<<api-param-type-string,`String`>>} params.scriptId - The id of a stored script
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.scriptedUpsert - True if the script referenced in script or script_id should be called to perform inserts - defaults to false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    consistency: {
		      type: 'enum',
		      options: [
		        'one',
		        'quorum',
		        'all'
		      ]
		    },
		    fields: {
		      type: 'list'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    replication: {
		      type: 'enum',
		      'default': 'sync',
		      options: [
		        'sync',
		        'async'
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    script: {
		      type: 'string'
		    },
		    scriptId: {
		      type: 'string',
		      name: 'script_id'
		    },
		    scriptedUpsert: {
		      type: 'boolean',
		      name: 'scripted_upsert'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.consistency - Explicit write consistency setting for the operation
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the index after performing the operation
		 * @param {<<api-param-type-string,`String`>>} [params.replication=sync] - Specific replication type
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca.proxy(api.index, {
		  transform: function (params) {
		    params.op_type = 'create';
		  }
		});
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - Default list of fields to exclude from the returned _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - Default list of fields to extract and return from the _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-string,`String`>>} params.health - A health status ("green", "yellow", or "red" to filter only indices matching the specified health status
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    health: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ]
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Return the full node ID instead of the shortened version (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    fullId: {
		      type: 'boolean',
		      name: 'full_id'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/snapshots/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/snapshots'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.tasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-number,`Number`>>} params.parentTask - Return tasks with specified parent task id. Set to -1 to return all.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.tasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'number',
		      name: 'parent_task'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/tasks'
		  }
		});
	
		/**
		 * Perform a [cat.templates](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>} params.name - A pattern that returned template names must match
		 */
		api.cat.prototype.templates = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/templates/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/templates'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.threadPool](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.size - The multiplier in which to display values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.threadPoolPatterns - A comma-separated list of regular-expressions to filter the thread pools in the output
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    size: {
		      type: 'enum',
		      options: [
		        '',
		        'k',
		        'm',
		        'g',
		        't',
		        'p'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/thread_pool/<%=threadPoolPatterns%>',
		      req: {
		        threadPoolPatterns: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/thread_pool'
		    }
		  ]
		});
	
		/**
		 * Perform a [clearScroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: {
		    param: 'scrollId',
		    body: 'scroll_id'
		  },
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.allocationExplain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-allocation-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeYesDecisions - Return 'YES' decisions in explanation (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDiskInfo - Return information about disk usage and shard sizes (default: false)
		 */
		api.cluster.prototype.allocationExplain = ca({
		  params: {
		    includeYesDecisions: {
		      type: 'boolean',
		      name: 'include_yes_decisions'
		    },
		    includeDiskInfo: {
		      type: 'boolean',
		      name: 'include_disk_info'
		    }
		  },
		  url: {
		    fmt: '/_cluster/allocation/explain'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default clusters setting.
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-string,`String`>>} params.waitForEvents - Wait until all currently queued events with the given priority are processed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForNoRelocatingShards - Whether to wait until there are no relocating shards in the cluster
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForEvents: {
		      type: 'enum',
		      options: [
		        'immediate',
		        'urgent',
		        'high',
		        'normal',
		        'low',
		        'languid'
		      ],
		      name: 'wait_for_events'
		    },
		    waitForNoRelocatingShards: {
		      type: 'boolean',
		      name: 'wait_for_no_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.retryFailed - Retries allocation of shards that are blocked due to too many subsequent allocation failures
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    retryFailed: {
		      type: 'boolean',
		      name: 'retry_failed'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_create',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the delete-by-query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the delete-by-query is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [deleteScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [getSource](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilter - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filter - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - With `true`, outputs more advanced details. (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.attributes - A comma-separated list of token attributes to output, this parameter works only with `explain=true`
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilter: {
		      type: 'list',
		      name: 'char_filter'
		    },
		    field: {
		      type: 'string'
		    },
		    filter: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'list'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    attributes: {
		      type: 'list'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for before the operation returns.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_mapping/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=all] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'all',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preserveExisting - Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    preserveExisting: {
		      type: 'boolean',
		      name: 'preserve_existing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.rollover](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-rollover-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the newly created rollover index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.alias - The name of the alias to rollover
		 * @param {<<api-param-type-string,`String`>>} params.newIndex - The name of the rollover index
		 */
		api.indices.prototype.rollover = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=alias%>/_rollover/<%=newIndex%>',
		      req: {
		        alias: {
		          type: 'string'
		        },
		        newIndex: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=alias%>/_rollover',
		      req: {
		        alias: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shrink](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shrink-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the shrunken index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the source index to shrink
		 * @param {<<api-param-type-string,`String`>>} params.target - The name of the target index to shrink into
		 */
		api.indices.prototype.shrink = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_shrink/<%=target%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      target: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		api.ingest = namespace();
	
		/**
		 * Perform a [ingest.deletePipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.deletePipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [ingest.getPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.id - Comma separated list of pipeline ids. Wildcards supported
		 */
		api.ingest.prototype.getPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline'
		    }
		  ]
		});
	
		/**
		 * Perform a [ingest.putPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.putPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [ingest.simulate](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Verbose mode. Display data output for each processor in executed pipeline
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.simulate = ca({
		  params: {
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>/_simulate',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline/_simulate'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mget](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.maxConcurrentSearches - Controls the maximum number of concurrent searches the multi search api will execute
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    maxConcurrentSearches: {
		      type: 'number',
		      name: 'max_concurrent_searches'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearchTemplate = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch/template'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at index, node or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'indices',
		        'node',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: {
		    param: 'scrollId',
		    body: 'scroll_id'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.docvalueFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    docvalueFields: {
		      type: 'list',
		      name: 'docvalue_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.profile - Specify whether to profile the query execution
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    profile: {
		      type: 'boolean'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified task id (node_id:task_number)
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.get = ca({
		  params: {
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_tasks/<%=taskId%>',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [tasks.list](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.groupBy=nodes] - Group tasks by nodes or parent/child relationships
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    groupBy: {
		      type: 'enum',
		      'default': 'nodes',
		      options: [
		        'nodes',
		        'parents'
		      ],
		      name: 'group_by'
		    }
		  },
		  url: {
		    fmt: '/_tasks'
		  }
		});
	
		/**
		 * Perform a [termvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: painless)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the update by query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - Ingest pipeline to set on index requests made by this action. (default: none)
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the update by query operation is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    pipeline: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - Default list of fields to exclude from the returned _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - Default list of fields to extract and return from the _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-string,`String`>>} params.health - A health status ("green", "yellow", or "red" to filter only indices matching the specified health status
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    health: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ]
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Return the full node ID instead of the shortened version (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    fullId: {
		      type: 'boolean',
		      name: 'full_id'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/snapshots/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/snapshots'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.tasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-number,`Number`>>} params.parentTask - Return tasks with specified parent task id. Set to -1 to return all.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.tasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'number',
		      name: 'parent_task'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/tasks'
		  }
		});
	
		/**
		 * Perform a [cat.templates](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>} params.name - A pattern that returned template names must match
		 */
		api.cat.prototype.templates = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/templates/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/templates'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.threadPool](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.size - The multiplier in which to display values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.threadPoolPatterns - A comma-separated list of regular-expressions to filter the thread pools in the output
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    size: {
		      type: 'enum',
		      options: [
		        '',
		        'k',
		        'm',
		        'g',
		        't',
		        'p'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/thread_pool/<%=threadPoolPatterns%>',
		      req: {
		        threadPoolPatterns: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/thread_pool'
		    }
		  ]
		});
	
		/**
		 * Perform a [clearScroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: {
		    param: 'scrollId',
		    body: 'scroll_id'
		  },
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.allocationExplain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-allocation-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeYesDecisions - Return 'YES' decisions in explanation (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDiskInfo - Return information about disk usage and shard sizes (default: false)
		 */
		api.cluster.prototype.allocationExplain = ca({
		  params: {
		    includeYesDecisions: {
		      type: 'boolean',
		      name: 'include_yes_decisions'
		    },
		    includeDiskInfo: {
		      type: 'boolean',
		      name: 'include_disk_info'
		    }
		  },
		  url: {
		    fmt: '/_cluster/allocation/explain'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default clusters setting.
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-string,`String`>>} params.waitForEvents - Wait until all currently queued events with the given priority are processed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForNoRelocatingShards - Whether to wait until there are no relocating shards in the cluster
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForEvents: {
		      type: 'enum',
		      options: [
		        'immediate',
		        'urgent',
		        'high',
		        'normal',
		        'low',
		        'languid'
		      ],
		      name: 'wait_for_events'
		    },
		    waitForNoRelocatingShards: {
		      type: 'boolean',
		      name: 'wait_for_no_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.retryFailed - Retries allocation of shards that are blocked due to too many subsequent allocation failures
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    retryFailed: {
		      type: 'boolean',
		      name: 'retry_failed'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [countPercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to count percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to count percolate document into. Defaults to type.
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being count percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.countPercolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate/count',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_create',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the delete-by-query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the delete-by-query is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [deleteScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [getSource](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The name of the analyzer to use
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.charFilter - A comma-separated list of character filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.filter - A comma-separated list of filters to use for the analysis
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.text - The text on which the analysis should be performed (when request body is not used)
		 * @param {<<api-param-type-string,`String`>>} params.tokenizer - The name of the tokenizer to use for the analysis
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - With `true`, outputs more advanced details. (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.attributes - A comma-separated list of token attributes to output, this parameter works only with `explain=true`
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    charFilter: {
		      type: 'list',
		      name: 'char_filter'
		    },
		    field: {
		      type: 'string'
		    },
		    filter: {
		      type: 'list'
		    },
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    text: {
		      type: 'list'
		    },
		    tokenizer: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    attributes: {
		      type: 'list'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for before the operation returns.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_mapping/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=all] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'all',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preserveExisting - Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    preserveExisting: {
		      type: 'boolean',
		      name: 'preserve_existing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.rollover](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-rollover-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the newly created rollover index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.alias - The name of the alias to rollover
		 * @param {<<api-param-type-string,`String`>>} params.newIndex - The name of the rollover index
		 */
		api.indices.prototype.rollover = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=alias%>/_rollover/<%=newIndex%>',
		      req: {
		        alias: {
		          type: 'string'
		        },
		        newIndex: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=alias%>/_rollover',
		      req: {
		        alias: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shrink](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-shrink-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the shrunken index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the source index to shrink
		 * @param {<<api-param-type-string,`String`>>} params.target - The name of the target index to shrink into
		 */
		api.indices.prototype.shrink = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_shrink/<%=target%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      target: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		api.ingest = namespace();
	
		/**
		 * Perform a [ingest.deletePipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.deletePipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [ingest.getPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.id - Comma separated list of pipeline ids. Wildcards supported
		 */
		api.ingest.prototype.getPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline'
		    }
		  ]
		});
	
		/**
		 * Perform a [ingest.putPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.putPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [ingest.simulate](https://www.elastic.co/guide/en/elasticsearch/plugins/5.x/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Verbose mode. Display data output for each processor in executed pipeline
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.simulate = ca({
		  params: {
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>/_simulate',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline/_simulate'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mget](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mpercolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being count percolated to use as default
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated to use as default.
		 */
		api.mpercolate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mpercolate',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mpercolate'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.maxConcurrentSearches - Controls the maximum number of concurrent searches the multi search api will execute
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    maxConcurrentSearches: {
		      type: 'number',
		      name: 'max_concurrent_searches'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearchTemplate = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch/template'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at index, node or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'indices',
		        'node',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'percolate',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [percolate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-percolate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.percolateIndex - The index to percolate the document into. Defaults to index.
		 * @param {<<api-param-type-string,`String`>>} params.percolateType - The type to percolate document into. Defaults to type.
		 * @param {<<api-param-type-string,`String`>>} params.percolateRouting - The routing value to use when percolating the existing document.
		 * @param {<<api-param-type-string,`String`>>} params.percolatePreference - Which shard to prefer when executing the percolate request.
		 * @param {<<api-param-type-string,`String`>>} params.percolateFormat - Return an array of matching query IDs instead of objects
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document being percolated.
		 * @param {<<api-param-type-string,`String`>>} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
		 */
		api.percolate = ca({
		  params: {
		    routing: {
		      type: 'list'
		    },
		    preference: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    percolateIndex: {
		      type: 'string',
		      name: 'percolate_index'
		    },
		    percolateType: {
		      type: 'string',
		      name: 'percolate_type'
		    },
		    percolateRouting: {
		      type: 'string',
		      name: 'percolate_routing'
		    },
		    percolatePreference: {
		      type: 'string',
		      name: 'percolate_preference'
		    },
		    percolateFormat: {
		      type: 'enum',
		      options: [
		        'ids'
		      ],
		      name: 'percolate_format'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_percolate',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [ping](https://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/5.x/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: {
		    param: 'scrollId',
		    body: 'scroll_id'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.docvalueFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    docvalueFields: {
		      type: 'list',
		      name: 'docvalue_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.profile - Specify whether to profile the query execution
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    profile: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [suggest](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/search-suggesters.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 */
		api.suggest = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_suggest',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_suggest'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified task id (node_id:task_number)
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.get](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.get = ca({
		  params: {
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_tasks/<%=taskId%>',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [tasks.list](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.groupBy=nodes] - Group tasks by nodes or parent/child relationships
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    groupBy: {
		      type: 'enum',
		      'default': 'nodes',
		      options: [
		        'nodes',
		        'parents'
		      ],
		      name: 'group_by'
		    }
		  },
		  url: {
		    fmt: '/_tasks'
		  }
		});
	
		/**
		 * Perform a [termvectors](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: painless)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the update by query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - Ingest pipeline to set on index requests made by this action. (default: none)
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the update by query operation is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    pipeline: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ca = __webpack_require__(46).makeFactoryWithModifier(function (spec) {
		  return __webpack_require__(3).merge(spec, {
		    params: {
		      filterPath: {
		        type: 'list',
		        name: 'filter_path'
		      }
		    }
		  });
		});
		var namespace = __webpack_require__(46).namespaceFactory;
		var api = module.exports = {};
	
		api._namespaces = ['cat', 'cluster', 'indices', 'ingest', 'nodes', 'snapshot', 'tasks'];
	
		/**
		 * Perform a [bulk](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.type - Default document type for items which don't provide one
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - Default list of fields to exclude from the returned _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - Default list of fields to extract and return from the _source field, can be overridden on each sub-request
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.index - Default index for items which don't provide one
		 */
		api.bulk = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    type: {
		      type: 'string'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_bulk',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_bulk'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		api.cat = namespace();
	
		/**
		 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.cat.prototype.aliases = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/aliases/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/aliases'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.allocation](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
		 */
		api.cat.prototype.allocation = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/allocation/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/allocation'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.count](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.count = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/count/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/count'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.fielddata](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return the fielddata size
		 */
		api.cat.prototype.fielddata = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    },
		    fields: {
		      type: 'list'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/fielddata/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/fielddata'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.health](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.ts=true] - Set to false to disable timestamping
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.health = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    ts: {
		      type: 'boolean',
		      'default': true
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/health'
		  }
		});
	
		/**
		 * Perform a [cat.help](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 */
		api.cat.prototype.help = ca({
		  params: {
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    }
		  },
		  url: {
		    fmt: '/_cat'
		  }
		});
	
		/**
		 * Perform a [cat.indices](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-string,`String`>>} params.health - A health status ("green", "yellow", or "red" to filter only indices matching the specified health status
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.pri - Set to true to return stats only for primary shards
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.indices = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'm',
		        'g'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    health: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ]
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    pri: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/indices/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/indices'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.master](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.master = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/master'
		  }
		});
	
		/**
		 * Perform a [cat.nodeattrs](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodeattrs = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodeattrs'
		  }
		});
	
		/**
		 * Perform a [cat.nodes](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fullId - Return the full node ID instead of the shortened version (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.nodes = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    fullId: {
		      type: 'boolean',
		      name: 'full_id'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/nodes'
		  }
		});
	
		/**
		 * Perform a [cat.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.pendingTasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cat.plugins](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.plugins = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/plugins'
		  }
		});
	
		/**
		 * Perform a [cat.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.bytes - The unit in which to display byte values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.recovery = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    bytes: {
		      type: 'enum',
		      options: [
		        'b',
		        'k',
		        'kb',
		        'm',
		        'mb',
		        'g',
		        'gb',
		        't',
		        'tb',
		        'p',
		        'pb'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/recovery/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.repositories](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-repositories.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.repositories = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean',
		      'default': false
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/repositories'
		  }
		});
	
		/**
		 * Perform a [cat.segments](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.segments = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/segments/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.shards](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to limit the returned information
		 */
		api.cat.prototype.shards = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/shards/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/shards'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.snapshots](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Set to true to ignore unavailable snapshots
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - Name of repository from which to fetch the snapshot information
		 */
		api.cat.prototype.snapshots = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      'default': false,
		      name: 'ignore_unavailable'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/snapshots/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/snapshots'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.tasks](http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-number,`Number`>>} params.parentTask - Return tasks with specified parent task id. Set to -1 to return all.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 */
		api.cat.prototype.tasks = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'number',
		      name: 'parent_task'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  url: {
		    fmt: '/_cat/tasks'
		  }
		});
	
		/**
		 * Perform a [cat.templates](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>} params.name - A pattern that returned template names must match
		 */
		api.cat.prototype.templates = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/templates/<%=name%>',
		      req: {
		        name: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/templates'
		    }
		  ]
		});
	
		/**
		 * Perform a [cat.threadPool](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.format - a short version of the Accept header, e.g. json, yaml
		 * @param {<<api-param-type-string,`String`>>} params.size - The multiplier in which to display values
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.h - Comma-separated list of column names to display
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.help - Return help information
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.s - Comma-separated list of column names or column aliases to sort by
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.v - Verbose mode. Display column headers
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.threadPoolPatterns - A comma-separated list of regular-expressions to filter the thread pools in the output
		 */
		api.cat.prototype.threadPool = ca({
		  params: {
		    format: {
		      type: 'string'
		    },
		    size: {
		      type: 'enum',
		      options: [
		        '',
		        'k',
		        'm',
		        'g',
		        't',
		        'p'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    h: {
		      type: 'list'
		    },
		    help: {
		      type: 'boolean',
		      'default': false
		    },
		    s: {
		      type: 'list'
		    },
		    v: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cat/thread_pool/<%=threadPoolPatterns%>',
		      req: {
		        threadPoolPatterns: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cat/thread_pool'
		    }
		  ]
		});
	
		/**
		 * Perform a [clearScroll](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.scrollId - A comma-separated list of scroll IDs to clear
		 */
		api.clearScroll = ca({
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'DELETE'
		});
	
		api.cluster = namespace();
	
		/**
		 * Perform a [cluster.allocationExplain](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-allocation-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeYesDecisions - Return 'YES' decisions in explanation (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDiskInfo - Return information about disk usage and shard sizes (default: false)
		 */
		api.cluster.prototype.allocationExplain = ca({
		  params: {
		    includeYesDecisions: {
		      type: 'boolean',
		      name: 'include_yes_decisions'
		    },
		    includeDiskInfo: {
		      type: 'boolean',
		      name: 'include_disk_info'
		    }
		  },
		  url: {
		    fmt: '/_cluster/allocation/explain'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default clusters setting.
		 */
		api.cluster.prototype.getSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  }
		});
	
		/**
		 * Perform a [cluster.health](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Specify the level of detail for returned information
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Wait until the specified number of shards is active
		 * @param {<<api-param-type-string,`String`>>} params.waitForNodes - Wait until the specified number of nodes is available
		 * @param {<<api-param-type-string,`String`>>} params.waitForEvents - Wait until all currently queued events with the given priority are processed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForNoRelocatingShards - Whether to wait until there are no relocating shards in the cluster
		 * @param {<<api-param-type-string,`String`>>} params.waitForStatus - Wait until cluster is in a specific state
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - Limit the information returned to a specific index
		 */
		api.cluster.prototype.health = ca({
		  params: {
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForNodes: {
		      type: 'string',
		      name: 'wait_for_nodes'
		    },
		    waitForEvents: {
		      type: 'enum',
		      options: [
		        'immediate',
		        'urgent',
		        'high',
		        'normal',
		        'low',
		        'languid'
		      ],
		      name: 'wait_for_events'
		    },
		    waitForNoRelocatingShards: {
		      type: 'boolean',
		      name: 'wait_for_no_relocating_shards'
		    },
		    waitForStatus: {
		      type: 'enum',
		      'default': null,
		      options: [
		        'green',
		        'yellow',
		        'red'
		      ],
		      name: 'wait_for_status'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/health/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/health'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.cluster.prototype.pendingTasks = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_cluster/pending_tasks'
		  }
		});
	
		/**
		 * Perform a [cluster.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.putSettings = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/settings'
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [cluster.reroute](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - Simulate the operation only and return the resulting state
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return an explanation of why the commands can or cannot be executed
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.retryFailed - Retries allocation of shards that are blocked due to too many subsequent allocation failures
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 */
		api.cluster.prototype.reroute = ca({
		  params: {
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    retryFailed: {
		      type: 'boolean',
		      name: 'retry_failed'
		    },
		    metric: {
		      type: 'list',
		      options: [
		        '_all',
		        'blocks',
		        'metadata',
		        'nodes',
		        'routing_table',
		        'master_node',
		        'version'
		      ]
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_cluster/reroute'
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [cluster.state](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 */
		api.cluster.prototype.state = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        },
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'blocks',
		            'metadata',
		            'nodes',
		            'routing_table',
		            'routing_nodes',
		            'master_node',
		            'version'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/state'
		    }
		  ]
		});
	
		/**
		 * Perform a [cluster.stats](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.cluster.prototype.stats = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cluster/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [count](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.minScore - Include only documents with a specific `_score` value in the result
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to restrict the results
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of types to restrict the results
		 */
		api.count = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    minScore: {
		      type: 'number',
		      name: 'min_score'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_count',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_count'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [create](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_create',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [delete](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api['delete'] = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the delete-by-query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the delete-by-query is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle for this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.deleteByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_delete_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [deleteScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.deleteScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.deleteTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [exists](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.exists = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [explain](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer for the query string query
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The default field for query string query (default: _all)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.explain = ca({
		  params: {
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [fieldStats](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
		 * @param {<<api-param-type-string,`String`>>} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.fieldStats = ca({
		  params: {
		    fields: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'cluster',
		      options: [
		        'indices',
		        'cluster'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_field_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_field_stats'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [get](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
		 */
		api.get = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.getScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [getSource](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.parent - The ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - The document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
		 */
		api.getSource = ca({
		  params: {
		    parent: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.getTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [index](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>} [params.opType=index] - Explicit operation type
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - The pipeline id to preprocess incoming documents with
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.index = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    opType: {
		      type: 'enum',
		      'default': 'index',
		      options: [
		        'index',
		        'create'
		      ],
		      name: 'op_type'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    },
		    pipeline: {
		      type: 'string'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		api.indices = namespace();
	
		/**
		 * Perform a [indices.analyze](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index to scope the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
		 * @param {<<api-param-type-string,`String`>>} [params.format=detailed] - Format of the output
		 */
		api.indices.prototype.analyze = ca({
		  params: {
		    index: {
		      type: 'string'
		    },
		    preferLocal: {
		      type: 'boolean',
		      name: 'prefer_local'
		    },
		    format: {
		      type: 'enum',
		      'default': 'detailed',
		      options: [
		        'detailed',
		        'text'
		      ]
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_analyze',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_analyze'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.clearCache](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fieldData - Clear field data
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.fielddata - Clear field data
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.query - Clear query caches
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index name to limit the operation
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.recycler - Clear the recycler cache
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.request - Clear request cache
		 */
		api.indices.prototype.clearCache = ca({
		  params: {
		    fieldData: {
		      type: 'boolean',
		      name: 'field_data'
		    },
		    fielddata: {
		      type: 'boolean'
		    },
		    fields: {
		      type: 'list'
		    },
		    query: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    index: {
		      type: 'list'
		    },
		    recycler: {
		      type: 'boolean'
		    },
		    request: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_cache/clear',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_cache/clear'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.close](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to close
		 */
		api.indices.prototype.close = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_close',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.create](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for before the operation returns.
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 */
		api.indices.prototype.create = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.delete](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
		 */
		api.indices.prototype['delete'] = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
		 */
		api.indices.prototype.deleteAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.deleteTemplate = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [indices.exists](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of indices to check
		 */
		api.indices.prototype.exists = ca({
		  params: {
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.existsAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.existsTemplate = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.existsType](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to check
		 */
		api.indices.prototype.existsType = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_mapping/<%=type%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      type: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [indices.flush](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flush = ca({
		  params: {
		    force: {
		      type: 'boolean'
		    },
		    waitIfOngoing: {
		      type: 'boolean',
		      name: 'wait_if_ongoing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.flushSynced](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
		 */
		api.indices.prototype.flushSynced = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_flush/synced',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_flush/synced'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.forcemerge](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-number,`Number`>>} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.forcemerge = ca({
		  params: {
		    flush: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    maxNumSegments: {
		      type: 'number',
		      name: 'max_num_segments'
		    },
		    onlyExpungeDeletes: {
		      type: 'boolean',
		      name: 'only_expunge_deletes'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    waitForMerge: {
		      type: 'boolean',
		      name: 'wait_for_merge'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_forcemerge',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_forcemerge'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.get](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.feature - A comma-separated list of features
		 */
		api.indices.prototype.get = ca({
		  params: {
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=feature%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        feature: {
		          type: 'list',
		          options: [
		            '_settings',
		            '_mappings',
		            '_aliases'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=all] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to filter aliases
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - A comma-separated list of alias names to return
		 */
		api.indices.prototype.getAlias = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'all',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_alias/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_alias',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_alias'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getFieldMapping](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether the default mapping values should be returned as well
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields
		 */
		api.indices.prototype.getFieldMapping = ca({
		  params: {
		    includeDefaults: {
		      type: 'boolean',
		      name: 'include_defaults'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping/field/<%=fields%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>/field/<%=fields%>',
		      req: {
		        type: {
		          type: 'list'
		        },
		        fields: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/field/<%=fields%>',
		      req: {
		        fields: {
		          type: 'list'
		        }
		      }
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getMapping](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types
		 */
		api.indices.prototype.getMapping = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mapping',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeDefaults - Whether to return all default setting for each of the indices.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The name of the settings that should be included
		 */
		api.indices.prototype.getSettings = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': [
		        'open',
		        'closed'
		      ],
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    local: {
		      type: 'boolean'
		    },
		    includeDefaults: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_defaults'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings/<%=name%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.name - The comma separated names of the index templates
		 */
		api.indices.prototype.getTemplate = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_template/<%=name%>',
		      req: {
		        name: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_template'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.getUpgrade](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.getUpgrade = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.open](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma separated list of indices to open
		 */
		api.indices.prototype.open = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'closed',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_open',
		    req: {
		      index: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.putAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the alias to be created or updated
		 */
		api.indices.prototype.putAlias = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_alias/<%=name%>',
		    req: {
		      index: {
		        type: 'list'
		      },
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putMapping](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
		 * @param {<<api-param-type-string,`String`>>} params.type - The name of the document type
		 */
		api.indices.prototype.putMapping = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    updateAllTypes: {
		      type: 'boolean',
		      name: 'update_all_types'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_mapping/<%=type%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mapping/<%=type%>',
		      req: {
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.preserveExisting - Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.putSettings = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    preserveExisting: {
		      type: 'boolean',
		      name: 'preserve_existing'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_settings',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_settings'
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.create - Whether the index template should only be added if new or can also replace an existing one
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.name - The name of the template
		 */
		api.indices.prototype.putTemplate = ca({
		  params: {
		    order: {
		      type: 'number'
		    },
		    create: {
		      type: 'boolean',
		      'default': false
		    },
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    }
		  },
		  url: {
		    fmt: '/_template/<%=name%>',
		    req: {
		      name: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [indices.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Whether to display detailed information about shard recovery
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.activeOnly - Display only those recoveries that are currently on-going
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.recovery = ca({
		  params: {
		    detailed: {
		      type: 'boolean',
		      'default': false
		    },
		    activeOnly: {
		      type: 'boolean',
		      'default': false,
		      name: 'active_only'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_recovery',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_recovery'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.refresh](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.force - Force a refresh even if not required
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.refresh = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    force: {
		      type: 'boolean',
		      'default': false
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_refresh',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_refresh'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.rollover](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.dryRun - If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the newly created rollover index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.alias - The name of the alias to rollover
		 * @param {<<api-param-type-string,`String`>>} params.newIndex - The name of the rollover index
		 */
		api.indices.prototype.rollover = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    dryRun: {
		      type: 'boolean',
		      name: 'dry_run'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=alias%>/_rollover/<%=newIndex%>',
		      req: {
		        alias: {
		          type: 'string'
		        },
		        newIndex: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=alias%>/_rollover',
		      req: {
		        alias: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.segments](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Includes detailed memory usage by Lucene.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.segments = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_segments',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_segments'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shardStores](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.status - A comma-separated list of statuses used to filter on shards to get store information for
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.shardStores = ca({
		  params: {
		    status: {
		      type: 'list',
		      options: [
		        'green',
		        'yellow',
		        'red',
		        'all'
		      ]
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_shard_stores',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_shard_stores'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.shrink](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Set the number of active shards to wait for on the shrunken index before the operation returns.
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the source index to shrink
		 * @param {<<api-param-type-string,`String`>>} params.target - The name of the target index to shrink into
		 */
		api.indices.prototype.shrink = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/_shrink/<%=target%>',
		    req: {
		      index: {
		        type: 'string'
		      },
		      target: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.stats](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-string,`String`>>} [params.level=indices] - Return stats aggregated at cluster, index or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned the specific metrics.
		 */
		api.indices.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'list'
		    },
		    level: {
		      type: 'enum',
		      'default': 'indices',
		      options: [
		        'cluster',
		        'indices',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_stats/<%=metric%>',
		      req: {
		        index: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_stats',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [indices.updateAliases](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Request timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Specify timeout for connection to master
		 */
		api.indices.prototype.updateAliases = ca({
		  params: {
		    timeout: {
		      type: 'time'
		    },
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_aliases'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.upgrade](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
		 */
		api.indices.prototype.upgrade = ca({
		  params: {
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    onlyAncientSegments: {
		      type: 'boolean',
		      name: 'only_ancient_segments'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_upgrade',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_upgrade'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [indices.validateQuery](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Return detailed information about the error
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {anything} params.operationThreading - TODO: ?
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
		 */
		api.indices.prototype.validateQuery = ca({
		  params: {
		    explain: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    operationThreading: {
		      name: 'operation_threading'
		    },
		    q: {
		      type: 'string'
		    },
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    rewrite: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_validate/query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_validate/query'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [info](http://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.info = ca({
		  url: {
		    fmt: '/'
		  }
		});
	
		api.ingest = namespace();
	
		/**
		 * Perform a [ingest.deletePipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.deletePipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [ingest.getPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.id - Comma separated list of pipeline ids. Wildcards supported
		 */
		api.ingest.prototype.getPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline'
		    }
		  ]
		});
	
		/**
		 * Perform a [ingest.putPipeline](https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.putPipeline = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_ingest/pipeline/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [ingest.simulate](https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verbose - Verbose mode. Display data output for each processor in executed pipeline
		 * @param {<<api-param-type-string,`String`>>} params.id - Pipeline ID
		 */
		api.ingest.prototype.simulate = ca({
		  params: {
		    verbose: {
		      type: 'boolean',
		      'default': false
		    }
		  },
		  urls: [
		    {
		      fmt: '/_ingest/pipeline/<%=id%>/_simulate',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_ingest/pipeline/_simulate'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mget](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return in the response
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specify whether to perform the operation in realtime or search mode
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Refresh the shard containing the document before performing the operation
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.mget = ca({
		  params: {
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    preference: {
		      type: 'string'
		    },
		    realtime: {
		      type: 'boolean'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    routing: {
		      type: 'string'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mget',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mget'
		    }
		  ],
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearch](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.maxConcurrentSearches - Controls the maximum number of concurrent searches the multi search api will execute
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearch = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    maxConcurrentSearches: {
		      type: 'number',
		      name: 'max_concurrent_searches'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [msearchTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to use as default
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to use as default
		 */
		api.msearchTemplate = ca({
		  params: {
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_msearch/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_msearch/template'
		    }
		  ],
		  needBody: true,
		  bulkBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [mtermvectors](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 */
		api.mtermvectors = ca({
		  params: {
		    ids: {
		      type: 'list',
		      required: false
		    },
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_mtermvectors',
		      req: {
		        index: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_mtermvectors'
		    }
		  ],
		  method: 'POST'
		});
	
		api.nodes = namespace();
	
		/**
		 * Perform a [nodes.hotThreads](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.interval - The interval for the second sampling of threads
		 * @param {<<api-param-type-number,`Number`>>} params.snapshots - Number of samples of thread stacktrace (default: 10)
		 * @param {<<api-param-type-number,`Number`>>} params.threads - Specify the number of threads to provide information for (default: 3)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
		 * @param {<<api-param-type-string,`String`>>} params.type - The type to sample (default: cpu)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.hotThreads = ca({
		  params: {
		    interval: {
		      type: 'time'
		    },
		    snapshots: {
		      type: 'number'
		    },
		    threads: {
		      type: 'number'
		    },
		    ignoreIdleThreads: {
		      type: 'boolean',
		      name: 'ignore_idle_threads'
		    },
		    type: {
		      type: 'enum',
		      options: [
		        'cpu',
		        'wait',
		        'block'
		      ]
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/hotthreads',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/hotthreads'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.info](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.flatSettings - Return settings in flat format (default: false)
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
		 */
		api.nodes.prototype.info = ca({
		  params: {
		    flatSettings: {
		      type: 'boolean',
		      name: 'flat_settings'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            'settings',
		            'os',
		            'process',
		            'jvm',
		            'thread_pool',
		            'transport',
		            'http',
		            'plugins',
		            'ingest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes'
		    }
		  ]
		});
	
		/**
		 * Perform a [nodes.stats](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.groups - A comma-separated list of search groups for `search` index metric
		 * @param {<<api-param-type-string,`String`>>} [params.level=node] - Return indices stats aggregated at index, node or shard level
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.types - A comma-separated list of document types for the `indexing` index metric
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.includeSegmentFileSizes - Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.metric - Limit the information returned to the specified metrics
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 */
		api.nodes.prototype.stats = ca({
		  params: {
		    completionFields: {
		      type: 'list',
		      name: 'completion_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    fields: {
		      type: 'list'
		    },
		    groups: {
		      type: 'boolean'
		    },
		    level: {
		      type: 'enum',
		      'default': 'node',
		      options: [
		        'indices',
		        'node',
		        'shards'
		      ]
		    },
		    types: {
		      type: 'list'
		    },
		    timeout: {
		      type: 'time'
		    },
		    includeSegmentFileSizes: {
		      type: 'boolean',
		      'default': false,
		      name: 'include_segment_file_sizes'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
		      req: {
		        nodeId: {
		          type: 'list'
		        },
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        },
		        indexMetric: {
		          type: 'list',
		          options: [
		            '_all',
		            'completion',
		            'docs',
		            'fielddata',
		            'query_cache',
		            'flush',
		            'get',
		            'indexing',
		            'merge',
		            'request_cache',
		            'refresh',
		            'search',
		            'segments',
		            'store',
		            'warmer',
		            'suggest'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/<%=nodeId%>/stats',
		      req: {
		        nodeId: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats/<%=metric%>',
		      req: {
		        metric: {
		          type: 'list',
		          options: [
		            '_all',
		            'breaker',
		            'fs',
		            'http',
		            'indices',
		            'jvm',
		            'os',
		            'process',
		            'thread_pool',
		            'transport',
		            'discovery'
		          ]
		        }
		      }
		    },
		    {
		      fmt: '/_nodes/stats'
		    }
		  ]
		});
	
		/**
		 * Perform a [ping](http://www.elastic.co/guide/) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 */
		api.ping = ca({
		  url: {
		    fmt: '/'
		  },
		  requestTimeout: 3000,
		  method: 'HEAD'
		});
	
		/**
		 * Perform a [putScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Script ID
		 * @param {<<api-param-type-string,`String`>>} params.lang - Script language
		 */
		api.putScript = ca({
		  urls: [
		    {
		      fmt: '/_scripts/<%=lang%>/<%=id%>',
		      req: {
		        lang: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_scripts/<%=lang%>',
		      req: {
		        lang: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - Template ID
		 */
		api.putTemplate = ca({
		  url: {
		    fmt: '/_search/template/<%=id%>',
		    req: {
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'PUT'
		});
	
		/**
		 * Perform a [reindex](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the reindex is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 */
		api.reindex = ca({
		  params: {
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  url: {
		    fmt: '/_reindex'
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [reindexRethrottle](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - The task id to rethrottle
		 */
		api.reindexRethrottle = ca({
		  params: {
		    requestsPerSecond: {
		      type: 'number',
		      required: true,
		      name: 'requests_per_second'
		    }
		  },
		  url: {
		    fmt: '/_reindex/<%=taskId%>/_rethrottle',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the stored search template
		 */
		api.renderSearchTemplate = ca({
		  urls: [
		    {
		      fmt: '/_render/template/<%=id%>',
		      req: {
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_render/template'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [scroll](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.scrollId - The scroll ID
		 */
		api.scroll = ca({
		  params: {
		    scroll: {
		      type: 'time'
		    },
		    scrollId: {
		      type: 'string',
		      name: 'scroll_id'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_search/scroll/<%=scrollId%>',
		      req: {
		        scrollId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_search/scroll'
		    }
		  ],
		  paramAsBody: 'scrollId',
		  method: 'POST'
		});
	
		/**
		 * Perform a [search](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.storedFields - A comma-separated list of stored fields to return as part of a hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.docvalueFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fielddataFields - A comma-separated list of fields to return as the docvalue representation of a field for each hit
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-string,`String`>>} params.suggestField - Specify which field to use for suggestions
		 * @param {<<api-param-type-string,`String`>>} [params.suggestMode=missing] - Specify suggest mode
		 * @param {<<api-param-type-number,`Number`>>} params.suggestSize - How many suggestions to return in response
		 * @param {<<api-param-type-string,`String`>>} params.suggestText - The source text for which the suggestions should be returned
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.search = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    storedFields: {
		      type: 'list',
		      name: 'stored_fields'
		    },
		    docvalueFields: {
		      type: 'list',
		      name: 'docvalue_fields'
		    },
		    fielddataFields: {
		      type: 'list',
		      name: 'fielddata_fields'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    suggestField: {
		      type: 'string',
		      name: 'suggest_field'
		    },
		    suggestMode: {
		      type: 'enum',
		      'default': 'missing',
		      options: [
		        'missing',
		        'popular',
		        'always'
		      ],
		      name: 'suggest_mode'
		    },
		    suggestSize: {
		      type: 'number',
		      name: 'suggest_size'
		    },
		    suggestText: {
		      type: 'string',
		      name: 'suggest_text'
		    },
		    timeout: {
		      type: 'time'
		    },
		    trackScores: {
		      type: 'boolean',
		      name: 'track_scores'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    },
		    version: {
		      type: 'boolean'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchShards](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 */
		api.searchShards = ca({
		  params: {
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'string'
		    },
		    local: {
		      type: 'boolean'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/_search_shards',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search_shards'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [searchTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.explain - Specify whether to return detailed information about score computation as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.profile - Specify whether to profile the query execution
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.typedKeys - Specify whether aggregation and suggester names should be prefixed by their respective types in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.searchTemplate = ca({
		  params: {
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    preference: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'query_and_fetch',
		        'dfs_query_then_fetch',
		        'dfs_query_and_fetch'
		      ],
		      name: 'search_type'
		    },
		    explain: {
		      type: 'boolean'
		    },
		    profile: {
		      type: 'boolean'
		    },
		    typedKeys: {
		      type: 'boolean',
		      name: 'typed_keys'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_search/template',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_search/template'
		    }
		  ],
		  method: 'POST'
		});
	
		api.snapshot = namespace();
	
		/**
		 * Perform a [snapshot.create](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.create = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.createRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.verify - Whether to verify the repository after creation
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.createRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    },
		    verify: {
		      type: 'boolean'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  needBody: true,
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.delete](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype['delete'] = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.deleteRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.deleteRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>',
		    req: {
		      repository: {
		        type: 'list'
		      }
		    }
		  },
		  method: 'DELETE'
		});
	
		/**
		 * Perform a [snapshot.get](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.get = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'list'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [snapshot.getRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.local - Return local information, do not retrieve the state from master node (default: false)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.repository - A comma-separated list of repository names
		 */
		api.snapshot.prototype.getRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    local: {
		      type: 'boolean'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>',
		      req: {
		        repository: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.restore](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should this request wait until the operation has completed before returning
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>} params.snapshot - A snapshot name
		 */
		api.snapshot.prototype.restore = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
		    req: {
		      repository: {
		        type: 'string'
		      },
		      snapshot: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [snapshot.status](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.snapshot - A comma-separated list of snapshot names
		 */
		api.snapshot.prototype.status = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        },
		        snapshot: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/<%=repository%>/_status',
		      req: {
		        repository: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_snapshot/_status'
		    }
		  ]
		});
	
		/**
		 * Perform a [snapshot.verifyRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.masterTimeout - Explicit operation timeout for connection to master node
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-string,`String`>>} params.repository - A repository name
		 */
		api.snapshot.prototype.verifyRepository = ca({
		  params: {
		    masterTimeout: {
		      type: 'time',
		      name: 'master_timeout'
		    },
		    timeout: {
		      type: 'time'
		    }
		  },
		  url: {
		    fmt: '/_snapshot/<%=repository%>/_verify',
		    req: {
		      repository: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		api.tasks = namespace();
	
		/**
		 * Perform a [tasks.cancel](http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be cancelled. Leave empty to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Cancel tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Cancel the task with specified task id (node_id:task_number)
		 */
		api.tasks.prototype.cancel = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    }
		  },
		  urls: [
		    {
		      fmt: '/_tasks/<%=taskId%>/_cancel',
		      req: {
		        taskId: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/_tasks/_cancel'
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [tasks.get](http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.taskId - Return the task with specified id (node_id:task_number)
		 */
		api.tasks.prototype.get = ca({
		  params: {
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    }
		  },
		  url: {
		    fmt: '/_tasks/<%=taskId%>',
		    req: {
		      taskId: {
		        type: 'string'
		      }
		    }
		  }
		});
	
		/**
		 * Perform a [tasks.list](http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.actions - A comma-separated list of actions that should be returned. Leave empty to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.detailed - Return detailed task information (default: false)
		 * @param {<<api-param-type-string,`String`>>} params.parentNode - Return tasks with specified parent node.
		 * @param {<<api-param-type-string,`String`>>} params.parentTask - Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Wait for the matching tasks to complete (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.groupBy=nodes] - Group tasks by nodes or parent/child relationships
		 */
		api.tasks.prototype.list = ca({
		  params: {
		    nodeId: {
		      type: 'list',
		      name: 'node_id'
		    },
		    actions: {
		      type: 'list'
		    },
		    detailed: {
		      type: 'boolean'
		    },
		    parentNode: {
		      type: 'string',
		      name: 'parent_node'
		    },
		    parentTask: {
		      type: 'string',
		      name: 'parent_task'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      name: 'wait_for_completion'
		    },
		    groupBy: {
		      type: 'enum',
		      'default': 'nodes',
		      options: [
		        'nodes',
		        'parents'
		      ],
		      name: 'group_by'
		    }
		  },
		  url: {
		    fmt: '/_tasks'
		  }
		});
	
		/**
		 * Perform a [termvectors](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.offsets=true] - Specifies if term offsets should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.positions=true] - Specifies if term positions should be returned.
		 * @param {<<api-param-type-boolean,`Boolean`>>} [params.payloads=true] - Specifies if term payloads should be returned.
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random).
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value.
		 * @param {<<api-param-type-string,`String`>>} params.parent - Parent id of documents.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.index - The index in which the document resides.
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document.
		 * @param {<<api-param-type-string,`String`>>} params.id - The id of the document, when not specified a doc param should be supplied.
		 */
		api.termvectors = ca({
		  params: {
		    termStatistics: {
		      type: 'boolean',
		      'default': false,
		      required: false,
		      name: 'term_statistics'
		    },
		    fieldStatistics: {
		      type: 'boolean',
		      'default': true,
		      required: false,
		      name: 'field_statistics'
		    },
		    fields: {
		      type: 'list',
		      required: false
		    },
		    offsets: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    positions: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    payloads: {
		      type: 'boolean',
		      'default': true,
		      required: false
		    },
		    preference: {
		      type: 'string',
		      required: false
		    },
		    routing: {
		      type: 'string',
		      required: false
		    },
		    parent: {
		      type: 'string',
		      required: false
		    },
		    realtime: {
		      type: 'boolean',
		      required: false
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'external',
		        'external_gte',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        },
		        id: {
		          type: 'string'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/<%=type%>/_termvectors',
		      req: {
		        index: {
		          type: 'string'
		        },
		        type: {
		          type: 'string'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
		/**
		 * Perform a [update](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.fields - A comma-separated list of fields to return in the response
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-string,`String`>>} params.lang - The script language (default: painless)
		 * @param {<<api-param-type-string,`String`>>} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
		 * @param {<<api-param-type-string,`String`>>} params.refresh - If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
		 * @param {<<api-param-type-number,`Number`>>} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
		 * @param {<<api-param-type-string,`String`>>} params.routing - Specific routing value
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timeout - Explicit operation timeout
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.timestamp - Explicit timestamp for the document
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.ttl - Expiration time for the document
		 * @param {<<api-param-type-number,`Number`>>} params.version - Explicit version number for concurrency control
		 * @param {<<api-param-type-string,`String`>>} params.versionType - Specific version type
		 * @param {<<api-param-type-string,`String`>>} params.id - Document ID
		 * @param {<<api-param-type-string,`String`>>} params.index - The name of the index
		 * @param {<<api-param-type-string,`String`>>} params.type - The type of the document
		 */
		api.update = ca({
		  params: {
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    fields: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    lang: {
		      type: 'string'
		    },
		    parent: {
		      type: 'string'
		    },
		    refresh: {
		      type: 'enum',
		      options: [
		        'true',
		        'false',
		        'wait_for',
		        ''
		      ]
		    },
		    retryOnConflict: {
		      type: 'number',
		      name: 'retry_on_conflict'
		    },
		    routing: {
		      type: 'string'
		    },
		    timeout: {
		      type: 'time'
		    },
		    timestamp: {
		      type: 'time'
		    },
		    ttl: {
		      type: 'time'
		    },
		    version: {
		      type: 'number'
		    },
		    versionType: {
		      type: 'enum',
		      options: [
		        'internal',
		        'force'
		      ],
		      name: 'version_type'
		    }
		  },
		  url: {
		    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
		    req: {
		      index: {
		        type: 'string'
		      },
		      type: {
		        type: 'string'
		      },
		      id: {
		        type: 'string'
		      }
		    }
		  },
		  method: 'POST'
		});
	
		/**
		 * Perform a [updateByQuery](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html) request
		 *
		 * @param {Object} params - An object with parameters used to carry out this action
		 * @param {<<api-param-type-string,`String`>>} params.analyzer - The analyzer to use for the query string
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
		 * @param {<<api-param-type-string,`String`>>} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
		 * @param {<<api-param-type-string,`String`>>} params.df - The field to use as default where no field prefix is given in the query string
		 * @param {<<api-param-type-number,`Number`>>} params.from - Starting offset (default: 0)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
		 * @param {<<api-param-type-string,`String`>>} [params.conflicts=abort] - What to do when the update by query hits version conflicts?
		 * @param {<<api-param-type-string,`String`>>} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
		 * @param {<<api-param-type-string,`String`>>} params.pipeline - Ingest pipeline to set on index requests made by this action. (default: none)
		 * @param {<<api-param-type-string,`String`>>} params.preference - Specify the node or shard the operation should be performed on (default: random)
		 * @param {<<api-param-type-string,`String`>>} params.q - Query in the Lucene query string syntax
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.routing - A comma-separated list of specific routing values
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
		 * @param {<<api-param-type-string,`String`>>} params.searchType - Search operation type
		 * @param {<<api-param-type-duration-string,`DurationString`>>} params.searchTimeout - Explicit timeout for each search request. Defaults to no timeout.
		 * @param {<<api-param-type-number,`Number`>>} params.size - Number of hits to return (default: 10)
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.sort - A comma-separated list of <field>:<direction> pairs
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._source - True or false to return the _source field or not, or a list of fields to return
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceExclude - A list of fields to exclude from the returned _source field
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params._sourceInclude - A list of fields to extract and return from the _source field
		 * @param {<<api-param-type-number,`Number`>>} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.stats - Specific 'tag' of the request for logging and statistical purposes
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.version - Specify whether to return document version as part of a hit
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.versionType - Should the document increment the version number (internal) on hit or not (reindex)
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.refresh - Should the effected indexes be refreshed?
		 * @param {<<api-param-type-duration-string,`DurationString`>>} [params.timeout=1m] - Time each individual bulk request should wait for shards that are unavailable.
		 * @param {<<api-param-type-string,`String`>>} params.waitForActiveShards - Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		 * @param {<<api-param-type-number,`Number`>>} params.scrollSize - Size on the scroll request powering the update_by_query
		 * @param {<<api-param-type-boolean,`Boolean`>>} params.waitForCompletion - Should the request should block until the update by query operation is complete.
		 * @param {<<api-param-type-number,`Number`>>} params.requestsPerSecond - The throttle to set on this request in sub-requests per second. -1 means no throttle.
		 * @param {<<api-param-type-number,`Number`>>} [params.slices=1] - The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
		 * @param {<<api-param-type-string,`String`>>, <<api-param-type-string-array,`String[]`>>, <<api-param-type-boolean,`Boolean`>>} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
		 */
		api.updateByQuery = ca({
		  params: {
		    analyzer: {
		      type: 'string'
		    },
		    analyzeWildcard: {
		      type: 'boolean',
		      name: 'analyze_wildcard'
		    },
		    defaultOperator: {
		      type: 'enum',
		      'default': 'OR',
		      options: [
		        'AND',
		        'OR'
		      ],
		      name: 'default_operator'
		    },
		    df: {
		      type: 'string'
		    },
		    from: {
		      type: 'number'
		    },
		    ignoreUnavailable: {
		      type: 'boolean',
		      name: 'ignore_unavailable'
		    },
		    allowNoIndices: {
		      type: 'boolean',
		      name: 'allow_no_indices'
		    },
		    conflicts: {
		      type: 'enum',
		      'default': 'abort',
		      options: [
		        'abort',
		        'proceed'
		      ]
		    },
		    expandWildcards: {
		      type: 'enum',
		      'default': 'open',
		      options: [
		        'open',
		        'closed',
		        'none',
		        'all'
		      ],
		      name: 'expand_wildcards'
		    },
		    lenient: {
		      type: 'boolean'
		    },
		    pipeline: {
		      type: 'string'
		    },
		    preference: {
		      type: 'string'
		    },
		    q: {
		      type: 'string'
		    },
		    routing: {
		      type: 'list'
		    },
		    scroll: {
		      type: 'time'
		    },
		    searchType: {
		      type: 'enum',
		      options: [
		        'query_then_fetch',
		        'dfs_query_then_fetch'
		      ],
		      name: 'search_type'
		    },
		    searchTimeout: {
		      type: 'time',
		      name: 'search_timeout'
		    },
		    size: {
		      type: 'number'
		    },
		    sort: {
		      type: 'list'
		    },
		    _source: {
		      type: 'list'
		    },
		    _sourceExclude: {
		      type: 'list',
		      name: '_source_exclude'
		    },
		    _sourceInclude: {
		      type: 'list',
		      name: '_source_include'
		    },
		    terminateAfter: {
		      type: 'number',
		      name: 'terminate_after'
		    },
		    stats: {
		      type: 'list'
		    },
		    version: {
		      type: 'boolean'
		    },
		    versionType: {
		      type: 'boolean',
		      name: 'version_type'
		    },
		    requestCache: {
		      type: 'boolean',
		      name: 'request_cache'
		    },
		    refresh: {
		      type: 'boolean'
		    },
		    timeout: {
		      type: 'time',
		      'default': '1m'
		    },
		    waitForActiveShards: {
		      type: 'string',
		      name: 'wait_for_active_shards'
		    },
		    scrollSize: {
		      type: 'number',
		      name: 'scroll_size'
		    },
		    waitForCompletion: {
		      type: 'boolean',
		      'default': false,
		      name: 'wait_for_completion'
		    },
		    requestsPerSecond: {
		      type: 'number',
		      'default': 0,
		      name: 'requests_per_second'
		    },
		    slices: {
		      type: 'number',
		      'default': 1
		    }
		  },
		  urls: [
		    {
		      fmt: '/<%=index%>/<%=type%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        },
		        type: {
		          type: 'list'
		        }
		      }
		    },
		    {
		      fmt: '/<%=index%>/_update_by_query',
		      req: {
		        index: {
		          type: 'list'
		        }
		      }
		    }
		  ],
		  method: 'POST'
		});
	
	
	/***/ }
	/******/ ]);
	}());

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	__webpack_require__(482);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	var _uiIndex_patterns_index_pattern = __webpack_require__(483);
	
	var _uiIndex_patterns_index_pattern2 = _interopRequireDefault(_uiIndex_patterns_index_pattern);
	
	var _uiIndex_patterns_pattern_cache = __webpack_require__(542);
	
	var _uiIndex_patterns_pattern_cache2 = _interopRequireDefault(_uiIndex_patterns_pattern_cache);
	
	var _uiIndex_patterns_get_ids = __webpack_require__(495);
	
	var _uiIndex_patterns_get_ids2 = _interopRequireDefault(_uiIndex_patterns_get_ids);
	
	var _uiIndex_patterns_intervals = __webpack_require__(502);
	
	var _uiIndex_patterns_intervals2 = _interopRequireDefault(_uiIndex_patterns_intervals);
	
	var _uiIndex_patterns_mapper = __webpack_require__(496);
	
	var _uiIndex_patterns_mapper2 = _interopRequireDefault(_uiIndex_patterns_mapper);
	
	var _uiIndex_patterns_pattern_to_wildcard = __webpack_require__(503);
	
	var _uiIndex_patterns_pattern_to_wildcard2 = _interopRequireDefault(_uiIndex_patterns_pattern_to_wildcard);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana/index_patterns');
	
	function IndexPatternsProvider(esAdmin, Notifier, Private, Promise, kbnIndex) {
	  var self = this;
	
	  var IndexPattern = Private(_uiIndex_patterns_index_pattern2['default']);
	  var patternCache = Private(_uiIndex_patterns_pattern_cache2['default']);
	
	  var notify = new Notifier({ location: 'IndexPatterns Service' });
	
	  self.get = function (id) {
	    if (!id) return self.make();
	
	    var cache = patternCache.get(id);
	    return cache || patternCache.set(id, self.make(id));
	  };
	
	  self.make = function (id) {
	    return new IndexPattern(id).init();
	  };
	
	  self['delete'] = function (pattern) {
	    self.getIds.clearCache();
	    pattern.destroy();
	
	    return esAdmin['delete']({
	      index: kbnIndex,
	      type: 'index-pattern',
	      id: pattern.id
	    });
	  };
	
	  self.errors = {
	    MissingIndices: _uiErrors2['default'].IndexPatternMissingIndices
	  };
	
	  self.cache = patternCache;
	  self.getIds = Private(_uiIndex_patterns_get_ids2['default']);
	  self.intervals = Private(_uiIndex_patterns_intervals2['default']);
	  self.mapper = Private(_uiIndex_patterns_mapper2['default']);
	  self.patternToWildcard = Private(_uiIndex_patterns_pattern_to_wildcard2['default']);
	  self.fieldFormats = Private(_uiRegistryField_formats2['default']);
	  self.IndexPattern = IndexPattern;
	}
	
	_module.service('indexPatterns', function (Private) {
	  return Private(IndexPatternsProvider);
	});
	exports['default'] = IndexPatternsProvider;
	module.exports = exports['default'];

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	// Shorts dot notated strings
	// eg: foo.bar.baz becomes f.b.baz
	// 'foo.bar.baz'.replace(/(.+?\.)/g,function(v) {return v[0]+'.';});
	
	_uiModules2['default'].get('kibana').filter('shortDots', function (Private) {
	  return Private(shortDotsFilterProvider);
	});
	
	function shortDotsFilterProvider(config) {
	  var filter = undefined;
	
	  config.watch('shortDots:enable', updateFilter);
	
	  return wrapper;
	
	  function updateFilter(enabled) {
	    filter = enabled ? _lodash2['default'].shortenDottedString : _lodash2['default'].identity;
	  }
	  function wrapper(str) {
	    return filter(str);
	  }
	}
	
	exports['default'] = shortDotsFilterProvider;
	module.exports = exports['default'];

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _WeakMap = __webpack_require__(484)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IndexPatternFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiIndex_patterns_get_computed_fields = __webpack_require__(492);
	
	var _uiIndex_patterns_get_computed_fields2 = _interopRequireDefault(_uiIndex_patterns_get_computed_fields);
	
	var _uiIndex_patterns_format_hit = __webpack_require__(493);
	
	var _uiIndex_patterns_format_hit2 = _interopRequireDefault(_uiIndex_patterns_format_hit);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _uiIndex_patterns_get_ids = __webpack_require__(495);
	
	var _uiIndex_patterns_get_ids2 = _interopRequireDefault(_uiIndex_patterns_get_ids);
	
	var _uiIndex_patterns_mapper = __webpack_require__(496);
	
	var _uiIndex_patterns_mapper2 = _interopRequireDefault(_uiIndex_patterns_mapper);
	
	var _uiIndex_patterns_intervals = __webpack_require__(502);
	
	var _uiIndex_patterns_intervals2 = _interopRequireDefault(_uiIndex_patterns_intervals);
	
	var _uiCourierData_sourceAdmin_doc_source = __webpack_require__(505);
	
	var _uiCourierData_sourceAdmin_doc_source2 = _interopRequireDefault(_uiCourierData_sourceAdmin_doc_source);
	
	var _uiUtilsMapping_setup = __webpack_require__(533);
	
	var _uiUtilsMapping_setup2 = _interopRequireDefault(_uiUtilsMapping_setup);
	
	var _uiIndex_patterns_field_list = __webpack_require__(534);
	
	var _uiIndex_patterns_field_list2 = _interopRequireDefault(_uiIndex_patterns_field_list);
	
	var _uiIndex_patterns_flatten_hit = __webpack_require__(540);
	
	var _uiIndex_patterns_flatten_hit2 = _interopRequireDefault(_uiIndex_patterns_flatten_hit);
	
	var _uiIndex_patterns_calculate_indices = __webpack_require__(541);
	
	var _uiIndex_patterns_calculate_indices2 = _interopRequireDefault(_uiIndex_patterns_calculate_indices);
	
	var _uiIndex_patterns_pattern_cache = __webpack_require__(542);
	
	var _uiIndex_patterns_pattern_cache2 = _interopRequireDefault(_uiIndex_patterns_pattern_cache);
	
	function IndexPatternFactory(Private, Notifier, config, kbnIndex, Promise, confirmModalPromise) {
	  var fieldformats = Private(_uiRegistryField_formats2['default']);
	  var getIds = Private(_uiIndex_patterns_get_ids2['default']);
	  var mapper = Private(_uiIndex_patterns_mapper2['default']);
	  var intervals = Private(_uiIndex_patterns_intervals2['default']);
	  var DocSource = Private(_uiCourierData_sourceAdmin_doc_source2['default']);
	  var mappingSetup = Private(_uiUtilsMapping_setup2['default']);
	  var FieldList = Private(_uiIndex_patterns_field_list2['default']);
	  var flattenHit = Private(_uiIndex_patterns_flatten_hit2['default']);
	  var calculateIndices = Private(_uiIndex_patterns_calculate_indices2['default']);
	  var patternCache = Private(_uiIndex_patterns_pattern_cache2['default']);
	  var type = 'index-pattern';
	  var notify = new Notifier();
	  var configWatchers = new _WeakMap();
	  var docSources = new _WeakMap();
	  var getRoutes = function getRoutes() {
	    return {
	      edit: '/management/kibana/indices/{{id}}',
	      addField: '/management/kibana/indices/{{id}}/create-field',
	      indexedFields: '/management/kibana/indices/{{id}}?_a=(tab:indexedFields)',
	      scriptedFields: '/management/kibana/indices/{{id}}?_a=(tab:scriptedFields)',
	      sourceFilters: '/management/kibana/indices/{{id}}?_a=(tab:sourceFilters)'
	    };
	  };
	
	  var mapping = mappingSetup.expandShorthand({
	    title: 'string',
	    timeFieldName: 'string',
	    notExpandable: 'boolean',
	    intervalName: 'string',
	    fields: 'json',
	    sourceFilters: 'json',
	    fieldFormatMap: {
	      type: 'string',
	      _serialize: function _serialize() {
	        var map = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	        var serialized = _lodash2['default'].transform(map, serialize);
	        return _lodash2['default'].isEmpty(serialized) ? undefined : _angular2['default'].toJson(serialized);
	      },
	      _deserialize: function _deserialize() {
	        var map = arguments.length <= 0 || arguments[0] === undefined ? '{}' : arguments[0];
	
	        return _lodash2['default'].mapValues(_angular2['default'].fromJson(map), deserialize);
	      }
	    }
	  });
	
	  function serialize(flat, format, field) {
	    if (format) {
	      flat[field] = format;
	    }
	  }
	
	  function deserialize(mapping) {
	    var FieldFormat = fieldformats.byId[mapping.id];
	    return FieldFormat && new FieldFormat(mapping.params);
	  }
	
	  function updateFromElasticSearch(indexPattern, response) {
	    if (!response.found) {
	      throw new _uiErrors2['default'].SavedObjectNotFound(type, indexPattern.id);
	    }
	
	    _lodash2['default'].forOwn(mapping, function (fieldMapping, name) {
	      if (!fieldMapping._deserialize) {
	        return;
	      }
	      response._source[name] = fieldMapping._deserialize(response._source[name], response, name, fieldMapping);
	    });
	
	    // give index pattern all of the values in _source
	    _lodash2['default'].assign(indexPattern, response._source);
	
	    var promise = indexFields(indexPattern);
	
	    // any time index pattern in ES is updated, update index pattern object
	    docSources.get(indexPattern).onUpdate().then(function (response) {
	      return updateFromElasticSearch(indexPattern, response);
	    }, notify.fatal);
	
	    return promise;
	  }
	
	  function containsFieldCapabilities(fields) {
	    return _lodash2['default'].any(fields, function (field) {
	      return _lodash2['default'].has(field, 'aggregatable') && _lodash2['default'].has(field, 'searchable');
	    });
	  }
	
	  function indexFields(indexPattern) {
	    var promise = Promise.resolve();
	
	    if (!indexPattern.id) {
	      return promise;
	    }
	
	    if (!indexPattern.fields || !containsFieldCapabilities(indexPattern.fields)) {
	      promise = indexPattern.refreshFields();
	    }
	    return promise.then(function () {
	      initFields(indexPattern);
	    });
	  }
	
	  function setId(indexPattern, id) {
	    indexPattern.id = id;
	    return id;
	  }
	
	  function watch(indexPattern) {
	    if (configWatchers.has(indexPattern)) {
	      return;
	    }
	    var unwatch = config.watchAll(function () {
	      if (indexPattern.fields) {
	        initFields(indexPattern); // re-init fields when config changes, but only if we already had fields
	      }
	    });
	    configWatchers.set(indexPattern, { unwatch: unwatch });
	  }
	
	  function unwatch(indexPattern) {
	    if (!configWatchers.has(indexPattern)) {
	      return;
	    }
	    configWatchers.get(indexPattern).unwatch();
	    configWatchers['delete'](indexPattern);
	  }
	
	  function initFields(indexPattern, input) {
	    var oldValue = indexPattern.fields;
	    var newValue = input || oldValue || [];
	    indexPattern.fields = new FieldList(indexPattern, newValue);
	  }
	
	  function fetchFields(indexPattern) {
	    return mapper.getFieldsForIndexPattern(indexPattern, { skipIndexPatternCache: true }).then(function (fields) {
	      var scripted = indexPattern.getScriptedFields();
	      var all = fields.concat(scripted);
	      initFields(indexPattern, all);
	    });
	  }
	
	  var IndexPattern = (function () {
	    function IndexPattern(id) {
	      _classCallCheck(this, IndexPattern);
	
	      setId(this, id);
	      docSources.set(this, new DocSource());
	
	      this.metaFields = config.get('metaFields');
	      this.getComputedFields = _uiIndex_patterns_get_computed_fields2['default'].bind(this);
	
	      this.flattenHit = flattenHit(this);
	      this.formatHit = (0, _uiIndex_patterns_format_hit2['default'])(this, fieldformats.getDefaultInstance('string'));
	      this.formatField = this.formatHit.formatField;
	    }
	
	    _createClass(IndexPattern, [{
	      key: 'init',
	      value: function init() {
	        var _this = this;
	
	        docSources.get(this).index(kbnIndex).type(type).id(this.id);
	
	        watch(this);
	
	        return mappingSetup.isDefined(type).then(function (defined) {
	          if (defined) {
	            return true;
	          }
	          return mappingSetup.setup(type, mapping);
	        }).then(function () {
	          if (!_this.id) {
	            return; // no id === no elasticsearch document
	          }
	          return docSources.get(_this).fetch().then(function (response) {
	            return updateFromElasticSearch(_this, response);
	          });
	        }).then(function () {
	          return _this;
	        });
	      }
	
	      // Get the source filtering configuration for that index.
	    }, {
	      key: 'getSourceFiltering',
	      value: function getSourceFiltering() {
	        return {
	          excludes: this.sourceFilters && this.sourceFilters.map(function (filter) {
	            return filter.value;
	          }) || []
	        };
	      }
	    }, {
	      key: 'addScriptedField',
	      value: function addScriptedField(name, script, type, lang) {
	        if (type === undefined) type = 'string';
	
	        var scriptedFields = this.getScriptedFields();
	        var names = _lodash2['default'].pluck(scriptedFields, 'name');
	
	        if (_lodash2['default'].contains(names, name)) {
	          throw new _uiErrors2['default'].DuplicateField(name);
	        }
	
	        this.fields.push({
	          name: name,
	          script: script,
	          type: type,
	          scripted: true,
	          lang: lang
	        });
	
	        this.save();
	      }
	    }, {
	      key: 'removeScriptedField',
	      value: function removeScriptedField(name) {
	        var fieldIndex = _lodash2['default'].findIndex(this.fields, {
	          name: name,
	          scripted: true
	        });
	        this.fields.splice(fieldIndex, 1);
	        this.save();
	      }
	    }, {
	      key: 'popularizeField',
	      value: function popularizeField(fieldName) {
	        var unit = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	
	        var field = _lodash2['default'].get(this, ['fields', 'byName', fieldName]);
	        if (!field) {
	          return;
	        }
	        var count = Math.max((field.count || 0) + unit, 0);
	        if (field.count === count) {
	          return;
	        }
	        field.count = count;
	        this.save();
	      }
	    }, {
	      key: 'getNonScriptedFields',
	      value: function getNonScriptedFields() {
	        return _lodash2['default'].where(this.fields, { scripted: false });
	      }
	    }, {
	      key: 'getScriptedFields',
	      value: function getScriptedFields() {
	        return _lodash2['default'].where(this.fields, { scripted: true });
	      }
	    }, {
	      key: 'getInterval',
	      value: function getInterval() {
	        return this.intervalName && _lodash2['default'].find(intervals, { name: this.intervalName });
	      }
	    }, {
	      key: 'toIndexList',
	      value: function toIndexList(start, stop, sortDirection) {
	        return this.toDetailedIndexList(start, stop, sortDirection).then(function (detailedIndices) {
	          if (!_lodash2['default'].isArray(detailedIndices)) {
	            return detailedIndices.index;
	          }
	          return _lodash2['default'].pluck(detailedIndices, 'index');
	        });
	      }
	    }, {
	      key: 'toDetailedIndexList',
	      value: function toDetailedIndexList(start, stop, sortDirection) {
	        var _this2 = this;
	
	        return Promise.resolve().then(function () {
	          var interval = _this2.getInterval();
	          if (interval) {
	            return intervals.toIndexList(_this2.id, interval, start, stop, sortDirection);
	          }
	
	          if (_this2.isWildcard() && _this2.hasTimeField() && _this2.canExpandIndices()) {
	            return calculateIndices(_this2.id, _this2.timeFieldName, start, stop, sortDirection);
	          }
	
	          return {
	            index: _this2.id,
	            min: -Infinity,
	            max: Infinity
	          };
	        });
	      }
	    }, {
	      key: 'canExpandIndices',
	      value: function canExpandIndices() {
	        return !this.notExpandable;
	      }
	    }, {
	      key: 'hasTimeField',
	      value: function hasTimeField() {
	        return !!(this.timeFieldName && this.fields.byName[this.timeFieldName]);
	      }
	    }, {
	      key: 'isWildcard',
	      value: function isWildcard() {
	        return _lodash2['default'].includes(this.id, '*');
	      }
	    }, {
	      key: 'prepBody',
	      value: function prepBody() {
	        var _this3 = this;
	
	        var body = {};
	
	        // serialize json fields
	        _lodash2['default'].forOwn(mapping, function (fieldMapping, fieldName) {
	          if (_this3[fieldName] != null) {
	            body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this3[fieldName]) : _this3[fieldName];
	          }
	        });
	
	        // ensure that the docSource has the current this.id
	        docSources.get(this).id(this.id);
	
	        // clear the indexPattern list cache
	        getIds.clearCache();
	        return body;
	      }
	    }, {
	      key: 'create',
	      value: function create() {
	        var _this4 = this;
	
	        var body = this.prepBody();
	        return docSources.get(this).doCreate(body).then(function (id) {
	          return setId(_this4, id);
	        })['catch'](function (err) {
	          if (_lodash2['default'].get(err, 'origError.status') !== 409) {
	            return Promise.resolve(false);
	          }
	          var confirmMessage = 'Are you sure you want to overwrite this?';
	
	          return confirmModalPromise(confirmMessage, { confirmButtonText: 'Overwrite' }).then(function () {
	            return Promise['try'](function () {
	              var cached = patternCache.get(_this4.id);
	              if (cached) {
	                return cached.then(function (pattern) {
	                  return pattern.destroy();
	                });
	              }
	            }).then(function () {
	              return docSources.get(_this4).doIndex(body);
	            }).then(function (id) {
	              return setId(_this4, id);
	            });
	          }, _lodash2['default'].constant(false) // if the user doesn't overwrite, resolve with false
	          );
	        });
	      }
	    }, {
	      key: 'save',
	      value: function save() {
	        var _this5 = this;
	
	        var body = this.prepBody();
	        return docSources.get(this).doIndex(body).then(function (id) {
	          return setId(_this5, id);
	        });
	      }
	    }, {
	      key: 'refreshFields',
	      value: function refreshFields() {
	        var _this6 = this;
	
	        return mapper.clearCache(this).then(function () {
	          return fetchFields(_this6);
	        }).then(function () {
	          return _this6.save();
	        })['catch'](function (err) {
	          notify.error(err);
	          return Promise.reject(err);
	        });
	      }
	    }, {
	      key: 'toJSON',
	      value: function toJSON() {
	        return this.id;
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        return '' + this.toJSON();
	      }
	    }, {
	      key: 'destroy',
	      value: function destroy() {
	        unwatch(this);
	        patternCache.clear(this.id);
	        docSources.get(this).destroy();
	        docSources['delete'](this);
	      }
	    }, {
	      key: 'routes',
	      get: function get() {
	        return getRoutes();
	      }
	    }]);
	
	    return IndexPattern;
	  })();
	
	  return IndexPattern;
	}
	
	module.exports = exports['default'];

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(485), __esModule: true };

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(333);
	__webpack_require__(293);
	__webpack_require__(486);
	module.exports = __webpack_require__(34).WeakMap;

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(14)
	  , redefine     = __webpack_require__(300)
	  , weak         = __webpack_require__(487)
	  , isObject     = __webpack_require__(41)
	  , has          = __webpack_require__(304)
	  , frozenStore  = weak.frozenStore
	  , WEAK         = weak.WEAK
	  , isExtensible = Object.isExtensible || isObject
	  , tmp          = {};
	
	// 23.3 WeakMap Objects
	var $WeakMap = __webpack_require__(491)('WeakMap', function(get){
	  return function WeakMap(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      if(!isExtensible(key))return frozenStore(this).get(key);
	      if(has(key, WEAK))return key[WEAK][this._i];
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	}, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  $.each.call(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on leaky map
	      if(isObject(a) && !isExtensible(a)){
	        var result = frozenStore(this)[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide              = __webpack_require__(301)
	  , redefineAll       = __webpack_require__(347)
	  , anObject          = __webpack_require__(259)
	  , isObject          = __webpack_require__(41)
	  , strictNew         = __webpack_require__(335)
	  , forOf             = __webpack_require__(336)
	  , createArrayMethod = __webpack_require__(488)
	  , $has              = __webpack_require__(304)
	  , WEAK              = __webpack_require__(309)('weak')
	  , isExtensible      = Object.isExtensible || isObject
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for frozen keys
	var frozenStore = function(that){
	  return that._l || (that._l = new FrozenStore);
	};
	var FrozenStore = function(){
	  this.a = [];
	};
	var findFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	FrozenStore.prototype = {
	  get: function(key){
	    var entry = findFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this)['delete'](key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this).has(key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    if(!isExtensible(anObject(key))){
	      frozenStore(that).set(key, value);
	    } else {
	      $has(key, WEAK) || hide(key, WEAK, {});
	      key[WEAK][that._i] = value;
	    } return that;
	  },
	  frozenStore: frozenStore,
	  WEAK: WEAK
	};

/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(35)
	  , IObject  = __webpack_require__(252)
	  , toObject = __webpack_require__(29)
	  , toLength = __webpack_require__(339)
	  , asc      = __webpack_require__(489);
	module.exports = function(TYPE){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var isObject = __webpack_require__(41)
	  , isArray  = __webpack_require__(490)
	  , SPECIES  = __webpack_require__(307)('species');
	module.exports = function(original, length){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length);
	};

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(253);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $              = __webpack_require__(14)
	  , global         = __webpack_require__(33)
	  , $export        = __webpack_require__(32)
	  , fails          = __webpack_require__(37)
	  , hide           = __webpack_require__(301)
	  , redefineAll    = __webpack_require__(347)
	  , forOf          = __webpack_require__(336)
	  , strictNew      = __webpack_require__(335)
	  , isObject       = __webpack_require__(41)
	  , setToStringTag = __webpack_require__(306)
	  , DESCRIPTORS    = __webpack_require__(303);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	  } else {
	    C = wrapper(function(target, iterable){
	      strictNew(target, C, NAME);
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
	// returns a flattened version
	
	exports['default'] = function () {
	  var self = this;
	  var scriptFields = {};
	  var docvalueFields = [];
	
	  docvalueFields = _lodash2['default'].map(_lodash2['default'].reject(self.fields.byType.date, 'scripted'), 'name');
	
	  _lodash2['default'].each(self.getScriptedFields(), function (field) {
	    scriptFields[field.name] = {
	      script: {
	        inline: field.script,
	        lang: field.lang
	      }
	    };
	  });
	
	  return {
	    storedFields: ['*'],
	    scriptFields: scriptFields,
	    docvalueFields: docvalueFields
	  };
	};
	
	module.exports = exports['default'];

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
	// returns a formated version
	
	exports['default'] = function (indexPattern, defaultFormat) {
	
	  function convert(hit, val, fieldName) {
	    var field = indexPattern.fields.byName[fieldName];
	    if (!field) return defaultFormat.convert(val, 'html');
	    return field.format.getConverterFor('html')(val, field, hit);
	  }
	
	  function formatHit(hit) {
	    if (hit.$$_formatted) return hit.$$_formatted;
	
	    // use and update the partial cache, but don't rewrite it. _source is stored in partials
	    // but not $$_formatted
	    var partials = hit.$$_partialFormatted || (hit.$$_partialFormatted = {});
	    var cache = hit.$$_formatted = {};
	
	    _lodash2['default'].forOwn(indexPattern.flattenHit(hit), function (val, fieldName) {
	      // sync the formatted and partial cache
	      var formatted = partials[fieldName] == null ? convert(hit, val, fieldName) : partials[fieldName];
	      cache[fieldName] = partials[fieldName] = formatted;
	    });
	
	    return cache;
	  }
	
	  formatHit.formatField = function (hit, fieldName) {
	    var partials = hit.$$_partialFormatted;
	    if (partials && partials[fieldName] != null) {
	      return partials[fieldName];
	    }
	
	    if (!partials) {
	      partials = hit.$$_partialFormatted = {};
	    }
	
	    var val = fieldName === '_source' ? hit._source : indexPattern.flattenHit(hit)[fieldName];
	    return partials[fieldName] = convert(hit, val, fieldName);
	  };
	
	  return formatHit;
	};
	
	module.exports = exports['default'];

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiRegistry_registry = __webpack_require__(446);
	
	var _uiRegistry_registry2 = _interopRequireDefault(_uiRegistry_registry);
	
	exports['default'] = (0, _uiRegistry_registry2['default'])({
	  name: 'fieldFormats',
	  index: ['id'],
	  group: ['fieldType'],
	
	  constructor: function constructor(config) {
	    var self = this;
	    var defaultMap = undefined;
	
	    function init() {
	      config.watch('format:defaultTypeMap', parseDefaultTypeMap);
	    }
	
	    /**
	     * Get the id of the default type for this field type
	     * using the format:defaultTypeMap config map
	     *
	     * @param  {String} fieldType - the field type
	     * @return {String}
	     */
	    self.getDefaultConfig = function (fieldType) {
	      return defaultMap[fieldType] || defaultMap._default_;
	    };
	
	    /**
	     * Get a FieldFormat type (class) by it's id.
	     *
	     * @param  {String} formatId - the format id
	     * @return {Function}
	     */
	    self.getType = function (formatId) {
	      return self.byId[formatId];
	    };
	
	    /**
	     * Get the default FieldFormat type (class) for
	     * a field type, using the format:defaultTypeMap.
	     *
	     * @param  {String} fieldType
	     * @return {Function}
	     */
	    self.getDefaultType = function (fieldType) {
	      return self.byId[self.getDefaultConfig(fieldType).id];
	    };
	
	    /**
	     * Get the singleton instance of the FieldFormat type by it's id.
	     *
	     * @param  {String} formatId
	     * @return {FieldFormat}
	     */
	    self.getInstance = _lodash2['default'].memoize(function (formatId) {
	      var FieldFormat = self.byId[formatId];
	      return new FieldFormat();
	    });
	
	    /**
	     * Get the default fieldFormat instance for a field format.
	     *
	     * @param  {String} fieldType
	     * @return {FieldFormat}
	     */
	    self.getDefaultInstance = _lodash2['default'].memoize(function (fieldType) {
	      var conf = self.getDefaultConfig(fieldType);
	      var FieldFormat = self.byId[conf.id];
	      return new FieldFormat(conf.params);
	    });
	
	    function parseDefaultTypeMap(value) {
	      defaultMap = value;
	      _lodash2['default'].forOwn(self, function (fn) {
	        if (_lodash2['default'].isFunction(fn) && fn.cache) {
	          // clear all memoize caches
	          fn.cache = new _lodash2['default'].memoize.Cache();
	        }
	      });
	    }
	
	    init();
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = GetIndexPatternIdsFn;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function GetIndexPatternIdsFn(esAdmin, kbnIndex) {
	
	  // many places may require the id list, so we will cache it seperately
	  // didn't incorportate with the indexPattern cache to prevent id collisions.
	  var cachedPromise = undefined;
	
	  var getIds = function getIds() {
	    if (cachedPromise) {
	      // retrun a clone of the cached response
	      return cachedPromise.then(function (cachedResp) {
	        return _lodash2['default'].clone(cachedResp);
	      });
	    }
	
	    cachedPromise = esAdmin.search({
	      index: kbnIndex,
	      type: 'index-pattern',
	      storedFields: [],
	      body: {
	        query: { match_all: {} },
	        size: 10000
	      }
	    }).then(function (resp) {
	      return _lodash2['default'].pluck(resp.hits.hits, '_id');
	    });
	
	    // ensure that the response stays pristine by cloning it here too
	    return cachedPromise.then(function (resp) {
	      return _lodash2['default'].clone(resp);
	    });
	  };
	
	  getIds.clearCache = function () {
	    cachedPromise = null;
	  };
	
	  return getIds;
	}
	
	module.exports = exports['default'];

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = MapperService;
	
	var _uiErrors = __webpack_require__(359);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiIndex_patterns_enhance_fields_with_capabilities = __webpack_require__(497);
	
	var _uiIndex_patterns_enhance_fields_with_capabilities2 = _interopRequireDefault(_uiIndex_patterns_enhance_fields_with_capabilities);
	
	var _uiIndex_patterns_transform_mapping_into_fields = __webpack_require__(498);
	
	var _uiIndex_patterns_transform_mapping_into_fields2 = _interopRequireDefault(_uiIndex_patterns_transform_mapping_into_fields);
	
	var _uiIndex_patterns_intervals = __webpack_require__(502);
	
	var _uiIndex_patterns_intervals2 = _interopRequireDefault(_uiIndex_patterns_intervals);
	
	var _uiIndex_patterns_pattern_to_wildcard = __webpack_require__(503);
	
	var _uiIndex_patterns_pattern_to_wildcard2 = _interopRequireDefault(_uiIndex_patterns_pattern_to_wildcard);
	
	var _uiIndex_patterns_local_cache = __webpack_require__(504);
	
	var _uiIndex_patterns_local_cache2 = _interopRequireDefault(_uiIndex_patterns_local_cache);
	
	function MapperService(Private, Promise, es, esAdmin, config, kbnIndex) {
	
	  var enhanceFieldsWithCapabilities = Private(_uiIndex_patterns_enhance_fields_with_capabilities2['default']);
	  var transformMappingIntoFields = Private(_uiIndex_patterns_transform_mapping_into_fields2['default']);
	  var intervals = Private(_uiIndex_patterns_intervals2['default']);
	  var patternToWildcard = Private(_uiIndex_patterns_pattern_to_wildcard2['default']);
	
	  var LocalCache = Private(_uiIndex_patterns_local_cache2['default']);
	
	  function Mapper() {
	
	    // Save a reference to mapper
	    var self = this;
	
	    // proper-ish cache, keeps a clean copy of the object, only returns copies of it's copy
	    var fieldCache = self.cache = new LocalCache();
	
	    /**
	     * Gets an object containing all fields with their mappings
	     * @param {dataSource} dataSource
	     * @param {boolean} skipIndexPatternCache - should we ping the index-pattern objects
	     * @returns {Promise}
	     * @async
	     */
	    self.getFieldsForIndexPattern = function (indexPattern, opts) {
	      var id = indexPattern.id;
	
	      var cache = fieldCache.get(id);
	      if (cache) return Promise.resolve(cache);
	
	      if (!opts.skipIndexPatternCache) {
	        return esAdmin.get({
	          index: kbnIndex,
	          type: 'index-pattern',
	          id: id,
	          _sourceInclude: ['fields']
	        }).then(function (resp) {
	          if (resp.found && resp._source.fields) {
	            fieldCache.set(id, JSON.parse(resp._source.fields));
	          }
	          return self.getFieldsForIndexPattern(indexPattern, { skipIndexPatternCache: true });
	        });
	      }
	
	      var indexList = id;
	      var promise = Promise.resolve();
	      if (indexPattern.intervalName) {
	        promise = self.getIndicesForIndexPattern(indexPattern).then(function (existing) {
	          if (existing.matches.length === 0) throw new _uiErrors.IndexPatternMissingIndices();
	          indexList = existing.matches.slice(-config.get('indexPattern:fieldMapping:lookBack')); // Grab the most recent
	        });
	      }
	
	      return promise.then(function () {
	        return es.indices.getFieldMapping({
	          index: indexList,
	          fields: '*',
	          ignoreUnavailable: _lodash2['default'].isArray(indexList),
	          allowNoIndices: false,
	          includeDefaults: true
	        });
	      })['catch'](handleMissingIndexPattern).then(transformMappingIntoFields).then(function (fields) {
	        return enhanceFieldsWithCapabilities(fields, indexList);
	      }).then(function (fields) {
	        fieldCache.set(id, fields);
	        return fieldCache.get(id);
	      });
	    };
	
	    self.getIndicesForIndexPattern = function (indexPattern) {
	      return es.indices.getAlias({
	        index: patternToWildcard(indexPattern.id)
	      }).then(function (resp) {
	        // let all = Object.keys(resp).sort();
	        var all = (0, _lodash2['default'])(resp).map(function (index, key) {
	          if (index.aliases) {
	            return [_Object$keys(index.aliases), key];
	          } else {
	            return key;
	          }
	        }).flattenDeep().sort().uniq(true).value();
	
	        var matches = all.filter(function (existingIndex) {
	          var parsed = (0, _moment2['default'])(existingIndex, indexPattern.id);
	          return existingIndex === parsed.format(indexPattern.id);
	        });
	
	        return {
	          all: all,
	          matches: matches
	        };
	      })['catch'](handleMissingIndexPattern);
	    };
	
	    /**
	     * Clears mapping caches from elasticsearch and from local object
	     * @param {dataSource} dataSource
	     * @returns {Promise}
	     * @async
	     */
	    self.clearCache = function (indexPattern) {
	      fieldCache.clear(indexPattern);
	      return Promise.resolve();
	    };
	  }
	
	  function handleMissingIndexPattern(err) {
	    if (err.status >= 400) {
	      // transform specific error type
	      return Promise.reject(new _uiErrors.IndexPatternMissingIndices(err.message));
	    } else {
	      // rethrow all others
	      throw err;
	    }
	  }
	
	  return new Mapper();
	}
	
	module.exports = exports['default'];

/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _uiChrome = __webpack_require__(1);
	
	var _uiChrome2 = _interopRequireDefault(_uiChrome);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	exports['default'] = function ($http) {
	
	  return function (fields, indices) {
	    return $http.get(_uiChrome2['default'].addBasePath('/api/kibana/' + indices + '/field_capabilities')).then(function (res) {
	      var stats = _lodash2['default'].get(res, 'data.fields', {});
	
	      return _lodash2['default'].map(fields, function (field) {
	        if (field.type === 'geo_point' && !stats[field.name]) {
	          // FIXME: remove once https://github.com/elastic/elasticsearch/issues/20707 is fixed
	          return _lodash2['default'].assign(field, {
	            'searchable': true,
	            'aggregatable': true
	          });
	        }
	
	        return _lodash2['default'].assign(field, stats[field.name]);
	      });
	    });
	  };
	};
	
	module.exports = exports['default'];

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = transformMappingIntoFields;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_map_field = __webpack_require__(499);
	
	var _uiIndex_patterns_map_field2 = _interopRequireDefault(_uiIndex_patterns_map_field);
	
	var _uiIndex_patterns_conflict_tracker = __webpack_require__(501);
	
	function transformMappingIntoFields(Private, kbnIndex, config) {
	  var mapField = Private(_uiIndex_patterns_map_field2['default']);
	
	  /**
	   * Convert the ES response into the simple map for fields to
	   * mappings which we will cache
	   *
	   * @param  {object} response - complex, excessively nested
	   *                           object returned from ES
	   * @return {object} - simple object that works for all of kibana
	   *                    use-cases
	   */
	  return function (response) {
	    var fields = {};
	    var conflictTracker = new _uiIndex_patterns_conflict_tracker.ConflictTracker();
	
	    _lodash2['default'].each(response, function (index, indexName) {
	      if (indexName === kbnIndex) return;
	      _lodash2['default'].each(index.mappings, function (mappings) {
	        _lodash2['default'].each(mappings, function (field, name) {
	          var keys = _Object$keys(field.mapping);
	          if (keys.length === 0 || name[0] === '_' && !_lodash2['default'].contains(config.get('metaFields'), name)) return;
	
	          var mapping = mapField(field, name);
	          // track the name, type and index for every field encountered so that the source
	          // of conflicts can be described later
	          conflictTracker.trackField(name, mapping.type, indexName);
	
	          if (fields[name]) {
	            if (fields[name].type !== mapping.type) {
	              // conflict fields are not available for much except showing in the discover table
	              // overwrite the entire mapping object to reset all fields
	              fields[name] = { type: 'conflict' };
	            }
	          } else {
	            fields[name] = _lodash2['default'].pick(mapping, 'type', 'indexed', 'analyzed', 'doc_values');
	          }
	        });
	      });
	    });
	
	    config.get('metaFields').forEach(function (meta) {
	      if (fields[meta]) return;
	
	      var field = { mapping: {} };
	      field.mapping[meta] = {};
	      fields[meta] = mapField(field, meta);
	    });
	
	    return _lodash2['default'].map(fields, function (mapping, name) {
	      mapping.name = name;
	
	      if (mapping.type === 'conflict') {
	        mapping.conflictDescriptions = conflictTracker.describeConflict(name);
	      }
	
	      return mapping;
	    });
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = MapFieldFn;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_cast_mapping_type = __webpack_require__(500);
	
	var _uiIndex_patterns_cast_mapping_type2 = _interopRequireDefault(_uiIndex_patterns_cast_mapping_type);
	
	function MapFieldFn(Private, config) {
	  var castMappingType = Private(_uiIndex_patterns_cast_mapping_type2['default']);
	
	  /**
	   * Accepts a field object and its name, and tries to give it a mapping
	   * @param  {Object} field - the field mapping returned by elasticsearch
	   * @param  {String} type - name of the field
	   * @return {Object} - the resulting field after overrides and tweaking
	   */
	  return function mapField(field, name) {
	    var keys = _Object$keys(field.mapping);
	    if (keys.length === 0 || name[0] === '_' && !_lodash2['default'].contains(config.get('metaFields'), name)) return;
	
	    // Override the mapping, even if elasticsearch says otherwise
	    var mappingOverrides = {
	      _source: { type: '_source' },
	      _index: { type: 'string' },
	      _type: { type: 'string' },
	      _id: { type: 'string' },
	      _timestamp: {
	        type: 'date',
	        indexed: true
	      },
	      _score: {
	        type: 'number',
	        indexed: false
	      }
	    };
	
	    var mapping = _lodash2['default'].cloneDeep(field.mapping[keys.shift()]);
	
	    if (!mapping.index || mapping.index === 'no') {
	      // elasticsearch responds with false sometimes and 'no' others
	      mapping.indexed = false;
	    } else {
	      mapping.indexed = true;
	    }
	
	    mapping.analyzed = mapping.index === 'analyzed' || mapping.type === 'text';
	
	    mapping.type = castMappingType(mapping.type);
	
	    if (mappingOverrides[name]) {
	      _lodash2['default'].merge(mapping, mappingOverrides[name]);
	    }
	
	    return mapping;
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CastMappingTypeFn;
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	function CastMappingTypeFn() {
	
	  castMappingType.types = new _uiIndexed_array2['default']({
	    index: ['name'],
	    group: ['type'],
	    immutable: true,
	    initialSet: [{ name: 'string', type: 'string', group: 'base' }, { name: 'text', type: 'string', group: 'base' }, { name: 'keyword', type: 'string', group: 'base' }, { name: 'date', type: 'date', group: 'base' }, { name: 'boolean', type: 'boolean', group: 'base' }, { name: 'float', type: 'number', group: 'number' }, { name: 'half_float', type: 'number', group: 'number' }, { name: 'scaled_float', type: 'number', group: 'number' }, { name: 'double', type: 'number', group: 'number' }, { name: 'integer', type: 'number', group: 'number' }, { name: 'long', type: 'number', group: 'number' }, { name: 'short', type: 'number', group: 'number' }, { name: 'byte', type: 'number', group: 'number' }, { name: 'token_count', type: 'number', group: 'number' }, { name: 'geo_point', type: 'geo_point', group: 'geo' }, { name: 'geo_shape', type: 'geo_shape', group: 'geo' }, { name: 'ip', type: 'ip', group: 'other' }, { name: 'attachment', type: 'attachment', group: 'other' }, { name: 'murmur3', type: 'murmur3', group: 'hash' }]
	  });
	
	  /**
	   * Accepts a mapping type, and converts it into it's js equivilent
	   * @param  {String} type - the type from the mapping's 'type' field
	   * @return {String} - the most specific type that we care for
	   */
	  function castMappingType(name) {
	    if (!name) return 'unknown';
	
	    var match = castMappingType.types.byName[name];
	    return match ? match.type : 'string';
	  }
	
	  return castMappingType;
	}
	
	module.exports = exports['default'];

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var ConflictTracker = (function () {
	  function ConflictTracker() {
	    _classCallCheck(this, ConflictTracker);
	
	    this._history = [];
	  }
	
	  _createClass(ConflictTracker, [{
	    key: 'trackField',
	    value: function trackField(name, type, index) {
	      this._history.push({ name: name, type: type, index: index });
	    }
	  }, {
	    key: 'describeConflict',
	    value: function describeConflict(name) {
	      var fieldHistory = (0, _lodash.where)(this._history, { name: name });
	      var entriesByType = (0, _lodash.groupBy)(fieldHistory, 'type');
	
	      return (0, _lodash.mapValues)(entriesByType, function (entries) {
	        var indices = (0, _lodash.uniq)((0, _lodash.pluck)(entries, 'index'));
	
	        // keep the list short so we don't polute the .kibana index
	        if (indices.length > 10) {
	          var total = indices.length;
	          indices.length = 9;
	          indices.push('... and ' + (total - indices.length) + ' others');
	        }
	
	        return indices;
	      });
	    }
	  }]);
	
	  return ConflictTracker;
	})();

	exports.ConflictTracker = ConflictTracker;

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IndexNameIntervalsService;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	function IndexNameIntervalsService(timefilter) {
	
	  var intervals = new _uiIndexed_array2['default']({
	    index: ['name'],
	    initialSet: [{
	      name: 'hours',
	      startOf: 'hour',
	      display: 'Hourly'
	    }, {
	      name: 'days',
	      startOf: 'day',
	      display: 'Daily'
	    }, {
	      name: 'weeks',
	      startOf: 'isoWeek',
	      display: 'Weekly'
	    }, {
	      name: 'months',
	      startOf: 'month',
	      display: 'Monthly'
	    }, {
	      name: 'years',
	      startOf: 'year',
	      display: 'Yearly'
	    }]
	  });
	
	  intervals.toIndexList = function (format, interval, a, b, sortDirection) {
	    var bounds = undefined;
	
	    // setup the range that the list will span, return two moment objects that
	    // are in proper order. a and b can be numbers to specify to go before or after now (respectively)
	    // a certain number of times, based on the interval
	    var range = [[a, 'min', 'startOf'], [b, 'max', 'startOf']].map(function (v) {
	      var val = v[0];
	      var bound = v[1];
	      var extend = v[2];
	
	      // grab a bound from the time filter
	      if (val == null) {
	        bounds = bounds || timefilter.getBounds();
	        val = bounds[bound];
	      }
	
	      if (_lodash2['default'].isNumeric(val)) val = (0, _moment2['default'])().add(val, interval.name);else if (!_moment2['default'].isMoment(val)) val = (0, _moment2['default'])(val);
	
	      return val.clone().utc()[extend](interval.startOf);
	    }).sort(function (a, b) {
	      return a - b;
	    });
	
	    if (typeof interval === 'string') {
	      interval = _lodash2['default'].find(intervals, { name: interval });
	      if (!interval) throw new Error('Interval must be one of ' + _lodash2['default'].pluck(intervals, 'name'));
	    }
	
	    var indexList = [];
	    var start = range.shift();
	    // turn stop into milliseconds to that it's not constantly converted by the while condition
	    var stop = range.shift().valueOf();
	
	    var add = sortDirection === 'desc' ? 'unshift' : 'push';
	
	    while (start <= stop) {
	      var index = start.format(format);
	      var next = (0, _moment2['default'])(start).add(1, interval.name);
	      var bound = (0, _moment2['default'])(next).subtract(1, 'ms');
	
	      var min = start.valueOf();
	      var max = bound.valueOf();
	      indexList[add]({
	        index: index,
	        min: min,
	        max: max
	      });
	
	      start = next;
	    }
	
	    return indexList;
	  };
	
	  return intervals;
	}
	
	module.exports = exports['default'];

/***/ },
/* 503 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = PatternToWildcardFn;
	
	function PatternToWildcardFn() {
	  return function (format) {
	    var wildcard = '';
	    var inEscape = false;
	    var inPattern = false;
	
	    for (var i = 0; i < format.length; i++) {
	      var ch = format.charAt(i);
	      switch (ch) {
	        case '[':
	          inPattern = false;
	          if (!inEscape) {
	            inEscape = true;
	          } else {
	            wildcard += ch;
	          }
	          break;
	        case ']':
	          if (inEscape) {
	            inEscape = false;
	          } else if (!inPattern) {
	            wildcard += ch;
	          }
	          break;
	        default:
	          if (inEscape) {
	            wildcard += ch;
	          } else if (!inPattern) {
	            wildcard += '*';
	            inPattern = true;
	          }
	      }
	    }
	
	    return wildcard;
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = LocalCacheFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	function LocalCacheFactory() {
	  function LocalCache(opts) {
	    opts = opts || {};
	    var _id = opts.id || function (o) {
	      return '' + o;
	    };
	    var _cache = {};
	
	    this.get = function (obj) {
	      var id = _id(obj);
	      return _cache[id] ? JSON.parse(_cache[id]) : null;
	    };
	
	    this.set = function (obj, val) {
	      var id = _id(obj);
	      var clean = !_cache.hasOwnProperty(id);
	      _cache[id] = _angular2['default'].toJson(val);
	      return clean;
	    };
	
	    this.clear = function (obj) {
	      if (!obj) {
	        _cache = {};
	        return;
	      }
	
	      var id = _id(obj);
	      delete _cache[id];
	    };
	  }
	
	  return LocalCache;
	}
	
	module.exports = exports['default'];

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name AdminDocSource
	 */
	
	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocSourceFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _abstract_doc_source = __webpack_require__(506);
	
	var _abstract_doc_source2 = _interopRequireDefault(_abstract_doc_source);
	
	var _fetchStrategyDoc_admin = __webpack_require__(531);
	
	var _fetchStrategyDoc_admin2 = _interopRequireDefault(_fetchStrategyDoc_admin);
	
	var _fetchRequestDoc_admin = __webpack_require__(532);
	
	var _fetchRequestDoc_admin2 = _interopRequireDefault(_fetchRequestDoc_admin);
	
	function DocSourceFactory(Private) {
	  var AbstractDocSource = Private(_abstract_doc_source2['default']);
	  var docStrategy = Private(_fetchStrategyDoc_admin2['default']);
	  var DocRequest = Private(_fetchRequestDoc_admin2['default']);
	
	  var AdminDocSource = (function (_AbstractDocSource) {
	    _inherits(AdminDocSource, _AbstractDocSource);
	
	    function AdminDocSource(initialState) {
	      _classCallCheck(this, AdminDocSource);
	
	      _get(Object.getPrototypeOf(AdminDocSource.prototype), 'constructor', this).call(this, initialState, docStrategy);
	    }
	
	    _createClass(AdminDocSource, [{
	      key: '_createRequest',
	      value: function _createRequest(defer) {
	        return new DocRequest(this, defer);
	      }
	    }]);
	
	    return AdminDocSource;
	  })(AbstractDocSource);
	
	  return AdminDocSource;
	}
	
	module.exports = exports['default'];

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name AbstractDocSource
	 *
	 * NOTE: This class is tightly coupled with _doc_send_to_es. Its primary
	 * methods (`doUpdate`, `doIndex`, `doCreate`) are all proxies for methods
	 * exposed by _doc_send_to_es (`update`, `index`, `create`). These methods are
	 * called with AbstractDocSource as the context. When called, they depend on private
	 * AbstractDocSource methods within their execution.
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AbstractDocSourceFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(478);
	
	__webpack_require__(392);
	
	var _doc_send_to_es = __webpack_require__(507);
	
	var _doc_send_to_es2 = _interopRequireDefault(_doc_send_to_es);
	
	var _abstract = __webpack_require__(522);
	
	var _abstract2 = _interopRequireDefault(_abstract);
	
	var _fetchRequest_abstract_doc = __webpack_require__(530);
	
	var _fetchRequest_abstract_doc2 = _interopRequireDefault(_fetchRequest_abstract_doc);
	
	function AbstractDocSourceFactory(Private, Promise, es, sessionStorage) {
	  var sendToEs = Private(_doc_send_to_es2['default']);
	  var SourceAbstract = Private(_abstract2['default']);
	  var DocRequest = Private(_fetchRequest_abstract_doc2['default']);
	
	  _lodash2['default']['class'](AbstractDocSource).inherits(SourceAbstract);
	  function AbstractDocSource(initialState, strategy) {
	    AbstractDocSource.Super.call(this, initialState, strategy);
	  }
	
	  AbstractDocSource.prototype.onUpdate = SourceAbstract.prototype.onResults;
	  AbstractDocSource.prototype.onResults = void 0;
	
	  /*****
	   * PUBLIC API
	   *****/
	
	  AbstractDocSource.prototype._createRequest = function (defer) {
	    return new DocRequest(this, defer);
	  };
	
	  /**
	   * List of methods that is turned into a chainable API in the constructor
	   * @type {Array}
	   */
	  AbstractDocSource.prototype._methods = ['index', 'type', 'id', 'sourceInclude', 'sourceExclude'];
	
	  /**
	   * Applies a partial update to the document
	   * @param  {object} fields - The fields to change and their new values (es doc field)
	   * @return {undefined}
	   */
	  AbstractDocSource.prototype.doUpdate = function (fields) {
	    if (!this._state.id) return this.doIndex(fields);
	    return sendToEs.call(this, 'update', false, { doc: fields });
	  };
	
	  /**
	   * Update the document stored
	   * @param  {[type]}   body [description]
	   * @return {[type]}        [description]
	   */
	  AbstractDocSource.prototype.doIndex = function (body) {
	    return sendToEs.call(this, 'index', false, body);
	  };
	
	  AbstractDocSource.prototype.doCreate = function (body) {
	    return sendToEs.call(this, 'create', false, body, []);
	  };
	
	  /*****
	   * PRIVATE API
	   *****/
	
	  /**
	   * Get the type of this SourceAbstract
	   * @return {string} - 'doc'
	   */
	  AbstractDocSource.prototype._getType = function () {
	    return 'doc';
	  };
	
	  /**
	   * Used to merge properties into the state within ._flatten().
	   * The state is passed in and modified by the function
	   *
	   * @param  {object} state - the current merged state
	   * @param  {*} val - the value at `key`
	   * @param  {*} key - The key of `val`
	   * @return {undefined}
	   */
	  AbstractDocSource.prototype._mergeProp = function (state, val, key) {
	    var flatKey = '_' + key;
	
	    if (val != null && state[flatKey] == null) {
	      state[flatKey] = val;
	    }
	  };
	
	  /**
	   * Creates a key based on the doc's index/type/id
	   * @return {string}
	   */
	  AbstractDocSource.prototype._versionKey = function () {
	    var state = this._state;
	
	    if (!state.index || !state.type || !state.id) return;
	    return 'DocVersion:' + [state.index, state.type, state.id].map(encodeURIComponent).join('/');
	  };
	
	  /**
	   * Get the cached version number, not the version that is
	   * stored/shared with other tabs
	   *
	   * @return {number} - the version number, or undefined
	   */
	  AbstractDocSource.prototype._getVersion = function () {
	    if (this._version) return this._version;else return this._getStoredVersion();
	  };
	
	  /**
	   * Fetches the stored version from storage
	   * @return {[type]} [description]
	   */
	  AbstractDocSource.prototype._getStoredVersion = function () {
	    var key = this._versionKey();
	    if (!key) return;
	
	    var v = sessionStorage.get(key);
	    this._version = v ? _lodash2['default'].parseInt(v) : void 0;
	    return this._version;
	  };
	
	  /**
	   * Stores the version into storage
	   * @param  {number, NaN} version - the current version number, NaN works well forcing a refresh
	   * @return {undefined}
	   */
	  AbstractDocSource.prototype._storeVersion = function (version) {
	    if (!version) return this._clearVersion();
	
	    var key = this._versionKey();
	    if (!key) return;
	    this._version = version;
	    sessionStorage.set(key, version);
	  };
	
	  /**
	   * Clears the stored version for a AbstractDocSource
	   */
	  AbstractDocSource.prototype._clearVersion = function () {
	    var key = this._versionKey();
	    if (!key) return;
	    sessionStorage.remove(key);
	  };
	
	  return AbstractDocSource;
	}
	
	module.exports = exports['default'];

/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name _doc_send_to_es
	 *
	 * NOTE: Depends upon the es object to make ES requests, and also interacts
	 * with courier objects.
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	var _uiCourier_request_queue = __webpack_require__(508);
	
	var _uiCourier_request_queue2 = _interopRequireDefault(_uiCourier_request_queue);
	
	var _uiCourierFetchFetch = __webpack_require__(509);
	
	var _uiCourierFetchFetch2 = _interopRequireDefault(_uiCourierFetchFetch);
	
	exports['default'] = function (Promise, Private, es, esAdmin, kbnIndex) {
	  var requestQueue = Private(_uiCourier_request_queue2['default']);
	  var courierFetch = Private(_uiCourierFetchFetch2['default']);
	
	  /**
	   * Backend for doUpdate and doIndex
	   * @param  {String} method - the client method to call
	   * @param  {Boolean} validateVersion - should our knowledge
	   *                                   of the the docs current version be sent to es?
	   * @param  {String} body - HTTP request body
	   */
	  return function (method, validateVersion, body, ignore) {
	    var doc = this;
	    // straight assignment will causes undefined values
	    var params = _lodash2['default'].pick(this._state, ['id', 'type', 'index']);
	    params.body = body;
	    params.ignore = ignore || [409];
	
	    if (validateVersion && params.id) {
	      params.version = doc._getVersion();
	    }
	
	    var client = [].concat(params.index).includes(kbnIndex) ? esAdmin : es;
	    return client[method](params).then(function (resp) {
	      if (resp.status === 409) throw new _uiErrors2['default'].VersionConflict(resp);
	
	      doc._storeVersion(resp._version);
	      doc.id(resp._id);
	
	      var docFetchProm = undefined;
	      if (method !== 'index') {
	        docFetchProm = doc.fetch();
	      } else {
	        // we already know what the response will be
	        docFetchProm = Promise.resolve({
	          _id: resp._id,
	          _index: params.index,
	          _source: body,
	          _type: params.type,
	          _version: doc._getVersion(),
	          found: true
	        });
	      }
	
	      // notify pending request for this same document that we have updates
	      docFetchProm.then(function (fetchResp) {
	        // use the key to compair sources
	        var key = doc._versionKey();
	
	        // clear the queue and filter out the removed items, pushing the
	        // unmatched ones back in.
	        var respondTo = requestQueue.splice(0).filter(function (req) {
	          var isDoc = req.source._getType() === 'doc';
	          var keyMatches = isDoc && req.source._versionKey() === key;
	
	          // put some request back into the queue
	          if (!keyMatches) {
	            requestQueue.push(req);
	            return false;
	          }
	
	          return true;
	        });
	
	        return courierFetch.fakeFetchThese(respondTo, respondTo.map(function () {
	          return _lodash2['default'].cloneDeep(fetchResp);
	        }));
	      });
	
	      return resp._id;
	    })['catch'](function (err) {
	      // cast the error
	      throw new _uiErrors2['default'].RequestFailure(err);
	    });
	  };
	};
	
	module.exports = exports['default'];

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = PendingRequestList;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function PendingRequestList() {
	
	  /**
	   * Queue of pending requests, requests are removed as
	   * they are processed by fetch.[sourceType]().
	   * @type {Array}
	   */
	  var queue = [];
	
	  queue.getInactive = function () /* strategies */{
	    return queue.get.apply(queue, arguments).filter(function (req) {
	      return !req.started;
	    });
	  };
	
	  queue.getStartable = function () {
	    return queue.get.apply(queue, arguments).filter(function (req) {
	      return req.canStart();
	    });
	  };
	
	  queue.get = function () {
	    for (var _len = arguments.length, strategies = Array(_len), _key = 0; _key < _len; _key++) {
	      strategies[_key] = arguments[_key];
	    }
	
	    return queue.filter(function (req) {
	      var strategyMatch = !strategies.length;
	      if (!strategyMatch) {
	        strategyMatch = strategies.some(function (strategy) {
	          return req.strategy === strategy;
	        });
	      }
	
	      return strategyMatch;
	    });
	  };
	
	  return queue;
	}
	
	module.exports = exports['default'];

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = fetchService;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _request_queue = __webpack_require__(508);
	
	var _request_queue2 = _interopRequireDefault(_request_queue);
	
	var _fetch_these = __webpack_require__(510);
	
	var _fetch_these2 = _interopRequireDefault(_fetch_these);
	
	var _call_response_handlers = __webpack_require__(520);
	
	var _call_response_handlers2 = _interopRequireDefault(_call_response_handlers);
	
	var _req_status = __webpack_require__(519);
	
	var _req_status2 = _interopRequireDefault(_req_status);
	
	function fetchService(Private, Promise) {
	
	  var requestQueue = Private(_request_queue2['default']);
	  var immediatelyFetchThese = Private(_fetch_these2['default']);
	  var callResponseHandlers = Private(_call_response_handlers2['default']);
	  var INCOMPLETE = Private(_req_status2['default']).INCOMPLETE;
	
	  var debouncedFetchThese = _lodash2['default'].debounce(function () {
	    var requests = requestQueue.get().filter(function (req) {
	      return req.isFetchRequestedAndPending();
	    });
	    immediatelyFetchThese(requests);
	  }, {
	    wait: 10,
	    maxWait: 50
	  });
	
	  var fetchTheseSoon = function fetchTheseSoon(requests) {
	    requests.forEach(function (req) {
	      return req._setFetchRequested();
	    });
	    debouncedFetchThese();
	    return Promise.all(requests.map(function (req) {
	      return req.getCompletePromise();
	    }));
	  };
	
	  this.fetchQueued = function (strategy) {
	    return fetchTheseSoon(requestQueue.getStartable(strategy));
	  };
	
	  function fetchASource(source, strategy) {
	    var defer = Promise.defer();
	
	    fetchTheseSoon([source._createRequest(defer)]);
	
	    return defer.promise;
	  }
	
	  /**
	   * Fetch a single doc source
	   * @param {DocSource} source - The DocSource to request
	   * @async
	   */
	  this.doc = fetchASource;
	
	  /**
	   * Fetch a single search source
	   * @param {SearchSource} source - The SearchSource to request
	   * @async
	   */
	  this.search = fetchASource;
	
	  /**
	   * Fetch a list of requests
	   * @param {array} reqs - the requests to fetch
	   * @async
	   */
	  this.these = fetchTheseSoon;
	
	  /**
	   * Send responses to a list of requests, used when requests
	   * should be skipped (like when a doc is updated with an index).
	   *
	   * This logic is a simplified version of what fetch_these does, and
	   * could have been added elsewhere, but I would rather the logic be
	   * here than outside the courier/fetch module.
	   *
	   * @param {array[Request]} requests - the list of requests to respond to
	   * @param {array[any]} responses - the list of responses for each request
	   */
	  this.fakeFetchThese = function (requests, responses) {
	    return Promise.map(requests, function (req) {
	      return req.start();
	    }).then(function () {
	      return callResponseHandlers(requests, responses);
	    }).then(function (requestStates) {
	      if (_lodash2['default'].contains(requestStates, INCOMPLETE)) {
	        throw new Error('responding to requests did not complete!');
	      }
	    });
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FetchTheseProvider;
	
	var _notifier = __webpack_require__(511);
	
	var _notifier2 = _interopRequireDefault(_notifier);
	
	var _for_each_strategy = __webpack_require__(512);
	
	var _for_each_strategy2 = _interopRequireDefault(_for_each_strategy);
	
	var _call_client = __webpack_require__(513);
	
	var _call_client2 = _interopRequireDefault(_call_client);
	
	var _call_response_handlers = __webpack_require__(520);
	
	var _call_response_handlers2 = _interopRequireDefault(_call_response_handlers);
	
	var _continue_incomplete = __webpack_require__(521);
	
	var _continue_incomplete2 = _interopRequireDefault(_continue_incomplete);
	
	var _req_status = __webpack_require__(519);
	
	var _req_status2 = _interopRequireDefault(_req_status);
	
	function FetchTheseProvider(Private, Promise) {
	  var notify = Private(_notifier2['default']);
	  var forEachStrategy = Private(_for_each_strategy2['default']);
	
	  // core tasks
	  var callClient = Private(_call_client2['default']);
	  var callResponseHandlers = Private(_call_response_handlers2['default']);
	  var continueIncomplete = Private(_continue_incomplete2['default']);
	
	  var ABORTED = Private(_req_status2['default']).ABORTED;
	  var DUPLICATE = Private(_req_status2['default']).DUPLICATE;
	  var INCOMPLETE = Private(_req_status2['default']).INCOMPLETE;
	
	  function fetchThese(requests) {
	    return forEachStrategy(requests, function (strategy, reqsForStrategy) {
	      return fetchWithStrategy(strategy, reqsForStrategy.map(function (req) {
	        if (!req.started) return req;
	        return req.retry();
	      }));
	    })['catch'](notify.fatal);
	  }
	
	  function fetchWithStrategy(strategy, requests) {
	    function replaceAbortedRequests() {
	      requests = requests.map(function (r) {
	        return r.aborted ? ABORTED : r;
	      });
	    }
	
	    replaceAbortedRequests();
	    return startRequests(requests).then(function () {
	      replaceAbortedRequests();
	      return callClient(strategy, requests);
	    }).then(function (responses) {
	      replaceAbortedRequests();
	      return callResponseHandlers(requests, responses);
	    }).then(function (responses) {
	      replaceAbortedRequests();
	      return continueIncomplete(strategy, requests, responses, fetchWithStrategy);
	    }).then(function (responses) {
	      replaceAbortedRequests();
	      return responses.map(function (resp) {
	        switch (resp) {
	          case ABORTED:
	            return null;
	          case DUPLICATE:
	          case INCOMPLETE:
	            throw new Error('Failed to clear incomplete or duplicate request from responses.');
	          default:
	            return resp;
	        }
	      });
	    });
	  }
	
	  function startRequests(requests) {
	    return Promise.map(requests, function (req) {
	      if (req === ABORTED) {
	        return req;
	      }
	
	      return new Promise(function (resolve) {
	        var action = req.started ? req['continue'] : req.start;
	        resolve(action.call(req));
	      })['catch'](function (err) {
	        return req.handleFailure(err);
	      });
	    });
	  }
	
	  return fetchThese;
	}
	
	module.exports = exports['default'];

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CourierFetchNotifier;
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	function CourierFetchNotifier() {
	  return new _uiNotifyNotifier2['default']({
	    location: 'Courier Fetch'
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FetchForEachRequestStrategy;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function FetchForEachRequestStrategy(Private, Promise) {
	  function forEachStrategy(requests, block) {
	    block = Promise.method(block);
	    var sets = [];
	
	    requests.forEach(function (req) {
	      var strategy = req.strategy;
	      var set = _lodash2['default'].find(sets, { 0: strategy });
	      if (set) set[1].push(req);else sets.push([strategy, [req]]);
	    });
	
	    return Promise.all(sets.map(function (set) {
	      return block(set[0], set[1]);
	    }));
	  }
	
	  return forEachStrategy;
	}
	
	module.exports = exports['default'];

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CourierFetchCallClient;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _is_request = __webpack_require__(514);
	
	var _is_request2 = _interopRequireDefault(_is_request);
	
	var _merge_duplicate_requests = __webpack_require__(518);
	
	var _merge_duplicate_requests2 = _interopRequireDefault(_merge_duplicate_requests);
	
	var _req_status = __webpack_require__(519);
	
	var _req_status2 = _interopRequireDefault(_req_status);
	
	function CourierFetchCallClient(Private, Promise, esAdmin, es) {
	
	  var isRequest = Private(_is_request2['default']);
	  var mergeDuplicateRequests = Private(_merge_duplicate_requests2['default']);
	
	  var ABORTED = Private(_req_status2['default']).ABORTED;
	  var DUPLICATE = Private(_req_status2['default']).DUPLICATE;
	
	  function callClient(strategy, requests) {
	    // merging docs can change status to DUPLICATE, capture new statuses
	    var statuses = mergeDuplicateRequests(requests);
	
	    // get the actual list of requests that we will be fetching
	    var executable = statuses.filter(isRequest);
	    var execCount = executable.length;
	
	    if (!execCount) return Promise.resolve([]);
	
	    // resolved by respond()
	    var esPromise = undefined;
	    var defer = Promise.defer();
	
	    // for each respond with either the response or ABORTED
	    var respond = function respond(responses) {
	      responses = responses || [];
	      return Promise.map(requests, function (req, i) {
	        switch (statuses[i]) {
	          case ABORTED:
	            return ABORTED;
	          case DUPLICATE:
	            return req._uniq.resp;
	          default:
	            return responses[_lodash2['default'].findIndex(executable, req)];
	        }
	      }).then(function (res) {
	        return defer.resolve(res);
	      }, function (err) {
	        return defer.reject(err);
	      });
	    };
	
	    // handle a request being aborted while being fetched
	    var requestWasAborted = Promise.method(function (req, i) {
	      if (statuses[i] === ABORTED) {
	        defer.reject(new Error('Request was aborted twice?'));
	      }
	
	      execCount -= 1;
	      if (execCount > 0) {
	        // the multi-request still contains other requests
	        return;
	      }
	
	      if (esPromise && _lodash2['default'].isFunction(esPromise.abort)) {
	        esPromise.abort();
	      }
	
	      esPromise = ABORTED;
	
	      return respond();
	    });
	
	    // attach abort handlers, close over request index
	    statuses.forEach(function (req, i) {
	      if (!isRequest(req)) return;
	      req.whenAborted(function () {
	        requestWasAborted(req, i)['catch'](defer.reject);
	      });
	    });
	
	    // Now that all of THAT^^^ is out of the way, lets actually
	    // call out to elasticsearch
	    Promise.map(executable, function (req) {
	      return Promise['try'](req.getFetchParams, void 0, req).then(function (fetchParams) {
	        return req.fetchParams = fetchParams;
	      });
	    }).then(function (reqsFetchParams) {
	      return strategy.reqsFetchParamsToBody(reqsFetchParams);
	    }).then(function (body) {
	      // while the strategy was converting, our request was aborted
	      if (esPromise === ABORTED) {
	        throw ABORTED;
	      }
	
	      var id = strategy.id;
	      var client = id && id.includes('admin') ? esAdmin : es;
	      return esPromise = client[strategy.clientMethod]({ body: body });
	    }).then(function (clientResp) {
	      return strategy.getResponses(clientResp);
	    }).then(respond)['catch'](function (err) {
	      if (err === ABORTED) respond();else defer.reject(err);
	    });
	
	    // return our promise, but catch any errors we create and
	    // send them to the requests
	    return defer.promise['catch'](function (err) {
	      requests.forEach(function (req, i) {
	        if (statuses[i] !== ABORTED) {
	          req.handleFailure(err);
	        }
	      });
	    });
	  }
	
	  return callClient;
	}
	
	module.exports = exports['default'];

/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IsRequestProvider;
	
	var _request = __webpack_require__(515);
	
	var _request2 = _interopRequireDefault(_request);
	
	function IsRequestProvider(Private) {
	  var AbstractRequest = Private(_request2['default']);
	
	  return function isRequest(obj) {
	    return obj instanceof AbstractRequest;
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AbstractReqProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	var _request_queue = __webpack_require__(508);
	
	var _request_queue2 = _interopRequireDefault(_request_queue);
	
	var _error_handler = __webpack_require__(516);
	
	var _error_handler2 = _interopRequireDefault(_error_handler);
	
	function AbstractReqProvider(Private, Promise) {
	  var requestQueue = Private(_request_queue2['default']);
	  var requestErrorHandler = Private(_error_handler2['default']);
	
	  return (function () {
	    function AbstractReq(source, defer) {
	      _classCallCheck(this, AbstractReq);
	
	      this.source = source;
	      this.defer = defer || Promise.defer();
	      this.abortedDefer = Promise.defer();
	      requestQueue.push(this);
	    }
	
	    /**
	     *  Called by the loopers to find requests that should be sent to the
	     *  fetch() module. When a module is sent to fetch() it's _fetchRequested flag
	     *  is set, and this consults that flag so requests are not send to fetch()
	     *  multiple times.
	     *
	     *  @return {Boolean}
	     */
	
	    _createClass(AbstractReq, [{
	      key: 'canStart',
	      value: function canStart() {
	        return !this._fetchRequested && !this.stopped && !this.source._fetchDisabled;
	      }
	
	      /**
	       *  Used to find requests that were previously sent to the fetch() module but
	       *  have not been started yet, so they can be started.
	       *
	       *  @return {Boolean}
	       */
	    }, {
	      key: 'isFetchRequestedAndPending',
	      value: function isFetchRequestedAndPending() {
	        return this._fetchRequested && !this.started;
	      }
	
	      /**
	       *  Called by the fetch() module when this request has been sent to
	       *  be fetched. At that point the request is somewhere between `ready-to-start`
	       *  and `started`. The fetch module then waits a short period of time to
	       *  allow requests to build up in the request queue, and then immediately
	       *  fetches all requests that return true from `isFetchRequestedAndPending()`
	       *
	       *  @return {undefined}
	       */
	    }, {
	      key: '_setFetchRequested',
	      value: function _setFetchRequested() {
	        this._fetchRequested = true;
	      }
	    }, {
	      key: 'start',
	      value: function start() {
	        if (this.started) {
	          throw new TypeError('Unable to start request because it has already started');
	        }
	
	        this.started = true;
	        this.moment = (0, _moment2['default'])();
	
	        var source = this.source;
	        if (source.activeFetchCount) {
	          source.activeFetchCount += 1;
	        } else {
	          source.activeFetchCount = 1;
	        }
	
	        source.history = [this];
	      }
	    }, {
	      key: 'getFetchParams',
	      value: function getFetchParams() {
	        return this.source._flatten();
	      }
	    }, {
	      key: 'transformResponse',
	      value: function transformResponse(resp) {
	        return resp;
	      }
	    }, {
	      key: 'filterError',
	      value: function filterError(resp) {
	        return false;
	      }
	    }, {
	      key: 'handleResponse',
	      value: function handleResponse(resp) {
	        this.success = true;
	        this.resp = resp;
	      }
	    }, {
	      key: 'handleFailure',
	      value: function handleFailure(error) {
	        this.success = false;
	        this.resp = error && error.resp;
	        this.retry();
	        return requestErrorHandler(this, error);
	      }
	    }, {
	      key: 'isIncomplete',
	      value: function isIncomplete() {
	        return false;
	      }
	    }, {
	      key: 'continue',
	      value: function _continue() {
	        throw new Error('Unable to continue ' + this.type + ' request');
	      }
	    }, {
	      key: 'retry',
	      value: function retry() {
	        var clone = this.clone();
	        this.abort();
	        return clone;
	      }
	    }, {
	      key: '_markStopped',
	      value: function _markStopped() {
	        if (this.stopped) return;
	        this.stopped = true;
	        this.source.activeFetchCount -= 1;
	        _lodash2['default'].pull(requestQueue, this);
	      }
	    }, {
	      key: 'abort',
	      value: function abort() {
	        this._markStopped();
	        this.defer = null;
	        this.aborted = true;
	        this.abortedDefer.resolve();
	        this.abortedDefer = null;
	      }
	    }, {
	      key: 'whenAborted',
	      value: function whenAborted(cb) {
	        this.abortedDefer.promise.then(cb);
	      }
	    }, {
	      key: 'complete',
	      value: function complete() {
	        this._markStopped();
	        this.ms = this.moment.diff() * -1;
	        this.defer.resolve(this.resp);
	      }
	    }, {
	      key: 'getCompletePromise',
	      value: function getCompletePromise() {
	        return this.defer.promise;
	      }
	    }, {
	      key: 'getCompleteOrAbortedPromise',
	      value: function getCompleteOrAbortedPromise() {
	        return Promise.race([this.defer.promise, this.abortedDefer.promise]);
	      }
	    }, {
	      key: 'clone',
	      value: function clone() {
	        return new this.constructor(this.source, this.defer);
	      }
	    }]);
	
	    return AbstractReq;
	  })();
	}
	
	module.exports = exports['default'];

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RequestErrorHandlerFactory;
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	var _error_handlers = __webpack_require__(517);
	
	var _error_handlers2 = _interopRequireDefault(_error_handlers);
	
	function RequestErrorHandlerFactory(Private) {
	  var errHandlers = Private(_error_handlers2['default']);
	
	  var notify = new _uiNotifyNotifier2['default']({
	    location: 'Courier Fetch Error'
	  });
	
	  function handleError(req, error) {
	    var myHandlers = [];
	
	    errHandlers.splice(0).forEach(function (handler) {
	      (handler.source === req.source ? myHandlers : errHandlers).push(handler);
	    });
	
	    if (!myHandlers.length) {
	      notify.fatal(new Error('unhandled courier request error: ' + notify.describeError(error)));
	    } else {
	      myHandlers.forEach(function (handler) {
	        handler.defer.resolve(error);
	      });
	    }
	  }
	
	  return handleError;
	}
	
	module.exports = exports['default'];

/***/ },
/* 517 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = ErrorHandlerList;
	
	function ErrorHandlerList() {
	  /**
	   * Queue of pending error handlers, they are removed as
	   * they are resolved.
	   * @type {Array}
	   */
	  return [];
	}
	
	module.exports = exports["default"];

/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FetchMergeDuplicateRequests;
	
	var _is_request = __webpack_require__(514);
	
	var _is_request2 = _interopRequireDefault(_is_request);
	
	var _req_status = __webpack_require__(519);
	
	var _req_status2 = _interopRequireDefault(_req_status);
	
	function FetchMergeDuplicateRequests(Private) {
	  var isRequest = Private(_is_request2['default']);
	  var DUPLICATE = Private(_req_status2['default']).DUPLICATE;
	
	  function mergeDuplicateRequests(requests) {
	    // dedupe requests
	    var index = {};
	    return requests.map(function (req) {
	      if (!isRequest(req)) return req;
	
	      var iid = req.source._instanceid;
	      if (!index[iid]) {
	        // this request is unique so far
	        index[iid] = req;
	        // keep the request
	        return req;
	      }
	
	      // the source was requested at least twice
	      req._uniq = index[iid];
	      return DUPLICATE;
	    });
	  }
	
	  return mergeDuplicateRequests;
	}
	
	module.exports = exports['default'];

/***/ },
/* 519 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CourierFetchRequestStatus;
	
	function CourierFetchRequestStatus() {
	  return {
	    ABORTED: { CourierFetchRequestStatus: 'aborted' },
	    DUPLICATE: { CourierFetchRequestStatus: 'duplicate' },
	    INCOMPLETE: { CourierFetchRequestStatus: 'incomplete' }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CourierFetchCallResponseHandlers;
	
	var _uiErrors = __webpack_require__(359);
	
	var _req_status = __webpack_require__(519);
	
	var _req_status2 = _interopRequireDefault(_req_status);
	
	var _notifier = __webpack_require__(511);
	
	var _notifier2 = _interopRequireDefault(_notifier);
	
	function CourierFetchCallResponseHandlers(Private, Promise) {
	  var ABORTED = Private(_req_status2['default']).ABORTED;
	  var INCOMPLETE = Private(_req_status2['default']).INCOMPLETE;
	  var notify = Private(_notifier2['default']);
	
	  function callResponseHandlers(requests, responses) {
	    return Promise.map(requests, function (req, i) {
	      if (req === ABORTED || req.aborted) {
	        return ABORTED;
	      }
	
	      var resp = responses[i];
	
	      if (resp.timed_out) {
	        notify.warning(new _uiErrors.SearchTimeout());
	      }
	
	      if (resp._shards && resp._shards.failed) {
	        notify.warning(new _uiErrors.ShardFailure(resp));
	      }
	
	      function progress() {
	        if (req.isIncomplete()) {
	          return INCOMPLETE;
	        }
	
	        req.complete();
	        return resp;
	      }
	
	      if (resp.error) {
	        if (req.filterError(resp)) {
	          return progress();
	        } else {
	          return req.handleFailure(new _uiErrors.RequestFailure(null, resp));
	        }
	      }
	
	      return Promise['try'](function () {
	        return req.transformResponse(resp);
	      }).then(function () {
	        resp = arguments[0];
	        return req.handleResponse(resp);
	      }).then(progress);
	    });
	  }
	
	  return callResponseHandlers;
	}
	
	module.exports = exports['default'];

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CourierFetchContinueIncompleteRequests;
	
	var _req_status = __webpack_require__(519);
	
	var _req_status2 = _interopRequireDefault(_req_status);
	
	function CourierFetchContinueIncompleteRequests(Private) {
	  var INCOMPLETE = Private(_req_status2['default']).INCOMPLETE;
	
	  function continueIncompleteRequests(strategy, requests, responses, fetchWithStrategy) {
	    var incomplete = [];
	
	    responses.forEach(function (resp, i) {
	      if (resp === INCOMPLETE) {
	        incomplete.push(requests[i]);
	      }
	    });
	
	    if (!incomplete.length) return responses;
	
	    return fetchWithStrategy(strategy, incomplete).then(function (completedResponses) {
	      return responses.map(function (prevResponse) {
	        if (prevResponse !== INCOMPLETE) return prevResponse;
	        return completedResponses.shift();
	      });
	    });
	  }
	
	  return continueIncompleteRequests;
	}
	
	module.exports = exports['default'];

/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SourceAbstractFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(391);
	
	var _request_queue = __webpack_require__(508);
	
	var _request_queue2 = _interopRequireDefault(_request_queue);
	
	var _error_handlers = __webpack_require__(517);
	
	var _error_handlers2 = _interopRequireDefault(_error_handlers);
	
	var _fetch = __webpack_require__(509);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _decorate_query = __webpack_require__(523);
	
	var _decorate_query2 = _interopRequireDefault(_decorate_query);
	
	var _field_wildcard = __webpack_require__(524);
	
	var _field_wildcard2 = _interopRequireDefault(_field_wildcard);
	
	var _highlight = __webpack_require__(525);
	
	function SourceAbstractFactory(Private, Promise, PromiseEmitter) {
	  var requestQueue = Private(_request_queue2['default']);
	  var errorHandlers = Private(_error_handlers2['default']);
	  var courierFetch = Private(_fetch2['default']);
	
	  var _Private = Private(_field_wildcard2['default']);
	
	  var fieldWildcardFilter = _Private.fieldWildcardFilter;
	
	  var getHighlightRequest = Private(_highlight.getHighlightRequestProvider);
	
	  function SourceAbstract(initialState, strategy) {
	    var self = this;
	    self._instanceid = _lodash2['default'].uniqueId('data_source');
	
	    self._state = (function () {
	      // state can be serialized as JSON, and passed back in to restore
	      if (initialState) {
	        if (typeof initialState === 'string') {
	          return JSON.parse(initialState);
	        } else {
	          return _lodash2['default'].cloneDeep(initialState);
	        }
	      } else {
	        return {};
	      }
	    })();
	
	    // set internal state values
	    self._methods.forEach(function (name) {
	      self[name] = function (val) {
	        if (val == null) {
	          delete self._state[name];
	        } else {
	          self._state[name] = val;
	        }
	
	        return self;
	      };
	    });
	
	    self.history = [];
	    self._fetchStrategy = strategy;
	  }
	
	  /*****
	   * PUBLIC API
	   *****/
	
	  /**
	   * Get values from the state
	   * @param {string} name - The name of the property desired
	   * @return {any} - the value found
	   */
	  SourceAbstract.prototype.get = function (name) {
	    var self = this;
	    while (self) {
	      if (self._state[name] !== void 0) return self._state[name];
	      self = self.getParent();
	    }
	  };
	
	  /**
	   * Get the value from our own state, don't traverse up the chain
	   * @param {string} name - The name of the property desired
	   * @return {any} - the value found
	   */
	  SourceAbstract.prototype.getOwn = function (name) {
	    if (this._state[name] !== void 0) return this._state[name];
	  };
	
	  /**
	   * Change the entire state of a SourceAbstract
	   * @param {object|string} state - The SourceAbstract's new state, or a
	   *   string of the state value to set
	   */
	  SourceAbstract.prototype.set = function (state, val) {
	    var self = this;
	
	    if (typeof state === 'string') {
	      // the getter and setter methods check for undefined explicitly
	      // to identify getters and null to identify deletion
	      if (val === undefined) {
	        val = null;
	      }
	      self[state](val);
	    } else {
	      self._state = state;
	    }
	    return self;
	  };
	
	  /**
	   * Create a new dataSource object of the same type
	   * as this, which inherits this dataSource's properties
	   * @return {SourceAbstract}
	   */
	  SourceAbstract.prototype.extend = function () {
	    return new this.Class().inherits(this);
	  };
	
	  /**
	   * return a simple, encodable object representing the state of the SourceAbstract
	   * @return {[type]} [description]
	   */
	  SourceAbstract.prototype.toJSON = function () {
	    return _lodash2['default'].clone(this._state);
	  };
	
	  /**
	   * Create a string representation of the object
	   * @return {[type]} [description]
	   */
	  SourceAbstract.prototype.toString = function () {
	    return _angular2['default'].toJson(this.toJSON());
	  };
	
	  /**
	   * Put a request in to the courier that this Source should
	   * be fetched on the next run of the courier
	   * @return {Promise}
	   */
	  SourceAbstract.prototype.onResults = function (handler) {
	    var self = this;
	
	    return new PromiseEmitter(function (resolve, reject) {
	      var defer = Promise.defer();
	      defer.promise.then(resolve, reject);
	
	      self._createRequest(defer);
	    }, handler);
	  };
	
	  /**
	   * Noop
	   */
	  SourceAbstract.prototype.getParent = function () {
	    return this._parent;
	  };
	
	  /**
	   * similar to onResults, but allows a seperate loopy code path
	   * for error handling.
	   *
	   * @return {Promise}
	   */
	  SourceAbstract.prototype.onError = function (handler) {
	    var self = this;
	
	    return new PromiseEmitter(function (resolve, reject) {
	      var defer = Promise.defer();
	      defer.promise.then(resolve, reject);
	
	      errorHandlers.push({
	        source: self,
	        defer: defer
	      });
	    }, handler);
	  };
	
	  /**
	   * Fetch just this source ASAP
	   *
	   * ONLY USE IF YOU WILL BE USING THE RESULTS
	   * provided by the returned promise, otherwise
	   * call #fetchQueued()
	   *
	   * @async
	   */
	  SourceAbstract.prototype.fetch = function () {
	    var self = this;
	    var req = _lodash2['default'].first(self._myStartableQueued());
	
	    if (!req) {
	      req = self._createRequest();
	    }
	
	    courierFetch.these([req]);
	
	    return req.getCompletePromise();
	  };
	
	  /**
	   * Fetch all pending requests for this source ASAP
	   * @async
	   */
	  SourceAbstract.prototype.fetchQueued = function () {
	    return courierFetch.these(this._myStartableQueued());
	  };
	
	  /**
	   * Cancel all pending requests for this dataSource
	   * @return {undefined}
	   */
	  SourceAbstract.prototype.cancelQueued = function () {
	    var _this = this;
	
	    requestQueue.get(this._fetchStrategy).filter(function (req) {
	      return req.source === _this;
	    }).forEach(function (req) {
	      return req.abort();
	    });
	  };
	
	  /**
	   * Completely destroy the SearchSource.
	   * @return {undefined}
	   */
	  SourceAbstract.prototype.destroy = function () {
	    this.cancelQueued();
	  };
	
	  /*****
	   * PRIVATE API
	   *****/
	
	  SourceAbstract.prototype._myStartableQueued = function () {
	    var _this2 = this;
	
	    return requestQueue.getStartable(this._fetchStrategy).filter(function (req) {
	      return req.source === _this2;
	    });
	  };
	
	  SourceAbstract.prototype._createRequest = function () {
	    throw new Error('_createRequest must be implemented by subclass');
	  };
	
	  /**
	   * Walk the inheritance chain of a source and return it's
	   * flat representaion (taking into account merging rules)
	   * @returns {Promise}
	   * @resolved {Object|null} - the flat state of the SourceAbstract
	   */
	  SourceAbstract.prototype._flatten = function () {
	    var type = this._getType();
	
	    // the merged state of this dataSource and it's ancestors
	    var flatState = {};
	
	    // function used to write each property from each state object in the chain to flat state
	    var root = this;
	
	    // start the chain at this source
	    var current = this;
	
	    // call the ittr and return it's promise
	    return (function ittr() {
	      // itterate the _state object (not array) and
	      // pass each key:value pair to source._mergeProp. if _mergeProp
	      // returns a promise, then wait for it to complete and call _mergeProp again
	      return Promise.all(_lodash2['default'].map(current._state, function ittr(value, key) {
	        if (Promise.is(value)) {
	          return value.then(function (value) {
	            return ittr(value, key);
	          });
	        }
	
	        var prom = root._mergeProp(flatState, value, key);
	        return Promise.is(prom) ? prom : null;
	      })).then(function () {
	        // move to this sources parent
	        var parent = current.getParent();
	        // keep calling until we reach the top parent
	        if (parent) {
	          current = parent;
	          return ittr();
	        }
	      });
	    })().then(function () {
	      if (type === 'search') {
	        (function () {
	          // This is down here to prevent the circular dependency
	          var decorateQuery = Private(_decorate_query2['default']);
	
	          flatState.body = flatState.body || {};
	
	          // defaults for the query
	          if (!flatState.body.query) {
	            flatState.body.query = {
	              'match_all': {}
	            };
	          }
	
	          if (flatState.body.size > 0) {
	            var computedFields = flatState.index.getComputedFields();
	            flatState.body.stored_fields = computedFields.storedFields;
	            flatState.body.script_fields = flatState.body.script_fields || {};
	            flatState.body.docvalue_fields = flatState.body.docvalue_fields || [];
	
	            _lodash2['default'].extend(flatState.body.script_fields, computedFields.scriptFields);
	            flatState.body.docvalue_fields = _lodash2['default'].union(flatState.body.docvalue_fields, computedFields.docvalueFields);
	
	            if (flatState.body._source) {
	              // exclude source fields for this index pattern specified by the user
	              var filter = fieldWildcardFilter(flatState.body._source.excludes);
	              flatState.body.docvalue_fields = flatState.body.docvalue_fields.filter(filter);
	            }
	          }
	
	          decorateQuery(flatState.body.query);
	
	          /**
	           * Create a filter that can be reversed for filters with negate set
	           * @param {boolean} reverse This will reverse the filter. If true then
	           *                          anything where negate is set will come
	           *                          through otherwise it will filter out
	           * @returns {function}
	           */
	          var filterNegate = function filterNegate(reverse) {
	            return function (filter) {
	              if (_lodash2['default'].isUndefined(filter.meta) || _lodash2['default'].isUndefined(filter.meta.negate)) return !reverse;
	              return filter.meta && filter.meta.negate === reverse;
	            };
	          };
	
	          /**
	          * Translate a filter into a query to support es 3+
	          * @param  {Object} filter - The filter to translate
	          * @return {Object} the query version of that filter
	          */
	          var translateToQuery = function translateToQuery(filter) {
	            if (!filter) return;
	
	            if (filter.query) {
	              return filter.query;
	            }
	
	            return filter;
	          };
	
	          /**
	           * Clean out any invalid attributes from the filters
	           * @param {object} filter The filter to clean
	           * @returns {object}
	           */
	          var cleanFilter = function cleanFilter(filter) {
	            return _lodash2['default'].omit(filter, ['meta']);
	          };
	
	          // switch to filtered query if there are filters
	          if (flatState.filters) {
	            if (flatState.filters.length) {
	              _lodash2['default'].each(flatState.filters, function (filter) {
	                if (filter.query) {
	                  decorateQuery(filter.query);
	                }
	              });
	
	              flatState.body.query = {
	                bool: {
	                  must: [flatState.body.query].concat((flatState.filters || []).filter(filterNegate(false)).map(translateToQuery).map(cleanFilter)),
	                  must_not: (flatState.filters || []).filter(filterNegate(true)).map(translateToQuery).map(cleanFilter)
	                }
	              };
	            }
	            delete flatState.filters;
	          }
	
	          if (flatState.highlightAll != null) {
	            if (flatState.highlightAll && flatState.body.query) {
	              flatState.body.highlight = getHighlightRequest(flatState.body.query);
	            }
	            delete flatState.highlightAll;
	          }
	
	          // re-write filters within filter aggregations
	          (function recurse(aggBranch) {
	            if (!aggBranch) return;
	            _Object$keys(aggBranch).forEach(function (id) {
	              var agg = aggBranch[id];
	
	              if (agg.filters) {
	                (function () {
	                  // translate filters aggregations
	                  var filters = agg.filters.filters;
	
	                  _Object$keys(filters).forEach(function (filterId) {
	                    filters[filterId] = translateToQuery(filters[filterId]);
	                  });
	                })();
	              }
	
	              recurse(agg.aggs || agg.aggregations);
	            });
	          })(flatState.body.aggs || flatState.body.aggregations);
	        })();
	      }
	
	      return flatState;
	    });
	  };
	
	  return SourceAbstract;
	}
	
	module.exports = exports['default'];

/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DecorateQuery;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function DecorateQuery(config) {
	  /**
	   * Decorate queries with default parameters
	   * @param {query} query object
	   * @returns {object}
	   */
	  return function (query) {
	    var queryOptions = config.get('query:queryString:options');
	
	    if (_lodash2['default'].has(query, 'query_string.query')) {
	      _lodash2['default'].extend(query.query_string, queryOptions);
	    }
	
	    return query;
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = fieldWildcard;
	
	var _lodash = __webpack_require__(3);
	
	function fieldWildcard(config) {
	  var metaFields = config.get('metaFields');
	
	  var makeRegEx = (0, _lodash.memoize)(function makeRegEx(glob) {
	    return new RegExp('^' + glob.split('*').map(_lodash.escapeRegExp).join('.*') + '$');
	  });
	
	  function fieldWildcardMatcher(globs) {
	    return function matcher(val) {
	      // do not test metaFields or keyword
	      if (metaFields.indexOf(val) !== -1) {
	        return false;
	      }
	      return globs.some(function (p) {
	        return makeRegEx(p).test(val);
	      });
	    };
	  }
	
	  function fieldWildcardFilter(globs) {
	    var matcher = fieldWildcardMatcher(globs);
	    return function filter(val) {
	      return !matcher(val);
	    };
	  }
	
	  return { makeRegEx: makeRegEx, fieldWildcardMatcher: fieldWildcardMatcher, fieldWildcardFilter: fieldWildcardFilter };
	}
	
	module.exports = exports['default'];

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _highlight_html = __webpack_require__(526);
	
	var _highlight_html2 = _interopRequireDefault(_highlight_html);
	
	var _highlight_request = __webpack_require__(529);
	
	var _highlight_request2 = _interopRequireDefault(_highlight_request);
	
	exports['default'] = {
	  getHighlightHtml: _highlight_html2['default'],
	  getHighlightRequestProvider: _highlight_request2['default']
	};
	module.exports = exports['default'];

/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = getHighlightHtml;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _highlight_tags = __webpack_require__(527);
	
	var _highlight_tags2 = _interopRequireDefault(_highlight_tags);
	
	var _html_tags = __webpack_require__(528);
	
	var _html_tags2 = _interopRequireDefault(_html_tags);
	
	function getHighlightHtml(fieldValue, highlights) {
	  var highlightHtml = typeof fieldValue === 'object' ? _angular2['default'].toJson(fieldValue) : fieldValue;
	
	  _lodash2['default'].each(highlights, function (highlight) {
	    var escapedHighlight = _lodash2['default'].escape(highlight);
	
	    // Strip out the highlight tags to compare against the field text
	    var untaggedHighlight = escapedHighlight.split(_highlight_tags2['default'].pre).join('').split(_highlight_tags2['default'].post).join('');
	
	    // Replace all highlight tags with proper html tags
	    var taggedHighlight = escapedHighlight.split(_highlight_tags2['default'].pre).join(_html_tags2['default'].pre).split(_highlight_tags2['default'].post).join(_html_tags2['default'].post);
	
	    // Replace all instances of the untagged string with the properly tagged string
	    highlightHtml = highlightHtml.split(untaggedHighlight).join(taggedHighlight);
	  });
	
	  return highlightHtml;
	}
	
	module.exports = exports['default'];

/***/ },
/* 527 */
/***/ function(module, exports) {

	// By default, ElasticSearch surrounds matched values in <em></em>. This is not ideal because it is possible that
	// the value could contain <em></em> in the value. We define these custom tags that we would never expect to see
	// inside a field value.
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = {
	  pre: '@kibana-highlighted-field@',
	  post: '@/kibana-highlighted-field@'
	};
	module.exports = exports['default'];

/***/ },
/* 528 */
/***/ function(module, exports) {

	// These are the html tags that will replace the highlight tags.
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = {
	  pre: '<mark>',
	  post: '</mark>'
	};
	module.exports = exports['default'];

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = getHighlightRequestProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _highlight_tags = __webpack_require__(527);
	
	var _highlight_tags2 = _interopRequireDefault(_highlight_tags);
	
	var FRAGMENT_SIZE = Math.pow(2, 31) - 1; // Max allowed value for fragment_size (limit of a java int)
	
	/**
	  * Returns a clone of the query with `"all_fields": true` set on any `query_string` queries
	  */
	function getHighlightQuery(query) {
	  var clone = _lodash2['default'].cloneDeep(query);
	
	  if (_lodash2['default'].has(clone, 'query_string') && !_lodash2['default'].has(clone, ['query_string', 'default_field']) && !_lodash2['default'].has(clone, ['query_string', 'fields'])) {
	    clone.query_string.all_fields = true;
	  } else if (_lodash2['default'].has(clone, 'bool.must')) {
	    if (Array.isArray(clone.bool.must)) {
	      clone.bool.must = clone.bool.must.map(getHighlightQuery);
	    } else {
	      clone.bool.must = getHighlightQuery(clone.bool.must);
	    }
	  }
	
	  return clone;
	}
	
	function getHighlightRequestProvider(config) {
	  return function getHighlightRequest(query) {
	    if (!config.get('doc_table:highlight')) return;
	
	    var fieldsParams = config.get('doc_table:highlight:all_fields') ? { highlight_query: getHighlightQuery(query) } : {};
	
	    return {
	      pre_tags: [_highlight_tags2['default'].pre],
	      post_tags: [_highlight_tags2['default'].post],
	      fields: {
	        '*': fieldsParams
	      },
	      fragment_size: FRAGMENT_SIZE
	    };
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocRequestProvider;
	
	var _request = __webpack_require__(515);
	
	var _request2 = _interopRequireDefault(_request);
	
	function DocRequestProvider(Private) {
	
	  var AbstractRequest = Private(_request2['default']);
	
	  var AbstractDocRequest = (function (_AbstractRequest) {
	    _inherits(AbstractDocRequest, _AbstractRequest);
	
	    function AbstractDocRequest() {
	      _classCallCheck(this, AbstractDocRequest);
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      _get(Object.getPrototypeOf(AbstractDocRequest.prototype), 'constructor', this).apply(this, args);
	
	      this.type = 'doc';
	    }
	
	    _createClass(AbstractDocRequest, [{
	      key: 'canStart',
	      value: function canStart() {
	        var parent = _get(Object.getPrototypeOf(AbstractDocRequest.prototype), 'canStart', this).call(this);
	        if (!parent) return false;
	
	        var version = this.source._version;
	        var storedVersion = this.source._getStoredVersion();
	
	        // conditions that equal "fetch This DOC!"
	        var unknown = !version && !storedVersion;
	        var mismatch = version !== storedVersion;
	
	        return Boolean(mismatch || unknown && !this.started);
	      }
	    }, {
	      key: 'handleResponse',
	      value: function handleResponse(resp) {
	        if (resp.found) {
	          this.source._storeVersion(resp._version);
	        } else {
	          this.source._clearVersion();
	        }
	
	        return _get(Object.getPrototypeOf(AbstractDocRequest.prototype), 'handleResponse', this).call(this, resp);
	      }
	    }]);
	
	    return AbstractDocRequest;
	  })(AbstractRequest);
	
	  return AbstractDocRequest;
	}
	
	module.exports = exports['default'];

/***/ },
/* 531 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FetchStrategyForDoc;
	
	function FetchStrategyForDoc(Promise) {
	  return {
	    id: 'doc_admin',
	    clientMethod: 'mget',
	
	    /**
	     * Flatten a series of requests into as ES request body
	     * @param  {array} requests - an array of flattened requests
	     * @return {Promise} - a promise that is fulfilled by the request body
	     */
	    reqsFetchParamsToBody: function reqsFetchParamsToBody(reqsFetchParams) {
	      return Promise.resolve({
	        docs: reqsFetchParams
	      });
	    },
	
	    /**
	     * Fetch the multiple responses from the ES Response
	     * @param  {object} resp - The response sent from Elasticsearch
	     * @return {array} - the list of responses
	     */
	    getResponses: function getResponses(resp) {
	      return resp.docs;
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocRequestProvider;
	
	var _strategyDoc_admin = __webpack_require__(531);
	
	var _strategyDoc_admin2 = _interopRequireDefault(_strategyDoc_admin);
	
	var _abstract_doc = __webpack_require__(530);
	
	var _abstract_doc2 = _interopRequireDefault(_abstract_doc);
	
	function DocRequestProvider(Private) {
	
	  var docStrategy = Private(_strategyDoc_admin2['default']);
	  var AbstractDocRequest = Private(_abstract_doc2['default']);
	
	  var AdminDocRequest = (function (_AbstractDocRequest) {
	    _inherits(AdminDocRequest, _AbstractDocRequest);
	
	    function AdminDocRequest() {
	      _classCallCheck(this, AdminDocRequest);
	
	      _get(Object.getPrototypeOf(AdminDocRequest.prototype), 'constructor', this).apply(this, arguments);
	
	      this.strategy = docStrategy;
	    }
	
	    return AdminDocRequest;
	  })(AbstractDocRequest);
	
	  return AdminDocRequest;
	}
	
	module.exports = exports['default'];

/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(2);
	__webpack_require__(17);
	__webpack_require__(3);
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function MappingSetupService(kbnIndex, esAdmin) {
	    var mappingSetup = this;
	
	    var json = {
	      _serialize: function _serialize(val) {
	        if (val != null) return _angular2['default'].toJson(val);
	      },
	      _deserialize: function _deserialize(val) {
	        if (val != null) return JSON.parse(val);
	      }
	    };
	
	    /**
	     * Use to create the mappings, but that should only happen one at a time
	     */
	    var activeTypeCreations = {};
	
	    /**
	     * Get the list of type's mapped in elasticsearch
	     * @return {[type]} [description]
	     */
	    var getKnownKibanaTypes = _lodash2['default'].once(function () {
	      return esAdmin.indices.getFieldMapping({
	        // only concerned with types in this kibana index
	        index: kbnIndex,
	        // check all types
	        type: '*',
	        // limit the response to just the _source field for each index
	        fields: '_source'
	      }).then(function (resp) {
	        // kbnIndex is not sufficient here, if the kibana indexed is aliased we need to use
	        // the root index name as key
	        var index = _lodash2['default'].keys(resp)[0];
	        return _lodash2['default'].keys(resp[index].mappings);
	      });
	    });
	
	    mappingSetup.expandShorthand = function (sh) {
	      return _lodash2['default'].mapValues(sh || {}, function (val, prop) {
	        // allow shortcuts for the field types, by just setting the value
	        // to the type name
	        if (typeof val === 'string') val = { type: val };
	
	        if (val.type === 'json') {
	          val.type = 'string';
	          val._serialize = json._serialize;
	          val._deserialize = json._deserialize;
	        }
	
	        return val;
	      });
	    };
	
	    mappingSetup.isDefined = function (type) {
	      return getKnownKibanaTypes().then(function (knownTypes) {
	        // if the type is in the knownTypes array already
	        return !! ~knownTypes.indexOf(type);
	      });
	    };
	
	    mappingSetup.setup = function (type, mapping) {
	      // if there is already a creation running for this index type
	      if (activeTypeCreations[type]) {
	        // return a promise that will reexecute the setup once the
	        // current is complete.
	        return activeTypeCreations[type].then(function () {
	          return mappingSetup.setup(type, mapping);
	        });
	      }
	
	      var prom = getKnownKibanaTypes().then(function (knownTypes) {
	        // if the type is in the knownTypes array already
	        if (~knownTypes.indexOf(type)) return false;
	
	        // we need to create the mapping
	        var body = {};
	        body[type] = {
	          properties: mapping
	        };
	
	        return esAdmin.indices.putMapping({
	          index: kbnIndex,
	          type: type,
	          body: body
	        }).then(function (resp) {
	          // add this type to the list of knownTypes
	          knownTypes.push(type);
	
	          // cast the response to "true", meaning
	          // the mapping exists
	          return true;
	        });
	      })
	      // wether this fails or not, remove it from the activeTypeCreations obj
	      // once complete
	      ['finally'](function () {
	        delete activeTypeCreations[type];
	      });
	
	      activeTypeCreations[type] = prom;
	      return prom;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FieldListProvider;
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_field = __webpack_require__(535);
	
	var _uiIndex_patterns_field2 = _interopRequireDefault(_uiIndex_patterns_field);
	
	function FieldListProvider(Private) {
	  var Field = Private(_uiIndex_patterns_field2['default']);
	
	  _lodash2['default']['class'](FieldList).inherits(_uiIndexed_array2['default']);
	  function FieldList(indexPattern, specs) {
	    FieldList.Super.call(this, {
	      index: ['name'],
	      group: ['type'],
	      initialSet: specs.map(function (field) {
	        return new Field(indexPattern, field);
	      })
	    });
	  }
	
	  return FieldList;
	}
	
	module.exports = exports['default'];

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FieldObjectProvider;
	
	var _uiUtilsObj_define = __webpack_require__(536);
	
	var _uiUtilsObj_define2 = _interopRequireDefault(_uiUtilsObj_define);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _uiIndex_patterns_field_types = __webpack_require__(539);
	
	var _uiIndex_patterns_field_types2 = _interopRequireDefault(_uiIndex_patterns_field_types);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	function FieldObjectProvider(Private, shortDotsFilter, $rootScope, Notifier) {
	  var notify = new Notifier({ location: 'IndexPattern Field' });
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var fieldTypes = Private(_uiIndex_patterns_field_types2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  function Field(indexPattern, spec) {
	    // unwrap old instances of Field
	    if (spec instanceof Field) spec = spec.$$spec;
	
	    // constuct this object using ObjDefine class, which
	    // extends the Field.prototype but gets it's properties
	    // defined using the logic below
	    var obj = new _uiUtilsObj_define2['default'](spec, Field.prototype);
	
	    if (spec.name === '_source') {
	      spec.type = '_source';
	    }
	
	    // find the type for this field, fallback to unknown type
	    var type = fieldTypes.byName[spec.type];
	    if (spec.type && !type) {
	      notify.error('Unknown field type "' + spec.type + '"' + ' for field "' + spec.name + '"' + ' in indexPattern "' + indexPattern.id + '"');
	    }
	
	    if (!type) type = fieldTypes.byName.unknown;
	
	    var format = spec.format;
	    if (!format || !(format instanceof FieldFormat)) {
	      format = indexPattern.fieldFormatMap[spec.name] || fieldFormats.getDefaultInstance(spec.type);
	    }
	
	    var indexed = !!spec.indexed;
	    var scripted = !!spec.scripted;
	    var sortable = spec.name === '_score' || (indexed || scripted) && type.sortable;
	    var filterable = spec.name === '_id' || scripted || indexed && type.filterable;
	    var searchable = !!spec.searchable || scripted;
	    var aggregatable = !!spec.aggregatable || scripted;
	    var visualizable = aggregatable;
	
	    obj.fact('name');
	    obj.fact('type');
	    obj.writ('count', spec.count || 0);
	
	    // scripted objs
	    obj.fact('scripted', scripted);
	    obj.writ('script', scripted ? spec.script : null);
	    obj.writ('lang', scripted ? spec.lang || 'painless' : null);
	
	    // mapping info
	    obj.fact('indexed', indexed);
	    obj.fact('analyzed', !!spec.analyzed);
	    obj.fact('doc_values', !!spec.doc_values);
	
	    // stats
	    obj.fact('searchable', searchable);
	    obj.fact('aggregatable', aggregatable);
	
	    // usage flags, read-only and won't be saved
	    obj.comp('format', format);
	    obj.comp('sortable', sortable);
	    obj.comp('filterable', filterable);
	    obj.comp('visualizable', visualizable);
	
	    // computed values
	    obj.comp('indexPattern', indexPattern);
	    obj.comp('displayName', shortDotsFilter(spec.name));
	    obj.comp('$$spec', spec);
	
	    // conflict info
	    obj.writ('conflictDescriptions');
	
	    return obj.create();
	  }
	
	  Field.prototype.routes = {
	    edit: '/management/kibana/indices/{{indexPattern.id}}/field/{{name}}'
	  };
	
	  return Field;
	}
	
	module.exports = exports['default'];

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$create = __webpack_require__(12)['default'];
	
	var _Object$defineProperty = __webpack_require__(243)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function ObjDefine(defaults, prototype) {
	  this.obj; // created by this.create()
	
	  this.descs = {};
	  this.defaults = defaults || {};
	  this.prototype = prototype || Object.prototype;
	}
	
	ObjDefine.REDEFINE_SUPPORTED = (function () {
	  var a = _Object$create(Object.prototype, {
	    prop: {
	      configurable: true,
	      value: 1
	    }
	  });
	
	  Object.defineProperty(a, 'prop', {
	    configurable: true,
	    value: 2
	  });
	
	  return a.prop === 2;
	})();
	
	/**
	 * normal value, writable and exported in JSON
	 *
	 * @param  {any} v - value
	 * @return {object} - property descriptor
	 */
	ObjDefine.prototype.writ = function (name, val) {
	  this._define(name, val, true, true);
	};
	
	/**
	 * known value, exported in JSON, not changeable
	 *
	 * @param  {any} v - value
	 * @return {object} - property descriptor
	 */
	ObjDefine.prototype.fact = function (name, val) {
	  this._define(name, val, true);
	};
	
	/**
	 * computed fact, not exported or changeable
	 *
	 * @param  {any} v - value
	 * @return {object} - property descriptor
	 */
	ObjDefine.prototype.comp = function (name, val) {
	  this._define(name, val);
	};
	
	/**
	 * Creates an object, decorated by the property descriptors
	 * created by other ObjDefine methods and inheritting form the
	 * prototype
	 *
	 * # note:
	 * If a value is writable, but the value is undefined, the property will
	 * be created by not exported to JSON unless the property is written to
	 *
	 * @return {object} - created object
	 */
	ObjDefine.prototype.create = function () {
	  var self = this;
	  self.obj = _Object$create(this.prototype, self.descs);
	
	  if (!ObjDefine.REDEFINE_SUPPORTED && !self.prototype.toJSON) {
	    // since we can't redefine properties as enumerable we will
	    // clone the object on serialization and choose which properties
	    // to include or trim manually. This is currently only in use in PhantomJS
	    // due to https://github.com/ariya/phantomjs/issues/11856
	    self.obj.toJSON = function () {
	      return _lodash2['default'].transform(self.obj, function (json, val, key) {
	        var desc = self.descs[key];
	        if (desc && desc.enumerable && val == null) return;
	        json[key] = val;
	      }, {});
	    };
	  }
	
	  return self.obj;
	};
	
	/**
	 * Private APIS
	 */
	
	ObjDefine.prototype._define = function (name, val, exported, changeable) {
	  val = val != null ? val : this.defaults[name];
	  this.descs[name] = this._describe(name, val, !!exported, !!changeable);
	};
	
	ObjDefine.prototype._describe = function (name, val, exported, changeable) {
	  var self = this;
	  var exists = val != null;
	
	  if (exported && ObjDefine.REDEFINE_SUPPORTED) {
	    return {
	      enumerable: exists,
	      configurable: true,
	      get: _lodash2['default'].constant(val),
	      set: function set(update) {
	        if (!changeable) return false;
	
	        // change the descriptor, since the value now exists.
	        self.descs[name] = self._describe(name, update, exported, changeable);
	
	        // apply the updated descriptor
	        _Object$defineProperty(self.obj, name, self.descs[name]);
	      }
	    };
	  }
	
	  if (exported && !ObjDefine.REDEFINE_SUPPORTED) {
	    return {
	      enumerable: true,
	      configurable: true,
	      writable: changeable,
	      value: val
	    };
	  }
	
	  return {
	    enumerable: false,
	    writable: changeable,
	    configurable: true,
	    value: val
	  };
	};
	
	exports['default'] = ObjDefine;
	module.exports = exports['default'];

/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FieldFormatClassProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_field_formatContent_types = __webpack_require__(538);
	
	var _uiIndex_patterns_field_formatContent_types2 = _interopRequireDefault(_uiIndex_patterns_field_formatContent_types);
	
	function FieldFormatClassProvider(config, $rootScope, Private) {
	  var contentTypes = Private(_uiIndex_patterns_field_formatContent_types2['default']);
	
	  function FieldFormat(params) {
	    var self = this;
	
	    // give the constructor a more appropriate name
	    self.type = self.constructor;
	
	    // keep the params and defaults seperate
	    self._params = params || {};
	    self._paramDefaults = self.type.paramDefaults || {};
	
	    // one content type, so assume text
	    if (_lodash2['default'].isFunction(self._convert)) {
	      self._convert = { text: self._convert };
	    }
	
	    contentTypes.setup(self);
	  }
	
	  FieldFormat.from = function (converter) {
	    _lodash2['default']['class'](FieldFormatFromConverter).inherits(FieldFormat);
	    function FieldFormatFromConverter(params) {
	      FieldFormatFromConverter.Super.call(this, params);
	    }
	    FieldFormatFromConverter.prototype._convert = converter;
	    return FieldFormatFromConverter;
	  };
	
	  /**
	   * Convert a raw value to a formated string
	   * @param  {any} value
	   * @param  {string} [contentType=text] - optional content type, the only two contentTypes
	   *                                currently supported are "html" and "text", which helps
	   *                                formatters adjust to different contexts
	   * @return {string} - the formatted string, which is assumed to be html, safe for
	   *                    injecting into the DOM or a DOM attribute
	   */
	  FieldFormat.prototype.convert = function (value, contentType) {
	    return this.getConverterFor(contentType)(value);
	  };
	
	  /**
	   * Get a convert function that is bound to a specific contentType
	   * @param  {string} [contentType=text]
	   * @return {function} - a bound converter function
	   */
	  FieldFormat.prototype.getConverterFor = function (contentType) {
	    return this._convert[contentType || 'text'];
	  };
	
	  /**
	   * Get the value of a param. This value may be a default value.
	   *
	   * @param  {string} name - the param name to fetch
	   * @return {any}
	   */
	  FieldFormat.prototype.param = function (name) {
	    var val = this._params[name];
	    if (val || val === false || val === 0) {
	      // truthy, false, or 0 are fine
	      // '', NaN, null, undefined, etc are not
	      return val;
	    }
	
	    return this._paramDefaults[name];
	  };
	
	  /**
	   * Get all of the params in a single object
	   * @return {object}
	   */
	  FieldFormat.prototype.params = function () {
	    return _lodash2['default'].cloneDeep(_lodash2['default'].defaults({}, this._params, this._paramDefaults));
	  };
	
	  /**
	   * serialize this format to a simple POJO, with only the params
	   * that are not default
	   *
	   * @return {object}
	   */
	  FieldFormat.prototype.toJSON = function () {
	    var type = this.type;
	    var defaults = this._paramDefaults;
	
	    var params = _lodash2['default'].transform(this._params, function (uniqParams, val, param) {
	      if (val !== defaults[param]) {
	        uniqParams[param] = val;
	      }
	    }, {});
	
	    if (!_lodash2['default'].size(params)) {
	      params = undefined;
	    }
	
	    return {
	      id: type.id,
	      params: params
	    };
	  };
	
	  return FieldFormat;
	}
	
	module.exports = exports['default'];

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = contentTypesProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiHighlight = __webpack_require__(525);
	
	function contentTypesProvider() {
	
	  var types = {
	    html: function html(format, convert) {
	      function recurse(value, field, hit) {
	        if (value == null) {
	          return _lodash2['default'].asPrettyString(value);
	        }
	
	        if (!value || typeof value.map !== 'function') {
	          return convert.call(format, value, field, hit);
	        }
	
	        var subVals = value.map(function (v) {
	          return recurse(v, field, hit);
	        });
	        var useMultiLine = subVals.some(function (sub) {
	          return sub.indexOf('\n') > -1;
	        });
	
	        return subVals.join(',' + (useMultiLine ? '\n' : ' '));
	      }
	
	      return function () {
	        return '<span ng-non-bindable>' + recurse.apply(undefined, arguments) + '</span>';
	      };
	    },
	
	    text: function text(format, convert) {
	      return function recurse(value) {
	        if (!value || typeof value.map !== 'function') {
	          return convert.call(format, value);
	        }
	
	        // format a list of values. In text contexts we just use JSON encoding
	        return _angular2['default'].toJson(value.map(recurse), true);
	      };
	    }
	  };
	
	  function fallbackText(value) {
	    return _lodash2['default'].asPrettyString(value);
	  }
	
	  function fallbackHtml(value, field, hit) {
	    var formatted = _lodash2['default'].escape(this.convert(value, 'text'));
	
	    if (!hit || !hit.highlight || !hit.highlight[field.name]) {
	      return formatted;
	    } else {
	      return (0, _uiHighlight.getHighlightHtml)(formatted, hit.highlight[field.name]);
	    }
	  }
	
	  function setup(format) {
	    var src = format._convert || {};
	    var converters = format._convert = {};
	
	    converters.text = types.text(format, src.text || fallbackText);
	    converters.html = types.html(format, src.html || fallbackHtml);
	
	    return format._convert;
	  }
	
	  return {
	    types: types,
	    setup: setup
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IndexPatternFieldTypes;
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	function IndexPatternFieldTypes() {
	
	  return new _uiIndexed_array2['default']({
	    index: ['name'],
	    group: ['sortable', 'filterable'],
	    immutable: true,
	    initialSet: [{ name: 'ip', sortable: true, filterable: true }, { name: 'date', sortable: true, filterable: true }, { name: 'string', sortable: true, filterable: true }, { name: 'number', sortable: true, filterable: true }, { name: 'boolean', sortable: true, filterable: true }, { name: 'conflict', sortable: false, filterable: false }, { name: 'geo_point', sortable: false, filterable: false }, { name: 'geo_shape', sortable: false, filterable: false }, { name: 'attachment', sortable: false, filterable: false }, { name: 'murmur3', sortable: false, filterable: false }, { name: 'unknown', sortable: false, filterable: false }, { name: '_source', sortable: false, filterable: false }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FlattenHitProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
	// returns a flattened version
	
	function FlattenHitProvider(config) {
	  var metaFields = config.get('metaFields');
	
	  config.watch('metaFields', function (value) {
	    metaFields = value;
	  });
	
	  function flattenHit(indexPattern, hit, deep) {
	    var flat = {};
	
	    // recursively merge _source
	    var fields = indexPattern.fields.byName;
	    (function flatten(obj, keyPrefix) {
	      keyPrefix = keyPrefix ? keyPrefix + '.' : '';
	      _lodash2['default'].forOwn(obj, function (val, key) {
	        key = keyPrefix + key;
	
	        if (deep) {
	          var isNestedField = fields[key] && fields[key].type === 'nested';
	          var isArrayOfObjects = _lodash2['default'].isArray(val) && _lodash2['default'].isPlainObject(_lodash2['default'].first(val));
	          if (isArrayOfObjects && !isNestedField) {
	            _lodash2['default'].each(val, function (v) {
	              return flatten(v, key);
	            });
	            return;
	          }
	        } else if (flat[key] !== void 0) {
	          return;
	        }
	
	        var hasValidMapping = fields[key] && fields[key].type !== 'conflict';
	        var isValue = !_lodash2['default'].isPlainObject(val);
	
	        if (hasValidMapping || isValue) {
	          if (!flat[key]) {
	            flat[key] = val;
	          } else if (_lodash2['default'].isArray(flat[key])) {
	            flat[key].push(val);
	          } else {
	            flat[key] = [flat[key], val];
	          }
	          return;
	        }
	
	        flatten(val, key);
	      });
	    })(hit._source);
	
	    // assign the meta fields
	    _lodash2['default'].each(metaFields, function (meta) {
	      if (meta === '_source') return;
	      flat[meta] = hit[meta];
	    });
	
	    // unwrap computed fields
	    _lodash2['default'].forOwn(hit.fields, function (val, key) {
	      if (key[0] === '_' && !_lodash2['default'].contains(metaFields, key)) return;
	      flat[key] = _lodash2['default'].isArray(val) && val.length === 1 ? val[0] : val;
	    });
	
	    return flat;
	  }
	
	  return function flattenHitWrapper(indexPattern) {
	    return function cachedFlatten(hit) {
	      var deep = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      return hit.$$_flattened || (hit.$$_flattened = flattenHit(indexPattern, hit, deep));
	    };
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _defineProperty = __webpack_require__(437)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CalculateIndicesFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	// gets parsed value if given arg is a moment object
	function timeValue(val) {
	  return _moment2['default'].isMoment(val) ? val.valueOf() : val;
	}
	
	// returns a properly formatted millisecond timestamp index constraint
	function msConstraint(comparison, value) {
	  var _ref;
	
	  return _ref = {}, _defineProperty(_ref, comparison, timeValue(value)), _defineProperty(_ref, 'format', 'epoch_millis'), _ref;
	}
	
	// returns a new object with any indexes removed that do not include the
	// time field
	//
	// fixme: this really seems like a bug that needs to be fixed in
	//        elasticsearch itself, but this workaround will do for now
	function omitIndicesWithoutTimeField(indices, timeFieldName) {
	  return _lodash2['default'].pick(indices, function (index) {
	    return index.fields[timeFieldName];
	  });
	}
	
	function CalculateIndicesFactory(Promise, es) {
	
	  // Uses the field stats api to determine the names of indices that need to
	  // be queried against that match the given pattern and fall within the
	  // given time range
	  function calculateIndices(pattern, timeFieldName, start, stop, sortDirection) {
	    return getFieldStats(pattern, timeFieldName, start, stop).then(function (resp) {
	      return omitIndicesWithoutTimeField(resp.indices, timeFieldName);
	    }).then(function (indices) {
	      return sortIndexStats(indices, timeFieldName, sortDirection);
	    });
	  }
	
	  // creates the configuration hash that must be passed to the elasticsearch
	  // client
	  function getFieldStats(pattern, timeFieldName, start, stop) {
	    var constraints = {};
	    if (start) {
	      constraints.max_value = msConstraint('gte', start);
	    }
	    if (stop) {
	      constraints.min_value = msConstraint('lte', stop);
	    }
	
	    return es.fieldStats({
	      index: pattern,
	      level: 'indices',
	      body: {
	        fields: [timeFieldName],
	        index_constraints: _defineProperty({}, timeFieldName, constraints)
	      }
	    });
	  }
	
	  function sortIndexStats(indices, timeFieldName, sortDirection) {
	    var desc = sortDirection === 'desc';
	    var leader = desc ? 'max' : 'min';
	
	    var indexDetails = (0, _lodash2['default'])(indices).map(function (stats, index) {
	      var field = stats.fields[timeFieldName];
	      return {
	        index: index,
	        min: field.min_value,
	        max: field.max_value
	      };
	    });
	
	    if (sortDirection) {
	      indexDetails = indexDetails.sortByOrder([leader], [sortDirection]);
	    }
	
	    return indexDetails.value();
	  }
	
	  return calculateIndices;
	}
	
	module.exports = exports['default'];

/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = PatternCache;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function PatternCache() {
	
	  var vals = {};
	
	  var validId = function validId(id) {
	    return typeof id !== 'object';
	  };
	
	  this.get = function (id) {
	    if (validId(id)) return vals[id];
	  };
	
	  this.set = function (id, prom) {
	    if (validId(id)) vals[id] = prom;
	    return prom;
	  };
	
	  this.clear = this['delete'] = function (id) {
	    if (validId(id)) delete vals[id];
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name DocSource
	 */
	
	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocSourceFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _abstract_doc_source = __webpack_require__(506);
	
	var _abstract_doc_source2 = _interopRequireDefault(_abstract_doc_source);
	
	var _fetchStrategyDoc_data = __webpack_require__(544);
	
	var _fetchStrategyDoc_data2 = _interopRequireDefault(_fetchStrategyDoc_data);
	
	var _fetchRequestDoc_data = __webpack_require__(545);
	
	var _fetchRequestDoc_data2 = _interopRequireDefault(_fetchRequestDoc_data);
	
	function DocSourceFactory(Private) {
	  var AbstractDocSource = Private(_abstract_doc_source2['default']);
	  var docStrategy = Private(_fetchStrategyDoc_data2['default']);
	  var DocRequest = Private(_fetchRequestDoc_data2['default']);
	
	  var DocSource = (function (_AbstractDocSource) {
	    _inherits(DocSource, _AbstractDocSource);
	
	    function DocSource(initialState) {
	      _classCallCheck(this, DocSource);
	
	      _get(Object.getPrototypeOf(DocSource.prototype), 'constructor', this).call(this, initialState, docStrategy);
	    }
	
	    _createClass(DocSource, [{
	      key: '_createRequest',
	      value: function _createRequest(defer) {
	        return new DocRequest(this, defer);
	      }
	    }]);
	
	    return DocSource;
	  })(AbstractDocSource);
	
	  return DocSource;
	}
	
	module.exports = exports['default'];

/***/ },
/* 544 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FetchStrategyForDoc;
	
	function FetchStrategyForDoc(Promise) {
	  return {
	    clientMethod: 'mget',
	
	    /**
	     * Flatten a series of requests into as ES request body
	     * @param  {array} requests - an array of flattened requests
	     * @return {Promise} - a promise that is fulfilled by the request body
	     */
	    reqsFetchParamsToBody: function reqsFetchParamsToBody(reqsFetchParams) {
	      return Promise.resolve({
	        docs: reqsFetchParams
	      });
	    },
	
	    /**
	     * Fetch the multiple responses from the ES Response
	     * @param  {object} resp - The response sent from Elasticsearch
	     * @return {array} - the list of responses
	     */
	    getResponses: function getResponses(resp) {
	      return resp.docs;
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocRequestProvider;
	
	var _strategyDoc_data = __webpack_require__(544);
	
	var _strategyDoc_data2 = _interopRequireDefault(_strategyDoc_data);
	
	var _abstract_doc = __webpack_require__(530);
	
	var _abstract_doc2 = _interopRequireDefault(_abstract_doc);
	
	function DocRequestProvider(Private) {
	
	  var docStrategy = Private(_strategyDoc_data2['default']);
	  var AbstractDocRequest = Private(_abstract_doc2['default']);
	
	  var DataDocRequest = (function (_AbstractDocRequest) {
	    _inherits(DataDocRequest, _AbstractDocRequest);
	
	    function DataDocRequest() {
	      _classCallCheck(this, DataDocRequest);
	
	      _get(Object.getPrototypeOf(DataDocRequest.prototype), 'constructor', this).apply(this, arguments);
	
	      this.strategy = docStrategy;
	    }
	
	    return DataDocRequest;
	  })(AbstractDocRequest);
	
	  return DataDocRequest;
	}
	
	module.exports = exports['default'];

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SearchSource
	 *
	 * @description A promise-based stream of search results that can inherit from other search sources.
	 *
	 * Because filters/queries in Kibana have different levels of persistence and come from different
	 * places, it is important to keep track of where filters come from for when they are saved back to
	 * the savedObject store in the Kibana index. To do this, we create trees of searchSource objects
	 * that can have associated query parameters (index, query, filter, etc) which can also inherit from
	 * other searchSource objects.
	 *
	 * At query time, all of the searchSource objects that have subscribers are "flattened", at which
	 * point the query params from the searchSource are collected while traversing up the inheritance
	 * chain. At each link in the chain a decision about how to merge the query params is made until a
	 * single set of query parameters is created for each active searchSource (a searchSource with
	 * subscribers).
	 *
	 * That set of query parameters is then sent to elasticsearch. This is how the filter hierarchy
	 * works in Kibana.
	 *
	 * Visualize, starting from a new search:
	 *
	 *  - the `savedVis.searchSource` is set as the `appSearchSource`.
	 *  - The `savedVis.searchSource` would normally inherit from the `appSearchSource`, but now it is
	 *    upgraded to inherit from the `rootSearchSource`.
	 *  - Any interaction with the visualization will still apply filters to the `appSearchSource`, so
	 *    they will be stored directly on the `savedVis.searchSource`.
	 *  - Any interaction with the time filter will be written to the `rootSearchSource`, so those
	 *    filters will not be saved by the `savedVis`.
	 *  - When the `savedVis` is saved to elasticsearch, it takes with it all the filters that are
	 *    defined on it directly, but none of the ones that it inherits from other places.
	 *
	 * Visualize, starting from an existing search:
	 *
	 *  - The `savedVis` loads the `savedSearch` on which it is built.
	 *  - The `savedVis.searchSource` is set to inherit from the `saveSearch.searchSource` and set as
	 *    the `appSearchSource`.
	 *  - The `savedSearch.searchSource`, is set to inherit from the `rootSearchSource`.
	 *  - Then the `savedVis` is written to elasticsearch it will be flattened and only include the
	 *    filters created in the visualize application and will reconnect the filters from the
	 *    `savedSearch` at runtime to prevent losing the relationship
	 *
	 * Dashboard search sources:
	 *
	 *  - Each panel in a dashboard has a search source.
	 *  - The `savedDashboard` also has a searchsource, and it is set as the `appSearchSource`.
	 *  - Each panel's search source inherits from the `appSearchSource`, meaning that they inherit from
	 *    the dashboard search source.
	 *  - When a filter is added to the search box, or via a visualization, it is written to the
	 *    `appSearchSource`.
	 */
	
	'use strict';
	
	var _Symbol = __webpack_require__(547)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SearchSourceFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _normalize_sort_request = __webpack_require__(552);
	
	var _normalize_sort_request2 = _interopRequireDefault(_normalize_sort_request);
	
	var _root_search_source = __webpack_require__(553);
	
	var _root_search_source2 = _interopRequireDefault(_root_search_source);
	
	var _abstract = __webpack_require__(522);
	
	var _abstract2 = _interopRequireDefault(_abstract);
	
	var _fetchRequestSearch = __webpack_require__(554);
	
	var _fetchRequestSearch2 = _interopRequireDefault(_fetchRequestSearch);
	
	var _fetchRequestSegmented = __webpack_require__(557);
	
	var _fetchRequestSegmented2 = _interopRequireDefault(_fetchRequestSegmented);
	
	var _fetchStrategySearch = __webpack_require__(555);
	
	var _fetchStrategySearch2 = _interopRequireDefault(_fetchStrategySearch);
	
	function SearchSourceFactory(Promise, Private, config) {
	  var SourceAbstract = Private(_abstract2['default']);
	  var SearchRequest = Private(_fetchRequestSearch2['default']);
	  var SegmentedRequest = Private(_fetchRequestSegmented2['default']);
	  var searchStrategy = Private(_fetchStrategySearch2['default']);
	  var normalizeSortRequest = Private(_normalize_sort_request2['default']);
	
	  var forIp = _Symbol('for which index pattern?');
	
	  function isIndexPattern(val) {
	    return Boolean(val && typeof val.toIndexList === 'function');
	  }
	
	  _lodash2['default']['class'](SearchSource).inherits(SourceAbstract);
	  function SearchSource(initialState) {
	    SearchSource.Super.call(this, initialState, searchStrategy);
	  }
	
	  /*****
	   * PUBLIC API
	   *****/
	
	  /**
	   * List of the editable state properties that turn into a
	   * chainable API
	   *
	   * @type {Array}
	   */
	  SearchSource.prototype._methods = ['type', 'query', 'filter', 'sort', 'highlight', 'highlightAll', 'aggs', 'from', 'size', 'source'];
	
	  SearchSource.prototype.index = function (indexPattern) {
	    var state = this._state;
	
	    var hasSource = state.source;
	    var sourceCameFromIp = hasSource && state.source.hasOwnProperty(forIp);
	    var sourceIsForOurIp = sourceCameFromIp && state.source[forIp] === state.index;
	    if (sourceIsForOurIp) {
	      delete state.source;
	    }
	
	    if (indexPattern === undefined) return state.index;
	    if (indexPattern === null) return delete state.index;
	    if (!isIndexPattern(indexPattern)) {
	      throw new TypeError('expected indexPattern to be an IndexPattern duck.');
	    }
	
	    state.index = indexPattern;
	    if (!state.source) {
	      // imply source filtering based on the index pattern, but allow overriding
	      // it by simply setting another value for "source". When index is changed
	      state.source = function () {
	        return indexPattern.getSourceFiltering();
	      };
	      state.source[forIp] = indexPattern;
	    }
	
	    return this;
	  };
	
	  SearchSource.prototype.extend = function () {
	    return new SearchSource().inherits(this);
	  };
	
	  /**
	   * Set a searchSource that this source should inherit from
	   * @param  {SearchSource} searchSource - the parent searchSource
	   * @return {this} - chainable
	   */
	  SearchSource.prototype.inherits = function (parent) {
	    this._parent = parent;
	    return this;
	  };
	
	  /**
	   * Get the parent of this SearchSource
	   * @return {undefined|searchSource}
	   */
	  SearchSource.prototype.getParent = function (onlyHardLinked) {
	    var self = this;
	    if (self._parent === false) return;
	    if (self._parent) return self._parent;
	    return onlyHardLinked ? undefined : Private(_root_search_source2['default']).get();
	  };
	
	  /**
	   * Temporarily prevent this Search from being fetched... not a fan but it's easy
	   */
	  SearchSource.prototype.disable = function () {
	    this._fetchDisabled = true;
	  };
	
	  /**
	   * Reverse of SourceAbstract#disable(), only need to call this if source was previously disabled
	   */
	  SearchSource.prototype.enable = function () {
	    this._fetchDisabled = false;
	  };
	
	  SearchSource.prototype.onBeginSegmentedFetch = function (initFunction) {
	    var self = this;
	    return Promise['try'](function addRequest() {
	      var req = new SegmentedRequest(self, Promise.defer(), initFunction);
	
	      // return promises created by the completion handler so that
	      // errors will bubble properly
	      return req.getCompletePromise().then(addRequest);
	    });
	  };
	
	  /******
	   * PRIVATE APIS
	   ******/
	
	  /**
	   * Gets the type of the DataSource
	   * @return {string}
	   */
	  SearchSource.prototype._getType = function () {
	    return 'search';
	  };
	
	  /**
	   * Create a common search request object, which should
	   * be put into the pending request queye, for this search
	   * source
	   *
	   * @param {Deferred} defer - the deferred object that should be resolved
	   *                         when the request is complete
	   * @return {SearchRequest}
	   */
	  SearchSource.prototype._createRequest = function (defer) {
	    return new SearchRequest(this, defer);
	  };
	
	  /**
	   * Used to merge properties into the state within ._flatten().
	   * The state is passed in and modified by the function
	   *
	   * @param  {object} state - the current merged state
	   * @param  {*} val - the value at `key`
	   * @param  {*} key - The key of `val`
	   * @return {undefined}
	   */
	  SearchSource.prototype._mergeProp = function (state, val, key) {
	    var _this = this;
	
	    if (typeof val === 'function') {
	      var _ret = (function () {
	        var source = _this;
	        return {
	          v: Promise.cast(val(_this)).then(function (newVal) {
	            return source._mergeProp(state, newVal, key);
	          })
	        };
	      })();
	
	      if (typeof _ret === 'object') return _ret.v;
	    }
	
	    if (val == null || !key || !_lodash2['default'].isString(key)) return;
	
	    switch (key) {
	      case 'filter':
	        var verifiedFilters = val;
	        if (config.get('courier:ignoreFilterIfFieldNotInIndex')) {
	          if (!_lodash2['default'].isArray(val)) val = [val];
	          verifiedFilters = val.filter(function (el) {
	            if ('meta' in el && 'index' in state) {
	              var field = state.index.fields.byName[el.meta.key];
	              if (!field) return false;
	            }
	            return true;
	          });
	        }
	        // user a shallow flatten to detect if val is an array, and pull the values out if it is
	        state.filters = (0, _lodash2['default'])([state.filters || [], verifiedFilters]).flatten()
	        // Yo Dawg! I heard you needed to filter out your filters
	        .reject(function (filter) {
	          return !filter || _lodash2['default'].get(filter, 'meta.disabled');
	        }).value();
	        return;
	      case 'index':
	      case 'type':
	      case 'id':
	      case 'highlightAll':
	        if (key && state[key] == null) {
	          state[key] = val;
	        }
	        return;
	      case 'source':
	        key = '_source';
	        addToBody();
	        break;
	      case 'sort':
	        val = normalizeSortRequest(val, this.get('index'));
	        addToBody();
	        break;
	      default:
	        addToBody();
	    }
	
	    /**
	     * Add the key and val to the body of the request
	     */
	    function addToBody() {
	      state.body = state.body || {};
	      // ignore if we already have a value
	      if (state.body[key] == null) {
	        if (key === 'query' && _lodash2['default'].isString(val)) {
	          val = { query_string: { query: val } };
	        }
	
	        state.body[key] = val;
	      }
	    }
	  };
	
	  return SearchSource;
	}
	
	module.exports = exports['default'];

/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(548), __esModule: true };

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(549);
	__webpack_require__(333);
	module.exports = __webpack_require__(34).Symbol;

/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(14)
	  , global         = __webpack_require__(33)
	  , has            = __webpack_require__(304)
	  , DESCRIPTORS    = __webpack_require__(303)
	  , $export        = __webpack_require__(32)
	  , redefine       = __webpack_require__(300)
	  , $fails         = __webpack_require__(37)
	  , shared         = __webpack_require__(308)
	  , setToStringTag = __webpack_require__(306)
	  , uid            = __webpack_require__(309)
	  , wks            = __webpack_require__(307)
	  , keyOf          = __webpack_require__(550)
	  , $names         = __webpack_require__(410)
	  , enumKeys       = __webpack_require__(551)
	  , isArray        = __webpack_require__(490)
	  , anObject       = __webpack_require__(259)
	  , toIObject      = __webpack_require__(251)
	  , createDesc     = __webpack_require__(302)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};
	
	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});
	
	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  redefine($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });
	
	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };
	
	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(299)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}
	
	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});
	
	setter = true;
	
	$export($export.G + $export.W, {Symbol: $Symbol});
	
	$export($export.S, 'Symbol', symbolStatics);
	
	$export($export.S + $export.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
	
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(14)
	  , toIObject = __webpack_require__(251);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(14);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = normalizeSortRequest;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function normalizeSortRequest(config) {
	  var defaultSortOptions = config.get('sort:options');
	
	  /**
	   * Decorate queries with default parameters
	   * @param {query} query object
	   * @returns {object}
	   */
	  return function (sortObject, indexPattern) {
	    var normalizedSort = [];
	
	    // [].concat({}) -> [{}], [].concat([{}]) -> [{}]
	    return [].concat(sortObject).map(function (sortable) {
	      return normalize(sortable, indexPattern);
	    });
	  };
	
	  /*
	    Normalize the sort description to the more verbose format:
	    { someField: "desc" } into { someField: { "order": "desc"}}
	  */
	  function normalize(sortable, indexPattern) {
	    var normalized = {};
	    var sortField = _lodash2['default'].keys(sortable)[0];
	    var sortValue = sortable[sortField];
	    var indexField = indexPattern.fields.byName[sortField];
	
	    if (indexField && indexField.scripted && indexField.sortable) {
	      var direction = undefined;
	      if (_lodash2['default'].isString(sortValue)) direction = sortValue;
	      if (_lodash2['default'].isObject(sortValue) && sortValue.order) direction = sortValue.order;
	
	      sortField = '_script';
	      sortValue = {
	        script: {
	          inline: indexField.script,
	          lang: indexField.lang
	        },
	        type: castSortType(indexField.type),
	        order: direction
	      };
	    } else {
	      if (_lodash2['default'].isString(sortValue)) {
	        sortValue = { order: sortValue };
	      }
	      sortValue = _lodash2['default'].defaults({}, sortValue, defaultSortOptions);
	
	      if (sortField === '_score') {
	        delete sortValue.unmapped_type;
	      }
	    }
	
	    normalized[sortField] = sortValue;
	    return normalized;
	  }
	}
	
	// The ES API only supports sort scripts of type 'number' and 'string'
	function castSortType(type) {
	  var typeCastings = {
	    number: 'number',
	    string: 'string',
	    date: 'number',
	    boolean: 'string'
	  };
	
	  var castedType = typeCastings[type];
	  if (!castedType) {
	    throw new Error('Unsupported script sort type: ' + type);
	  }
	
	  return castedType;
	}
	module.exports = exports['default'];

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RootSearchSource;
	
	var _uiCourierData_sourceSearch_source = __webpack_require__(546);
	
	var _uiCourierData_sourceSearch_source2 = _interopRequireDefault(_uiCourierData_sourceSearch_source);
	
	function RootSearchSource(Private, $rootScope, timefilter, Notifier) {
	  var SearchSource = Private(_uiCourierData_sourceSearch_source2['default']);
	
	  var notify = new Notifier({ location: 'Root Search Source' });
	
	  var globalSource = new SearchSource();
	  globalSource.inherits(false); // this is the final source, it has no parents
	  globalSource.filter(function (globalSource) {
	    // dynamic time filter will be called in the _flatten phase of things
	    return timefilter.get(globalSource.get('index'));
	  });
	
	  var appSource = undefined; // set in setAppSource()
	  resetAppSource();
	
	  // when the route changes, clear the appSource
	  $rootScope.$on('$routeChangeStart', resetAppSource);
	
	  /**
	   * Get the current AppSource
	   * @return {Promise} - resolved with the current AppSource
	   */
	  function getAppSource() {
	    return appSource;
	  }
	
	  /**
	   * Set the current AppSource
	   * @param {SearchSource} source - The Source that represents the applications "root" search source object
	   */
	  function setAppSource(source) {
	    appSource = source;
	
	    // walk the parent chain until we get to the global source or nothing
	    // that's where we will attach to the globalSource
	    var literalRoot = source;
	    while (literalRoot._parent && literalRoot._parent !== globalSource) {
	      literalRoot = literalRoot._parent;
	    }
	
	    literalRoot.inherits(globalSource);
	  }
	
	  /**
	   * Sets the appSource to be a new, empty, SearchSource
	   * @return {undefined}
	   */
	  function resetAppSource() {
	    setAppSource(new SearchSource());
	  }
	
	  return {
	    get: getAppSource,
	    set: setAppSource,
	
	    getGlobalSource: function getGlobalSource() {
	      return globalSource;
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SearchReqProvider;
	
	var _strategySearch = __webpack_require__(555);
	
	var _strategySearch2 = _interopRequireDefault(_strategySearch);
	
	var _request = __webpack_require__(515);
	
	var _request2 = _interopRequireDefault(_request);
	
	function SearchReqProvider(Private) {
	
	  var searchStrategy = Private(_strategySearch2['default']);
	  var AbstractRequest = Private(_request2['default']);
	
	  return (function (_AbstractRequest) {
	    _inherits(SearchReq, _AbstractRequest);
	
	    function SearchReq() {
	      _classCallCheck(this, SearchReq);
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      _get(Object.getPrototypeOf(SearchReq.prototype), 'constructor', this).apply(this, args);
	
	      this.type = 'search';
	      this.strategy = searchStrategy;
	    }
	
	    return SearchReq;
	  })(AbstractRequest);
	}
	
	module.exports = exports['default'];

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FetchStrategyForSearch;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiUtilsAggressive_parse = __webpack_require__(556);
	
	function FetchStrategyForSearch(Private, Promise, timefilter, kbnIndex, sessionId) {
	
	  return {
	    clientMethod: 'msearch',
	
	    /**
	     * Flatten a series of requests into as ES request body
	     *
	     * @param  {array} reqsFetchParams - the requests to serialize
	     * @return {Promise} - a promise that is fulfilled by the request body
	     */
	    reqsFetchParamsToBody: function reqsFetchParamsToBody(reqsFetchParams) {
	      var indexToListMapping = {};
	
	      return Promise.map(reqsFetchParams, function (fetchParams) {
	        return Promise.resolve(fetchParams.index).then(function (indexList) {
	          if (!_lodash2['default'].isFunction(_lodash2['default'].get(indexList, 'toIndexList'))) {
	            return indexList;
	          }
	
	          var timeBounds = timefilter.getBounds();
	
	          if (!indexToListMapping[indexList.id]) {
	            indexToListMapping[indexList.id] = indexList.toIndexList(timeBounds.min, timeBounds.max);
	          }
	          return indexToListMapping[indexList.id].then(function (indexList) {
	            // Make sure the index list in the cache can't be subsequently updated.
	            return _lodash2['default'].clone(indexList);
	          });
	        }).then(function (indexList) {
	          var body = fetchParams.body || {};
	          var index = [];
	          // If we've reached this point and there are no indexes in the
	          // index list at all, it means that we shouldn't expect any indexes
	          // to contain the documents we're looking for, so we instead
	          // perform a request for an index pattern that we know will always
	          // return an empty result (ie. -*). If instead we had gone ahead
	          // with an msearch without any index patterns, elasticsearch would
	          // handle that request by querying *all* indexes, which is the
	          // opposite of what we want in this case.
	          if (_lodash2['default'].isArray(indexList) && indexList.length === 0) {
	            index.push(kbnIndex);
	            body = emptySearch();
	          } else {
	            index = indexList;
	          }
	          return _angular2['default'].toJson({
	            index: index,
	            type: fetchParams.type,
	            search_type: fetchParams.search_type,
	            ignore_unavailable: true,
	            preference: sessionId
	          }) + '\n' + (0, _uiUtilsAggressive_parse.toJson)(body, _angular2['default'].toJson);
	        });
	      }).then(function (requests) {
	        return requests.join('\n') + '\n';
	      });
	    },
	
	    /**
	     * Fetch the multiple responses from the ES Response
	     * @param  {object} resp - The response sent from Elasticsearch
	     * @return {array} - the list of responses
	     */
	    getResponses: function getResponses(resp) {
	      return resp.responses;
	    }
	  };
	}
	
	function emptySearch() {
	  return {
	    query: {
	      bool: {
	        must_not: [{ match_all: {} }]
	      }
	    }
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.toJson = toJson;
	exports.replacer = replacer;
	
	var _lodash = __webpack_require__(3);
	
	/**
	 * Serializes the given object into a JSON string
	 *
	 * All properties that begin with $ throughout the entire object are omitted.
	 * If a custom JSON serializer function is passed, then the given object is
	 * passed through it before being re-stringified with the native stringify.
	 *
	 * The space argument is passed unaltered to the native stringify.
	 */
	
	function toJson(object, jsonFn, space) {
	  if (jsonFn) {
	    // We reparse the stringified json so that we can lean on JSON.stringify's
	    // avoiding-infinite-recursion capabilities when stripping out any
	    // remaining properties that begin with a dollar sign ($)
	    object = JSON.parse(jsonFn(object));
	  }
	  return JSON.stringify(object, replacer, space);
	}
	
	/**
	 * Returns the given value if the key does not begin with a dollar sign ($)
	 */
	
	function replacer(key, value) {
	  return (0, _lodash.isString)(key) && (0, _lodash.startsWith)(key, '$') ? undefined : value;
	}

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SegmentedReqProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	var _search = __webpack_require__(554);
	
	var _search2 = _interopRequireDefault(_search);
	
	var _segmented_handle = __webpack_require__(558);
	
	var _segmented_handle2 = _interopRequireDefault(_segmented_handle);
	
	function SegmentedReqProvider(es, Private, Promise, timefilter, config) {
	  var SearchReq = Private(_search2['default']);
	  var SegmentedHandle = Private(_segmented_handle2['default']);
	
	  var notify = new _uiNotifyNotifier2['default']({
	    location: 'Segmented Fetch'
	  });
	
	  var SegmentedReq = (function (_SearchReq) {
	    _inherits(SegmentedReq, _SearchReq);
	
	    function SegmentedReq(source, defer, initFn) {
	      _classCallCheck(this, SegmentedReq);
	
	      _get(Object.getPrototypeOf(SegmentedReq.prototype), 'constructor', this).call(this, source, defer);
	
	      this.type = 'segmented';
	
	      // segmented request specific state
	      this._initFn = initFn;
	
	      this._desiredSize = null;
	      this._maxSegments = config.get('courier:maxSegmentCount');
	      this._direction = 'desc';
	      this._sortFn = null;
	      this._queueCreated = false;
	      this._handle = new SegmentedHandle(this);
	
	      this._hitWindow = null;
	
	      // prevent the source from changing between requests,
	      // all calls will return the same promise
	      this._getFlattenedSource = _lodash2['default'].once(this._getFlattenedSource);
	    }
	
	    /*********
	    ** SearchReq overrides
	    *********/
	
	    _createClass(SegmentedReq, [{
	      key: 'start',
	      value: function start() {
	        var _this = this;
	
	        _get(Object.getPrototypeOf(SegmentedReq.prototype), 'start', this).call(this);
	
	        this._complete = [];
	        this._active = null;
	        this._segments = [];
	        this._all = [];
	        this._queue = [];
	
	        this._mergedResp = {
	          took: 0,
	          hits: {
	            hits: [],
	            total: 0,
	            max_score: 0
	          }
	        };
	
	        // give the request consumer a chance to receive each segment and set
	        // parameters via the handle
	        if (_lodash2['default'].isFunction(this._initFn)) this._initFn(this._handle);
	        return this._createQueue().then(function (queue) {
	          if (_this.stopped) return;
	
	          _this._all = queue.slice(0);
	
	          // Send the initial fetch status
	          _this._reportStatus();
	        });
	      }
	    }, {
	      key: 'continue',
	      value: function _continue() {
	        return this._reportStatus();
	      }
	    }, {
	      key: 'getFetchParams',
	      value: function getFetchParams() {
	        var _this2 = this;
	
	        return this._getFlattenedSource().then(function (flatSource) {
	          var params = _lodash2['default'].cloneDeep(flatSource);
	
	          // calculate the number of indices to fetch in this request in order to prevent
	          // more than this._maxSegments requests. We use Math.max(1, n) to ensure that each request
	          // has at least one index pattern, and Math.floor() to make sure that if the
	          // number of indices does not round out evenly the extra index is tacked onto the last
	          // request, making sure the first request returns faster.
	          var remainingSegments = _this2._maxSegments - _this2._segments.length;
	          var indexCount = Math.max(1, Math.floor(_this2._queue.length / remainingSegments));
	
	          var indices = _this2._active = _this2._queue.splice(0, indexCount);
	          params.index = _lodash2['default'].pluck(indices, 'index');
	
	          if ((0, _lodash.isNumber)(_this2._desiredSize)) {
	            params.body.size = _this2._pickSizeForIndices(indices);
	          }
	
	          return params;
	        });
	      }
	    }, {
	      key: 'handleResponse',
	      value: function handleResponse(resp) {
	        return this._consumeSegment(resp);
	      }
	    }, {
	      key: 'filterError',
	      value: function filterError(resp) {
	        if (/ClusterBlockException.*index\sclosed/.test(resp.error)) {
	          this._consumeSegment(false);
	          return true;
	        }
	      }
	    }, {
	      key: 'isIncomplete',
	      value: function isIncomplete() {
	        var queueNotCreated = !this._queueCreated;
	        var queueNotEmpty = this._queue.length > 0;
	        return queueNotCreated || queueNotEmpty;
	      }
	    }, {
	      key: 'clone',
	      value: function clone() {
	        return new SegmentedReq(this.source, this.defer, this._initFn);
	      }
	    }, {
	      key: 'complete',
	      value: function complete() {
	        this._reportStatus();
	        this._handle.emit('complete');
	        return _get(Object.getPrototypeOf(SegmentedReq.prototype), 'complete', this).call(this);
	      }
	
	      /*********
	      ** SegmentedReq specific methods
	      *********/
	
	      /**
	      * Set the sort total number of segments to emit
	      *
	      * @param {number}
	      */
	    }, {
	      key: 'setMaxSegments',
	      value: function setMaxSegments(maxSegments) {
	        this._maxSegments = Math.max(_lodash2['default'].parseInt(maxSegments), 1);
	      }
	
	      /**
	      * Set the sort direction for the request.
	      *
	      * @param {string} dir - one of 'asc' or 'desc'
	      */
	    }, {
	      key: 'setDirection',
	      value: function setDirection(dir) {
	        switch (dir) {
	          case 'asc':
	          case 'desc':
	            return this._direction = dir;
	          default:
	            throw new TypeError('unknown sort direction "' + dir + '"');
	        }
	      }
	
	      /**
	      * Set the function that will be used to sort the rows
	      *
	      * @param {fn}
	      */
	    }, {
	      key: 'setSortFn',
	      value: function setSortFn(sortFn) {
	        this._sortFn = sortFn;
	      }
	
	      /**
	      * Set the sort total number of documents to
	      * emit
	      *
	      * Setting to false will not limit the documents,
	      * if a number is set the size of the request to es
	      * will be updated on each new request
	      *
	      * @param {number|false}
	      */
	    }, {
	      key: 'setSize',
	      value: function setSize(totalSize) {
	        this._desiredSize = _lodash2['default'].parseInt(totalSize);
	        if (isNaN(this._desiredSize)) this._desiredSize = null;
	      }
	    }, {
	      key: '_createQueue',
	      value: function _createQueue() {
	        var _this3 = this;
	
	        var timeBounds = timefilter.getBounds();
	        var indexPattern = this.source.get('index');
	        this._queueCreated = false;
	
	        return indexPattern.toDetailedIndexList(timeBounds.min, timeBounds.max, this._direction).then(function (queue) {
	          if (!_lodash2['default'].isArray(queue)) queue = [queue];
	
	          _this3._queue = queue;
	          _this3._queueCreated = true;
	
	          return queue;
	        });
	      }
	    }, {
	      key: '_reportStatus',
	      value: function _reportStatus() {
	        return this._handle.emit('status', {
	          total: this._queueCreated ? this._all.length : NaN,
	          complete: this._queueCreated ? this._complete.length : NaN,
	          remaining: this._queueCreated ? this._queue.length : NaN,
	          hitCount: this._queueCreated ? this._mergedResp.hits.hits.length : NaN
	        });
	      }
	    }, {
	      key: '_getFlattenedSource',
	      value: function _getFlattenedSource() {
	        return this.source._flatten();
	      }
	    }, {
	      key: '_consumeSegment',
	      value: function _consumeSegment(seg) {
	        var index = this._active;
	        this._complete.push(index);
	        if (!seg) return; // segment was ignored/filtered, don't store it
	
	        var hadHits = _lodash2['default'].get(this._mergedResp, 'hits.hits.length') > 0;
	        var gotHits = _lodash2['default'].get(seg, 'hits.hits.length') > 0;
	        var firstHits = !hadHits && gotHits;
	        var haveHits = hadHits || gotHits;
	
	        this._mergeSegment(seg);
	        this.resp = _lodash2['default'].omit(this._mergedResp, '_bucketIndex');
	
	        if (firstHits) this._handle.emit('first', seg);
	        if (gotHits) this._handle.emit('segment', seg);
	        if (haveHits) this._handle.emit('mergedSegment', this.resp);
	      }
	    }, {
	      key: '_mergeHits',
	      value: function _mergeHits(hits) {
	        var mergedHits = this._mergedResp.hits.hits;
	        var desiredSize = this._desiredSize;
	        var sortFn = this._sortFn;
	
	        _lodash2['default'].pushAll(hits, mergedHits);
	
	        if (sortFn) {
	          notify.event('resort rows', function () {
	            mergedHits.sort(sortFn);
	          });
	        }
	
	        if ((0, _lodash.isNumber)(desiredSize)) {
	          this._mergedResp.hits.hits = mergedHits.slice(0, desiredSize);
	        }
	      }
	    }, {
	      key: '_mergeSegment',
	      value: function _mergeSegment(seg) {
	        var merged = this._mergedResp;
	
	        this._segments.push(seg);
	
	        merged.took += seg.took;
	        merged.hits.total += seg.hits.total;
	        merged.hits.max_score = Math.max(merged.hits.max_score, seg.hits.max_score);
	
	        if (_lodash2['default'].size(seg.hits.hits)) {
	          this._mergeHits(seg.hits.hits);
	          this._detectHitsWindow(merged.hits.hits);
	        }
	
	        if (!seg.aggregations) return;
	
	        _Object$keys(seg.aggregations).forEach(function (aggKey) {
	
	          if (!merged.aggregations) {
	            // start merging aggregations
	            merged.aggregations = {};
	            merged._bucketIndex = {};
	          }
	
	          if (!merged.aggregations[aggKey]) {
	            merged.aggregations[aggKey] = {
	              buckets: []
	            };
	          }
	
	          seg.aggregations[aggKey].buckets.forEach(function (bucket) {
	            var mbucket = merged._bucketIndex[bucket.key];
	            if (mbucket) {
	              mbucket.doc_count += bucket.doc_count;
	              return;
	            }
	
	            mbucket = merged._bucketIndex[bucket.key] = bucket;
	            merged.aggregations[aggKey].buckets.push(mbucket);
	          });
	        });
	      }
	    }, {
	      key: '_detectHitsWindow',
	      value: function _detectHitsWindow(hits) {
	        hits = hits || [];
	        var indexPattern = this.source.get('index');
	        var desiredSize = this._desiredSize;
	
	        var size = _lodash2['default'].size(hits);
	        if (!(0, _lodash.isNumber)(desiredSize) || size < desiredSize) {
	          this._hitWindow = {
	            size: size,
	            min: -Infinity,
	            max: Infinity
	          };
	          return;
	        }
	
	        var min = undefined;
	        var max = undefined;
	
	        hits.forEach(function (deepHit) {
	          var hit = indexPattern.flattenHit(deepHit);
	          var time = hit[indexPattern.timeFieldName];
	          if (min == null || time < min) min = time;
	          if (max == null || time > max) max = time;
	        });
	
	        this._hitWindow = { size: size, min: min, max: max };
	      }
	    }, {
	      key: '_pickSizeForIndices',
	      value: function _pickSizeForIndices(indices) {
	        var hitWindow = this._hitWindow;
	        var desiredSize = this._desiredSize;
	
	        if (!(0, _lodash.isNumber)(desiredSize)) return null;
	        // we don't have any hits yet, get us more info!
	        if (!hitWindow) return desiredSize;
	        // the order of documents isn't important, just get us more
	        if (!this._sortFn) return Math.max(desiredSize - hitWindow.size, 0);
	        // if all of the documents in every index fall outside of our current doc set, we can ignore them.
	        var someOverlap = indices.some(function (index) {
	          return index.min <= hitWindow.max && hitWindow.min <= index.max;
	        });
	
	        return someOverlap ? desiredSize : 0;
	      }
	    }]);
	
	    return SegmentedReq;
	  })(SearchReq);
	
	  SegmentedReq.prototype.mergedSegment = notify.timed('merge response segment', SegmentedReq.prototype.mergedSegment);
	
	  return SegmentedReq;
	}
	
	module.exports = exports['default'];

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _Symbol = __webpack_require__(547)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CourierSegmentedReqHandle;
	
	var _uiEvents = __webpack_require__(283);
	
	var _uiEvents2 = _interopRequireDefault(_uiEvents);
	
	function CourierSegmentedReqHandle(Private) {
	  var Events = Private(_uiEvents2['default']);
	
	  var segmentedRequest = _Symbol('Actual Segmented Request');
	
	  /**
	   * Simple class for creating an object to send to the
	   * requester of a SegmentedRequest. Since the SegmentedRequest
	   * extends AbstractRequest, it wasn't able to be the event
	   * emitter it was born to be. This provides a channel for
	   * setting values on the segmented request, and an event
	   * emitter for the request to speak outwardly
	   *
	   * @param {SegmentedRequest} - req - the requst this handle relates to
	   */
	  return (function (_Events) {
	    _inherits(SegmentedHandle, _Events);
	
	    function SegmentedHandle(req) {
	      _classCallCheck(this, SegmentedHandle);
	
	      _get(Object.getPrototypeOf(SegmentedHandle.prototype), 'constructor', this).call(this);
	      this[segmentedRequest] = req;
	    }
	
	    _createClass(SegmentedHandle, [{
	      key: 'setDirection',
	      value: function setDirection() {
	        var _segmentedRequest;
	
	        (_segmentedRequest = this[segmentedRequest]).setDirection.apply(_segmentedRequest, arguments);
	      }
	    }, {
	      key: 'setSize',
	      value: function setSize() {
	        var _segmentedRequest2;
	
	        (_segmentedRequest2 = this[segmentedRequest]).setSize.apply(_segmentedRequest2, arguments);
	      }
	    }, {
	      key: 'setMaxSegments',
	      value: function setMaxSegments() {
	        var _segmentedRequest3;
	
	        (_segmentedRequest3 = this[segmentedRequest]).setMaxSegments.apply(_segmentedRequest3, arguments);
	      }
	    }, {
	      key: 'setSortFn',
	      value: function setSortFn() {
	        var _segmentedRequest4;
	
	        (_segmentedRequest4 = this[segmentedRequest]).setSortFn.apply(_segmentedRequest4, arguments);
	      }
	    }]);
	
	    return SegmentedHandle;
	  })(Events);
	}
	
	module.exports = exports['default'];

/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocLooperService;
	
	var _fetch = __webpack_require__(509);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _looper = __webpack_require__(560);
	
	var _looper2 = _interopRequireDefault(_looper);
	
	var _fetchStrategyDoc_data = __webpack_require__(544);
	
	var _fetchStrategyDoc_data2 = _interopRequireDefault(_fetchStrategyDoc_data);
	
	function DocLooperService(Private) {
	  var fetch = Private(_fetch2['default']);
	  var Looper = Private(_looper2['default']);
	  var DocStrategy = Private(_fetchStrategyDoc_data2['default']);
	
	  /**
	   * The Looper which will manage the doc fetch interval
	   * @type {Looper}
	   */
	  var docLooper = new Looper(1500, function () {
	    fetch.fetchQueued(DocStrategy);
	  });
	
	  return docLooper;
	}
	
	module.exports = exports['default'];

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = LooperFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(391);
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	function LooperFactory($timeout, Promise) {
	  var notify = new _uiNotifyNotifier2['default']();
	
	  function Looper(ms, fn) {
	    this._fn = fn;
	    this._ms = ms === void 0 ? 1500 : ms;
	    this._timer = null;
	    this._started = false;
	
	    this._loopTheLoop = _lodash2['default'].bind(this._loopTheLoop, this);
	  }
	
	  /**
	   * Set the number of milliseconds between
	   * each loop
	   *
	   * @param  {integer} ms
	   * @chainable
	   */
	  Looper.prototype.ms = function (ms) {
	    this._ms = _lodash2['default'].parseInt(ms) || 0;
	
	    if (!this._started) return;
	
	    if (this._ms) {
	      this.start(false);
	    } else {
	      this._unScheduleLoop();
	    }
	
	    return this;
	  };
	
	  /**
	   * Cancels the current looper while keeping internal
	   * state as started
	   *
	   * @chainable
	   */
	  Looper.prototype.pause = function () {
	    this._unScheduleLoop();
	    return this;
	  };
	
	  /**
	   * Start the looping madness
	   *
	   * @chainable
	   */
	  Looper.prototype.start = function (loopOver) {
	    if (loopOver == null) loopOver = true;
	
	    if (!this._started) {
	      this._started = true;
	    } else {
	      this._unScheduleLoop();
	    }
	
	    if (loopOver) {
	      this._loopTheLoop();
	    } else {
	      this._scheduleLoop();
	    }
	
	    return this;
	  };
	
	  /**
	   * ...
	   *
	   * @chainable
	   */
	  Looper.prototype.stop = function () {
	    this._unScheduleLoop();
	    this._started = false;
	    return this;
	  };
	
	  /**
	   * Restart the looper only if it is already started.
	   * Called automatically when ms is changed
	   *
	   * @chainable
	   */
	  Looper.prototype.restart = function () {
	    this.start(false);
	    return this;
	  };
	
	  /**
	   * Is the looper currently started/running/scheduled/going to execute
	   *
	   * @return {boolean}
	   */
	  Looper.prototype.started = function () {
	    return !!this._started;
	  };
	
	  /**
	   * Returns the current loop interval
	   *
	   * @return {number}
	   */
	  Looper.prototype.loopInterval = function () {
	    return this._ms;
	  };
	
	  /**
	   * Called when the loop is executed before the previous
	   * run has completed.
	   *
	   * @override
	   * @return {undefined}
	   */
	  Looper.prototype.onHastyLoop = function () {
	    // override this in subclasses
	  };
	
	  /**
	   * Wraps this._fn so that this._fn can be changed
	   * without rescheduling and schedules
	   * the next itteration
	   *
	   * @private
	   * @return {undefined}
	   */
	  Looper.prototype._loopTheLoop = function () {
	    var self = this;
	
	    if (self.active) {
	      self.onHastyLoop();
	      return;
	    }
	
	    self.active = Promise['try'](this._fn).then(function () {
	      self._scheduleLoop();
	    })['catch'](function (err) {
	      self.stop();
	      notify.fatal(err);
	    })['finally'](function () {
	      self.active = null;
	    });
	  };
	
	  /**
	   * Schedule the next itteration of the loop
	   *
	   * @private
	   * @return {number} - the timer promise
	   */
	  Looper.prototype._scheduleLoop = function () {
	    this._unScheduleLoop();
	    this._timer = this._ms ? $timeout(this._loopTheLoop, this._ms) : null;
	    return this._timer;
	  };
	
	  /**
	   * Cancel the next itteration of the loop
	   *
	   * @private
	   * @return {number} - the timer promise
	   */
	  Looper.prototype._unScheduleLoop = function () {
	    if (this._timer) {
	      $timeout.cancel(this._timer);
	      this._timer = null;
	    }
	  };
	
	  /**
	   * execute the this._fn, and restart the timer
	   */
	  Looper.prototype.run = function () {
	    this.start();
	  };
	
	  return Looper;
	}
	
	module.exports = exports['default'];

/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DocLooperService;
	
	var _fetch = __webpack_require__(509);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _looper = __webpack_require__(560);
	
	var _looper2 = _interopRequireDefault(_looper);
	
	var _fetchStrategyDoc_admin = __webpack_require__(531);
	
	var _fetchStrategyDoc_admin2 = _interopRequireDefault(_fetchStrategyDoc_admin);
	
	function DocLooperService(Private) {
	  var fetch = Private(_fetch2['default']);
	  var Looper = Private(_looper2['default']);
	  var DocStrategy = Private(_fetchStrategyDoc_admin2['default']);
	
	  /**
	   * The Looper which will manage the doc fetch interval
	   * @type {Looper}
	   */
	  var docLooper = new Looper(1500, function () {
	    fetch.fetchQueued(DocStrategy);
	  });
	
	  return docLooper;
	}
	
	module.exports = exports['default'];

/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SearchLooperService;
	
	var _fetch = __webpack_require__(509);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _fetchStrategySearch = __webpack_require__(555);
	
	var _fetchStrategySearch2 = _interopRequireDefault(_fetchStrategySearch);
	
	var _request_queue = __webpack_require__(508);
	
	var _request_queue2 = _interopRequireDefault(_request_queue);
	
	var _looper = __webpack_require__(560);
	
	var _looper2 = _interopRequireDefault(_looper);
	
	function SearchLooperService(Private, Promise, Notifier, $rootScope) {
	  var fetch = Private(_fetch2['default']);
	  var searchStrategy = Private(_fetchStrategySearch2['default']);
	  var requestQueue = Private(_request_queue2['default']);
	
	  var Looper = Private(_looper2['default']);
	  var notif = new Notifier({ location: 'Search Looper' });
	
	  /**
	   * The Looper which will manage the doc fetch interval
	   * @type {Looper}
	   */
	  var searchLooper = new Looper(null, function () {
	    $rootScope.$broadcast('courier:searchRefresh');
	    var requests = requestQueue.getInactive(searchStrategy);
	    // promise returned from fetch.these() only resolves when
	    // the requests complete, but we want to continue even if
	    // the requests abort so we make our own
	    fetch.these(requests);
	    return Promise.all(requests.map(function (request) {
	      return request.getCompleteOrAbortedPromise();
	    }));
	  });
	
	  searchLooper.onHastyLoop = function () {
	    if (searchLooper.afterHastyQueued) return;
	
	    searchLooper.afterHastyQueued = Promise.resolve(searchLooper.active).then(function () {
	      return searchLooper._loopTheLoop();
	    })['finally'](function () {
	      searchLooper.afterHastyQueued = null;
	    });
	  };
	
	  return searchLooper;
	}
	
	module.exports = exports['default'];

/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SavedObject
	 *
	 * NOTE: SavedObject seems to track a reference to an object in ES,
	 * and surface methods for CRUD functionality (save and delete). This seems
	 * similar to how Backbone Models work.
	 *
	 * This class seems to interface with ES primarily through the es Angular
	 * service and a DocSource instance.
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SavedObjectFactory;
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	var _nodeUuid = __webpack_require__(564);
	
	var _nodeUuid2 = _interopRequireDefault(_nodeUuid);
	
	var _uiUtilsMapping_setup = __webpack_require__(533);
	
	var _uiUtilsMapping_setup2 = _interopRequireDefault(_uiUtilsMapping_setup);
	
	var _data_sourceAdmin_doc_source = __webpack_require__(505);
	
	var _data_sourceAdmin_doc_source2 = _interopRequireDefault(_data_sourceAdmin_doc_source);
	
	var _data_sourceSearch_source = __webpack_require__(546);
	
	var _data_sourceSearch_source2 = _interopRequireDefault(_data_sourceSearch_source);
	
	function SavedObjectFactory(esAdmin, kbnIndex, Promise, Private, Notifier, confirmModalPromise, indexPatterns) {
	
	  var DocSource = Private(_data_sourceAdmin_doc_source2['default']);
	  var SearchSource = Private(_data_sourceSearch_source2['default']);
	  var mappingSetup = Private(_uiUtilsMapping_setup2['default']);
	
	  function SavedObject(config) {
	    var _this = this;
	
	    if (!_lodash2['default'].isObject(config)) config = {};
	
	    /************
	     * Initialize config vars
	     ************/
	    // the doc which is used to store this object
	    var docSource = new DocSource();
	
	    // type name for this object, used as the ES-type
	    var type = config.type;
	
	    this.getDisplayName = function () {
	      return type;
	    };
	
	    /**
	     * Flips to true during a save operation, and back to false once the save operation
	     * completes.
	     * @type {boolean}
	     */
	    this.isSaving = false;
	    this.defaults = config.defaults || {};
	
	    // Create a notifier for sending alerts
	    var notify = new Notifier({
	      location: 'Saved ' + type
	    });
	
	    // mapping definition for the fields that this object will expose
	    var mapping = mappingSetup.expandShorthand(config.mapping);
	
	    var afterESResp = config.afterESResp || _lodash2['default'].noop;
	    var customInit = config.init || _lodash2['default'].noop;
	
	    // optional search source which this object configures
	    this.searchSource = config.searchSource ? new SearchSource() : undefined;
	
	    // the id of the document
	    this.id = config.id || void 0;
	
	    // Whether to create a copy when the object is saved. This should eventually go away
	    // in favor of a better rename/save flow.
	    this.copyOnSave = false;
	
	    var parseSearchSource = function parseSearchSource(searchSourceJson) {
	      if (!_this.searchSource) return;
	
	      // if we have a searchSource, set its state based on the searchSourceJSON field
	      var state = undefined;
	      try {
	        state = JSON.parse(searchSourceJson);
	      } catch (e) {
	        state = {};
	      }
	
	      var oldState = _this.searchSource.toJSON();
	      var fnProps = _lodash2['default'].transform(oldState, function (dynamic, val, name) {
	        if (_lodash2['default'].isFunction(val)) dynamic[name] = val;
	      }, {});
	
	      _this.searchSource.set(_lodash2['default'].defaults(state, fnProps));
	    };
	
	    /**
	     * After creation or fetching from ES, ensure that the searchSources index indexPattern
	     * is an bonafide IndexPattern object.
	     *
	     * @return {Promise<IndexPattern | null>}
	     */
	    var hydrateIndexPattern = function hydrateIndexPattern() {
	      if (!_this.searchSource) {
	        return Promise.resolve(null);
	      }
	
	      if (config.clearSavedIndexPattern) {
	        _this.searchSource.set('index', undefined);
	        return Promise.resolve(null);
	      }
	
	      var index = config.indexPattern || _this.searchSource.getOwn('index');
	
	      if (!index) {
	        return Promise.resolve(null);
	      }
	
	      // If index is not an IndexPattern object at this point, then it's a string id of an index.
	      if (!(index instanceof indexPatterns.IndexPattern)) {
	        index = indexPatterns.get(index);
	      }
	
	      // At this point index will either be an IndexPattern, if cached, or a promise that
	      // will return an IndexPattern, if not cached.
	      return Promise.resolve(index).then(function (indexPattern) {
	        _this.searchSource.set('index', indexPattern);
	      });
	    };
	
	    /**
	     * Asynchronously initialize this object - will only run
	     * once even if called multiple times.
	     *
	     * @return {Promise}
	     * @resolved {SavedObject}
	     */
	    this.init = _lodash2['default'].once(function () {
	      // ensure that the type is defined
	      if (!type) throw new Error('You must define a type name to use SavedObject objects.');
	
	      // tell the docSource where to find the doc
	      docSource.index(kbnIndex).type(type).id(_this.id);
	
	      // check that the mapping for this type is defined
	      return mappingSetup.isDefined(type).then(function (defined) {
	        // if it is already defined skip this step
	        if (defined) return true;
	
	        mapping.kibanaSavedObjectMeta = {
	          properties: {
	            // setup the searchSource mapping, even if it is not used but this type yet
	            searchSourceJSON: {
	              type: 'string'
	            }
	          }
	        };
	
	        // tell mappingSetup to set type
	        return mappingSetup.setup(type, mapping);
	      }).then(function () {
	        // If there is not id, then there is no document to fetch from elasticsearch
	        if (!_this.id) {
	          // just assign the defaults and be done
	          _lodash2['default'].assign(_this, _this.defaults);
	          return hydrateIndexPattern().then(function () {
	            return afterESResp.call(_this);
	          });
	        }
	
	        // fetch the object from ES
	        return docSource.fetch().then(_this.applyESResp);
	      }).then(function () {
	        return customInit.call(_this);
	      }).then(function () {
	        // return our obj as the result of init()
	        return _this;
	      });
	    });
	
	    this.applyESResp = function (resp) {
	      _this._source = _lodash2['default'].cloneDeep(resp._source);
	
	      if (resp.found != null && !resp.found) throw new _uiErrors2['default'].SavedObjectNotFound(type, _this.id);
	
	      var meta = resp._source.kibanaSavedObjectMeta || {};
	      delete resp._source.kibanaSavedObjectMeta;
	
	      if (!config.indexPattern && _this._source.indexPattern) {
	        config.indexPattern = _this._source.indexPattern;
	        delete _this._source.indexPattern;
	      }
	
	      // assign the defaults to the response
	      _lodash2['default'].defaults(_this._source, _this.defaults);
	
	      // transform the source using _deserializers
	      _lodash2['default'].forOwn(mapping, function (fieldMapping, fieldName) {
	        if (fieldMapping._deserialize) {
	          _this._source[fieldName] = fieldMapping._deserialize(_this._source[fieldName], resp, fieldName, fieldMapping);
	        }
	      });
	
	      // Give obj all of the values in _source.fields
	      _lodash2['default'].assign(_this, _this._source);
	      _this.lastSavedTitle = _this.title;
	
	      return Promise['try'](function () {
	        parseSearchSource(meta.searchSourceJSON);
	        return hydrateIndexPattern();
	      }).then(function () {
	        return Promise.cast(afterESResp.call(_this, resp));
	      }).then(function () {
	        // Any time obj is updated, re-call applyESResp
	        docSource.onUpdate().then(_this.applyESResp, notify.fatal);
	      });
	    };
	
	    /**
	     * Serialize this object
	     *
	     * @return {Object}
	     */
	    this.serialize = function () {
	      var body = {};
	
	      _lodash2['default'].forOwn(mapping, function (fieldMapping, fieldName) {
	        if (_this[fieldName] != null) {
	          body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this[fieldName]) : _this[fieldName];
	        }
	      });
	
	      if (_this.searchSource) {
	        body.kibanaSavedObjectMeta = {
	          searchSourceJSON: _angular2['default'].toJson(_lodash2['default'].omit(_this.searchSource.toJSON(), ['sort', 'size']))
	        };
	      }
	
	      return body;
	    };
	
	    /**
	     * Returns true if the object's original title has been changed. New objects return false.
	     * @return {boolean}
	     */
	    this.isTitleChanged = function () {
	      return _this._source && _this._source.title !== _this.title;
	    };
	
	    /**
	     * Queries es to refresh the index.
	     * @returns {Promise}
	     */
	    function refreshIndex() {
	      return esAdmin.indices.refresh({ index: kbnIndex });
	    }
	
	    /**
	     * An error message to be used when the user rejects a confirm overwrite.
	     * @type {string}
	     */
	    var OVERWRITE_REJECTED = 'Overwrite confirmation was rejected';
	
	    /**
	     * Attempts to create the current object using the serialized source. If an object already
	     * exists, a warning message requests an overwrite confirmation.
	     * @param source - serialized version of this object (return value from this.serialize())
	     * What will be indexed into elasticsearch.
	     * @returns {Promise} - A promise that is resolved with the objects id if the object is
	     * successfully indexed. If the overwrite confirmation was rejected, an error is thrown with
	     * a confirmRejected = true parameter so that case can be handled differently than
	     * a create or index error.
	     * @resolved {String} - The id of the doc
	     */
	    var createSource = function createSource(source) {
	      return docSource.doCreate(source)['catch'](function (err) {
	        // record exists, confirm overwriting
	        if (_lodash2['default'].get(err, 'origError.status') === 409) {
	          var confirmMessage = 'Are you sure you want to overwrite ' + _this.title + '?';
	
	          return confirmModalPromise(confirmMessage, { confirmButtonText: 'Overwrite ' + _this.getDisplayName() }).then(function () {
	            return docSource.doIndex(source);
	          })['catch'](function () {
	            return Promise.reject(new Error(OVERWRITE_REJECTED));
	          });
	        }
	        return Promise.reject(err);
	      });
	    };
	
	    /**
	     * @typedef {Object} SaveOptions
	     * @property {boolean} confirmOverwrite - If true, attempts to create the source so it
	     * can confirm an overwrite if a document with the id already exists.
	     */
	
	    /**
	     * Saves this object.
	     *
	     * @param {SaveOptions} saveOptions?
	     * @return {Promise}
	     * @resolved {String} - The id of the doc
	     */
	    this.save = function () {
	      var saveOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      // Save the original id in case the save fails.
	      var originalId = _this.id;
	      // Read https://github.com/elastic/kibana/issues/9056 and
	      // https://github.com/elastic/kibana/issues/9012 for some background into why this copyOnSave variable
	      // exists.
	      // The goal is to move towards a better rename flow, but since our users have been conditioned
	      // to expect a 'save as' flow during a rename, we are keeping the logic the same until a better
	      // UI/UX can be worked out.
	      if (_this.copyOnSave) {
	        _this.id = null;
	      }
	
	      // Create a unique id for this object if it doesn't have one already.
	      _this.id = _this.id || _nodeUuid2['default'].v1();
	      // ensure that the docSource has the current id
	      docSource.id(_this.id);
	
	      var source = _this.serialize();
	
	      _this.isSaving = true;
	      var doSave = saveOptions.confirmOverwrite ? createSource(source) : docSource.doIndex(source);
	      return doSave.then(function (id) {
	        _this.id = id;
	      }).then(refreshIndex).then(function () {
	        _this.isSaving = false;
	        _this.lastSavedTitle = _this.title;
	        return _this.id;
	      })['catch'](function (err) {
	        _this.isSaving = false;
	        _this.id = originalId;
	        if (err && err.message === OVERWRITE_REJECTED) return;
	        return Promise.reject(err);
	      });
	    };
	
	    this.destroy = function () {
	      docSource.cancelQueued();
	      if (_this.searchSource) {
	        _this.searchSource.cancelQueued();
	      }
	    };
	
	    /**
	     * Delete this object from Elasticsearch
	     * @return {promise}
	     */
	    this['delete'] = function () {
	      return esAdmin['delete']({
	        index: kbnIndex,
	        type: type,
	        id: _this.id
	      }).then(function () {
	        return refreshIndex();
	      });
	    };
	  }
	
	  return SavedObject;
	}
	
	module.exports = exports['default'];

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php
	
	/*global window, require, define */
	(function(_window) {
	  'use strict';
	
	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;
	
	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;
	
	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }
	
	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }
	
	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }
	
	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(565).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }
	
	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }
	
	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;
	
	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }
	
	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;
	
	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });
	
	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }
	
	    return buf;
	  }
	
	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }
	
	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html
	
	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();
	
	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];
	
	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
	
	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];
	
	    options = options || {};
	
	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;
	
	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();
	
	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;
	
	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
	
	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }
	
	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }
	
	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }
	
	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;
	
	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;
	
	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;
	
	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;
	
	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;
	
	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;
	
	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;
	
	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }
	
	    return buf ? buf : unparse(b);
	  }
	
	  // **`v4()` - Generate random UUID**
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;
	
	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};
	
	    var rnds = options.random || (options.rng || _rng)();
	
	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;
	
	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }
	
	    return buf || unparse(rnds);
	  }
	
	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;
	
	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	
	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;
	
	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };
	
	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(566)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(568)
	
	exports.createHmac = __webpack_require__(580)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(581)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(567)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(261).Buffer))

/***/ },
/* 567 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(569)
	
	var md5 = toConstructor(__webpack_require__(577))
	var rmd160 = toConstructor(__webpack_require__(579))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(261).Buffer
	var Hash   = __webpack_require__(570)(Buffer)
	
	exports.sha1 = __webpack_require__(571)(Buffer, Hash)
	exports.sha256 = __webpack_require__(575)(Buffer, Hash)
	exports.sha512 = __webpack_require__(576)(Buffer, Hash)


/***/ },
/* 570 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(572).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(573);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(574);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(233)))

/***/ },
/* 573 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(572).inherits


/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(572).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(572).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(578);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(568)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(582)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(261).Buffer))

/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RedirectWhenMissingFn;
	
	var _uiErrors = __webpack_require__(359);
	
	var _uiErrors2 = _interopRequireDefault(_uiErrors);
	
	function RedirectWhenMissingFn($location, kbnUrl, Notifier, Promise) {
	  var SavedObjectNotFound = _uiErrors2['default'].SavedObjectNotFound;
	
	  var notify = new Notifier();
	
	  /**
	   * Creates an error handler that will redirect to a url when a SavedObjectNotFound
	   * error is thrown
	   *
	   * @param  {string|object} mapping - a mapping of url's to redirect to based on the saved object that
	   *                                 couldn't be found, or just a string that will be used for all types
	   * @return {function} - the handler to pass to .catch()
	   */
	  return function (mapping) {
	    if (typeof mapping === 'string') {
	      mapping = { '*': mapping };
	    }
	
	    return function (err) {
	      // if this error is not "404", rethrow
	      if (!(err instanceof SavedObjectNotFound)) throw err;
	
	      var url = mapping[err.savedObjectType] || mapping['*'];
	      if (!url) url = '/';
	
	      url += (url.indexOf('?') >= 0 ? '&' : '?') + ('notFound=' + err.savedObjectType);
	
	      notify.error(err);
	      kbnUrl.redirect(url);
	      return Promise.halt();
	    };
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	// Debounce service, angularized version of lodash debounce
	// borrowed heavily from https://github.com/shahata/angular-debounce
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.service('debounce', ['$timeout', function ($timeout) {
	  return function (func, wait, options) {
	    var timeout = undefined;
	    var args = undefined;
	    var self = undefined;
	    var result = undefined;
	    options = _lodash2['default'].defaults(options || {}, {
	      leading: false,
	      trailing: true,
	      invokeApply: true
	    });
	
	    function debounce() {
	      self = this;
	      args = arguments;
	
	      var later = function later() {
	        timeout = null;
	        if (!options.leading || options.trailing) {
	          result = func.apply(self, args);
	        }
	      };
	
	      var callNow = options.leading && !timeout;
	
	      if (timeout) {
	        $timeout.cancel(timeout);
	      }
	      timeout = $timeout(later, wait, options.invokeApply);
	
	      if (callNow) {
	        result = func.apply(self, args);
	      }
	
	      return result;
	    }
	
	    debounce.cancel = function () {
	      $timeout.cancel(timeout);
	      timeout = null;
	    };
	
	    return debounce;
	  };
	}]);

/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DoctitleProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiChrome = __webpack_require__(1);
	
	var _uiChrome2 = _interopRequireDefault(_uiChrome);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').run(function ($rootScope, docTitle) {
	  // always bind to the route events
	  $rootScope.$on('$routeChangeStart', docTitle.reset);
	  $rootScope.$on('$routeChangeError', docTitle.update);
	  $rootScope.$on('$routeChangeSuccess', docTitle.update);
	}).service('docTitle', function ($rootScope) {
	  var baseTitle = document.title;
	  var self = this;
	
	  var lastChange = undefined;
	
	  function render() {
	    lastChange = lastChange || [];
	
	    var parts = [lastChange[0]];
	
	    if (!lastChange[1]) parts.push(baseTitle);
	
	    return (0, _lodash2['default'])(parts).flattenDeep().compact().join(' - ');
	  }
	
	  self.change = function (title, complete) {
	    lastChange = [title, complete];
	    self.update();
	  };
	
	  self.reset = function () {
	    lastChange = null;
	  };
	
	  self.update = function () {
	    document.title = render();
	  };
	});
	
	// return a "private module" so that it can be used both ways
	
	function DoctitleProvider(docTitle) {
	  return docTitle;
	}
	
	module.exports = exports['default'];

/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var NL_RE = /\n/g;
	var events = 'keydown keypress keyup change';
	
	_uiModules2['default'].get('kibana').directive('elasticTextarea', function () {
	  return {
	    restrict: 'A',
	    link: function link($scope, $el) {
	
	      function resize() {
	        $el.attr('rows', _lodash2['default'].size($el.val().match(NL_RE)) + 1);
	      }
	
	      $el.on(events, resize);
	      $scope.$evalAsync(resize);
	      $scope.$on('$destroy', function () {
	        $el.off(events, resize);
	      });
	    }
	  };
	});

/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _uiFancy_formsKbn_form_controller = __webpack_require__(588);
	
	var _uiFancy_formsKbn_form_controller2 = _interopRequireDefault(_uiFancy_formsKbn_form_controller);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').config(function ($provide) {
	  function decorateDirectiveController(DecorativeController) {
	    return function ($delegate, $injector) {
	      // directive providers are arrays
	      $delegate.forEach(function (directive) {
	        // get metadata about all init fns
	        var chain = [directive.controller, DecorativeController].map(function (fn) {
	          var deps = $injector.annotate(fn);
	          return { deps: deps, fn: _lodash2['default'].isArray(fn) ? _lodash2['default'].last(fn) : fn };
	        });
	
	        // replace the controller with one that will setup the actual controller
	        directive.controller = function stub() {
	          var allDeps = _lodash2['default'].toArray(arguments);
	          return chain.reduce(function (controller, link, i) {
	            var deps = allDeps.splice(0, link.deps.length);
	            return link.fn.apply(controller, deps) || controller;
	          }, this);
	        };
	
	        // set the deps of our new controller to be the merged deps of every fn
	        directive.controller.$inject = chain.reduce(function (deps, link) {
	          return deps.concat(link.deps);
	        }, []);
	      });
	
	      return $delegate;
	    };
	  }
	
	  $provide.decorator('formDirective', decorateDirectiveController(_uiFancy_formsKbn_form_controller2['default']));
	  $provide.decorator('ngFormDirective', decorateDirectiveController(_uiFancy_formsKbn_form_controller2['default']));
	});

/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	/**
	 * Extension of Angular's FormController class
	 * that provides helpers for error handling/validation.
	 *
	 * @param {$scope} $scope
	 */
	function KbnFormController($scope, $element) {
	  var self = this;
	
	  self.errorCount = function (predicate) {
	    return self.$$invalidModels().length;
	  };
	
	  // same as error count, but filters out untouched and pristine models
	  self.softErrorCount = function () {
	    return self.$$invalidModels(function (model) {
	      return model.$touched || model.$dirty;
	    }).length;
	  };
	
	  self.describeErrors = function () {
	    var count = self.softErrorCount();
	    return count + ' Error' + (count === 1 ? '' : 's');
	  };
	
	  self.$$invalidModels = function (predicate) {
	    predicate = _lodash2['default'].callback(predicate);
	
	    var invalid = [];
	
	    _lodash2['default'].forOwn(self.$error, function collect(models) {
	      if (!models) return;
	
	      models.forEach(function (model) {
	        if (model.$$invalidModels) {
	          // recurse into child form
	          _lodash2['default'].forOwn(model.$error, collect);
	        } else {
	          if (predicate(model)) {
	            // prevent dups
	            var len = invalid.length;
	            while (len--) if (invalid[len] === model) return;
	
	            invalid.push(model);
	          }
	        }
	      });
	    });
	
	    return invalid;
	  };
	
	  self.$setTouched = function () {
	    self.$$invalidModels().forEach(function (model) {
	      // only kbnModels have $setTouched
	      if (model.$setTouched) model.$setTouched();
	    });
	  };
	
	  function filterSubmits(event) {
	    if (self.errorCount()) {
	      event.preventDefault();
	      event.stopImmediatePropagation();
	      self.$setTouched();
	    }
	  }
	
	  $element.on('submit', filterSubmits);
	  $scope.$on('$destroy', function () {
	    $element.off('submit', filterSubmits);
	  });
	}
	
	exports['default'] = KbnFormController;
	module.exports = exports['default'];

/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barFilter_barHtml = __webpack_require__(590);
	
	var _uiFilter_barFilter_barHtml2 = _interopRequireDefault(_uiFilter_barFilter_barHtml);
	
	__webpack_require__(591);
	
	var _uiFilter_barLibFilter_applied_and_unwrap = __webpack_require__(592);
	
	var _uiFilter_barLibFilter_applied_and_unwrap2 = _interopRequireDefault(_uiFilter_barLibFilter_applied_and_unwrap);
	
	var _uiFilter_barLibMap_and_flatten_filters = __webpack_require__(593);
	
	var _uiFilter_barLibMap_and_flatten_filters2 = _interopRequireDefault(_uiFilter_barLibMap_and_flatten_filters);
	
	var _uiFilter_barLibMap_flatten_and_wrap_filters = __webpack_require__(605);
	
	var _uiFilter_barLibMap_flatten_and_wrap_filters2 = _interopRequireDefault(_uiFilter_barLibMap_flatten_and_wrap_filters);
	
	var _uiFilter_barLibExtract_time_filter = __webpack_require__(606);
	
	var _uiFilter_barLibExtract_time_filter2 = _interopRequireDefault(_uiFilter_barLibExtract_time_filter);
	
	var _uiFilter_barLibFilter_out_time_based_filter = __webpack_require__(607);
	
	var _uiFilter_barLibFilter_out_time_based_filter2 = _interopRequireDefault(_uiFilter_barLibFilter_out_time_based_filter);
	
	var _uiFilter_barLibChange_time_filter = __webpack_require__(608);
	
	var _uiFilter_barLibChange_time_filter2 = _interopRequireDefault(_uiFilter_barLibChange_time_filter);
	
	var _uiFilter_barQuery_filter = __webpack_require__(609);
	
	var _uiFilter_barQuery_filter2 = _interopRequireDefault(_uiFilter_barQuery_filter);
	
	var _libCompare_filters = __webpack_require__(612);
	
	var _libCompare_filters2 = _interopRequireDefault(_libCompare_filters);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('filterBar', function (Private, Promise, getAppState) {
	  var mapAndFlattenFilters = Private(_uiFilter_barLibMap_and_flatten_filters2['default']);
	  var mapFlattenAndWrapFilters = Private(_uiFilter_barLibMap_flatten_and_wrap_filters2['default']);
	  var extractTimeFilter = Private(_uiFilter_barLibExtract_time_filter2['default']);
	  var filterOutTimeBasedFilter = Private(_uiFilter_barLibFilter_out_time_based_filter2['default']);
	  var changeTimeFilter = Private(_uiFilter_barLibChange_time_filter2['default']);
	  var queryFilter = Private(_uiFilter_barQuery_filter2['default']);
	  var privateFilterFieldRegex = /(^\$|meta)/;
	
	  return {
	    restrict: 'E',
	    template: _uiFilter_barFilter_barHtml2['default'],
	    scope: {},
	    link: function link($scope, $el, attrs) {
	      // bind query filter actions to the scope
	      ['addFilters', 'toggleFilter', 'toggleAll', 'pinFilter', 'pinAll', 'invertFilter', 'invertAll', 'removeFilter', 'removeAll', 'updateFilter'].forEach(function (method) {
	        $scope[method] = queryFilter[method];
	      });
	
	      $scope.state = getAppState();
	
	      $scope.aceLoaded = function (editor) {
	        editor.$blockScrolling = Infinity;
	        var session = editor.getSession();
	        session.setTabSize(2);
	        session.setUseSoftTabs(true);
	      };
	
	      $scope.applyFilters = function (filters) {
	        addAndInvertFilters((0, _uiFilter_barLibFilter_applied_and_unwrap2['default'])(filters));
	        $scope.newFilters = [];
	
	        // change time filter
	        if ($scope.changeTimeFilter && $scope.changeTimeFilter.meta && $scope.changeTimeFilter.meta.apply) {
	          changeTimeFilter($scope.changeTimeFilter);
	        }
	      };
	
	      $scope.startEditingFilter = function (source) {
	        return $scope.editingFilter = {
	          source: source,
	          type: _lodash2['default'].findKey(source, function (val, key) {
	            return !key.match(privateFilterFieldRegex);
	          }),
	          model: convertToEditableFilter(source),
	          alias: source.meta.alias
	        };
	      };
	
	      $scope.stopEditingFilter = function () {
	        $scope.editingFilter = null;
	      };
	
	      $scope.editDone = function () {
	        $scope.updateFilter($scope.editingFilter);
	        $scope.stopEditingFilter();
	      };
	
	      $scope.clearFilterBar = function () {
	        $scope.newFilters = [];
	        $scope.changeTimeFilter = null;
	      };
	
	      // update the scope filter list on filter changes
	      $scope.$listen(queryFilter, 'update', function () {
	        $scope.stopEditingFilter();
	        updateFilters();
	      });
	
	      // when appState changes, update scope's state
	      $scope.$watch(getAppState, function (appState) {
	        $scope.state = appState;
	      });
	
	      $scope.$watch('state.$newFilters', function (filters) {
	        if (!filters) return;
	
	        // If filters is not undefined and the length is greater than
	        // one we need to set the newFilters attribute and allow the
	        // users to decide what they want to apply.
	        if (filters.length > 1) {
	          return mapFlattenAndWrapFilters(filters).then(function (results) {
	            extractTimeFilter(results).then(function (filter) {
	              $scope.changeTimeFilter = filter;
	            });
	            return results;
	          }).then(filterOutTimeBasedFilter).then(function (results) {
	            $scope.newFilters = results;
	          });
	        }
	
	        // Just add single filters to the state.
	        if (filters.length === 1) {
	          Promise.resolve(filters).then(function (filters) {
	            extractTimeFilter(filters).then(function (timeFilter) {
	              if (timeFilter) changeTimeFilter(timeFilter);
	            });
	            return filters;
	          }).then(filterOutTimeBasedFilter).then(addAndInvertFilters);
	        }
	      });
	
	      function addAndInvertFilters(filters) {
	        var existingFilters = queryFilter.getFilters();
	        var inversionFilters = _lodash2['default'].filter(existingFilters, function (existingFilter) {
	          var newMatchingFilter = _lodash2['default'].find(filters, _lodash2['default'].partial(_libCompare_filters2['default'], existingFilter));
	          return newMatchingFilter && newMatchingFilter.meta && existingFilter.meta && existingFilter.meta.negate !== newMatchingFilter.meta.negate;
	        });
	        var newFilters = _lodash2['default'].reject(filters, function (filter) {
	          return _lodash2['default'].find(inversionFilters, _lodash2['default'].partial(_libCompare_filters2['default'], filter));
	        });
	
	        _lodash2['default'].forEach(inversionFilters, $scope.invertFilter);
	        $scope.addFilters(newFilters);
	      }
	
	      function convertToEditableFilter(filter) {
	        return _lodash2['default'].omit(_lodash2['default'].cloneDeep(filter), function (val, key) {
	          return key.match(privateFilterFieldRegex);
	        });
	      }
	
	      function updateFilters() {
	        var filters = queryFilter.getFilters();
	        mapAndFlattenFilters(filters).then(function (results) {
	          // used to display the current filters in the state
	          $scope.filters = _lodash2['default'].sortBy(results, function (filter) {
	            return !filter.meta.pinned;
	          });
	          $scope.$emit('filterbar:updated');
	        });
	      }
	
	      updateFilters();
	    }
	  };
	});

/***/ },
/* 590 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-bar-confirm\" ng-show=\"newFilters.length\">\n  <form ng-submit=\"applyFilters(newFilters)\">\n  <ul class=\"list-unstyled\">\n    <li>Apply these filters?</li>\n    <li ng-repeat=\"filter in newFilters\" class=\"filter\" ng-click=\"filter.meta.apply = !filter.meta.apply\"><input type=\"checkbox\" ng-checked=\"filter.meta.apply\"/> {{ filter.meta.key }}: {{ filter.meta.value }}</li>\n    <li ng-if=\"changeTimeFilter\" class=\"changeTimeFilter filter\" ng-click=\"changeTimeFilter.meta.apply = !changeTimeFilter.meta.apply\"><input type=\"checkbox\" ng-checked=\"changeTimeFilter.meta.apply\"/> <strong>Change time to:</strong> {{changeTimeFilter.meta.value}} </li>\n    <li><button class=\"btn btn-xs btn-primary\">Apply Now</button> or <a ng-click=\"clearFilterBar();\">Cancel</a></li>\n  </ul>\n  </form>\n</div>\n\n<div class=\"filter-bar\" ng-show=\"filters.length\">\n  <div class=\"filter\" ng-class=\"{ negate: filter.meta.negate, disabled: filter.meta.disabled }\" ng-repeat=\"filter in filters\">\n    <div class=\"filter-description\">\n      <span ng-if=\"filter.$state.store == 'globalState'\"><i class=\"fa fa-fw fa-thumb-tack pinned\"></i></span>\n      <span ng-if=\"filter.meta.alias\">{{ filter.meta.alias }}</span>\n      <span ng-if=\"!filter.meta.alias\">{{ filter.meta.key }}:</span>\n      <span ng-if=\"!filter.meta.alias\">\"{{ filter.meta.value }}\"</span>\n    </div>\n    <div class=\"filter-actions\">\n      <a class=\"action filter-toggle\" ng-click=\"toggleFilter(filter)\" data-test-subj=\"disableFilter-{{ filter.meta.key }}\">\n        <i ng-show=\"filter.meta.disabled\" class=\"fa fa-fw fa-square-o disabled\"></i>\n        <i ng-hide=\"filter.meta.disabled\" class=\"fa fa-fw fa-check-square-o enabled\"></i>\n      </a>\n      <a class=\"action filter-pin\" ng-click=\"pinFilter(filter)\" data-test-subj=\"pinFilter-{{ filter.meta.key }}\">\n        <i ng-show=\"filter.$state.store == 'globalState'\" class=\"fa fa-fw fa-thumb-tack pinned\"></i>\n        <i ng-hide=\"filter.$state.store == 'globalState'\" class=\"fa fa-fw fa-thumb-tack fa-rotate-270 unpinned\"></i>\n      </a>\n      <a class=\"action filter-invert\" ng-click=\"invertFilter(filter)\" data-test-subj=\"invertFilter-{{ filter.meta.key }}\">\n        <i ng-show=\"filter.meta.negate\" class=\"fa fa-fw fa-search-plus negative\"></i>\n        <i ng-hide=\"filter.meta.negate\" class=\"fa fa-fw fa-search-minus positive\"></i>\n      </a>\n      <a class=\"action filter-remove\" ng-click=\"removeFilter(filter)\">\n        <i class=\"fa fa-fw fa-trash\" data-test-subj=\"removeFilter-{{ filter.meta.key }}\"></i>\n      </a>\n      <a class=\"action filter-edit\" ng-click=\"startEditingFilter(filter)\">\n        <i class=\"fa fa-fw fa-edit\"></i>\n      </a>\n    </div>\n  </div>\n\n  <div class=\"filter-edit-container\" ng-if=\"editingFilter\">\n    <form role=\"form\" name=\"editFilterForm\" ng-submit=\"editDone()\">\n      <div class=\"form-group filter-edit-alias\">\n        <label>Filter Alias\n          <small>(optional)</small>\n        </label>\n        <input\n          ng-model=\"editingFilter.alias\"\n          type=\"text\"\n          class=\"form-control\">\n      </div>\n      <div\n        json-input\n        require-keys=\"true\"\n        ui-ace=\"{\n          mode: 'json',\n          onLoad: aceLoaded\n        }\"\n        ng-model=\"editingFilter.model\"></div>\n      <div class=\"form-group\">\n        <button class=\"btn btn-primary\" ng-click=\"stopEditingFilter()\">Cancel</button>\n        <button type=\"submit\" class=\"btn btn-success\"\n          ng-disabled=\"editFilterForm.$invalid\"\n          >Done</button>\n        <small ng-show=\"editFilterForm.$invalid\">Could not parse JSON input</small>\n      </div>\n    </form>\n  </div>\n\n  <div class=\"filter-link\">\n    <div class=\"filter-description small\">\n      <a ng-click=\"showFilterActions = !showFilterActions\">\n        Actions\n        <i class=\"fa\"\n        ng-class=\"{'fa-caret-down': showFilterActions, 'fa-caret-right': !showFilterActions}\" data-test-subj=\"showFilterActions\"></i>\n      </a>\n    </div>\n  </div>\n</div>\n\n<div class=\"filter-bar filter-bar-condensed\" ng-show=\"filters.length && showFilterActions\">\n  <div class=\"filter-actions-all\">\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><strong>All filters:</strong></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"toggleAll(false)\">Enable</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"toggleAll(true)\">Disable</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"pinAll(true)\">Pin</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"pinAll(false)\">Unpin</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"invertAll()\">Invert</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"toggleAll()\">Toggle</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"removeAll()\" data-test-subj=\"removeAllFilters\">Remove</a></div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('jsonInput', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link(scope, $el, attrs, ngModelCntrl) {
	      ngModelCntrl.$formatters.push(toJSON);
	      ngModelCntrl.$parsers.push(fromJSON);
	
	      function fromJSON(value) {
	        try {
	          value = JSON.parse(value);
	          var validity = !scope.$eval(attrs.requireKeys) ? true : _lodash2['default'].keys(value).length > 0;
	          ngModelCntrl.$setValidity('json', validity);
	        } catch (e) {
	          ngModelCntrl.$setValidity('json', false);
	        }
	        return value;
	      }
	
	      function toJSON(value) {
	        return _angular2['default'].toJson(value, 2);
	      }
	    }
	  };
	});

/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	exports['default'] = function (filters) {
	  return _lodash2['default'].filter(filters, 'meta.apply');
	};
	
	module.exports = exports['default'];

/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapAndFlattenFiltersProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barLibMap_filter = __webpack_require__(594);
	
	var _uiFilter_barLibMap_filter2 = _interopRequireDefault(_uiFilter_barLibMap_filter);
	
	function mapAndFlattenFiltersProvider(Private, Promise) {
	  var mapFilter = Private(_uiFilter_barLibMap_filter2['default']);
	  return function (filters) {
	    return (0, _lodash2['default'])(filters).flatten().compact().map(mapFilter).thru(Promise.all).value();
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapFilterProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _generate_mapping_chain = __webpack_require__(595);
	
	var _generate_mapping_chain2 = _interopRequireDefault(_generate_mapping_chain);
	
	var _map_match_all = __webpack_require__(596);
	
	var _map_match_all2 = _interopRequireDefault(_map_match_all);
	
	var _map_terms = __webpack_require__(597);
	
	var _map_terms2 = _interopRequireDefault(_map_terms);
	
	var _map_range = __webpack_require__(598);
	
	var _map_range2 = _interopRequireDefault(_map_range);
	
	var _map_exists = __webpack_require__(599);
	
	var _map_exists2 = _interopRequireDefault(_map_exists);
	
	var _map_missing = __webpack_require__(600);
	
	var _map_missing2 = _interopRequireDefault(_map_missing);
	
	var _map_query_string = __webpack_require__(601);
	
	var _map_query_string2 = _interopRequireDefault(_map_query_string);
	
	var _map_geo_bounding_box = __webpack_require__(602);
	
	var _map_geo_bounding_box2 = _interopRequireDefault(_map_geo_bounding_box);
	
	var _map_script = __webpack_require__(603);
	
	var _map_script2 = _interopRequireDefault(_map_script);
	
	var _map_default = __webpack_require__(604);
	
	var _map_default2 = _interopRequireDefault(_map_default);
	
	function mapFilterProvider(Promise, Private) {
	
	  var generateMappingChain = Private(_generate_mapping_chain2['default']);
	
	  /** Mappers **/
	
	  // Each mapper is a simple promise function that test if the mapper can
	  // handle the mapping or not. If it handles it then it will resolve with
	  // and object that has the key and value for the filter. Otherwise it will
	  // reject it with the original filter. We had to go down the promise interface
	  // because mapTerms and mapRange need access to the indexPatterns to format
	  // the values and that's only available through the field formatters.
	
	  // The mappers to apply. Each mapper will either return
	  // a result object with a key and value attribute or
	  // undefined. If undefined is return then the next
	  // mapper will get the opportunity to map the filter.
	  // To create a new mapper you just need to create a function
	  // that either handles the mapping operation or not
	  // and add it here. ProTip: These are executed in order listed
	  var mappers = [Private(_map_match_all2['default']), Private(_map_terms2['default']), Private(_map_range2['default']), Private(_map_exists2['default']), Private(_map_missing2['default']), Private(_map_query_string2['default']), Private(_map_geo_bounding_box2['default']), Private(_map_script2['default']), Private(_map_default2['default'])];
	
	  var noop = function noop() {
	    return Promise.reject(new Error('No mappings have been found for filter.'));
	  };
	
	  // Create a chain of responsibility by reducing all the
	  // mappers down into one function.
	  var mapFn = _lodash2['default'].reduceRight(mappers, function (memo, map) {
	    var filterChainFn = generateMappingChain(map);
	    return filterChainFn(memo);
	  }, noop);
	
	  /**
	   * Map the filter into an object with the key and value exposed so it's
	   * easier to work with in the template
	   * @param {object} filter The filter the map
	   * @returns {Promise}
	   */
	  return function (filter) {
	    // Apply the mapping function
	    return mapFn(filter).then(function (result) {
	      filter.meta = filter.meta || {};
	      filter.meta.key = result.key;
	      filter.meta.value = result.value;
	      filter.meta.disabled = !!filter.meta.disabled;
	      filter.meta.negate = !!filter.meta.negate;
	      filter.meta.alias = filter.meta.alias || null;
	      return filter;
	    });
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 595 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = generateMappingChainProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function generateMappingChainProvider(Promise) {
	
	  var noop = function noop() {
	    return Promise.reject(new Error('No mappings have been found for filter.'));
	  };
	
	  return function (fn) {
	    return function (next) {
	      next = next || noop;
	      return function (filter) {
	        return fn(filter)['catch'](function (result) {
	          if (result === filter) {
	            return next(filter);
	          }
	          return Promise.reject(result);
	        });
	      };
	    };
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 596 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapMatchAllProvider;
	
	function mapMatchAllProvider(Promise) {
	  return function (filter) {
	    if (filter.match_all) {
	      var key = filter.meta.field;
	      var value = filter.meta.formattedValue || 'all';
	      return Promise.resolve({ key: key, value: value });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 597 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapTermsProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function mapTermsProvider(Promise, courier) {
	  return function (filter) {
	    var key = undefined;
	    var value = undefined;
	    var field = undefined;
	    if (filter.query && filter.query.match) {
	      return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	        key = _lodash2['default'].keys(filter.query.match)[0];
	        field = indexPattern.fields.byName[key];
	        value = filter.query.match[key].query;
	        value = field.format.convert(value);
	        return { key: key, value: value };
	      });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 598 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapRangeProvider;
	
	var _lodash = __webpack_require__(3);
	
	function mapRangeProvider(Promise, courier) {
	  return function (filter) {
	    if (!filter.range) return Promise.reject(filter);
	
	    return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	      var key = _Object$keys(filter.range)[0];
	      var convert = indexPattern.fields.byName[key].format.getConverterFor('text');
	      var range = filter.range[key];
	
	      var left = (0, _lodash.has)(range, 'gte') ? range.gte : range.gt;
	      if (left == null) left = -Infinity;
	
	      var right = (0, _lodash.has)(range, 'lte') ? range.lte : range.lt;
	      if (right == null) right = Infinity;
	
	      return {
	        key: key,
	        value: convert(left) + ' to ' + convert(right)
	      };
	    });
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 599 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapExistsProvider;
	
	function mapExistsProvider(Promise) {
	  return function (filter) {
	    var key = undefined;
	    var value = undefined;
	    if (filter.exists) {
	      key = 'exists';
	      value = filter.exists.field;
	      return Promise.resolve({ key: key, value: value });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 600 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapMissingProvider;
	
	function mapMissingProvider(Promise) {
	  return function (filter) {
	    var key = undefined;
	    var value = undefined;
	    if (filter.missing) {
	      key = 'missing';
	      value = filter.missing.field;
	      return Promise.resolve({ key: key, value: value });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 601 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapQueryStringProvider;
	
	function mapQueryStringProvider(Promise) {
	  return function (filter) {
	    var key = undefined;
	    var value = undefined;
	    if (filter.query && filter.query.query_string) {
	      key = 'query';
	      value = filter.query.query_string.query;
	      return Promise.resolve({ key: key, value: value });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 602 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapGeoBoundBoxProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function mapGeoBoundBoxProvider(Promise, courier) {
	  return function (filter) {
	    var key = undefined;
	    var value = undefined;
	    var topLeft = undefined;
	    var bottomRight = undefined;
	    var field = undefined;
	    if (filter.geo_bounding_box) {
	      return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	        key = _lodash2['default'].keys(filter.geo_bounding_box)[0];
	        field = indexPattern.fields.byName[key];
	        topLeft = field.format.convert(filter.geo_bounding_box[field.name].top_left);
	        bottomRight = field.format.convert(filter.geo_bounding_box[field.name].bottom_right);
	        value = topLeft + ' to ' + bottomRight;
	        return { key: key, value: value };
	      });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function mapScriptProvider(Promise, courier) {
	    return function (filter) {
	      var key = undefined;
	      var value = undefined;
	      var field = undefined;
	      if (filter.script) {
	        return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	          key = filter.meta.field;
	          field = indexPattern.fields.byName[key];
	
	          if (filter.meta.formattedValue) {
	            value = filter.meta.formattedValue;
	          } else {
	            value = filter.script.script.params.value;
	            value = field.format.convert(value);
	          }
	
	          return { key: key, value: value };
	        });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 604 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapDefaultProvider;
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function mapDefaultProvider(Promise) {
	
	  var metaProperty = /(^\$|meta)/;
	
	  return function (filter) {
	    var key = _lodash2['default'].find(_lodash2['default'].keys(filter), function (key) {
	      return !key.match(metaProperty);
	    });
	
	    if (key) {
	      var value = _angular2['default'].toJson(filter[key]);
	      return Promise.resolve({ key: key, value: value });
	    }
	    return Promise.reject(filter);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mapFlattenAndWrapFilters;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barLibMap_and_flatten_filters = __webpack_require__(593);
	
	var _uiFilter_barLibMap_and_flatten_filters2 = _interopRequireDefault(_uiFilter_barLibMap_and_flatten_filters);
	
	function mapFlattenAndWrapFilters(Private) {
	  var mapAndFlattenFilters = Private(_uiFilter_barLibMap_and_flatten_filters2['default']);
	  return function (filters) {
	    return mapAndFlattenFilters(filters).then(function (filters) {
	      return _lodash2['default'].map(filters, function (filter) {
	        filter.meta = filter.meta || {};
	        filter.meta.apply = true;
	        return filter;
	      });
	    });
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = extractTimeFilterProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function extractTimeFilterProvider(courier, Promise) {
	  return Promise.method(function (filters) {
	    // Assume all the index patterns are the same since they will be added
	    // from the same visualization.
	    var id = _lodash2['default'].get(filters, '[0].meta.index');
	    if (id == null) return;
	
	    return courier.indexPatterns.get(id).then(function (indexPattern) {
	      var filter = _lodash2['default'].find(filters, function (obj) {
	        var key = _lodash2['default'].keys(obj.range)[0];
	        return key === indexPattern.timeFieldName;
	      });
	      if (filter && filter.range) {
	        return filter;
	      }
	    });
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = filterOutTimeBaseFilter;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function filterOutTimeBaseFilter(courier, Promise) {
	  return Promise.method(function (filters) {
	    var id = _lodash2['default'].get(filters, '[0].meta.index');
	    if (id == null) return;
	
	    return courier.indexPatterns.get(id).then(function (indexPattern) {
	      return _lodash2['default'].filter(filters, function (filter) {
	        return !(filter.range && filter.range[indexPattern.timeFieldName]);
	      });
	    });
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 608 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = changeTimeFilterProvider;
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function changeTimeFilterProvider(timefilter) {
	  return function (filter) {
	    var key = _lodash2['default'].keys(filter.range)[0];
	    var values = filter.range[key];
	    timefilter.time.from = (0, _moment2['default'])(values.gt || values.gte);
	    timefilter.time.to = (0, _moment2['default'])(values.lt || values.lte);
	    timefilter.time.mode = 'absolute';
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 609 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barLibOnly_disabled = __webpack_require__(610);
	
	var _uiFilter_barLibOnly_disabled2 = _interopRequireDefault(_uiFilter_barLibOnly_disabled);
	
	var _uiFilter_barLibOnly_state_changed = __webpack_require__(611);
	
	var _uiFilter_barLibOnly_state_changed2 = _interopRequireDefault(_uiFilter_barLibOnly_state_changed);
	
	var _uiFilter_barLibUniq_filters = __webpack_require__(613);
	
	var _uiFilter_barLibUniq_filters2 = _interopRequireDefault(_uiFilter_barLibUniq_filters);
	
	var _uiFilter_barLibCompare_filters = __webpack_require__(612);
	
	var _uiFilter_barLibCompare_filters2 = _interopRequireDefault(_uiFilter_barLibCompare_filters);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiEvents = __webpack_require__(283);
	
	var _uiEvents2 = _interopRequireDefault(_uiEvents);
	
	var _uiFilter_barLibMap_and_flatten_filters = __webpack_require__(593);
	
	var _uiFilter_barLibMap_and_flatten_filters2 = _interopRequireDefault(_uiFilter_barLibMap_and_flatten_filters);
	
	exports['default'] = function (Private, $rootScope, getAppState, globalState, config) {
	  var EventEmitter = Private(_uiEvents2['default']);
	  var mapAndFlattenFilters = Private(_uiFilter_barLibMap_and_flatten_filters2['default']);
	
	  var queryFilter = new EventEmitter();
	
	  queryFilter.getFilters = function () {
	    var compareOptions = { disabled: true, negate: true };
	    var appFilters = queryFilter.getAppFilters();
	    var globalFilters = queryFilter.getGlobalFilters();
	
	    return (0, _uiFilter_barLibUniq_filters2['default'])(globalFilters.concat(appFilters), compareOptions);
	  };
	
	  queryFilter.getAppFilters = function () {
	    var appState = getAppState();
	    if (!appState || !appState.filters) return [];
	
	    // Work around for https://github.com/elastic/kibana/issues/5896
	    appState.filters = validateStateFilters(appState);
	
	    return appState.filters ? _lodash2['default'].map(appState.filters, appendStoreType('appState')) : [];
	  };
	
	  queryFilter.getGlobalFilters = function () {
	    if (!globalState.filters) return [];
	
	    // Work around for https://github.com/elastic/kibana/issues/5896
	    globalState.filters = validateStateFilters(globalState);
	
	    return _lodash2['default'].map(globalState.filters, appendStoreType('globalState'));
	  };
	
	  /**
	   * Adds new filters to the scope and state
	   * @param {object|array} filters Filter(s) to add
	   * @param {bool} global Whether the filter should be added to global state
	   * @returns {Promise} filter map promise
	   */
	  queryFilter.addFilters = function (filters, global) {
	
	    if (global === undefined) {
	      var configDefault = config.get('filters:pinnedByDefault');
	
	      if (configDefault === false || configDefault === true) {
	        global = configDefault;
	      }
	    }
	
	    // Determine the state for the new filter (whether to pass the filter through other apps or not)
	    var appState = getAppState();
	    var filterState = global ? globalState : appState;
	
	    if (!_lodash2['default'].isArray(filters)) {
	      filters = [filters];
	    }
	
	    return mapAndFlattenFilters(filters).then(function (filters) {
	      if (!filterState.filters) {
	        filterState.filters = [];
	      }
	
	      filterState.filters = filterState.filters.concat(filters);
	    });
	  };
	
	  /**
	   * Removes the filter from the proper state
	   * @param {object} matchFilter The filter to remove
	   */
	  queryFilter.removeFilter = function (matchFilter) {
	    var appState = getAppState();
	    var filter = _lodash2['default'].omit(matchFilter, ['$$hashKey']);
	    var state = undefined;
	    var index = undefined;
	
	    // check for filter in appState
	    if (appState) {
	      index = _lodash2['default'].findIndex(appState.filters, filter);
	      if (index !== -1) state = appState;
	    }
	
	    // if not found, check for filter in globalState
	    if (!state) {
	      index = _lodash2['default'].findIndex(globalState.filters, filter);
	      if (index !== -1) state = globalState;else return; // not found in either state, do nothing
	    }
	
	    state.filters.splice(index, 1);
	  };
	
	  /**
	  * Updates an existing filter
	  * @param {object} filter Contains a reference to a filter and its new model
	  * @param {object} filter.source The filter reference
	  * @param {string} filter.model The edited filter
	  * @returns {object} Promise that resolves to the new filter on a successful merge
	  */
	  queryFilter.updateFilter = function (filter) {
	    var mergedFilter = _lodash2['default'].assign({}, filter.source, filter.model);
	    mergedFilter.meta.alias = filter.alias;
	    //If the filter type is changed we want to discard the old type
	    //when merging changes back in
	    var filterTypeReplaced = filter.model[filter.type] !== mergedFilter[filter.type];
	    if (filterTypeReplaced) {
	      delete mergedFilter[filter.type];
	    }
	
	    return _angular2['default'].copy(mergedFilter, filter.source);
	  };
	
	  /**
	   * Removes all filters
	   */
	  queryFilter.removeAll = function () {
	    var appState = getAppState();
	    appState.filters = [];
	    globalState.filters = [];
	  };
	
	  /**
	   * Toggles the filter between enabled/disabled.
	   * @param {object} filter The filter to toggle
	   & @param {boolean} force Disabled true/false
	   * @returns {object} updated filter
	   */
	  queryFilter.toggleFilter = function (filter, force) {
	    // Toggle the disabled flag
	    var disabled = _lodash2['default'].isUndefined(force) ? !filter.meta.disabled : !!force;
	    filter.meta.disabled = disabled;
	    return filter;
	  };
	
	  /**
	   * Disables all filters
	   * @params {boolean} force Disable/enable all filters
	   */
	  queryFilter.toggleAll = function (force) {
	    function doToggle(filter) {
	      queryFilter.toggleFilter(filter, force);
	    }
	
	    executeOnFilters(doToggle);
	  };
	
	  /**
	   * Inverts the nagate value on the filter
	   * @param {object} filter The filter to toggle
	   * @returns {object} updated filter
	   */
	  queryFilter.invertFilter = function (filter) {
	    // Toggle the negate meta state
	    filter.meta.negate = !filter.meta.negate;
	    return filter;
	  };
	
	  /**
	   * Inverts all filters
	   * @returns {object} Resulting updated filter list
	   */
	  queryFilter.invertAll = function () {
	    executeOnFilters(queryFilter.invertFilter);
	  };
	
	  /**
	   * Pins the filter to the global state
	   * @param {object} filter The filter to pin
	   * @param {boolean} force pinned state
	   * @returns {object} updated filter
	   */
	  queryFilter.pinFilter = function (filter, force) {
	    var appState = getAppState();
	    if (!appState) return filter;
	
	    // ensure that both states have a filters property
	    if (!_lodash2['default'].isArray(globalState.filters)) globalState.filters = [];
	    if (!_lodash2['default'].isArray(appState.filters)) appState.filters = [];
	
	    var appIndex = _lodash2['default'].indexOf(appState.filters, filter);
	
	    if (appIndex !== -1 && force !== false) {
	      appState.filters.splice(appIndex, 1);
	      globalState.filters.push(filter);
	    } else {
	      var globalIndex = _lodash2['default'].indexOf(globalState.filters, filter);
	
	      if (globalIndex === -1 || force === true) return filter;
	
	      globalState.filters.splice(globalIndex, 1);
	      appState.filters.push(filter);
	    }
	
	    return filter;
	  };
	
	  /**
	   * Pins all filters
	   * @params {boolean} force Pin/Unpin all filters
	   */
	  queryFilter.pinAll = function (force) {
	    function pin(filter) {
	      queryFilter.pinFilter(filter, force);
	    }
	
	    executeOnFilters(pin);
	  };
	
	  initWatchers();
	
	  return queryFilter;
	
	  /**
	   * Rids filter list of null values and replaces state if any nulls are found
	   */
	  function validateStateFilters(state) {
	    var compacted = _lodash2['default'].compact(state.filters);
	    if (state.filters.length !== compacted.length) {
	      state.filters = compacted;
	      state.replace();
	    }
	    return state.filters;
	  }
	
	  /**
	   * Saves both app and global states, ensuring filters are persisted
	   * @returns {object} Resulting filter list, app and global combined
	   */
	  function saveState() {
	    var appState = getAppState();
	    if (appState) appState.save();
	    globalState.save();
	  }
	
	  function appendStoreType(type) {
	    return function (filter) {
	      filter.$state = {
	        store: type
	      };
	      return filter;
	    };
	  }
	
	  // helper to run a function on all filters in all states
	  function executeOnFilters(fn) {
	    var appState = getAppState();
	    var globalFilters = [];
	    var appFilters = [];
	
	    if (globalState.filters) globalFilters = globalState.filters;
	    if (appState && appState.filters) appFilters = appState.filters;
	
	    globalFilters.concat(appFilters).forEach(fn);
	  }
	
	  function mergeStateFilters(gFilters, aFilters, compareOptions) {
	    // ensure we don't mutate the filters passed in
	    var globalFilters = gFilters ? _lodash2['default'].cloneDeep(gFilters) : [];
	    var appFilters = aFilters ? _lodash2['default'].cloneDeep(aFilters) : [];
	    compareOptions = _lodash2['default'].defaults(compareOptions || {}, { disabled: true });
	
	    // existing globalFilters should be mutated by appFilters
	    _lodash2['default'].each(appFilters, function (filter, i) {
	      var match = _lodash2['default'].find(globalFilters, function (globalFilter) {
	        return (0, _uiFilter_barLibCompare_filters2['default'])(globalFilter, filter, compareOptions);
	      });
	
	      // no match, do nothing
	      if (!match) return;
	
	      // matching filter in globalState, update global and remove from appState
	      _lodash2['default'].assign(match.meta, filter.meta);
	      appFilters.splice(i, 1);
	    });
	
	    return [(0, _uiFilter_barLibUniq_filters2['default'])(globalFilters, { disabled: true }), (0, _uiFilter_barLibUniq_filters2['default'])(appFilters, { disabled: true })];
	  }
	
	  /**
	   * Initializes state watchers that use the event emitter
	   * @returns {void}
	   */
	  function initWatchers() {
	    var removeAppStateWatchers = undefined;
	
	    $rootScope.$watch(getAppState, function () {
	      removeAppStateWatchers && removeAppStateWatchers();
	      removeAppStateWatchers = initAppStateWatchers();
	    });
	
	    function initAppStateWatchers() {
	      // multi watch on the app and global states
	      var stateWatchers = [{
	        fn: $rootScope.$watch,
	        deep: true,
	        get: queryFilter.getGlobalFilters
	      }, {
	        fn: $rootScope.$watch,
	        deep: true,
	        get: queryFilter.getAppFilters
	      }];
	
	      // when states change, use event emitter to trigger updates and fetches
	      return $rootScope.$watchMulti(stateWatchers, function (next, prev) {
	        // prevent execution on watcher instantiation
	        if (_lodash2['default'].isEqual(next, prev)) return;
	
	        var doUpdate = false;
	        var doFetch = false;
	
	        // reconcile filter in global and app states
	        var filters = mergeStateFilters(next[0], next[1]);
	        var globalFilters = filters[0];
	        var appFilters = filters[1];
	        var appState = getAppState();
	
	        // save the state, as it may have updated
	        var globalChanged = !_lodash2['default'].isEqual(next[0], globalFilters);
	        var appChanged = !_lodash2['default'].isEqual(next[1], appFilters);
	
	        // the filters were changed, apply to state (re-triggers this watcher)
	        if (globalChanged || appChanged) {
	          globalState.filters = globalFilters;
	          if (appState) appState.filters = appFilters;
	          return;
	        }
	
	        // check for actions, bail if we're done
	        getActions();
	        if (!doUpdate) return;
	
	        // save states and emit the required events
	        saveState();
	        queryFilter.emit('update').then(function () {
	          if (!doFetch) return;
	          queryFilter.emit('fetch');
	        });
	
	        // iterate over each state type, checking for changes
	        function getActions() {
	          var newFilters = [];
	          var oldFilters = [];
	
	          stateWatchers.forEach(function (watcher, i) {
	            var nextVal = next[i];
	            var prevVal = prev[i];
	            newFilters = newFilters.concat(nextVal);
	            oldFilters = oldFilters.concat(prevVal);
	
	            // no update or fetch if there was no change
	            if (nextVal === prevVal) return;
	
	            if (nextVal) doUpdate = true;
	
	            // don't trigger fetch when only disabled filters
	            if (!(0, _uiFilter_barLibOnly_disabled2['default'])(nextVal, prevVal)) doFetch = true;
	          });
	
	          // make sure change wasn't only a state move
	          // checking length first is an optimization
	          if (doFetch && newFilters.length === oldFilters.length) {
	            if ((0, _uiFilter_barLibOnly_state_changed2['default'])(newFilters, oldFilters)) doFetch = false;
	          }
	        }
	      });
	    }
	  }
	};
	
	module.exports = exports['default'];

/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var pluckDisabled = function pluckDisabled(filter) {
	  return _lodash2['default'].get(filter, 'meta.disabled');
	};
	
	/**
	 * Checks to see if only disabled filters have been changed
	 * @returns {bool} Only disabled filters
	 */
	
	exports['default'] = function (newFilters, oldFilters) {
	  return _lodash2['default'].every(newFilters.concat(oldFilters), function (newFilter) {
	    return pluckDisabled(newFilter);
	  });
	};
	
	module.exports = exports['default'];

/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barLibCompare_filters = __webpack_require__(612);
	
	var _uiFilter_barLibCompare_filters2 = _interopRequireDefault(_uiFilter_barLibCompare_filters);
	
	var compareOptions = { disabled: true, negate: true };
	
	/**
	 * Checks to see if only disabled filters have been changed
	 * @returns {bool} Only disabled filters
	 */
	
	exports['default'] = function (newFilters, oldFilters) {
	  return _lodash2['default'].every(newFilters, function (newFilter, i) {
	    var match = _lodash2['default'].find(oldFilters, function (oldFilter) {
	      return (0, _uiFilter_barLibCompare_filters2['default'])(newFilter, oldFilter, compareOptions);
	    });
	    return !!match;
	  });
	};
	
	module.exports = exports['default'];

/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var excludedAttributes = undefined;
	var comparators = undefined;
	
	/**
	 * Compare two filters to see if they match
	 * @param {object} first The first filter to compare
	 * @param {object} second The second filter to compare
	 * @param {object} comparatorOptions Parameters to use for comparison
	 * @returns {bool} Filters are the same
	 */
	
	exports['default'] = function (first, second, comparatorOptions) {
	  excludedAttributes = ['$$hashKey', 'meta'];
	  comparators = _lodash2['default'].defaults(comparatorOptions || {}, {
	    state: false,
	    negate: false,
	    disabled: false
	  });
	
	  if (!comparators.state) excludedAttributes.push('$state');
	
	  return _lodash2['default'].isEqual(mapFilter(first), mapFilter(second));
	};
	
	function mapFilter(filter) {
	  var cleaned = _lodash2['default'].omit(filter, excludedAttributes);
	  if (comparators.negate) cleaned.negate = filter.meta && !!filter.meta.negate;
	  if (comparators.disabled) cleaned.disabled = filter.meta && !!filter.meta.disabled;
	  return cleaned;
	}
	module.exports = exports['default'];

/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barLibDedup_filters = __webpack_require__(614);
	
	var _uiFilter_barLibDedup_filters2 = _interopRequireDefault(_uiFilter_barLibDedup_filters);
	
	/**
	 * Remove duplicate filters from an array of filters
	 * @param {array} filters The filters to remove duplicates from
	 * @returns {object} The original filters array with duplicates removed
	 */
	
	exports['default'] = function (filters, comparatorOptions) {
	  var results = [];
	  _lodash2['default'].each(filters, function (filter) {
	    results = _lodash2['default'].union(results, (0, _uiFilter_barLibDedup_filters2['default'])(results, [filter], comparatorOptions));
	  });
	  return results;
	};
	
	module.exports = exports['default'];

/***/ },
/* 614 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiFilter_barLibCompare_filters = __webpack_require__(612);
	
	var _uiFilter_barLibCompare_filters2 = _interopRequireDefault(_uiFilter_barLibCompare_filters);
	
	/**
	 * Combine 2 filter collections, removing duplicates
	 * @param {object} existing The filters to compare to
	 * @param {object} filters The filters being added
	 * @param {object} comparatorOptions Parameters to use for comparison
	 * @returns {object} An array of filters that were not in existing
	 */
	
	exports['default'] = function (existingFilters, filters, comparatorOptions) {
	  if (!_lodash2['default'].isArray(filters)) filters = [filters];
	
	  return _lodash2['default'].filter(filters, function (filter) {
	    return !_lodash2['default'].find(existingFilters, function (existingFilter) {
	      return (0, _uiFilter_barLibCompare_filters2['default'])(existingFilter, filter, comparatorOptions);
	    });
	  });
	};
	
	module.exports = exports['default'];

/***/ },
/* 615 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilter_barQuery_filter = __webpack_require__(609);
	
	var _uiFilter_barQuery_filter2 = _interopRequireDefault(_uiFilter_barQuery_filter);
	
	var _libPhrase = __webpack_require__(616);
	
	// Adds a filter to a passed state
	
	exports['default'] = function (Private) {
	  var queryFilter = Private(_uiFilter_barQuery_filter2['default']);
	  var filterManager = {};
	
	  filterManager.add = function (field, values, operation, index) {
	    values = _lodash2['default'].isArray(values) ? values : [values];
	    var fieldName = _lodash2['default'].isObject(field) ? field.name : field;
	    var filters = _lodash2['default'].flatten([queryFilter.getAppFilters()]);
	    var newFilters = [];
	
	    var negate = operation === '-';
	
	    // TODO: On array fields, negating does not negate the combination, rather all terms
	    _lodash2['default'].each(values, function (value) {
	      var filter = undefined;
	      var existing = _lodash2['default'].find(filters, function (filter) {
	        if (!filter) return;
	
	        if (fieldName === '_exists_' && filter.exists) {
	          return filter.exists.field === value;
	        }
	
	        if (_lodash2['default'].has(filter, 'query.match')) {
	          return filter.query.match[fieldName] && filter.query.match[fieldName].query === value;
	        }
	
	        if (filter.script) {
	          return filter.meta.field === fieldName && filter.script.script.params.value === value;
	        }
	      });
	
	      if (existing) {
	        existing.meta.disabled = false;
	        if (existing.meta.negate !== negate) {
	          queryFilter.invertFilter(existing);
	        }
	        return;
	      }
	
	      switch (fieldName) {
	        case '_exists_':
	          filter = {
	            meta: {
	              negate: negate,
	              index: index
	            },
	            exists: {
	              field: value
	            }
	          };
	          break;
	        default:
	          if (field.scripted) {
	            filter = {
	              meta: { negate: negate, index: index, field: fieldName },
	              script: {
	                script: {
	                  inline: (0, _libPhrase.buildInlineScriptForPhraseFilter)(field),
	                  lang: field.lang,
	                  params: {
	                    value: value
	                  }
	                }
	              }
	            };
	          } else {
	            filter = { meta: { negate: negate, index: index }, query: { match: {} } };
	            filter.query.match[fieldName] = { query: value, type: 'phrase' };
	          }
	
	          break;
	      }
	
	      newFilters.push(filter);
	    });
	
	    return queryFilter.addFilters(newFilters);
	  };
	
	  return filterManager;
	};
	
	module.exports = exports['default'];

/***/ },
/* 616 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = buildPhraseFilter;
	exports.buildInlineScriptForPhraseFilter = buildInlineScriptForPhraseFilter;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function buildPhraseFilter(field, value, indexPattern) {
	  var filter = { meta: { index: indexPattern.id } };
	
	  if (field.scripted) {
	    // See https://github.com/elastic/elasticsearch/issues/20941 and https://github.com/elastic/kibana/issues/8677
	    // and https://github.com/elastic/elasticsearch/pull/22201
	    // for the reason behind this change. Aggs now return boolean buckets with a key of 1 or 0.
	    var convertedValue = value;
	    if (typeof value !== 'boolean' && field.type === 'boolean') {
	      if (value !== 1 && value !== 0) {
	        throw new Error('Boolean scripted fields must return true or false');
	      }
	      convertedValue = value === 1 ? true : false;
	    }
	
	    var script = buildInlineScriptForPhraseFilter(field);
	
	    _lodash2['default'].set(filter, 'script.script', {
	      inline: script,
	      lang: field.lang,
	      params: {
	        value: convertedValue
	      }
	    });
	    filter.meta.field = field.name;
	  } else {
	    filter.query = { match: {} };
	    filter.query.match[field.name] = {
	      query: value,
	      type: 'phrase'
	    };
	  }
	  return filter;
	}
	
	/**
	 * Takes a scripted field and returns an inline script appropriate for use in a script query.
	 * Handles lucene expression and Painless scripts. Other langs aren't guaranteed to generate valid
	 * scripts.
	 *
	 * @param {object} scriptedField A Field object representing a scripted field
	 * @returns {string} The inline script string
	 */
	
	function buildInlineScriptForPhraseFilter(scriptedField) {
	  // We must wrap painless scripts in a lambda in case they're more than a simple expression
	  if (scriptedField.lang === 'painless') {
	    return 'boolean compare(Supplier s, def v) {return s.get() == v;}' + ('compare(() -> { ' + scriptedField.script + ' }, params.value);');
	  } else {
	    return '(' + scriptedField.script + ') == value';
	  }
	}

/***/ },
/* 617 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').run(function ($rootScope) {
	
	  /**
	   * Helper that registers an event listener, and removes that listener when
	   * the $scope is destroyed.
	   *
	   * @param  {EventEmitter} emitter - the event emitter to listen to
	   * @param  {string} eventName - the event name
	   * @param  {Function} handler - the event handler
	   * @return {undefined}
	   */
	  $rootScope.constructor.prototype.$listen = function (emitter, eventName, handler) {
	    emitter.on(eventName, handler);
	    this.$on('$destroy', function () {
	      emitter.off(eventName, handler);
	    });
	  };
	});

/***/ },
/* 618 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiParse_queryLibTo_user = __webpack_require__(619);
	
	var _uiParse_queryLibTo_user2 = _interopRequireDefault(_uiParse_queryLibTo_user);
	
	var _uiParse_queryLibFrom_user = __webpack_require__(620);
	
	var _uiParse_queryLibFrom_user2 = _interopRequireDefault(_uiParse_queryLibFrom_user);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('parseQuery', function (Private) {
	  var fromUser = Private(_uiParse_queryLibFrom_user2['default']);
	
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    scope: {
	      'ngModel': '='
	    },
	    link: function link($scope, elem, attr, ngModel) {
	      var init = function init() {
	        $scope.ngModel = fromUser($scope.ngModel);
	      };
	
	      ngModel.$parsers.push(fromUser);
	      ngModel.$formatters.push(_uiParse_queryLibTo_user2['default']);
	
	      init();
	    }
	  };
	});

/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = toUser;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	/**
	 * Take text from the model and present it to the user as a string
	 * @param {text} model value
	 * @returns {string}
	 */
	
	function toUser(_x) {
	  var _again = true;
	
	  _function: while (_again) {
	    var text = _x;
	    _again = false;
	
	    if (text == null) return '';
	    if (_lodash2['default'].isObject(text)) {
	      if (text.query_string) {
	        _x = text.query_string.query;
	        _again = true;
	        continue _function;
	      }
	      return _angular2['default'].toJson(text);
	    }
	    return '' + text;
	  }
	}
	
	module.exports = exports['default'];

/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = GetQueryFromUser;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiCourierData_source_decorate_query = __webpack_require__(523);
	
	var _uiCourierData_source_decorate_query2 = _interopRequireDefault(_uiCourierData_source_decorate_query);
	
	function GetQueryFromUser(es, Private) {
	  var decorateQuery = Private(_uiCourierData_source_decorate_query2['default']);
	
	  /**
	   * Take text from the user and make it into a query object
	   * @param {text} user's query input
	   * @returns {object}
	   */
	  return function (text) {
	    function getQueryStringQuery(text) {
	      return decorateQuery({ query_string: { query: text } });
	    }
	
	    var matchAll = getQueryStringQuery('*');
	
	    // If we get an empty object, treat it as a *
	    if (_lodash2['default'].isObject(text)) {
	      if (_Object$keys(text).length) {
	        return text;
	      } else {
	        return matchAll;
	      }
	    }
	
	    // Nope, not an object.
	    text = (text || '').trim();
	    if (text.length === 0) return matchAll;
	
	    if (text[0] === '{') {
	      try {
	        return JSON.parse(text);
	      } catch (e) {
	        return getQueryStringQuery(text);
	      }
	    } else {
	      return getQueryStringQuery(text);
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 621 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	_uiModules2['default'].get('kibana/persisted_log').factory('PersistedLog', function ($window, localStorage) {
	  function PersistedLog(name, options) {
	    options = options || {};
	    this.name = name;
	    this.maxLength = parseInt(options.maxLength, 10);
	    this.filterDuplicates = options.filterDuplicates || false;
	    this.items = localStorage.get(this.name) || [];
	    if (!isNaN(this.maxLength)) this.items = _lodash2['default'].take(this.items, this.maxLength);
	  }
	
	  PersistedLog.prototype.add = function (val) {
	    if (val == null) {
	      return this.items;
	    }
	
	    // remove any matching items from the stack if option is set
	    if (this.filterDuplicates) {
	      _lodash2['default'].remove(this.items, function (item) {
	        return _lodash2['default'].isEqual(item, val);
	      });
	    }
	
	    this.items.unshift(val);
	
	    // if maxLength is set, truncate the stack
	    if (!isNaN(this.maxLength)) this.items = _lodash2['default'].take(this.items, this.maxLength);
	
	    // persist the stack
	    localStorage.set(this.name, this.items);
	    return this.items;
	  };
	
	  PersistedLog.prototype.get = function () {
	    return this.items;
	  };
	
	  return PersistedLog;
	});

/***/ },
/* 622 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(623);
	
	__webpack_require__(627);

/***/ },
/* 623 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$assign = __webpack_require__(352)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _lodash = __webpack_require__(3);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _confirm_modalHtml = __webpack_require__(624);
	
	var _confirm_modalHtml2 = _interopRequireDefault(_confirm_modalHtml);
	
	var _modal_overlay = __webpack_require__(625);
	
	var _module = _uiModules2['default'].get('kibana');
	
	/**
	 * @typedef {Object} ConfirmModalOptions
	 * @property {String} confirmButtonText
	 * @property {String=} cancelButtonText
	 * @property {function} onConfirm
	 * @property {function=} onCancel
	 * @property {String=} title - If given, shows a title on the confirm modal. A title must be given if
	 * showClose is true, for aesthetic reasons.
	 * @property {Boolean=} showClose - If true, shows an [x] icon close button which by default is a noop
	 * @property {function=} onClose - Custom close button to call if showClose is true. If not supplied
	 * but showClose is true, the function defaults to onCancel.
	 */
	
	_module.factory('confirmModal', function ($rootScope, $compile) {
	  var modalPopover = undefined;
	  var confirmQueue = [];
	
	  /**
	   * @param {String} message - the message to show in the body of the confirmation dialog.
	   * @param {ConfirmModalOptions} - Options to further customize the dialog.
	   */
	  return function confirmModal(message, customOptions) {
	    var defaultOptions = {
	      onCancel: _lodash.noop,
	      cancelButtonText: 'Cancel',
	      showClose: false
	    };
	
	    if (customOptions.showClose === true && !customOptions.title) {
	      throw new Error('A title must be supplied when a close icon is shown');
	    }
	
	    if (!customOptions.confirmButtonText || !customOptions.onConfirm) {
	      throw new Error('Please specify confirmation button text and onConfirm action');
	    }
	
	    var options = _Object$assign(defaultOptions, customOptions);
	
	    // Special handling for onClose - if no specific callback was supplied, default to the
	    // onCancel callback.
	    options.onClose = customOptions.onClose || options.onCancel;
	
	    var confirmScope = $rootScope.$new();
	
	    confirmScope.message = message;
	    confirmScope.confirmButtonText = options.confirmButtonText;
	    confirmScope.cancelButtonText = options.cancelButtonText;
	    confirmScope.title = options.title;
	    confirmScope.showClose = options.showClose;
	    confirmScope.onConfirm = function () {
	      destroy();
	      options.onConfirm();
	    };
	    confirmScope.onCancel = function () {
	      destroy();
	      options.onCancel();
	    };
	    confirmScope.onClose = function () {
	      destroy();
	      options.onClose();
	    };
	
	    function showModal(confirmScope) {
	      var modalInstance = $compile(_confirm_modalHtml2['default'])(confirmScope);
	      modalPopover = new _modal_overlay.ModalOverlay(modalInstance);
	      _angular2['default'].element(document.body).on('keydown', function (event) {
	        if (event.keyCode === 27) {
	          confirmScope.onCancel();
	        }
	      });
	
	      modalInstance.find('[data-test-subj=confirmModalConfirmButton]').focus();
	    }
	
	    if (modalPopover) {
	      confirmQueue.unshift(confirmScope);
	    } else {
	      showModal(confirmScope);
	    }
	
	    function destroy() {
	      modalPopover.destroy();
	      modalPopover = undefined;
	      _angular2['default'].element(document.body).off('keydown');
	      confirmScope.$destroy();
	
	      if (confirmQueue.length > 0) {
	        showModal(confirmQueue.pop());
	      }
	    }
	  };
	});

/***/ },
/* 624 */
/***/ function(module, exports) {

	module.exports = "<div class=\"kuiModal\" style=\"width: 450px\" data-test-subj=\"confirmModal\">\n  <div class=\"kuiModalHeader\" ng-if=\"title\">\n    <div class=\"kuiModalHeader__title\" data-test-subj=\"confirmModalTitleText\">\n      {{title}}\n    </div>\n    <div\n      ng-if=\"showClose\"\n      class=\"kuiModalHeaderCloseButton kuiIcon fa-times\"\n      data-test-subj=\"confirmModalCloseButton\"\n      ng-click=\"onClose()\"\n    ></div>\n  </div>\n  <div class=\"kuiModalBody\">\n    <div\n      class=\"kuiModalBodyText\"\n      data-test-subj=\"confirmModalBodyText\"\n    >\n      {{message}}\n    </div>\n  </div>\n\n  <div class=\"kuiModalFooter\">\n    <button\n      class=\"kuiButton kuiButton--hollow\"\n      data-test-subj=\"confirmModalCancelButton\"\n      ng-click=\"onCancel()\"\n    >\n      {{cancelButtonText}}\n    </button>\n    <button\n      class=\"kuiButton kuiButton--primary\"\n      data-test-subj=\"confirmModalConfirmButton\"\n      ng-click=\"onConfirm()\"\n    >\n      {{confirmButtonText}}\n    </button>\n  </div>\n</div>\n"

/***/ },
/* 625 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _modal_overlayHtml = __webpack_require__(626);
	
	var _modal_overlayHtml2 = _interopRequireDefault(_modal_overlayHtml);
	
	/**
	 * Appends the modal to the dom on instantiation, and removes it when destroy is called.
	 */
	
	var ModalOverlay = (function () {
	  function ModalOverlay(modalElement) {
	    _classCallCheck(this, ModalOverlay);
	
	    this.overlayElement = _angular2['default'].element(_modal_overlayHtml2['default']);
	    this.overlayElement.append(modalElement);
	
	    _angular2['default'].element(document.body).append(this.overlayElement);
	  }
	
	  /**
	   * Removes the overlay and modal from the dom.
	   */
	
	  _createClass(ModalOverlay, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.overlayElement.remove();
	    }
	  }]);
	
	  return ModalOverlay;
	})();

	exports.ModalOverlay = ModalOverlay;

/***/ },
/* 626 */
/***/ function(module, exports) {

	module.exports = "<div class=\"kuiModalOverlay\"></div>\n"

/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$assign = __webpack_require__(352)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	__webpack_require__(622);
	
	var _module = _uiModules2['default'].get('kibana');
	
	/**
	 * @typedef {Object} PromisifiedConfirmOptions
	 * @property {String} confirmButtonText
	 * @property {String=} cancelButtonText
	 */
	
	/**
	 * A "promisified" version of ConfirmModal that binds onCancel and onConfirm to
	 * Resolve and Reject methods.
	 */
	_module.factory('confirmModalPromise', function (Promise, confirmModal) {
	  /**
	   * @param {String} message
	   * @param {PromisifiedConfirmOptions} customOptions
	   */
	  return function (message, customOptions) {
	    return new Promise(function (resolve, reject) {
	      var defaultOptions = {
	        onConfirm: resolve,
	        onCancel: reject
	      };
	      var confirmOptions = _Object$assign(defaultOptions, customOptions);
	      confirmModal(message, confirmOptions);
	    });
	  };
	});

/***/ },
/* 628 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _uiStringifyTypesUrl = __webpack_require__(629);
	
	var _uiStringifyTypesUrl2 = _interopRequireDefault(_uiStringifyTypesUrl);
	
	var _uiStringifyTypesBytes = __webpack_require__(643);
	
	var _uiStringifyTypesBytes2 = _interopRequireDefault(_uiStringifyTypesBytes);
	
	var _uiStringifyTypesDate = __webpack_require__(649);
	
	var _uiStringifyTypesDate2 = _interopRequireDefault(_uiStringifyTypesDate);
	
	var _uiStringifyTypesDuration = __webpack_require__(651);
	
	var _uiStringifyTypesDuration2 = _interopRequireDefault(_uiStringifyTypesDuration);
	
	var _uiStringifyTypesIp = __webpack_require__(654);
	
	var _uiStringifyTypesIp2 = _interopRequireDefault(_uiStringifyTypesIp);
	
	var _uiStringifyTypesNumber = __webpack_require__(655);
	
	var _uiStringifyTypesNumber2 = _interopRequireDefault(_uiStringifyTypesNumber);
	
	var _uiStringifyTypesPercent = __webpack_require__(656);
	
	var _uiStringifyTypesPercent2 = _interopRequireDefault(_uiStringifyTypesPercent);
	
	var _uiStringifyTypesString = __webpack_require__(657);
	
	var _uiStringifyTypesString2 = _interopRequireDefault(_uiStringifyTypesString);
	
	var _uiStringifyTypesSource = __webpack_require__(659);
	
	var _uiStringifyTypesSource2 = _interopRequireDefault(_uiStringifyTypesSource);
	
	var _uiStringifyTypesColor = __webpack_require__(662);
	
	var _uiStringifyTypesColor2 = _interopRequireDefault(_uiStringifyTypesColor);
	
	var _uiStringifyTypesTruncate = __webpack_require__(665);
	
	var _uiStringifyTypesTruncate2 = _interopRequireDefault(_uiStringifyTypesTruncate);
	
	var _uiStringifyTypesBoolean = __webpack_require__(668);
	
	var _uiStringifyTypesBoolean2 = _interopRequireDefault(_uiStringifyTypesBoolean);
	
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesUrl2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesBytes2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesDate2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesDuration2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesIp2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesNumber2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesPercent2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesString2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesSource2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesColor2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesTruncate2['default']);
	_uiRegistryField_formats2['default'].register(_uiStringifyTypesBoolean2['default']);

/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = UrlFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(630);
	
	__webpack_require__(634);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _uiStringifyEditorsUrlHtml = __webpack_require__(642);
	
	var _uiStringifyEditorsUrlHtml2 = _interopRequireDefault(_uiStringifyEditorsUrlHtml);
	
	var _uiHighlight = __webpack_require__(525);
	
	function UrlFormatProvider(Private) {
	
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	
	  _lodash2['default']['class'](Url).inherits(FieldFormat);
	  function Url(params) {
	    Url.Super.call(this, params);
	    this._compileTemplate = _lodash2['default'].memoize(this._compileTemplate);
	  }
	
	  Url.id = 'url';
	  Url.title = 'Url';
	  Url.fieldType = ['number', 'boolean', 'date', 'ip', 'string', 'murmur3', 'unknown', 'conflict'];
	
	  Url.editor = {
	    template: _uiStringifyEditorsUrlHtml2['default'],
	    controllerAs: 'url',
	    controller: function controller($scope) {
	      var iconPattern = '/bundles/src/ui/public/stringify/icons/{{value}}.png';
	
	      this.samples = {
	        a: ['john', '/some/pathname/asset.png', 1234],
	        img: ['go', 'stop', ['de', 'ne', 'us', 'ni'], 'cv']
	      };
	
	      $scope.$watch('editor.formatParams.type', function (type, prev) {
	        var params = $scope.editor.formatParams;
	        if (type === 'img' && type !== prev && !params.urlTemplate) {
	          params.urlTemplate = iconPattern;
	        }
	      });
	    }
	  };
	
	  Url.templateMatchRE = /{{([\s\S]+?)}}/g;
	  Url.paramDefaults = {
	    type: 'a',
	    urlTemplate: null,
	    labelTemplate: null
	  };
	
	  Url.urlTypes = [{ id: 'a', name: 'Link' }, { id: 'img', name: 'Image' }];
	
	  Url.prototype._formatUrl = function (value) {
	    var template = this.param('urlTemplate');
	    if (!template) return value;
	
	    return this._compileTemplate(template)({
	      value: encodeURIComponent(value),
	      rawValue: value
	    });
	  };
	
	  Url.prototype._formatLabel = function (value, url) {
	    var template = this.param('labelTemplate');
	    if (url == null) url = this._formatUrl(value);
	    if (!template) return url;
	
	    return this._compileTemplate(template)({
	      value: value,
	      url: url
	    });
	  };
	
	  Url.prototype._convert = {
	    text: function text(value) {
	      return this._formatLabel(value);
	    },
	
	    html: function html(rawValue, field, hit) {
	      var url = _lodash2['default'].escape(this._formatUrl(rawValue));
	      var label = _lodash2['default'].escape(this._formatLabel(rawValue, url));
	
	      switch (this.param('type')) {
	        case 'img':
	          return '<img src="' + url + '" alt="' + label + '" title="' + label + '">';
	        default:
	          if (hit && hit.highlight && hit.highlight[field.name]) {
	            label = (0, _uiHighlight.getHighlightHtml)(label, hit.highlight[field.name]);
	          }
	
	          return '<a href="' + url + '" target="_blank">' + label + '</a>';
	      }
	    }
	  };
	
	  Url.prototype._compileTemplate = function (template) {
	    var parts = template.split(Url.templateMatchRE).map(function (part, i) {
	      // trim all the odd bits, the variable names
	      return i % 2 ? part.trim() : part;
	    });
	
	    return function (locals) {
	      // replace all the odd bits with their local var
	      var output = '';
	      var i = -1;
	      while (++i < parts.length) {
	        if (i % 2) {
	          if (locals.hasOwnProperty(parts[i])) {
	            var local = locals[parts[i]];
	            output += local == null ? '' : local;
	          }
	        } else {
	          output += parts[i];
	        }
	      }
	
	      return output;
	    };
	  };
	
	  return Url;
	}
	
	module.exports = exports['default'];

/***/ },
/* 630 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	__webpack_require__(631);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiField_format_editorPatternPatternHtml = __webpack_require__(633);
	
	var _uiField_format_editorPatternPatternHtml2 = _interopRequireDefault(_uiField_format_editorPatternPatternHtml);
	
	_uiModules2['default'].get('kibana').directive('fieldFormatEditorPattern', function () {
	  return {
	    restrict: 'E',
	    template: _uiField_format_editorPatternPatternHtml2['default'],
	    require: ['ngModel', '^fieldEditor'],
	    scope: true,
	    link: function link($scope, $el, attrs, cntrls) {
	      var ngModelCntrl = cntrls[0];
	
	      $scope.$bind('inputs', attrs.inputs);
	      $scope.$bind('placeholder', attrs.placeholder);
	
	      // bind our local model with the outside ngModel
	      $scope.$watch('model', ngModelCntrl.$setViewValue);
	      ngModelCntrl.$render = function () {
	        $scope.model = ngModelCntrl.$viewValue;
	      };
	    }
	  };
	});

/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiField_format_editorSamplesSamplesHtml = __webpack_require__(632);
	
	var _uiField_format_editorSamplesSamplesHtml2 = _interopRequireDefault(_uiField_format_editorSamplesSamplesHtml);
	
	_uiModules2['default'].get('kibana').directive('fieldFormatEditorSamples', function ($sce, Promise) {
	  return {
	    restrict: 'E',
	    template: _uiField_format_editorSamplesSamplesHtml2['default'],
	    require: ['?^ngModel', '^fieldEditor'],
	    scope: true,
	    link: function link($scope, $el, attrs, cntrls) {
	      var ngModelCntrl = cntrls[0];
	
	      $scope.samples = null;
	      $scope.$bind('inputs', attrs.inputs);
	
	      $scope.$watchMulti(['editor.field.format', '[]inputs'], function () {
	        $scope.samples = null;
	        var field = $scope.editor.field;
	
	        if (!field || !field.format) {
	          return;
	        }
	
	        Promise['try'](function () {
	          var converter = field.format.getConverterFor('html');
	          $scope.samples = _lodash2['default'].map($scope.inputs, function (input) {
	            return [input, $sce.trustAsHtml(converter(input))];
	          });
	        }).then(validity, validity);
	      });
	
	      function validity(err) {
	        $scope.error = err;
	        ngModelCntrl && ngModelCntrl.$setValidity('patternExecutes', !err);
	      }
	    }
	  };
	});

/***/ },
/* 632 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group hintbox\" ng-if=\"error\">\n  <h4 class=\"hintbox-heading\">\n    <i class=\"fa fa-danger text-danger\"></i> Format error\n  </h4>\n  <p>\n    An error occured while trying to use this format configuration.\n  </p>\n  <pre>{{ error.message }}</pre>\n</div>\n\n<div class=\"form-group\" ng-if=\"samples\">\n  <hr>\n  <label>Samples</label>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>\n          Input\n        </th>\n        <th>\n          Formatted\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"sample in samples\">\n        <td ng-bind=\"sample[0]\"></td>\n        <td ng-bind-html=\"sample[1]\"></td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n"

/***/ },
/* 633 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <input\n    ng-model=\"model\"\n    placeholder=\"{{ placeholder }}\"\n    class=\"form-control\">\n</div>\n\n<field-format-editor-samples\n  ng-model=\"model\"\n  inputs=\"inputs\">\n</field-format-editor-samples>\n"

/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(635);
	
	__webpack_require__(636);
	
	__webpack_require__(637);
	
	__webpack_require__(638);
	
	__webpack_require__(639);
	
	__webpack_require__(640);
	
	__webpack_require__(641);

/***/ },
/* 635 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/go.png"

/***/ },
/* 636 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/stop.png"

/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/de.png"

/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/ne.png"

/***/ },
/* 639 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/us.png"

/***/ },
/* 640 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/ni.png"

/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "src/ui/public/stringify/icons/cv.png"

/***/ },
/* 642 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Type</label>\n  <select\n    ng-model=\"editor.formatParams.type\"\n    ng-options=\"type.id as type.name for type in editor.field.format.type.urlTypes\"\n    class=\"form-control\">\n  </select>\n</div>\n\n<div class=\"form-group\">\n  <span class=\"pull-right text-info hintbox-label\" ng-click=\"editor.showUrlTmplHelp = !editor.showUrlTmplHelp\">\n    <i class=\"fa fa-info\"></i> Url Template Help\n  </span>\n\n  <label>Url Template</label>\n  <div class=\"hintbox\" ng-if=\"editor.showUrlTmplHelp\">\n    <h4 class=\"hintbox-heading\">\n      <i class=\"fa fa-question-circle text-info\"></i> Url Template Help\n    </h4>\n\n    <p>\n      If a field only contains part of a url then a \"Url Template\" can be used to format the value as a complete url. The format is a string which uses double curly brace notation <code ng-non-bindable>{{ }}</code> to inject values. The following values can be accessed:\n    </p>\n\n    <ul>\n      <li>\n        <strong>value</strong> &mdash; The uri-escaped value\n      </li>\n      <li>\n        <strong>rawValue</strong> &mdash; The unescaped value\n      </li>\n    </ul>\n\n    <table class=\"table table-striped table-bordered\">\n      <caption>Examples</caption>\n      <thead>\n        <tr>\n          <th>Value</th>\n          <th>Template</th>\n          <th>Result</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>1234</td>\n          <td ng-non-bindable>http://company.net/profiles?user_id={{value}}</td>\n          <td>http://company.net/profiles?user_id=1234</td>\n        </tr>\n        <tr>\n          <td>users/admin</td>\n          <td ng-non-bindable>http://company.net/groups?id={{value}}</td>\n          <td>http://company.net/groups?id=users%2Fadmin</td>\n        </tr>\n        <tr>\n          <td>/images/favicon.ico</td>\n          <td ng-non-bindable>http://www.site.com{{rawValue}}</td>\n          <td>http://www.site.com/images/favicon.ico</td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n\n  <input ng-model=\"editor.formatParams.urlTemplate\" class=\"form-control\">\n</div>\n\n<div class=\"form-group\">\n  <span class=\"pull-right text-info hintbox-label\" ng-click=\"editor.showLabelTmplHelp = !editor.showLabelTmplHelp\">\n    <i class=\"fa fa-info\"></i> Label Template Help\n  </span>\n\n  <label>Label Template</label>\n  <div class=\"hintbox\" ng-if=\"editor.showLabelTmplHelp\">\n    <h4 class=\"hintbox-heading\">\n      <i class=\"fa fa-question-circle text-info\"></i> Label Template Help\n    </h4>\n\n    <p>\n      If the url in this field is large, it might be useful to provide an alternate template for the text version of the url. This will be displayed instead of the url, but will still link to the url. The format is a string which uses double curly brace notation <code ng-non-bindable>{{ }}</code> to inject values. The following values can be accessed:\n    </p>\n\n    <ul>\n      <li>\n        <strong>value</strong> &mdash; The fields value\n      </li>\n      <li>\n        <strong>url</strong> &mdash; The formatted url\n      </li>\n    </ul>\n\n    <table class=\"table table-striped table-bordered\">\n      <caption>Examples</caption>\n      <thead>\n        <tr>\n          <th>Value</th>\n          <th>Url Template</th>\n          <th>Label Template</th>\n          <th>Result</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>1234</td>\n          <td ng-non-bindable>http://company.net/profiles?user_id={{value}}</td>\n          <td ng-non-bindable>User #{{value}}</td>\n          <td>\n            <a href=\"http://company.net/profiles?user_id=1234\">User #1234</a>\n          </td>\n        </tr>\n        <tr>\n          <td>/assets/main.css</td>\n          <td ng-non-bindable>http://site.com{{rawValue}}</td>\n          <td>View Asset</td>\n          <td>\n            <a href=\"http://site.com/assets/main.css\">View Asset</a>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n\n  <input ng-model=\"editor.formatParams.labelTemplate\" class=\"form-control\">\n</div>\n\n<field-format-editor-samples inputs=\"url.samples[editor.formatParams.type]\"></field-format-editor-samples>\n"

/***/ },
/* 643 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = BytesFormatProvider;
	
	var _uiStringifyTypes_numeral = __webpack_require__(644);
	
	var _uiStringifyTypes_numeral2 = _interopRequireDefault(_uiStringifyTypes_numeral);
	
	function BytesFormatProvider(Private) {
	  var Numeral = Private(_uiStringifyTypes_numeral2['default']);
	  return Numeral.factory({
	    id: 'bytes',
	    title: 'Bytes',
	    sampleInputs: [1024, 5150000, 1990000000]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 644 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AbstractNumeralFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(645);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _uiBound_to_config_obj = __webpack_require__(476);
	
	var _uiBound_to_config_obj2 = _interopRequireDefault(_uiBound_to_config_obj);
	
	function AbstractNumeralFormatProvider(Private) {
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var BoundToConfigObj = Private(_uiBound_to_config_obj2['default']);
	  var numeral = __webpack_require__(647)();
	
	  _lodash2['default']['class'](Numeral).inherits(FieldFormat);
	  function Numeral(params) {
	    Numeral.Super.call(this, params);
	  }
	
	  Numeral.prototype._convert = function (val) {
	    if (val === -Infinity) return '-';
	    if (val === +Infinity) return '+';
	    if (typeof val !== 'number') {
	      val = parseFloat(val);
	    }
	
	    if (isNaN(val)) return '';
	
	    return numeral.set(val).format(this.param('pattern'));
	  };
	
	  Numeral.factory = function (opts) {
	    _lodash2['default']['class'](Class).inherits(Numeral);
	    function Class(params) {
	      Class.Super.call(this, params);
	    }
	
	    Class.id = opts.id;
	    Class.title = opts.title;
	    Class.fieldType = 'number';
	
	    Class.paramDefaults = opts.paramDefaults || new BoundToConfigObj({
	      pattern: '=format:' + opts.id + ':defaultPattern'
	    });
	
	    Class.editor = {
	      template: opts.editorTemplate || __webpack_require__(646),
	      controllerAs: 'cntrl',
	      controller: opts.controller || function () {
	        this.sampleInputs = opts.sampleInputs;
	      }
	    };
	
	    if (opts.prototype) {
	      _lodash2['default'].assign(Class.prototype, opts.prototype);
	    }
	
	    return Class;
	  };
	
	  return Numeral;
	}
	
	module.exports = exports['default'];

/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	__webpack_require__(630);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiField_format_editorNumeralNumeralHtml = __webpack_require__(646);
	
	var _uiField_format_editorNumeralNumeralHtml2 = _interopRequireDefault(_uiField_format_editorNumeralNumeralHtml);
	
	_uiModules2['default'].get('kibana').directive('fieldEditorNumeral', function () {
	  return {
	    restrict: 'E',
	    template: _uiField_format_editorNumeralNumeralHtml2['default']
	  };
	});

/***/ },
/* 646 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <small class=\"pull-right\">\n    <a ng-href=\"https://adamwdraper.github.io/Numeral-js/\" target=\"_blank\">\n      Docs <i class=\"fa fa-link\"></i>\n    </a>\n  </small>\n\n  <label>\n    Numeral.js format pattern\n    <small>\n      (Default: \"{{ editor.field.format.type.paramDefaults.pattern }}\")\n    </small>\n  </label>\n</div>\n\n<field-format-editor-pattern\n  ng-model=\"editor.formatParams.pattern\"\n  placeholder=\"editor.field.format.type.paramDefaults.pattern\"\n  inputs=\"cntrl.sampleInputs\">\n</field-format-editor-pattern>\n\n"

/***/ },
/* 647 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(648);


/***/ },
/* 648 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * numeral.js
	 * version : 1.5.3
	 * author : Adam Draper
	 * license : MIT
	 * http://adamwdraper.github.com/Numeral-js/
	 */
	
	(function () {
	
	    /************************************
	        Constants
	    ************************************/
	
	    var numeral,
	        VERSION = '1.5.3',
	        // internal storage for language config files
	        languages = {},
	        currentLanguage = 'en',
	        zeroFormat = null,
	        defaultFormat = '0,0',
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module.exports);
	
	
	    /************************************
	        Constructors
	    ************************************/
	
	
	    // Numeral prototype object
	    function Numeral (number) {
	        this._value = number;
	    }
	
	    /**
	     * Implementation of toFixed() that treats floats more like decimals
	     *
	     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
	     * problems for accounting- and finance-related software.
	     */
	    function toFixed (value, precision, roundingFunction, optionals) {
	        var power = Math.pow(10, precision),
	            optionalsRegExp,
	            output;
	            
	        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
	        // Multiply up by precision, round accurately, then divide and use native toFixed():
	        output = (roundingFunction(value * power) / power).toFixed(precision);
	
	        if (optionals) {
	            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
	            output = output.replace(optionalsRegExp, '');
	        }
	
	        return output;
	    }
	
	    /************************************
	        Formatting
	    ************************************/
	
	    // determine what type of formatting we need to do
	    function formatNumeral (n, format, roundingFunction) {
	        var output;
	
	        // figure out what kind of format we are dealing with
	        if (format.indexOf('$') > -1) { // currency!!!!!
	            output = formatCurrency(n, format, roundingFunction);
	        } else if (format.indexOf('%') > -1) { // percentage
	            output = formatPercentage(n, format, roundingFunction);
	        } else if (format.indexOf(':') > -1) { // time
	            output = formatTime(n, format);
	        } else { // plain ol' numbers or bytes
	            output = formatNumber(n._value, format, roundingFunction);
	        }
	
	        // return string
	        return output;
	    }
	
	    // revert to number
	    function unformatNumeral (n, string) {
	        var stringOriginal = string,
	            thousandRegExp,
	            millionRegExp,
	            billionRegExp,
	            trillionRegExp,
	            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	            bytesMultiplier = false,
	            power;
	
	        if (string.indexOf(':') > -1) {
	            n._value = unformatTime(string);
	        } else {
	            if (string === zeroFormat) {
	                n._value = 0;
	            } else {
	                if (languages[currentLanguage].delimiters.decimal !== '.') {
	                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
	                }
	
	                // see if abbreviations are there so that we can multiply to the correct number
	                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	
	                // see if bytes are there so that we can multiply to the correct number
	                for (power = 0; power < suffixes.length; ++power) {
	                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;
	
	                    if (bytesMultiplier) {
	                        break;
	                    }
	                }
	
	                // do some math to create our number
	                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));
	
	                // round if we are talking about bytes
	                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
	            }
	        }
	        return n._value;
	    }
	
	    function formatCurrency (n, format, roundingFunction) {
	        var symbolIndex = format.indexOf('$'),
	            openParenIndex = format.indexOf('('),
	            minusSignIndex = format.indexOf('-'),
	            space = '',
	            spliceIndex,
	            output;
	
	        // check for space before or after currency
	        if (format.indexOf(' $') > -1) {
	            space = ' ';
	            format = format.replace(' $', '');
	        } else if (format.indexOf('$ ') > -1) {
	            space = ' ';
	            format = format.replace('$ ', '');
	        } else {
	            format = format.replace('$', '');
	        }
	
	        // format the number
	        output = formatNumber(n._value, format, roundingFunction);
	
	        // position the symbol
	        if (symbolIndex <= 1) {
	            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
	                output = output.split('');
	                spliceIndex = 1;
	                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
	                    // the symbol appears before the "(" or "-"
	                    spliceIndex = 0;
	                }
	                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
	                output = output.join('');
	            } else {
	                output = languages[currentLanguage].currency.symbol + space + output;
	            }
	        } else {
	            if (output.indexOf(')') > -1) {
	                output = output.split('');
	                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
	                output = output.join('');
	            } else {
	                output = output + space + languages[currentLanguage].currency.symbol;
	            }
	        }
	
	        return output;
	    }
	
	    function formatPercentage (n, format, roundingFunction) {
	        var space = '',
	            output,
	            value = n._value * 100;
	
	        // check for space before %
	        if (format.indexOf(' %') > -1) {
	            space = ' ';
	            format = format.replace(' %', '');
	        } else {
	            format = format.replace('%', '');
	        }
	
	        output = formatNumber(value, format, roundingFunction);
	        
	        if (output.indexOf(')') > -1 ) {
	            output = output.split('');
	            output.splice(-1, 0, space + '%');
	            output = output.join('');
	        } else {
	            output = output + space + '%';
	        }
	
	        return output;
	    }
	
	    function formatTime (n) {
	        var hours = Math.floor(n._value/60/60),
	            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
	            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
	        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
	    }
	
	    function unformatTime (string) {
	        var timeArray = string.split(':'),
	            seconds = 0;
	        // turn hours and minutes into seconds and add them all up
	        if (timeArray.length === 3) {
	            // hours
	            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
	            // minutes
	            seconds = seconds + (Number(timeArray[1]) * 60);
	            // seconds
	            seconds = seconds + Number(timeArray[2]);
	        } else if (timeArray.length === 2) {
	            // minutes
	            seconds = seconds + (Number(timeArray[0]) * 60);
	            // seconds
	            seconds = seconds + Number(timeArray[1]);
	        }
	        return Number(seconds);
	    }
	
	    function formatByteUnits (value) {
	        var suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	            suffix = suffixes[0],
	            power,
	            min,
	            max,
	            abs = Math.abs(value),
	            matched = (abs < 1024);
	
	        if (!matched) {
	            for (power = 1; power < suffixes.length; ++power) {
	                min = Math.pow(1024, power);
	                max = Math.pow(1024, power + 1);
	
	                if (abs >= min && abs < max) {
	                    matched = true;
	                    suffix = suffixes[power];
	                    value = value / min;
	                    break;
	                }
	            }
	
	            // values greater than or equal to 1024 YB
	            if (!matched) {
	                value = value / Math.pow(1024, suffixes.length - 1);
	                suffix = suffixes[suffixes.length - 1];
	            }
	        }
	
	        return { value: value, suffix: suffix };
	    }
	
	    function formatNumber (value, format, roundingFunction) {
	        var negP = false,
	            signed = false,
	            optDec = false,
	            abbr = '',
	            abbrK = false, // force abbreviation to thousands
	            abbrM = false, // force abbreviation to millions
	            abbrB = false, // force abbreviation to billions
	            abbrT = false, // force abbreviation to trillions
	            abbrForce = false, // force abbreviation
	            bytes = '',
	            units,
	            ord = '',
	            abs = Math.abs(value),
	            w,
	            precision,
	            thousands,
	            d = '',
	            neg = false;
	
	        // check if number is zero and a custom zero format has been set
	        if (value === 0 && zeroFormat !== null) {
	            return zeroFormat;
	        } else {
	            // see if we should use parentheses for negative number or if we should prefix with a sign
	            // if both are present we default to parentheses
	            if (format.indexOf('(') > -1) {
	                negP = true;
	                format = format.slice(1, -1);
	            } else if (format.indexOf('+') > -1) {
	                signed = true;
	                format = format.replace(/\+/g, '');
	            }
	
	            // see if abbreviation is wanted
	            if (format.indexOf('a') > -1) {
	                // check if abbreviation is specified
	                abbrK = format.indexOf('aK') >= 0;
	                abbrM = format.indexOf('aM') >= 0;
	                abbrB = format.indexOf('aB') >= 0;
	                abbrT = format.indexOf('aT') >= 0;
	                abbrForce = abbrK || abbrM || abbrB || abbrT;
	
	                // check for space before abbreviation
	                if (format.indexOf(' a') > -1) {
	                    abbr = ' ';
	                    format = format.replace(' a', '');
	                } else {
	                    format = format.replace('a', '');
	                }
	
	                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
	                    // trillion
	                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
	                    value = value / Math.pow(10, 12);
	                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
	                    // billion
	                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
	                    value = value / Math.pow(10, 9);
	                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
	                    // million
	                    abbr = abbr + languages[currentLanguage].abbreviations.million;
	                    value = value / Math.pow(10, 6);
	                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
	                    // thousand
	                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
	                    value = value / Math.pow(10, 3);
	                }
	            }
	
	            // see if we are formatting bytes
	            if (format.indexOf('b') > -1) {
	                // check for space before
	                if (format.indexOf(' b') > -1) {
	                    bytes = ' ';
	                    format = format.replace(' b', '');
	                } else {
	                    format = format.replace('b', '');
	                }
	
	                units = formatByteUnits(value);
	
	                value = units.value;
	                bytes = bytes + units.suffix;
	            }
	
	            // see if ordinal is wanted
	            if (format.indexOf('o') > -1) {
	                // check for space before
	                if (format.indexOf(' o') > -1) {
	                    ord = ' ';
	                    format = format.replace(' o', '');
	                } else {
	                    format = format.replace('o', '');
	                }
	
	                ord = ord + languages[currentLanguage].ordinal(value);
	            }
	
	            if (format.indexOf('[.]') > -1) {
	                optDec = true;
	                format = format.replace('[.]', '.');
	            }
	
	            w = value.toString().split('.')[0];
	            precision = format.split('.')[1];
	            thousands = format.indexOf(',');
	
	            if (precision) {
	                if (precision.indexOf('[') > -1) {
	                    precision = precision.replace(']', '');
	                    precision = precision.split('[');
	                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
	                } else {
	                    d = toFixed(value, precision.length, roundingFunction);
	                }
	
	                w = d.split('.')[0];
	
	                if (d.split('.')[1].length) {
	                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
	                } else {
	                    d = '';
	                }
	
	                if (optDec && Number(d.slice(1)) === 0) {
	                    d = '';
	                }
	            } else {
	                w = toFixed(value, null, roundingFunction);
	            }
	
	            // format number
	            if (w.indexOf('-') > -1) {
	                w = w.slice(1);
	                neg = true;
	            }
	
	            if (thousands > -1) {
	                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
	            }
	
	            if (format.indexOf('.') === 0) {
	                w = '';
	            }
	
	            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
	        }
	    }
	
	    /************************************
	        Top Level Functions
	    ************************************/
	
	    numeral = function (input) {
	        if (numeral.isNumeral(input)) {
	            input = input.value();
	        } else if (input === 0 || typeof input === 'undefined') {
	            input = 0;
	        } else if (!Number(input)) {
	            input = numeral.fn.unformat(input);
	        }
	
	        return new Numeral(Number(input));
	    };
	
	    // version number
	    numeral.version = VERSION;
	
	    // compare numeral object
	    numeral.isNumeral = function (obj) {
	        return obj instanceof Numeral;
	    };
	
	    // This function will load languages and then set the global language.  If
	    // no arguments are passed in, it will simply return the current global
	    // language key.
	    numeral.language = function (key, values) {
	        if (!key) {
	            return currentLanguage;
	        }
	
	        if (key && !values) {
	            if(!languages[key]) {
	                throw new Error('Unknown language : ' + key);
	            }
	            currentLanguage = key;
	        }
	
	        if (values || !languages[key]) {
	            loadLanguage(key, values);
	        }
	
	        return numeral;
	    };
	    
	    // This function provides access to the loaded language data.  If
	    // no arguments are passed in, it will simply return the current
	    // global language object.
	    numeral.languageData = function (key) {
	        if (!key) {
	            return languages[currentLanguage];
	        }
	        
	        if (!languages[key]) {
	            throw new Error('Unknown language : ' + key);
	        }
	        
	        return languages[key];
	    };
	
	    numeral.language('en', {
	        delimiters: {
	            thousands: ',',
	            decimal: '.'
	        },
	        abbreviations: {
	            thousand: 'k',
	            million: 'm',
	            billion: 'b',
	            trillion: 't'
	        },
	        ordinal: function (number) {
	            var b = number % 10;
	            return (~~ (number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	        },
	        currency: {
	            symbol: '$'
	        }
	    });
	
	    numeral.zeroFormat = function (format) {
	        zeroFormat = typeof(format) === 'string' ? format : null;
	    };
	
	    numeral.defaultFormat = function (format) {
	        defaultFormat = typeof(format) === 'string' ? format : '0.0';
	    };
	
	    /************************************
	        Helpers
	    ************************************/
	
	    function loadLanguage(key, values) {
	        languages[key] = values;
	    }
	
	    /************************************
	        Floating-point helpers
	    ************************************/
	
	    // The floating-point helper functions and implementation
	    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/
	
	    /**
	     * Array.prototype.reduce for browsers that don't support it
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
	     */
	    if ('function' !== typeof Array.prototype.reduce) {
	        Array.prototype.reduce = function (callback, opt_initialValue) {
	            'use strict';
	            
	            if (null === this || 'undefined' === typeof this) {
	                // At the moment all modern browsers, that support strict mode, have
	                // native implementation of Array.prototype.reduce. For instance, IE8
	                // does not support strict mode, so this check is actually useless.
	                throw new TypeError('Array.prototype.reduce called on null or undefined');
	            }
	            
	            if ('function' !== typeof callback) {
	                throw new TypeError(callback + ' is not a function');
	            }
	
	            var index,
	                value,
	                length = this.length >>> 0,
	                isValueSet = false;
	
	            if (1 < arguments.length) {
	                value = opt_initialValue;
	                isValueSet = true;
	            }
	
	            for (index = 0; length > index; ++index) {
	                if (this.hasOwnProperty(index)) {
	                    if (isValueSet) {
	                        value = callback(value, this[index], index, this);
	                    } else {
	                        value = this[index];
	                        isValueSet = true;
	                    }
	                }
	            }
	
	            if (!isValueSet) {
	                throw new TypeError('Reduce of empty array with no initial value');
	            }
	
	            return value;
	        };
	    }
	
	    
	    /**
	     * Computes the multiplier necessary to make x >= 1,
	     * effectively eliminating miscalculations caused by
	     * finite precision.
	     */
	    function multiplier(x) {
	        var parts = x.toString().split('.');
	        if (parts.length < 2) {
	            return 1;
	        }
	        return Math.pow(10, parts[1].length);
	    }
	
	    /**
	     * Given a variable number of arguments, returns the maximum
	     * multiplier that must be used to normalize an operation involving
	     * all of them.
	     */
	    function correctionFactor() {
	        var args = Array.prototype.slice.call(arguments);
	        return args.reduce(function (prev, next) {
	            var mp = multiplier(prev),
	                mn = multiplier(next);
	        return mp > mn ? mp : mn;
	        }, -Infinity);
	    }        
	
	
	    /************************************
	        Numeral Prototype
	    ************************************/
	
	
	    numeral.fn = Numeral.prototype = {
	
	        clone : function () {
	            return numeral(this);
	        },
	
	        format : function (inputString, roundingFunction) {
	            return formatNumeral(this, 
	                  inputString ? inputString : defaultFormat, 
	                  (roundingFunction !== undefined) ? roundingFunction : Math.round
	              );
	        },
	
	        unformat : function (inputString) {
	            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
	                return inputString; 
	            }
	            return unformatNumeral(this, inputString ? inputString : defaultFormat);
	        },
	
	        byteUnits : function () {
	            return formatByteUnits(this._value).suffix;
	        },
	
	        value : function () {
	            return this._value;
	        },
	
	        valueOf : function () {
	            return this._value;
	        },
	
	        set : function (value) {
	            this._value = Number(value);
	            return this;
	        },
	
	        add : function (value) {
	            var corrFactor = correctionFactor.call(null, this._value, value);
	            function cback(accum, curr, currI, O) {
	                return accum + corrFactor * curr;
	            }
	            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
	            return this;
	        },
	
	        subtract : function (value) {
	            var corrFactor = correctionFactor.call(null, this._value, value);
	            function cback(accum, curr, currI, O) {
	                return accum - corrFactor * curr;
	            }
	            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
	            return this;
	        },
	
	        multiply : function (value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = correctionFactor(accum, curr);
	                return (accum * corrFactor) * (curr * corrFactor) /
	                    (corrFactor * corrFactor);
	            }
	            this._value = [this._value, value].reduce(cback, 1);
	            return this;
	        },
	
	        divide : function (value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = correctionFactor(accum, curr);
	                return (accum * corrFactor) / (curr * corrFactor);
	            }
	            this._value = [this._value, value].reduce(cback);            
	            return this;
	        },
	
	        difference : function (value) {
	            return Math.abs(numeral(this._value).subtract(value).value());
	        }
	
	    };
	
	    /************************************
	        Exposing Numeral
	    ************************************/
	
	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = numeral;
	    }
	
	    /*global ender:false */
	    if (typeof ender === 'undefined') {
	        // here, `this` means `window` in the browser, or `global` on the server
	        // add `numeral` as a global object via a string identifier,
	        // for Closure Compiler 'advanced' mode
	        this['numeral'] = numeral;
	    }
	
	    /*global define:false */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return numeral;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	}).call(this);


/***/ },
/* 649 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DateTimeFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	__webpack_require__(630);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _uiBound_to_config_obj = __webpack_require__(476);
	
	var _uiBound_to_config_obj2 = _interopRequireDefault(_uiBound_to_config_obj);
	
	var _uiStringifyEditorsDateHtml = __webpack_require__(650);
	
	var _uiStringifyEditorsDateHtml2 = _interopRequireDefault(_uiStringifyEditorsDateHtml);
	
	function DateTimeFormatProvider(Private) {
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var BoundToConfigObj = Private(_uiBound_to_config_obj2['default']);
	
	  _lodash2['default']['class'](DateTime).inherits(FieldFormat);
	  function DateTime(params) {
	    DateTime.Super.call(this, params);
	  }
	
	  DateTime.id = 'date';
	  DateTime.title = 'Date';
	  DateTime.fieldType = 'date';
	
	  DateTime.paramDefaults = new BoundToConfigObj({
	    pattern: '=dateFormat',
	    timezone: '=dateFormat:tz'
	  });
	
	  DateTime.editor = {
	    template: _uiStringifyEditorsDateHtml2['default'],
	    controllerAs: 'cntrl',
	    controller: function controller($interval, $scope) {
	      var self = this;
	      self.sampleInputs = [Date.now(), +(0, _moment2['default'])().startOf('year'), +(0, _moment2['default'])().endOf('year')];
	
	      $scope.$on('$destroy', $interval(function () {
	        self.sampleInputs[0] = Date.now();
	      }, 1000));
	    }
	  };
	
	  DateTime.prototype._convert = function (val) {
	    // don't give away our ref to converter so
	    // we can hot-swap when config changes
	    var pattern = this.param('pattern');
	    var timezone = this.param('timezone');
	
	    var timezoneChanged = this._timeZone !== timezone;
	    var datePatternChanged = this._memoizedPattern !== pattern;
	    if (timezoneChanged || datePatternChanged) {
	      this._timeZone = timezone;
	      this._memoizedPattern = pattern;
	
	      this._memoizedConverter = _lodash2['default'].memoize(function converter(val) {
	        if (val === null || val === undefined) {
	          return '-';
	        }
	        return (0, _moment2['default'])(val).format(pattern);
	      });
	    }
	
	    return this._memoizedConverter(val);
	  };
	
	  return DateTime;
	}
	
	module.exports = exports['default'];

/***/ },
/* 650 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <small class=\"pull-right\">\n    <a ng-href=\"http://momentjs.com/\" target=\"_blank\">\n      Docs <i class=\"fa fa-link\"></i>\n    </a>\n  </small>\n\n  <label>\n    moment.js format pattern\n    <small>\n      (Default: \"{{ editor.field.format.type.paramDefaults.pattern }}\")\n    </small>\n  </label>\n\n  <field-format-editor-pattern\n    ng-model=\"editor.formatParams.pattern\"\n    inputs=\"cntrl.sampleInputs\"\n  ></field-format-editor-pattern>\n\n</div>\n"

/***/ },
/* 651 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DurationFormatProvider;
	
	__webpack_require__(652);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _uiStringifyEditorsDurationHtml = __webpack_require__(653);
	
	var _uiStringifyEditorsDurationHtml2 = _interopRequireDefault(_uiStringifyEditorsDurationHtml);
	
	function DurationFormatProvider(Private) {
	  var ratioToSeconds = {
	    picoseconds: 0.000000000001,
	    nanoseconds: 0.000000001,
	    microseconds: 0.000001
	  };
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var HUMAN_FRIENDLY = 'humanize';
	  var DEFAULT_OUTPUT_PRECISION = 2;
	  var DEFAULT_INPUT_FORMAT = { text: 'Seconds', kind: 'seconds' };
	  var inputFormats = [{ text: 'Picoseconds', kind: 'picoseconds' }, { text: 'Nanoseconds', kind: 'nanoseconds' }, { text: 'Microseconds', kind: 'microseconds' }, { text: 'Milliseconds', kind: 'milliseconds' }, DEFAULT_INPUT_FORMAT, { text: 'Minutes', kind: 'minutes' }, { text: 'Hours', kind: 'hours' }, { text: 'Days', kind: 'days' }, { text: 'Weeks', kind: 'weeks' }, { text: 'Months', kind: 'months' }, { text: 'Years', kind: 'years' }];
	  var DEFAULT_OUTPUT_FORMAT = { text: 'Human Readable', method: 'humanize' };
	  var outputFormats = [DEFAULT_OUTPUT_FORMAT, { text: 'Milliseconds', method: 'asMilliseconds' }, { text: 'Seconds', method: 'asSeconds' }, { text: 'Minutes', method: 'asMinutes' }, { text: 'Hours', method: 'asHours' }, { text: 'Days', method: 'asDays' }, { text: 'Weeks', method: 'asWeeks' }, { text: 'Months', method: 'asMonths' }, { text: 'Years', method: 'asYears' }];
	
	  var Duration = (function (_FieldFormat) {
	    _inherits(Duration, _FieldFormat);
	
	    function Duration() {
	      _classCallCheck(this, Duration);
	
	      _get(Object.getPrototypeOf(Duration.prototype), 'constructor', this).apply(this, arguments);
	    }
	
	    _createClass(Duration, [{
	      key: 'isHuman',
	      value: function isHuman() {
	        return this.param('outputFormat') === HUMAN_FRIENDLY;
	      }
	    }, {
	      key: '_convert',
	      value: function _convert(val) {
	        var inputFormat = this.param('inputFormat');
	        var outputFormat = this.param('outputFormat');
	        var outputPrecision = this.param('outputPrecision');
	        var human = this.isHuman();
	        var prefix = val < 0 && human ? 'minus ' : '';
	        var duration = parseInputAsDuration(val, inputFormat);
	        var formatted = duration[outputFormat]();
	        var precise = human ? formatted : formatted.toFixed(outputPrecision);
	        return prefix + precise;
	      }
	    }]);
	
	    return Duration;
	  })(FieldFormat);
	
	  Duration.id = 'duration';
	  Duration.title = 'Duration';
	  Duration.fieldType = 'number';
	
	  Duration.inputFormats = inputFormats;
	  Duration.outputFormats = outputFormats;
	
	  Duration.editor = {
	    template: _uiStringifyEditorsDurationHtml2['default'],
	    controllerAs: 'cntrl',
	    controller: function controller($scope, $interval) {
	      this.sampleInputs = [-123, 1, 12, 123, 658, 1988, 3857, 123292, 923528271];
	    }
	  };
	
	  Duration.paramDefaults = {
	    inputFormat: DEFAULT_INPUT_FORMAT.kind,
	    outputFormat: DEFAULT_OUTPUT_FORMAT.method,
	    outputPrecision: DEFAULT_OUTPUT_PRECISION
	  };
	
	  return Duration;
	
	  function parseInputAsDuration(val, inputFormat) {
	    var ratio = ratioToSeconds[inputFormat] || 1;
	    var kind = inputFormat in ratioToSeconds ? 'seconds' : inputFormat;
	    return _moment2['default'].duration(val * ratio, kind);
	  }
	}
	
	module.exports = exports['default'];

/***/ },
/* 652 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 653 */
/***/ function(module, exports) {

	module.exports = "<div class=\"editor-duration\">\n  <div class=\"form-group\">\n    <label>Input Format</label>\n    <select\n      ng-model=\"editor.formatParams.inputFormat\"\n      ng-options=\"inputFormat.kind as inputFormat.text for inputFormat in editor.field.format.type.inputFormats\"\n      class=\"form-control\">\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Output Format</label>\n    <select\n      ng-model=\"editor.formatParams.outputFormat\"\n      ng-options=\"outputFormat.method as outputFormat.text for outputFormat in editor.field.format.type.outputFormats\"\n      class=\"form-control\">\n    </select>\n  </div>\n  <div class=\"form-group\" ng-hide=\"editor.field.format.isHuman()\">\n    <label>Decimal Places</label>\n    <input type=\"number\" min=\"0\" max=\"20\" ng-model=\"editor.formatParams.outputPrecision\" class=\"form-control\" />\n  </div>\n</div>\n<div>\n  <field-format-editor-samples\n    ng-model=\"editor.formatParams\"\n    inputs=\"cntrl.sampleInputs\">\n  </field-format-editor-samples>\n</div>\n"

/***/ },
/* 654 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IpFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	function IpFormatProvider(Private) {
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	
	  _lodash2['default']['class'](Ip).inherits(FieldFormat);
	  function Ip(params) {
	    Ip.Super.call(this, params);
	  }
	
	  Ip.id = 'ip';
	  Ip.title = 'IP Address';
	  Ip.fieldType = 'ip';
	
	  Ip.prototype._convert = function (val) {
	    if (val === undefined || val === null) return '-';
	    if (!isFinite(val)) return val;
	
	    // shazzam!
	    return [val >>> 24, val >>> 16 & 0xFF, val >>> 8 & 0xFF, val & 0xFF].join('.');
	  };
	
	  return Ip;
	}
	
	module.exports = exports['default'];

/***/ },
/* 655 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = NumberFormatProvider;
	
	var _uiStringifyTypes_numeral = __webpack_require__(644);
	
	var _uiStringifyTypes_numeral2 = _interopRequireDefault(_uiStringifyTypes_numeral);
	
	function NumberFormatProvider(Private) {
	  var Numeral = Private(_uiStringifyTypes_numeral2['default']);
	  return Numeral.factory({
	    id: 'number',
	    title: 'Number',
	    sampleInputs: [10000, 12.345678, -1, -999, 0.52]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 656 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = PercentFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiBound_to_config_obj = __webpack_require__(476);
	
	var _uiBound_to_config_obj2 = _interopRequireDefault(_uiBound_to_config_obj);
	
	var _uiStringifyTypes_numeral = __webpack_require__(644);
	
	var _uiStringifyTypes_numeral2 = _interopRequireDefault(_uiStringifyTypes_numeral);
	
	function PercentFormatProvider(Private) {
	  var BoundToConfigObj = Private(_uiBound_to_config_obj2['default']);
	  var Numeral = Private(_uiStringifyTypes_numeral2['default']);
	
	  return Numeral.factory({
	    id: 'percent',
	    title: 'Percentage',
	    paramDefaults: new BoundToConfigObj({
	      pattern: '=format:percent:defaultPattern',
	      fractional: true
	    }),
	    sampleInputs: [0.10, 0.99999, 1, 100, 1000],
	    prototype: {
	      _convert: _lodash2['default'].compose(Numeral.prototype._convert, function (val) {
	        return this.param('fractional') ? val : val / 100;
	      })
	    }
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 657 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = StringFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(631);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	function StringFormatProvider(Private) {
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	
	  _lodash2['default']['class'](_String).inherits(FieldFormat);
	  function _String(params) {
	    _String.Super.call(this, params);
	  }
	
	  _String.id = 'string';
	  _String.title = 'String';
	  _String.fieldType = ['number', 'boolean', 'date', 'ip', 'attachment', 'geo_point', 'geo_shape', 'string', 'murmur3', 'unknown', 'conflict'];
	
	  _String.paramDefaults = {
	    transform: false
	  };
	
	  _String.editor = __webpack_require__(658);
	
	  _String.transformOpts = [{ id: false, name: '- none -' }, { id: 'lower', name: 'Lower Case' }, { id: 'upper', name: 'Upper Case' }, { id: 'title', name: 'Title Case' }, { id: 'short', name: 'Short Dots' }, { id: 'base64', name: 'Base64 Decode' }];
	
	  _String.sampleInputs = ['A Quick Brown Fox.', 'STAY CALM!', 'com.organizations.project.ClassName', 'hostname.net', 'SGVsbG8gd29ybGQ='];
	
	  _String.prototype._base64Decode = function (val) {
	    try {
	      return window.atob(val);
	    } catch (e) {
	      return _lodash2['default'].asPrettyString(val);
	    }
	  };
	
	  _String.prototype._toTitleCase = function (val) {
	    return val.replace(/\w\S*/g, function (txt) {
	      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	    });
	  };
	
	  _String.prototype._convert = function (val) {
	    switch (this.param('transform')) {
	      case 'lower':
	        return String(val).toLowerCase();
	      case 'upper':
	        return String(val).toUpperCase();
	      case 'title':
	        return this._toTitleCase(val);
	      case 'short':
	        return _lodash2['default'].shortenDottedString(val);
	      case 'base64':
	        return this._base64Decode(val);
	      default:
	        return _lodash2['default'].asPrettyString(val);
	    }
	  };
	
	  return _String;
	}
	
	module.exports = exports['default'];

/***/ },
/* 658 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Transform</label>\n  <select\n    ng-model=\"editor.formatParams.transform\"\n    ng-options=\"opt.id as opt.name for opt in editor.field.format.type.transformOpts\"\n    class=\"form-control\">\n  </select>\n</div>\n\n<field-format-editor-samples inputs=\"editor.field.format.type.sampleInputs\"></field-format-editor-samples>\n"

/***/ },
/* 659 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = _SourceFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsNo_white_space = __webpack_require__(660);
	
	var _uiUtilsNo_white_space2 = _interopRequireDefault(_uiUtilsNo_white_space);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	function _SourceFormatProvider(Private, shortDotsFilter) {
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var template = _lodash2['default'].template((0, _uiUtilsNo_white_space2['default'])(__webpack_require__(661)));
	
	  _lodash2['default']['class'](Source).inherits(FieldFormat);
	  function Source(params) {
	    Source.Super.call(this, params);
	  }
	
	  Source.id = '_source';
	  Source.title = '_source';
	  Source.fieldType = '_source';
	
	  Source.prototype._convert = {
	    text: _angular2['default'].toJson,
	    html: function sourceToHtml(source, field, hit) {
	      if (!field) return this.getConverterFor('text')(source, field, hit);
	
	      var highlights = hit && hit.highlight || {};
	      var formatted = field.indexPattern.formatHit(hit);
	      var highlightPairs = [];
	      var sourcePairs = [];
	
	      _lodash2['default'].keys(formatted).forEach(function (key) {
	        var pairs = highlights[key] ? highlightPairs : sourcePairs;
	        var field = shortDotsFilter(key);
	        var val = formatted[key];
	        pairs.push([field, val]);
	      }, []);
	
	      return template({ defPairs: highlightPairs.concat(sourcePairs) });
	    }
	  };
	
	  return Source;
	}
	
	module.exports = exports['default'];

/***/ },
/* 660 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = noWhiteSpace;
	var TAGS_WITH_WS = />\s+</g;
	
	/**
	 * Remove all of the whitespace between html tags
	 * so that inline elements don't have extra spaces.
	 *
	 * If you have inline elements (span, a, em, etc.) and any
	 * amount of whitespace around them in your markup, then the
	 * browser will push them appart. This is ugly in certain
	 * senarios and is only fixed by removing the whitespace
	 * from the html in the first place (or ugly css hacks).
	 *
	 * @param  {string} html - the html to modify
	 * @return {string} - modified html
	 */
	
	function noWhiteSpace(html) {
	  return html.replace(TAGS_WITH_WS, '><');
	}
	
	module.exports = exports['default'];

/***/ },
/* 661 */
/***/ function(module, exports) {

	module.exports = "<dl class=\"source truncate-by-height\">\n  <% defPairs.forEach(function (def) { %>\n    <dt><%- def[0] %>:</dt>\n    <dd><%= def[1] %></dd>\n    <%= ' ' %>\n  <% }); %>\n</dl>\n"

/***/ },
/* 662 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _slicedToArray = __webpack_require__(290)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = ColorFormatProvider;
	
	__webpack_require__(663);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _uiStringifyEditorsColorHtml = __webpack_require__(664);
	
	var _uiStringifyEditorsColorHtml2 = _interopRequireDefault(_uiStringifyEditorsColorHtml);
	
	function ColorFormatProvider(Private) {
	
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var convertTemplate = _lodash2['default'].template('<span style="<%- style %>"><%- val %></span>');
	  var DEFAULT_COLOR = {
	    range: Number.NEGATIVE_INFINITY + ':' + Number.POSITIVE_INFINITY,
	    regex: '<insert regex>',
	    text: '#000000',
	    background: '#ffffff'
	  };
	
	  _lodash2['default']['class'](_Color).inherits(FieldFormat);
	  function _Color(params) {
	    _Color.Super.call(this, params);
	  }
	
	  _Color.id = 'color';
	  _Color.title = 'Color';
	  _Color.fieldType = ['number', 'string'];
	
	  _Color.editor = {
	    template: _uiStringifyEditorsColorHtml2['default'],
	    controller: function controller($scope) {
	      $scope.$watch('editor.field.type', function (type) {
	        $scope.editor.formatParams.fieldType = type;
	      });
	
	      $scope.addColor = function () {
	        $scope.editor.formatParams.colors.push(_lodash2['default'].cloneDeep(DEFAULT_COLOR));
	      };
	
	      $scope.removeColor = function (index) {
	        $scope.editor.formatParams.colors.splice(index, 1);
	      };
	    }
	  };
	
	  _Color.paramDefaults = {
	    fieldType: null, // populated by editor, see controller below
	    colors: [_lodash2['default'].cloneDeep(DEFAULT_COLOR)]
	  };
	
	  _Color.prototype.findColorRuleForVal = function (val) {
	    switch (this.param('fieldType')) {
	      case 'string':
	        return _lodash2['default'].findLast(this.param('colors'), function (colorParam) {
	          return new RegExp(colorParam.regex).test(val);
	        });
	
	      case 'number':
	        return _lodash2['default'].findLast(this.param('colors'), function (_ref) {
	          var range = _ref.range;
	
	          if (!range) return;
	
	          var _range$split = range.split(':');
	
	          var _range$split2 = _slicedToArray(_range$split, 2);
	
	          var start = _range$split2[0];
	          var end = _range$split2[1];
	
	          return val >= Number(start) && val <= Number(end);
	        });
	
	      default:
	        return null;
	    }
	  };
	
	  _Color.prototype._convert = {
	    html: function html(val) {
	      var color = this.findColorRuleForVal(val);
	      if (!color) return _lodash2['default'].asPrettyString(val);
	
	      var style = '';
	      if (color.text) style += 'color: ' + color.text + ';';
	      if (color.background) style += 'background-color: ' + color.background + ';';
	      return convertTemplate({ val: val, style: style });
	    }
	  };
	
	  return _Color;
	}
	
	module.exports = exports['default'];

/***/ },
/* 663 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 664 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <div ng-repeat=\"color in editor.formatParams.colors\">\n    <div class=\"editor-color\">\n      <button ng-if=\"editor.formatParams.colors.length > 1\" aria-label=\"Remove Color\" ng-click=\"removeColor($index)\" tooltip=\"Remove Color\" tooltip-append-to-body=\"true\" type=\"button\" class=\"btn btn-xs btn-danger editor-color-remove\">\n        <i aria-hidden=\"true\" class=\"fa fa-times\"></i>\n      </button>\n      <div class=\"form-group\" ng-if=\"editor.formatParams.fieldType === 'number'\">\n        <label>Range <small>(min:max)</small></label>\n        <input\n          ng-model=\"color.range\"\n          class=\"form-control\">\n      </div>\n      <div class=\"form-group\" ng-if=\"editor.formatParams.fieldType === 'string'\">\n        <label>Pattern <small>(regular expression)</small></label>\n        <input\n            ng-model=\"color.regex\"\n            class=\"form-control\">\n      </div>\n      <div class=\"form-group\">\n        <label>Font Color</label>\n        <input\n          ng-model=\"color.text\"\n          colorpicker\n          type=\"text\"\n          class=\"form-control\">\n      </div>\n      <div class=\"form-group\">\n        <label>Background Color</label>\n        <input\n          ng-model=\"color.background\"\n          colorpicker\n          type=\"text\"\n          class=\"form-control\">\n      </div>\n      <div class=\"form-group\">\n        <label>Example</label>\n          <div class=\"form-control\"\n            ng-style=\"{color: color.text, 'background-color': color.background}\"\n            value=\"formatted\">\n            123456\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n  <button aria-label=\"Add Color\" ng-click=\"addColor()\" tooltip=\"Add Color\" tooltip-append-to-body=\"true\" type=\"button\" class=\"btn btn-primary btn-xs\">\n      <span class=\"sr-only\">Add Color</span>\n      <i aria-hidden=\"true\" class=\"fa fa-plus\"></i> Add Color\n  </button>\n\n</div>\n"

/***/ },
/* 665 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = TruncateFormatProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	function TruncateFormatProvider(Private) {
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var omission = '...';
	
	  _lodash2['default']['class'](Truncate).inherits(FieldFormat);
	
	  function Truncate(params) {
	    Truncate.Super.call(this, params);
	  }
	
	  Truncate.id = 'truncate';
	  Truncate.title = 'Truncated String';
	  Truncate.fieldType = ['string'];
	
	  Truncate.prototype._convert = function (val) {
	    var length = this.param('fieldLength');
	    if (length > 0) {
	      return _lodash2['default'].trunc(val, {
	        'length': length + omission.length,
	        'omission': omission
	      });
	    }
	
	    return val;
	  };
	
	  Truncate.editor = __webpack_require__(666);
	
	  Truncate.sampleInput = [__webpack_require__(667)];
	
	  return Truncate;
	}
	
	module.exports = exports['default'];

/***/ },
/* 666 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Field Length</label>\n  <input ng-model=\"editor.formatParams.fieldLength\" class=\"form-control\">\n</div>\n\n<field-format-editor-samples inputs=\"editor.field.format.type.sampleInput\"></field-format-editor-samples>\n"

/***/ },
/* 667 */
/***/ function(module, exports) {

	module.exports = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris vitae sem consequat, sollicitudin enim a, feugiat mi. Curabitur congue laoreet elit, eu dictum nisi commodo ut. Nullam congue sem a blandit commodo. Suspendisse eleifend sodales leo ac hendrerit. Nam fringilla tempor fermentum. Ut tristique pharetra sapien sit amet pharetra. Ut turpis massa, viverra id erat quis, fringilla vehicula risus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Phasellus tincidunt gravida gravida. Praesent et ligula viverra, semper lacus in, tristique elit. Cras ac eleifend diam. Nulla facilisi. Morbi id sagittis magna. Sed fringilla, magna in suscipit aliquet."

/***/ },
/* 668 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = __webpack_require__(247)['default'];
	
	var _inherits = __webpack_require__(254)['default'];
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = TruncateFormatProvider;
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function TruncateFormatProvider(Private) {
	
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	
	  var Bool = (function (_FieldFormat) {
	    _inherits(Bool, _FieldFormat);
	
	    function Bool(params) {
	      _classCallCheck(this, Bool);
	
	      _get(Object.getPrototypeOf(Bool.prototype), 'constructor', this).call(this, params);
	    }
	
	    _createClass(Bool, [{
	      key: '_convert',
	      value: function _convert(value) {
	
	        if (typeof value === 'string') {
	          value = value.trim().toLowerCase();
	        }
	
	        switch (value) {
	          case false:
	          case 0:
	          case 'false':
	          case 'no':
	            return 'false';
	          case true:
	          case 1:
	          case 'true':
	          case 'yes':
	            return 'true';
	          default:
	            return _lodash2['default'].asPrettyString(value);
	        }
	      }
	    }]);
	
	    return Bool;
	  })(FieldFormat);
	
	  Bool.id = 'boolean';
	  Bool.title = 'Boolean';
	  Bool.fieldType = ['boolean', 'number', 'string'];
	
	  return Bool;
	}
	
	module.exports = exports['default'];

/***/ },
/* 669 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	__webpack_require__(330);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var $style = (0, _jquery2['default'])('<style>').appendTo('head').attr('id', 'style-compile');
	
	_uiModules2['default'].get('kibana').run(function ($rootScope, $compile, config) {
	  var truncateGradientHeight = 15;
	  var template = _lodash2['default'].template(__webpack_require__(670));
	  var locals = {};
	
	  // watch the value of the truncate:maxHeight config param
	  $rootScope.$watch(function () {
	    return config.get('truncate:maxHeight');
	  }, function (maxHeight) {
	    if (maxHeight > 0) {
	      locals.truncateMaxHeight = maxHeight + 'px !important';
	      locals.truncateGradientTop = maxHeight - truncateGradientHeight + 'px';
	    } else {
	      locals.truncateMaxHeight = 'none';
	      locals.truncateGradientTop = '-' + truncateGradientHeight + 'px';
	    }
	
	    $style.html(template(locals));
	  });
	});

/***/ },
/* 670 */
/***/ function(module, exports) {

	module.exports = ".truncate-by-height {\n  max-height: <%= truncateMaxHeight %>;\n  display: inline-block;\n}\n.truncate-by-height:before {\n  top: <%= truncateGradientTop %>;\n}\n"

/***/ },
/* 671 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiTimepickerTimepickerHtml = __webpack_require__(672);
	
	var _uiTimepickerTimepickerHtml2 = _interopRequireDefault(_uiTimepickerTimepickerHtml);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _elasticDatemath = __webpack_require__(237);
	
	var _elasticDatemath2 = _interopRequireDefault(_elasticDatemath);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	__webpack_require__(673);
	
	__webpack_require__(674);
	
	__webpack_require__(675);
	
	__webpack_require__(676);
	
	__webpack_require__(677);
	
	__webpack_require__(678);
	
	__webpack_require__(679);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('ui/timepicker');
	var notify = new _uiNotifyNotifier2['default']({
	  location: 'timepicker'
	});
	
	_module.directive('kbnTimepicker', function (quickRanges, timeUnits, refreshIntervals) {
	  return {
	    restrict: 'E',
	    scope: {
	      from: '=',
	      to: '=',
	      mode: '=',
	      interval: '=',
	      activeTab: '=',
	      onFilterSelect: '&',
	      onIntervalSelect: '&'
	    },
	    template: _uiTimepickerTimepickerHtml2['default'],
	    controller: function controller($scope) {
	      $scope.format = 'MMMM Do YYYY, HH:mm:ss.SSS';
	      $scope.modes = ['quick', 'relative', 'absolute'];
	      $scope.activeTab = $scope.activeTab || 'filter';
	
	      if (_lodash2['default'].isUndefined($scope.mode)) $scope.mode = 'quick';
	
	      $scope.quickLists = (0, _lodash2['default'])(quickRanges).groupBy('section').values().value();
	      $scope.refreshLists = (0, _lodash2['default'])(refreshIntervals).groupBy('section').values().value();
	
	      $scope.relative = {
	        count: 1,
	        unit: 'm',
	        preview: undefined,
	        round: false
	      };
	
	      $scope.absolute = {
	        from: (0, _moment2['default'])(),
	        to: (0, _moment2['default'])()
	      };
	
	      $scope.units = timeUnits;
	
	      $scope.relativeOptions = [{ text: 'Seconds ago', value: 's' }, { text: 'Minutes ago', value: 'm' }, { text: 'Hours ago', value: 'h' }, { text: 'Days ago', value: 'd' }, { text: 'Weeks ago', value: 'w' }, { text: 'Months ago', value: 'M' }, { text: 'Years ago', value: 'y' }];
	
	      $scope.$watch('from', function (date) {
	        if (_moment2['default'].isMoment(date) && $scope.mode === 'absolute') {
	          $scope.absolute.from = date;
	        }
	      });
	
	      $scope.$watch('to', function (date) {
	        if (_moment2['default'].isMoment(date) && $scope.mode === 'absolute') {
	          $scope.absolute.to = date;
	        }
	      });
	
	      $scope.$watch('absolute.from', function (date) {
	        if (_lodash2['default'].isDate(date)) $scope.absolute.from = (0, _moment2['default'])(date);
	      });
	
	      $scope.$watch('absolute.to', function (date) {
	        if (_lodash2['default'].isDate(date)) $scope.absolute.to = (0, _moment2['default'])(date);
	      });
	
	      $scope.setMode = function (thisMode) {
	        switch (thisMode) {
	          case 'quick':
	            break;
	          case 'relative':
	            var fromParts = $scope.from.toString().split('-');
	            var relativeParts = [];
	
	            // Try to parse the relative time, if we can't use moment duration to guestimate
	            if ($scope.to.toString() === 'now' && fromParts[0] === 'now' && fromParts[1]) {
	              relativeParts = fromParts[1].match(/([0-9]+)([smhdwMy]).*/);
	            }
	            if (relativeParts[1] && relativeParts[2]) {
	              $scope.relative.count = parseInt(relativeParts[1], 10);
	              $scope.relative.unit = relativeParts[2];
	            } else {
	              var duration = _moment2['default'].duration((0, _moment2['default'])().diff(_elasticDatemath2['default'].parse($scope.from)));
	              var units = _lodash2['default'].pluck(_lodash2['default'].clone($scope.relativeOptions).reverse(), 'value');
	              if ($scope.from.toString().split('/')[1]) $scope.relative.round = true;
	              for (var i = 0; i < units.length; i++) {
	                var as = duration.as(units[i]);
	                if (as > 1) {
	                  $scope.relative.count = Math.round(as);
	                  $scope.relative.unit = units[i];
	                  break;
	                }
	              }
	            }
	
	            if ($scope.from.toString().split('/')[1]) $scope.relative.round = true;
	            $scope.formatRelative();
	
	            break;
	          case 'absolute':
	            $scope.absolute.from = _elasticDatemath2['default'].parse($scope.from || (0, _moment2['default'])().subtract(15, 'minutes'));
	            $scope.absolute.to = _elasticDatemath2['default'].parse($scope.to || (0, _moment2['default'])(), true);
	            break;
	        }
	
	        $scope.mode = thisMode;
	      };
	
	      $scope.setQuick = function (from, to) {
	        $scope.onFilterSelect({ from: from, to: to });
	      };
	
	      $scope.setToNow = function () {
	        $scope.absolute.to = (0, _moment2['default'])();
	      };
	
	      $scope.formatRelative = function () {
	        var parsed = _elasticDatemath2['default'].parse(getRelativeString());
	        $scope.relative.preview = parsed ? parsed.format($scope.format) : undefined;
	        return parsed;
	      };
	
	      $scope.applyRelative = function () {
	        $scope.onFilterSelect({
	          from: getRelativeString(),
	          to: 'now'
	        });
	      };
	
	      function getRelativeString() {
	        return 'now-' + $scope.relative.count + $scope.relative.unit + ($scope.relative.round ? '/' + $scope.relative.unit : '');
	      }
	
	      $scope.applyAbsolute = function () {
	        $scope.onFilterSelect({
	          from: (0, _moment2['default'])($scope.absolute.from),
	          to: (0, _moment2['default'])($scope.absolute.to)
	        });
	      };
	
	      $scope.setRefreshInterval = function (interval) {
	        interval = _lodash2['default'].clone(interval || {});
	        notify.log('before: ' + interval.pause);
	        interval.pause = interval.pause == null || interval.pause === false ? false : true;
	
	        notify.log('after: ' + interval.pause);
	
	        $scope.onIntervalSelect({ interval: interval });
	      };
	
	      $scope.setMode($scope.mode);
	    }
	  };
	});

/***/ },
/* 672 */
/***/ function(module, exports) {

	module.exports = "<div class=\"kbn-timepicker\">\n\n  <div class=\"tab-content\">\n\n    <!-- Filters -->\n    <div ng-show=\"activeTab === 'filter'\" role=\"tabpanel\" class=\"tab-pane active\">\n      <div class=\"kuiLocalDropdownTitle\">Time Range</div>\n      <div class=\"row\">\n        <div class=\"col-md-2\">\n          <ul class=\"nav nav-pills nav-stacked kbn-timepicker-modes\">\n            <li ng-class=\"{active: mode === 'quick' }\">\n              <a ng-click=\"setMode('quick')\">quick</a>\n            </li>\n            <li ng-class=\"{active: mode === 'relative' }\">\n              <a ng-click=\"setMode('relative')\">relative</a>\n            </li>\n            <li ng-class=\"{active: mode === 'absolute' }\">\n              <a ng-click=\"setMode('absolute')\">absolute</a>\n            </li>\n          </ul>\n        </div>\n\n        <div class=\"col-md-10\">\n          <div ng-switch on=\"mode\" class=\"container-fluid\">\n            <div ng-switch-when=\"quick\">\n\n              <div ng-repeat=\"list in quickLists\" class=\"kbn-timepicker-section\">\n                <ul class=\"list-unstyled\">\n                  <li ng-repeat=\"option in list\">\n                    <a ng-click=\"setQuick(option.from, option.to)\" ng-bind=\"::option.display\"></a>\n                  </li>\n                </ul>\n              </div>\n\n              <!-- TODO: Add a section for custom intervals -->\n            </div>\n\n            <div ng-switch-when=\"relative\">\n              <form role=\"form\" ng-submit=\"applyRelative()\" class=\"form-inline\" name=\"relativeTime\">\n                <div class=\"kbn-timepicker-section\">\n                  <label>\n                    From:\n                    <span ng-show=\"relative.preview\">{{relative.preview}}</span>\n                    <span ng-hide=\"relative.preview\"><i>Invalid Expression</i></span>\n                  </label>\n                  <br>\n                  <div class=\"form-group\">\n                    <input\n                      required\n                      ng-model=\"relative.count\"\n                      ng-change=\"formatRelative()\"\n                      greater-than=\"-1\"\n                      min=\"0\"\n                      type=\"number\"\n                      class=\"form-control\">\n                  </div>\n                  <div class=\"form-group\">\n                    <select\n                      ng-model=\"relative.unit\"\n                      ng-options=\"opt.value as opt.text for opt in relativeOptions\"\n                      ng-change=\"formatRelative()\"\n                      class=\"form-control col-xs-2\">\n                    </select>\n                  </div>\n                  <br>\n                  <div class=\"small\">\n                    <label>\n                      <input\n                        ng-model=\"relative.round\"\n                        ng-checked=\"relative.round\"\n                        ng-change=\"formatRelative()\"\n                        type=\"checkbox\">\n                      round to the {{units[relative.unit]}}\n                    </label>\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section\">\n                  <label>\n                    To: Now\n                  </label>\n                  <br>\n                  <div class=\"form-group\">\n                    <input type=\"text\" disabled class=\"form-control\" value=\"Now\">\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section\">\n                  <label>&nbsp;</label>\n                  <br>\n                  <div class=\"form-group\">\n                    <button type=\"submit\" class=\"btn btn-primary kbn-timepicker-go\" ng-disabled=\"!relative.preview\">\n                      Go\n                    </button>\n                  </div>\n                </div>\n              </form>\n            </div>\n\n            <div ng-switch-when=\"absolute\">\n              <form name=\"absoluteTime\" ng-submit=\"applyAbsolute()\">\n                <div class=\"kbn-timepicker-section\">\n                  <div>\n                    <label class=\"small\">From: <span ng-show=\"!absolute.from\"><i>Invalid Date</i></span>\n                    </label>\n                    <input type=\"text\" required class=\"form-control\" input-datetime=\"{{format}}\" ng-model=\"absolute.from\">\n                  </div>\n                  <div>\n                    <datepicker ng-model=\"absolute.from\" max-date=\"absolute.to\" show-weeks=\"false\"></datepicker>\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section\">\n                  <div>\n                    <label class=\"small\">To:\n                      <a class=\"label label-default\" ng-click=\"setToNow()\">Set To Now</a>\n                    </label>\n                    <span ng-show=\"!absolute.to\"><i>Invalid Date</i></span>\n                    <input type=\"text\" required class=\"form-control\" input-datetime=\"{{format}}\" ng-model=\"absolute.to\">\n                  </div>\n                  <div>\n                    <datepicker ng-model=\"absolute.to\" min-date=\"absolute.from\" show-weeks=\"false\"></datepicker>\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section kbn-timepicker-alert\">\n                  <label>&nbsp;</label>\n                  <div class=\"form-group\">\n                    <button class=\"btn btn-primary kbn-timepicker-go\" ng-disabled=\"absolute.from > absolute.to || !absolute.from || !absolute.to\" type=\"submit\">\n                      Go\n                    </button>\n                    <span class=\"small\" ng-show=\"absolute.from > absolute.to\"><strong>From</strong> must occur before <strong>To</strong></span>\n                  </div>\n                </div>\n              </form>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Refresh Intervals -->\n    <div ng-show=\"activeTab === 'interval'\" role=\"tabpanel\" class=\"tab-pane active\">\n      <div class=\"kuiLocalDropdownTitle\">Refresh Interval</div>\n      <div ng-repeat=\"list in refreshLists\" class=\"kbn-refresh-section\">\n        <ul class=\"list-unstyled\">\n          <li ng-repeat=\"inter in list\">\n            <a class=\"refresh-interval\" ng-class=\"{ 'refresh-interval-active': interval.value === inter.value }\" ng-click=\"setRefreshInterval(inter)\">\n              {{inter.display}}\n            </a>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 673 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 674 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('inputDatetime', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link($scope, $elem, attrs, ngModel) {
	
	      var format = 'YYYY-MM-DD HH:mm:ss.SSS';
	
	      $elem.after('<div class="input-datetime-format">' + format + '</div>');
	
	      // What should I make with the input from the user?
	      var fromUser = function fromUser(text) {
	        var parsed = (0, _moment2['default'])(text, format);
	        return parsed.isValid() ? parsed : undefined;
	      };
	
	      // How should I present the data back to the user in the input field?
	      var toUser = function toUser(datetime) {
	        return (0, _moment2['default'])(datetime).format(format);
	      };
	
	      ngModel.$parsers.push(fromUser);
	      ngModel.$formatters.push(toUser);
	    }
	  };
	});

/***/ },
/* 675 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	function makeDirectiveDef(id, compare) {
	  return function ($parse) {
	    return {
	      require: 'ngModel',
	      link: function link($scope, $el, $attr, ngModel) {
	        var getBound = function getBound() {
	          return $parse($attr[id])();
	        };
	        var defaultVal = ({
	          'greaterThan': -Infinity,
	          'greaterOrEqualThan': -Infinity,
	          'lessThan': Infinity
	        })[id];
	
	        ngModel.$parsers.push(validate);
	        ngModel.$formatters.push(validate);
	
	        $scope.$watch(getBound, function () {
	          validate(ngModel.$viewValue);
	        });
	
	        function validate(val) {
	          var bound = !isNaN(getBound()) ? +getBound() : defaultVal;
	          var valid = !isNaN(bound) && !isNaN(val) && compare(val, bound);
	          ngModel.$setValidity(id, valid);
	          return val;
	        }
	      }
	    };
	  };
	}
	
	_uiModules2['default'].get('kibana').directive('greaterThan', makeDirectiveDef('greaterThan', function (a, b) {
	  return a > b;
	})).directive('lessThan', makeDirectiveDef('lessThan', function (a, b) {
	  return a < b;
	})).directive('greaterOrEqualThan', makeDirectiveDef('greaterOrEqualThan', function (a, b) {
	  return a >= b;
	}));

/***/ },
/* 676 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.constant('quickRanges', [{ from: 'now/d', to: 'now/d', display: 'Today', section: 0 }, { from: 'now/w', to: 'now/w', display: 'This week', section: 0 }, { from: 'now/M', to: 'now/M', display: 'This month', section: 0 }, { from: 'now/y', to: 'now/y', display: 'This year', section: 0 }, { from: 'now/d', to: 'now', display: 'The day so far', section: 0 }, { from: 'now/w', to: 'now', display: 'Week to date', section: 0 }, { from: 'now/M', to: 'now', display: 'Month to date', section: 0 }, { from: 'now/y', to: 'now', display: 'Year to date', section: 0 }, { from: 'now-1d/d', to: 'now-1d/d', display: 'Yesterday', section: 1 }, { from: 'now-2d/d', to: 'now-2d/d', display: 'Day before yesterday', section: 1 }, { from: 'now-7d/d', to: 'now-7d/d', display: 'This day last week', section: 1 }, { from: 'now-1w/w', to: 'now-1w/w', display: 'Previous week', section: 1 }, { from: 'now-1M/M', to: 'now-1M/M', display: 'Previous month', section: 1 }, { from: 'now-1y/y', to: 'now-1y/y', display: 'Previous year', section: 1 }, { from: 'now-15m', to: 'now', display: 'Last 15 minutes', section: 2 }, { from: 'now-30m', to: 'now', display: 'Last 30 minutes', section: 2 }, { from: 'now-1h', to: 'now', display: 'Last 1 hour', section: 2 }, { from: 'now-4h', to: 'now', display: 'Last 4 hours', section: 2 }, { from: 'now-12h', to: 'now', display: 'Last 12 hours', section: 2 }, { from: 'now-24h', to: 'now', display: 'Last 24 hours', section: 2 }, { from: 'now-7d', to: 'now', display: 'Last 7 days', section: 2 }, { from: 'now-30d', to: 'now', display: 'Last 30 days', section: 3 }, { from: 'now-60d', to: 'now', display: 'Last 60 days', section: 3 }, { from: 'now-90d', to: 'now', display: 'Last 90 days', section: 3 }, { from: 'now-6M', to: 'now', display: 'Last 6 months', section: 3 }, { from: 'now-1y', to: 'now', display: 'Last 1 year', section: 3 }, { from: 'now-2y', to: 'now', display: 'Last 2 years', section: 3 }, { from: 'now-5y', to: 'now', display: 'Last 5 years', section: 3 }]);

/***/ },
/* 677 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.constant('refreshIntervals', [{ value: 0, display: 'Off', section: 0 }, { value: 5000, display: '5 seconds', section: 1 }, { value: 10000, display: '10 seconds', section: 1 }, { value: 30000, display: '30 seconds', section: 1 }, { value: 45000, display: '45 seconds', section: 1 }, { value: 60000, display: '1 minute', section: 2 }, { value: 300000, display: '5 minutes', section: 2 }, { value: 900000, display: '15 minutes', section: 2 }, { value: 1800000, display: '30 minutes', section: 2 }, { value: 3600000, display: '1 hour', section: 3 }, { value: 7200000, display: '2 hour', section: 3 }, { value: 43200000, display: '12 hour', section: 3 }, { value: 86400000, display: '1 day', section: 3 }]);

/***/ },
/* 678 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.constant('timeUnits', {
	  s: 'second',
	  m: 'minute',
	  h: 'hour',
	  d: 'day',
	  w: 'week',
	  M: 'month',
	  y: 'year'
	});

/***/ },
/* 679 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _lodash = __webpack_require__(3);
	
	var _kbn_global_timepickerHtml = __webpack_require__(680);
	
	var _kbn_global_timepickerHtml2 = _interopRequireDefault(_kbn_global_timepickerHtml);
	
	var _time_navigation = __webpack_require__(681);
	
	var _time_navigation2 = _interopRequireDefault(_time_navigation);
	
	_uiModules2['default'].get('kibana').directive('kbnGlobalTimepicker', function (timefilter, globalState, $rootScope) {
	  var listenForUpdates = (0, _lodash.once)(function ($scope) {
	    $scope.$listen(timefilter, 'update', function () {
	      globalState.time = (0, _lodash.clone)(timefilter.time);
	      globalState.refreshInterval = (0, _lodash.clone)(timefilter.refreshInterval);
	      globalState.save();
	    });
	  });
	
	  return {
	    template: _kbn_global_timepickerHtml2['default'],
	    replace: true,
	    require: '^kbnTopNav',
	    link: function link($scope, element, attributes, kbnTopNav) {
	      listenForUpdates($rootScope);
	
	      $rootScope.timefilter = timefilter;
	      $rootScope.toggleRefresh = function () {
	        timefilter.refreshInterval.pause = !timefilter.refreshInterval.pause;
	      };
	
	      $scope.forward = function () {
	        timefilter.time = _time_navigation2['default'].stepForward(timefilter.getBounds());
	      };
	
	      $scope.back = function () {
	        timefilter.time = _time_navigation2['default'].stepBackward(timefilter.getBounds());
	      };
	
	      $scope.updateFilter = function (from, to) {
	        timefilter.time.from = from;
	        timefilter.time.to = to;
	        kbnTopNav.close('filter');
	      };
	
	      $scope.updateInterval = function (interval) {
	        timefilter.refreshInterval = interval;
	        kbnTopNav.close('interval');
	      };
	    }
	  };
	});

/***/ },
/* 680 */
/***/ function(module, exports) {

	module.exports = "<div ng-show=\"timefilter.enabled\" class=\"kuiLocalMenu\" data-test-subj=\"globalTimepicker\">\n  <div\n    class=\"kuiLocalMenuItem\"\n    ng-click=\"toggleRefresh()\"\n    ng-show=\"timefilter.refreshInterval.value > 0\"\n  >\n    <span class=\"fa\" ng-class=\"timefilter.refreshInterval.pause ? 'fa-play' : 'fa-pause'\"></span>\n  </div>\n\n  <div\n    class=\"kuiLocalMenuItem navbar-timepicker-auto-refresh-desc\"\n    ng-class=\"{'kuiLocalMenuItem-isSelected': kbnTopNav.isCurrent('interval') }\"\n    ng-show=\"timefilter.refreshInterval.value > 0 || kbnTopNav.isCurrent('interval') || kbnTopNav.isCurrent('filter')\"\n    ng-click=\"kbnTopNav.toggle('interval')\"\n  >\n    <span ng-show=\"timefilter.refreshInterval.value === 0\">\n      <span class=\"fa fa-repeat\"></span> Auto-refresh\n    </span>\n    <span ng-show=\"timefilter.refreshInterval.value > 0\">\n      {{timefilter.refreshInterval.display}}\n    </span>\n  </div>\n\n  <div class=\"kuiLocalMenuItem\" ng-click=\"back()\">\n    <span class=\"fa fa-chevron-left ng-scope\" tooltip=\"Move backwards in time\"></span>\n  </div>\n\n  <div\n    data-test-subj=\"globalTimepickerButton\"\n    class=\"kuiLocalMenuItem navbar-timepicker-time-desc\"\n    ng-class=\"{'kuiLocalMenuItem-isSelected': kbnTopNav.isCurrent('filter')}\"\n    ng-click=\"kbnTopNav.toggle('filter')\"\n    aria-haspopup=\"true\"\n    aria-expanded=\"false\"\n  >\n    <span aria-hidden=\"true\" class=\"fa fa-clock-o\"></span>\n    <pretty-duration\n      from=\"timefilter.time.from\" to=\"timefilter.time.to\"\n      data-test-subj=\"globalTimepickerRange\"\n    ></pretty-duration>\n  </div>\n\n  <div class=\"kuiLocalMenuItem\" ng-click=\"forward()\">\n    <span class=\"fa fa-chevron-right ng-scope\" tooltip=\"Move forwards in time\"></span>\n  </div>\n</div>\n"

/***/ },
/* 681 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	exports['default'] = {
	  // travel forward in time based on the interval between from and to
	  stepForward: function stepForward(_ref) {
	    var min = _ref.min;
	    var max = _ref.max;
	
	    var diff = max.diff(min);
	    return {
	      from: (0, _moment2['default'])(max).add(1, 'ms').toISOString(),
	      to: (0, _moment2['default'])(max).add(diff + 1, 'ms').toISOString(),
	      mode: 'absolute'
	    };
	  },
	
	  // travel backwards in time based on the interval between from and to
	  stepBackward: function stepBackward(_ref2) {
	    var min = _ref2.min;
	    var max = _ref2.max;
	
	    var diff = max.diff(min);
	    return {
	      from: (0, _moment2['default'])(min).subtract(diff + 1, 'ms').toISOString(),
	      to: (0, _moment2['default'])(min).subtract(1, 'ms').toISOString(),
	      mode: 'absolute'
	    };
	  },
	
	  // zoom out, doubling the difference between start and end, keeping the same time range center
	  zoomOut: function zoomOut(_ref3) {
	    var min = _ref3.min;
	    var max = _ref3.max;
	
	    var diff = max.diff(min);
	    return {
	      from: (0, _moment2['default'])(min).subtract(diff / 2, 'ms').toISOString(),
	      to: (0, _moment2['default'])(max).add(diff / 2, 'ms').toISOString(),
	      mode: 'absolute'
	    };
	  },
	
	  // zoom in, halving the difference between start and end, keeping the same time range center
	  zoomIn: function zoomIn(_ref4) {
	    var min = _ref4.min;
	    var max = _ref4.max;
	
	    var diff = max.diff(min);
	    return {
	      from: (0, _moment2['default'])(min).add(diff / 4, 'ms').toISOString(),
	      to: (0, _moment2['default'])(max).subtract(diff / 4, 'ms').toISOString(),
	      mode: 'absolute'
	    };
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 682 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiTooltipTooltipHtml = __webpack_require__(683);
	
	var _uiTooltipTooltipHtml2 = _interopRequireDefault(_uiTooltipTooltipHtml);
	
	__webpack_require__(684).config(function ($tooltipProvider) {
	  $tooltipProvider.options({
	    placement: 'bottom',
	    animation: true,
	    popupDelay: 150,
	    appendToBody: false
	  });
	}).directive('kbnTooltip', function () {
	  return {
	    restrict: 'E',
	    template: _uiTooltipTooltipHtml2['default'],
	    transclude: true,
	    replace: true,
	    scope: true,
	    link: function link($scope, $el, attr) {
	      $scope.text = attr.text;
	      $scope.placement = attr.placement || 'top';
	      $scope.delay = attr.delay || 400;
	      $scope.appendToBody = attr.appendToBody || 0;
	    }
	  };
	});

/***/ },
/* 683 */
/***/ function(module, exports) {

	module.exports = "<span\n  tooltip=\"{{text}}\"\n  tooltip-placement=\"{{placement}}\"\n  tooltip-popup-delay=\"{{delay}}\"\n  tooltip-append-to-body=\"{{appendToBody}}\"\n  ng-transclude></span>"

/***/ },
/* 684 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(17);
	  __webpack_require__(685);
	
	  return __webpack_require__(24)
	  .get('kibana', ['ui.bootstrap'])
	  .config(function ($tooltipProvider) {
	    $tooltipProvider.setTriggers({ 'mouseenter': 'mouseleave click' });
	  });
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 685 */
/***/ function(module, exports, __webpack_require__) {

	
	/* eslint-disable */
	
	/**
	 * TODO: Write custom components that address our needs to directly and deprecate these Bootstrap components.
	 */
	
	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/
	
	 * Version: 0.12.1 - 2015-02-20
	 * License: MIT
	 */
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	__webpack_require__(686);
	
	__webpack_require__(687);
	
	__webpack_require__(688);
	
	__webpack_require__(689);
	
	__webpack_require__(690);
	
	__webpack_require__(691);
	
	__webpack_require__(692);
	
	__webpack_require__(693);
	
	__webpack_require__(694);
	
	__webpack_require__(695);
	
	__webpack_require__(696);
	
	__webpack_require__(697);
	
	__webpack_require__(698);
	
	__webpack_require__(699);
	
	__webpack_require__(700);
	
	__webpack_require__(701);
	
	__webpack_require__(702);
	
	__webpack_require__(703);
	
	__webpack_require__(704);
	
	var _alertAlertHtml = __webpack_require__(705);
	
	var _alertAlertHtml2 = _interopRequireDefault(_alertAlertHtml);
	
	var _datepickerDatepickerHtml = __webpack_require__(706);
	
	var _datepickerDatepickerHtml2 = _interopRequireDefault(_datepickerDatepickerHtml);
	
	var _datepickerDayHtml = __webpack_require__(707);
	
	var _datepickerDayHtml2 = _interopRequireDefault(_datepickerDayHtml);
	
	var _datepickerMonthHtml = __webpack_require__(708);
	
	var _datepickerMonthHtml2 = _interopRequireDefault(_datepickerMonthHtml);
	
	var _datepickerPopupHtml = __webpack_require__(709);
	
	var _datepickerPopupHtml2 = _interopRequireDefault(_datepickerPopupHtml);
	
	var _datepickerYearHtml = __webpack_require__(710);
	
	var _datepickerYearHtml2 = _interopRequireDefault(_datepickerYearHtml);
	
	var _modalBackdropHtml = __webpack_require__(711);
	
	var _modalBackdropHtml2 = _interopRequireDefault(_modalBackdropHtml);
	
	var _modalWindowHtml = __webpack_require__(712);
	
	var _modalWindowHtml2 = _interopRequireDefault(_modalWindowHtml);
	
	var _paginationPagerHtml = __webpack_require__(713);
	
	var _paginationPagerHtml2 = _interopRequireDefault(_paginationPagerHtml);
	
	var _paginationPaginationHtml = __webpack_require__(714);
	
	var _paginationPaginationHtml2 = _interopRequireDefault(_paginationPaginationHtml);
	
	var _tooltipTooltipHtmlUnsafePopupHtml = __webpack_require__(715);
	
	var _tooltipTooltipHtmlUnsafePopupHtml2 = _interopRequireDefault(_tooltipTooltipHtmlUnsafePopupHtml);
	
	var _tooltipTooltipPopupHtml = __webpack_require__(716);
	
	var _tooltipTooltipPopupHtml2 = _interopRequireDefault(_tooltipTooltipPopupHtml);
	
	var _popoverPopoverHtml = __webpack_require__(717);
	
	var _popoverPopoverHtml2 = _interopRequireDefault(_popoverPopoverHtml);
	
	var _progressbarBarHtml = __webpack_require__(718);
	
	var _progressbarBarHtml2 = _interopRequireDefault(_progressbarBarHtml);
	
	var _progressbarProgressHtml = __webpack_require__(719);
	
	var _progressbarProgressHtml2 = _interopRequireDefault(_progressbarProgressHtml);
	
	var _progressbarProgressbarHtml = __webpack_require__(720);
	
	var _progressbarProgressbarHtml2 = _interopRequireDefault(_progressbarProgressbarHtml);
	
	var _ratingRatingHtml = __webpack_require__(721);
	
	var _ratingRatingHtml2 = _interopRequireDefault(_ratingRatingHtml);
	
	var _tabsTabHtml = __webpack_require__(722);
	
	var _tabsTabHtml2 = _interopRequireDefault(_tabsTabHtml);
	
	var _tabsTabsetHtml = __webpack_require__(723);
	
	var _tabsTabsetHtml2 = _interopRequireDefault(_tabsTabsetHtml);
	
	var _timepickerTimepickerHtml = __webpack_require__(724);
	
	var _timepickerTimepickerHtml2 = _interopRequireDefault(_timepickerTimepickerHtml);
	
	var _typeaheadTypeaheadMatchHtml = __webpack_require__(725);
	
	var _typeaheadTypeaheadMatchHtml2 = _interopRequireDefault(_typeaheadTypeaheadMatchHtml);
	
	var _typeaheadTypeaheadPopupHtml = __webpack_require__(726);
	
	var _typeaheadTypeaheadPopupHtml2 = _interopRequireDefault(_typeaheadTypeaheadPopupHtml);
	
	angular.module('ui.bootstrap', ['ui.bootstrap.tpls', 'ui.bootstrap.transition', 'ui.bootstrap.collapse', 'ui.bootstrap.alert', 'ui.bootstrap.bindHtml', 'ui.bootstrap.buttons', 'ui.bootstrap.dateparser', 'ui.bootstrap.position', 'ui.bootstrap.datepicker', 'ui.bootstrap.dropdown', 'ui.bootstrap.modal', 'ui.bootstrap.pagination', 'ui.bootstrap.tooltip', 'ui.bootstrap.popover', 'ui.bootstrap.progressbar', 'ui.bootstrap.rating', 'ui.bootstrap.tabs', 'ui.bootstrap.timepicker', 'ui.bootstrap.typeahead']);
	
	angular.module('ui.bootstrap.tpls', ['template/alert/alert.html', 'template/datepicker/datepicker.html', 'template/datepicker/day.html', 'template/datepicker/month.html', 'template/datepicker/popup.html', 'template/datepicker/year.html', 'template/modal/backdrop.html', 'template/modal/window.html', 'template/pagination/pager.html', 'template/pagination/pagination.html', 'template/tooltip/tooltip-html-unsafe-popup.html', 'template/tooltip/tooltip-popup.html', 'template/popover/popover.html', 'template/progressbar/bar.html', 'template/progressbar/progress.html', 'template/progressbar/progressbar.html', 'template/rating/rating.html', 'template/tabs/tab.html', 'template/tabs/tabset.html', 'template/timepicker/timepicker.html', 'template/typeahead/typeahead-match.html', 'template/typeahead/typeahead-popup.html']);
	
	angular.module('template/alert/alert.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/alert/alert.html', _alertAlertHtml2['default']);
	}]);
	
	angular.module('template/datepicker/datepicker.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/datepicker/datepicker.html', _datepickerDatepickerHtml2['default']);
	}]);
	
	angular.module('template/datepicker/day.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/datepicker/day.html', _datepickerDayHtml2['default']);
	}]);
	
	angular.module('template/datepicker/month.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/datepicker/month.html', _datepickerMonthHtml2['default']);
	}]);
	
	angular.module('template/datepicker/popup.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/datepicker/popup.html', _datepickerPopupHtml2['default']);
	}]);
	
	angular.module('template/datepicker/year.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/datepicker/year.html', _datepickerYearHtml2['default']);
	}]);
	
	angular.module('template/modal/backdrop.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/modal/backdrop.html', _modalBackdropHtml2['default']);
	}]);
	
	angular.module('template/modal/window.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/modal/window.html', _modalWindowHtml2['default']);
	}]);
	
	angular.module('template/pagination/pager.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/pagination/pager.html', _paginationPagerHtml2['default']);
	}]);
	
	angular.module('template/pagination/pagination.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/pagination/pagination.html', _paginationPaginationHtml2['default']);
	}]);
	
	angular.module('template/tooltip/tooltip-html-unsafe-popup.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/tooltip/tooltip-html-unsafe-popup.html', _tooltipTooltipHtmlUnsafePopupHtml2['default']);
	}]);
	
	angular.module('template/tooltip/tooltip-popup.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/tooltip/tooltip-popup.html', _tooltipTooltipPopupHtml2['default']);
	}]);
	
	angular.module('template/popover/popover.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/popover/popover.html', _popoverPopoverHtml2['default']);
	}]);
	
	angular.module('template/progressbar/bar.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/progressbar/bar.html', _progressbarBarHtml2['default']);
	}]);
	
	angular.module('template/progressbar/progress.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/progressbar/progress.html', _progressbarProgressHtml2['default']);
	}]);
	
	angular.module('template/progressbar/progressbar.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/progressbar/progressbar.html', _progressbarProgressbarHtml2['default']);
	}]);
	
	angular.module('template/rating/rating.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/rating/rating.html', _ratingRatingHtml2['default']);
	}]);
	
	angular.module('template/tabs/tab.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/tabs/tab.html', _tabsTabHtml2['default']);
	}]);
	
	angular.module('template/tabs/tabset.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/tabs/tabset.html', _tabsTabsetHtml2['default']);
	}]);
	
	angular.module('template/timepicker/timepicker.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/timepicker/timepicker.html', _timepickerTimepickerHtml2['default']);
	}]);
	
	angular.module('template/typeahead/typeahead-match.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/typeahead/typeahead-match.html', _typeaheadTypeaheadMatchHtml2['default']);
	}]);
	
	angular.module('template/typeahead/typeahead-popup.html', []).run(['$templateCache', function ($templateCache) {
	  $templateCache.put('template/typeahead/typeahead-popup.html', _typeaheadTypeaheadPopupHtml2['default']);
	}]);

/***/ },
/* 686 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('accordionConfig', {
	  closeOthers: true
	}).controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {
	
	  // This array keeps track of the accordion groups
	  this.groups = [];
	
	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function (openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if (closeOthers) {
	      angular.forEach(this.groups, function (group) {
	        if (group !== openGroup) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };
	
	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function (groupScope) {
	    var that = this;
	    this.groups.push(groupScope);
	
	    groupScope.$on('$destroy', function (event) {
	      that.removeGroup(groupScope);
	    });
	  };
	
	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function (group) {
	    var index = this.groups.indexOf(group);
	    if (index !== -1) {
	      this.groups.splice(index, 1);
	    }
	  };
	}])
	
	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('accordion', function () {
	  return {
	    restrict: 'EA',
	    controller: 'AccordionController',
	    transclude: true,
	    replace: false,
	    templateUrl: 'template/accordion/accordion.html'
	  };
	})
	
	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('accordionGroup', function () {
	  return {
	    require: '^accordion', // We need this directive to be inside an accordion
	    restrict: 'EA',
	    transclude: true, // It transcludes the contents of the directive into the template
	    replace: true, // The element containing the directive will be replaced with the template
	    templateUrl: 'template/accordion/accordion-group.html',
	    scope: {
	      heading: '@', // Interpolate the heading attribute onto this scope
	      isOpen: '=?',
	      isDisabled: '=?'
	    },
	    controller: function controller() {
	      this.setHeading = function (element) {
	        this.heading = element;
	      };
	    },
	    link: function link(scope, element, attrs, accordionCtrl) {
	      accordionCtrl.addGroup(scope);
	
	      scope.$watch('isOpen', function (value) {
	        if (value) {
	          accordionCtrl.closeOthers(scope);
	        }
	      });
	
	      scope.toggleOpen = function () {
	        if (!scope.isDisabled) {
	          scope.isOpen = !scope.isOpen;
	        }
	      };
	    }
	  };
	})
	
	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	// <accordion-group>
	//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
	// </accordion-group>
	.directive('accordionHeading', function () {
	  return {
	    restrict: 'EA',
	    transclude: true, // Grab the contents to be used as the heading
	    template: '', // In effect remove this element!
	    replace: true,
	    require: '^accordionGroup',
	    link: function link(scope, element, attr, accordionGroupCtrl, transclude) {
	      // Pass the heading to the accordion-group controller
	      // so that it can be transcluded into the right place in the template
	      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	      accordionGroupCtrl.setHeading(transclude(scope, function () {}));
	    }
	  };
	})
	
	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	// <div class="accordion-group">
	//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
	//   ...
	// </div>
	.directive('accordionTransclude', function () {
	  return {
	    require: '^accordionGroup',
	    link: function link(scope, element, attr, controller) {
	      scope.$watch(function () {
	        return controller[attr.accordionTransclude];
	      }, function (heading) {
	        if (heading) {
	          element.html('');
	          element.append(heading);
	        }
	      });
	    }
	  };
	});

/***/ },
/* 687 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.alert', []).controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {
	  $scope.closeable = 'close' in $attrs;
	  this.close = $scope.close;
	}]).directive('alert', function () {
	  return {
	    restrict: 'EA',
	    controller: 'AlertController',
	    templateUrl: 'template/alert/alert.html',
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@',
	      close: '&'
	    }
	  };
	}).directive('dismissOnTimeout', ['$timeout', function ($timeout) {
	  return {
	    require: 'alert',
	    link: function link(scope, element, attrs, alertCtrl) {
	      $timeout(function () {
	        alertCtrl.close();
	      }, parseInt(attrs.dismissOnTimeout, 10));
	    }
	  };
	}]);

/***/ },
/* 688 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.bindHtml', []).directive('bindHtmlUnsafe', function () {
	  return function (scope, element, attr) {
	    element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
	    scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
	      element.html(value || '');
	    });
	  };
	});

/***/ },
/* 689 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.buttons', []).constant('buttonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	}).controller('ButtonsController', ['buttonConfig', function (buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}]).directive('btnRadio', function () {
	  return {
	    require: ['btnRadio', 'ngModel'],
	    controller: 'ButtonsController',
	    link: function link(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      //model -> UI
	      ngModelCtrl.$render = function () {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
	      };
	
	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function () {
	        var isActive = element.hasClass(buttonsCtrl.activeClass);
	
	        if (!isActive || angular.isDefined(attrs.uncheckable)) {
	          scope.$apply(function () {
	            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });
	    }
	  };
	}).directive('btnCheckbox', function () {
	  return {
	    require: ['btnCheckbox', 'ngModel'],
	    controller: 'ButtonsController',
	    link: function link(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }
	
	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }
	
	      function getCheckboxValue(attributeValue, defaultValue) {
	        var val = scope.$eval(attributeValue);
	        return angular.isDefined(val) ? val : defaultValue;
	      }
	
	      //model -> UI
	      ngModelCtrl.$render = function () {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };
	
	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function () {
	        scope.$apply(function () {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	});

/***/ },
/* 690 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition']).directive('collapse', ['$transition', function ($transition) {
	
	  return {
	    link: function link(scope, element, attrs) {
	
	      var initialAnimSkip = true;
	      var currentTransition;
	
	      function doTransition(change) {
	        var newTransition = $transition(element, change);
	        if (currentTransition) {
	          currentTransition.cancel();
	        }
	        currentTransition = newTransition;
	        newTransition.then(newTransitionDone, newTransitionDone);
	        return newTransition;
	
	        function newTransitionDone() {
	          // Make sure it's this transition, otherwise, leave it alone.
	          if (currentTransition === newTransition) {
	            currentTransition = undefined;
	          }
	        }
	      }
	
	      function expand() {
	        if (initialAnimSkip) {
	          initialAnimSkip = false;
	          expandDone();
	        } else {
	          element.removeClass('collapse').addClass('collapsing');
	          doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);
	        }
	      }
	
	      function expandDone() {
	        element.removeClass('collapsing');
	        element.addClass('collapse in');
	        element.css({ height: 'auto' });
	      }
	
	      function collapse() {
	        if (initialAnimSkip) {
	          initialAnimSkip = false;
	          collapseDone();
	          element.css({ height: 0 });
	        } else {
	          // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
	          element.css({ height: element[0].scrollHeight + 'px' });
	          //trigger reflow so a browser realizes that height was updated from auto to a specific value
	          var x = element[0].offsetWidth;
	
	          element.removeClass('collapse in').addClass('collapsing');
	
	          doTransition({ height: 0 }).then(collapseDone);
	        }
	      }
	
	      function collapseDone() {
	        element.removeClass('collapsing');
	        element.addClass('collapse');
	      }
	
	      scope.$watch(attrs.collapse, function (shouldCollapse) {
	        if (shouldCollapse) {
	          collapse();
	        } else {
	          expand();
	        }
	      });
	    }
	  };
	}]);

/***/ },
/* 691 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.dateparser', []).service('dateParser', ['$locale', 'orderByFilter', function ($locale, orderByFilter) {
	
	  this.parsers = {};
	
	  var formatCodeToRegex = {
	    'yyyy': {
	      regex: '\\d{4}',
	      apply: function apply(value) {
	        this.year = +value;
	      }
	    },
	    'yy': {
	      regex: '\\d{2}',
	      apply: function apply(value) {
	        this.year = +value + 2000;
	      }
	    },
	    'y': {
	      regex: '\\d{1,4}',
	      apply: function apply(value) {
	        this.year = +value;
	      }
	    },
	    'MMMM': {
	      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
	      apply: function apply(value) {
	        this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
	      }
	    },
	    'MMM': {
	      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
	      apply: function apply(value) {
	        this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
	      }
	    },
	    'MM': {
	      regex: '0[1-9]|1[0-2]',
	      apply: function apply(value) {
	        this.month = value - 1;
	      }
	    },
	    'M': {
	      regex: '[1-9]|1[0-2]',
	      apply: function apply(value) {
	        this.month = value - 1;
	      }
	    },
	    'dd': {
	      regex: '[0-2][0-9]{1}|3[0-1]{1}',
	      apply: function apply(value) {
	        this.date = +value;
	      }
	    },
	    'd': {
	      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
	      apply: function apply(value) {
	        this.date = +value;
	      }
	    },
	    'EEEE': {
	      regex: $locale.DATETIME_FORMATS.DAY.join('|')
	    },
	    'EEE': {
	      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
	    }
	  };
	
	  function createParser(format) {
	    var map = [],
	        regex = format.split('');
	
	    angular.forEach(formatCodeToRegex, function (data, code) {
	      var index = format.indexOf(code);
	
	      if (index > -1) {
	        format = format.split('');
	
	        regex[index] = '(' + data.regex + ')';
	        format[index] = '$'; // Custom symbol to define consumed part of format
	        for (var i = index + 1, n = index + code.length; i < n; i++) {
	          regex[i] = '';
	          format[i] = '$';
	        }
	        format = format.join('');
	
	        map.push({ index: index, apply: data.apply });
	      }
	    });
	
	    return {
	      regex: new RegExp('^' + regex.join('') + '$'),
	      map: orderByFilter(map, 'index')
	    };
	  }
	
	  this.parse = function (input, format) {
	    if (!angular.isString(input) || !format) {
	      return input;
	    }
	
	    format = $locale.DATETIME_FORMATS[format] || format;
	
	    if (!this.parsers[format]) {
	      this.parsers[format] = createParser(format);
	    }
	
	    var parser = this.parsers[format],
	        regex = parser.regex,
	        map = parser.map,
	        results = input.match(regex);
	
	    if (results && results.length) {
	      var fields = { year: 1900, month: 0, date: 1, hours: 0 },
	          dt;
	
	      for (var i = 1, n = results.length; i < n; i++) {
	        var mapper = map[i - 1];
	        if (mapper.apply) {
	          mapper.apply.call(fields, results[i]);
	        }
	      }
	
	      if (isValid(fields.year, fields.month, fields.date)) {
	        dt = new Date(fields.year, fields.month, fields.date, fields.hours);
	      }
	
	      return dt;
	    }
	  };
	
	  // Check if date is valid for specific month (and year for February).
	  // Month: 0 = Jan, 1 = Feb, etc
	  function isValid(year, month, date) {
	    if (month === 1 && date > 28) {
	      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
	    }
	
	    if (month === 3 || month === 5 || month === 8 || month === 10) {
	      return date < 31;
	    }
	
	    return true;
	  }
	}]);

/***/ },
/* 692 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position']).constant('datepickerConfig', {
	  formatDay: 'dd',
	  formatMonth: 'MMMM',
	  formatYear: 'yyyy',
	  formatDayHeader: 'EEE',
	  formatDayTitle: 'MMMM yyyy',
	  formatMonthTitle: 'yyyy',
	  datepickerMode: 'day',
	  minMode: 'day',
	  maxMode: 'year',
	  showWeeks: true,
	  startingDay: 0,
	  yearRange: 20,
	  minDate: null,
	  maxDate: null
	}).controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function ($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;
	
	  // Modes chain
	  this.modes = ['day', 'month', 'year'];
	
	  // Configuration attributes
	  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function (key, index) {
	    self[key] = angular.isDefined($attrs[key]) ? index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
	  });
	
	  // Watchable date attributes
	  angular.forEach(['minDate', 'maxDate'], function (key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function (value) {
	        self[key] = value ? new Date(value) : null;
	        self.refreshView();
	      });
	    } else {
	      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
	    }
	  });
	
	  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
	  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();
	
	  $scope.isActive = function (dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };
	
	  this.init = function (ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	
	    ngModelCtrl.$render = function () {
	      self.render();
	    };
	  };
	
	  this.render = function () {
	    if (ngModelCtrl.$modelValue) {
	      var date = new Date(ngModelCtrl.$modelValue),
	          isValid = !isNaN(date);
	
	      if (isValid) {
	        this.activeDate = date;
	      } else {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	      }
	      ngModelCtrl.$setValidity('date', isValid);
	    }
	    this.refreshView();
	  };
	
	  this.refreshView = function () {
	    if (this.element) {
	      this._refreshView();
	
	      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
	      ngModelCtrl.$setValidity('date-disabled', !date || this.element && !this.isDisabled(date));
	    }
	  };
	
	  this.createDateObject = function (date, format) {
	    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
	    return {
	      date: date,
	      label: dateFilter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      current: this.compare(date, new Date()) === 0
	    };
	  };
	
	  this.isDisabled = function (date) {
	    return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
	  };
	
	  // Split array into smaller arrays
	  this.split = function (arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };
	
	  $scope.select = function (date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
	    }
	  };
	
	  $scope.move = function (direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };
	
	  $scope.toggleMode = function (direction) {
	    direction = direction || 1;
	
	    if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
	      return;
	    }
	
	    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
	  };
	
	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
	
	  var focusElement = function focusElement() {
	    $timeout(function () {
	      self.element[0].focus();
	    }, 0, false);
	  };
	
	  // Listen for focus requests from popup directive
	  $scope.$on('datepicker.focus', focusElement);
	
	  $scope.keydown = function (evt) {
	    var key = $scope.keys[evt.which];
	
	    if (!key || evt.shiftKey || evt.altKey) {
	      return;
	    }
	
	    evt.preventDefault();
	    evt.stopPropagation();
	
	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	      focusElement();
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	      focusElement();
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };
	}]).directive('datepicker', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/datepicker.html',
	    scope: {
	      datepickerMode: '=?',
	      dateDisabled: '&'
	    },
	    require: ['datepicker', '?^ngModel'],
	    controller: 'DatepickerController',
	    link: function link(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        datepickerCtrl.init(ngModelCtrl);
	      }
	    }
	  };
	}).directive('daypicker', ['dateFilter', function (dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/day.html',
	    require: '^datepicker',
	    link: function link(scope, element, attrs, ctrl) {
	      scope.showWeeks = ctrl.showWeeks;
	
	      ctrl.step = { months: 1 };
	      ctrl.element = element;
	
	      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	      function getDaysInMonth(year, month) {
	        return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
	      }
	
	      function getDates(startDate, n) {
	        var dates = new Array(n),
	            current = new Date(startDate),
	            i = 0;
	        current.setHours(12); // Prevent repeated dates because of timezone bug
	        while (i < n) {
	          dates[i++] = new Date(current);
	          current.setDate(current.getDate() + 1);
	        }
	        return dates;
	      }
	
	      ctrl._refreshView = function () {
	        var year = ctrl.activeDate.getFullYear(),
	            month = ctrl.activeDate.getMonth(),
	            firstDayOfMonth = new Date(year, month, 1),
	            difference = ctrl.startingDay - firstDayOfMonth.getDay(),
	            numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
	            firstDate = new Date(firstDayOfMonth);
	
	        if (numDisplayedFromPreviousMonth > 0) {
	          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	        }
	
	        // 42 is the number of days on a six-month calendar
	        var days = getDates(firstDate, 42);
	        for (var i = 0; i < 42; i++) {
	          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
	            secondary: days[i].getMonth() !== month,
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.labels = new Array(7);
	        for (var j = 0; j < 7; j++) {
	          scope.labels[j] = {
	            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
	            full: dateFilter(days[j].date, 'EEEE')
	          };
	        }
	
	        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
	        scope.rows = ctrl.split(days, 7);
	
	        if (scope.showWeeks) {
	          scope.weekNumbers = [];
	          var weekNumber = getISO8601WeekNumber(scope.rows[0][0].date),
	              numWeeks = scope.rows.length;
	          while (scope.weekNumbers.push(weekNumber++) < numWeeks) {}
	        }
	      };
	
	      ctrl.compare = function (date1, date2) {
	        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
	      };
	
	      function getISO8601WeekNumber(date) {
	        var checkDate = new Date(date);
	        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	        var time = checkDate.getTime();
	        checkDate.setMonth(0); // Compare with Jan 1
	        checkDate.setDate(1);
	        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	      }
	
	      ctrl.handleKeyDown = function (key, evt) {
	        var date = ctrl.activeDate.getDate();
	
	        if (key === 'left') {
	          date = date - 1; // up
	        } else if (key === 'up') {
	            date = date - 7; // down
	          } else if (key === 'right') {
	              date = date + 1; // down
	            } else if (key === 'down') {
	                date = date + 7;
	              } else if (key === 'pageup' || key === 'pagedown') {
	                var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
	                ctrl.activeDate.setMonth(month, 1);
	                date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
	              } else if (key === 'home') {
	                date = 1;
	              } else if (key === 'end') {
	                date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
	              }
	        ctrl.activeDate.setDate(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}]).directive('monthpicker', ['dateFilter', function (dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/month.html',
	    require: '^datepicker',
	    link: function link(scope, element, attrs, ctrl) {
	      ctrl.step = { years: 1 };
	      ctrl.element = element;
	
	      ctrl._refreshView = function () {
	        var months = new Array(12),
	            year = ctrl.activeDate.getFullYear();
	
	        for (var i = 0; i < 12; i++) {
	          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
	        scope.rows = ctrl.split(months, 3);
	      };
	
	      ctrl.compare = function (date1, date2) {
	        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
	      };
	
	      ctrl.handleKeyDown = function (key, evt) {
	        var date = ctrl.activeDate.getMonth();
	
	        if (key === 'left') {
	          date = date - 1; // up
	        } else if (key === 'up') {
	            date = date - 3; // down
	          } else if (key === 'right') {
	              date = date + 1; // down
	            } else if (key === 'down') {
	                date = date + 3;
	              } else if (key === 'pageup' || key === 'pagedown') {
	                var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
	                ctrl.activeDate.setFullYear(year);
	              } else if (key === 'home') {
	                date = 0;
	              } else if (key === 'end') {
	                date = 11;
	              }
	        ctrl.activeDate.setMonth(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}]).directive('yearpicker', ['dateFilter', function (dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/year.html',
	    require: '^datepicker',
	    link: function link(scope, element, attrs, ctrl) {
	      var range = ctrl.yearRange;
	
	      ctrl.step = { years: range };
	      ctrl.element = element;
	
	      function getStartingYear(year) {
	        return parseInt((year - 1) / range, 10) * range + 1;
	      }
	
	      ctrl._refreshView = function () {
	        var years = new Array(range);
	
	        for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
	          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.title = [years[0].label, years[range - 1].label].join(' - ');
	        scope.rows = ctrl.split(years, 5);
	      };
	
	      ctrl.compare = function (date1, date2) {
	        return date1.getFullYear() - date2.getFullYear();
	      };
	
	      ctrl.handleKeyDown = function (key, evt) {
	        var date = ctrl.activeDate.getFullYear();
	
	        if (key === 'left') {
	          date = date - 1; // up
	        } else if (key === 'up') {
	            date = date - 5; // down
	          } else if (key === 'right') {
	              date = date + 1; // down
	            } else if (key === 'down') {
	                date = date + 5;
	              } else if (key === 'pageup' || key === 'pagedown') {
	                date += (key === 'pageup' ? -1 : 1) * ctrl.step.years;
	              } else if (key === 'home') {
	                date = getStartingYear(ctrl.activeDate.getFullYear());
	              } else if (key === 'end') {
	                date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
	              }
	        ctrl.activeDate.setFullYear(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}]).constant('datepickerPopupConfig', {
	  datepickerPopup: 'yyyy-MM-dd',
	  currentText: 'Today',
	  clearText: 'Clear',
	  closeText: 'Done',
	  closeOnDateSelection: true,
	  appendToBody: false,
	  showButtonBar: true
	}).directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig', function ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
	  return {
	    restrict: 'EA',
	    require: 'ngModel',
	    scope: {
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@',
	      dateDisabled: '&'
	    },
	    link: function link(scope, element, attrs, ngModel) {
	      var dateFormat,
	          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
	          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
	
	      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
	
	      scope.getText = function (key) {
	        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
	      };
	
	      attrs.$observe('datepickerPopup', function (value) {
	        dateFormat = value || datepickerPopupConfig.datepickerPopup;
	        ngModel.$render();
	      });
	
	      // popup element used to display calendar
	      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
	      popupEl.attr({
	        'ng-model': 'date',
	        'ng-change': 'dateSelection()'
	      });
	
	      function cameltoDash(string) {
	        return string.replace(/([A-Z])/g, function ($1) {
	          return '-' + $1.toLowerCase();
	        });
	      }
	
	      // datepicker element
	      var datepickerEl = angular.element(popupEl.children()[0]);
	      if (attrs.datepickerOptions) {
	        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function (value, option) {
	          datepickerEl.attr(cameltoDash(option), value);
	        });
	      }
	
	      scope.watchData = {};
	      angular.forEach(['minDate', 'maxDate', 'datepickerMode'], function (key) {
	        if (attrs[key]) {
	          var getAttribute = $parse(attrs[key]);
	          scope.$parent.$watch(getAttribute, function (value) {
	            scope.watchData[key] = value;
	          });
	          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
	
	          // Propagate changes from datepicker to outside
	          if (key === 'datepickerMode') {
	            var setAttribute = getAttribute.assign;
	            scope.$watch('watchData.' + key, function (value, oldvalue) {
	              if (value !== oldvalue) {
	                setAttribute(scope.$parent, value);
	              }
	            });
	          }
	        }
	      });
	      if (attrs.dateDisabled) {
	        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
	      }
	
	      function parseDate(viewValue) {
	        if (!viewValue) {
	          ngModel.$setValidity('date', true);
	          return null;
	        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	          ngModel.$setValidity('date', true);
	          return viewValue;
	        } else if (angular.isString(viewValue)) {
	          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);
	          if (isNaN(date)) {
	            ngModel.$setValidity('date', false);
	            return undefined;
	          } else {
	            ngModel.$setValidity('date', true);
	            return date;
	          }
	        } else {
	          ngModel.$setValidity('date', false);
	          return undefined;
	        }
	      }
	      ngModel.$parsers.unshift(parseDate);
	
	      // Inner change
	      scope.dateSelection = function (dt) {
	        if (angular.isDefined(dt)) {
	          scope.date = dt;
	        }
	        ngModel.$setViewValue(scope.date);
	        ngModel.$render();
	
	        if (closeOnDateSelection) {
	          scope.isOpen = false;
	          element[0].focus();
	        }
	      };
	
	      element.bind('input change keyup', function () {
	        scope.$apply(function () {
	          scope.date = ngModel.$modelValue;
	        });
	      });
	
	      // Outter change
	      ngModel.$render = function () {
	        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
	        element.val(date);
	        scope.date = parseDate(ngModel.$modelValue);
	      };
	
	      var documentClickBind = function documentClickBind(event) {
	        if (scope.isOpen && event.target !== element[0]) {
	          scope.$apply(function () {
	            scope.isOpen = false;
	          });
	        }
	      };
	
	      var keydown = function keydown(evt, noApply) {
	        scope.keydown(evt);
	      };
	      element.bind('keydown', keydown);
	
	      scope.keydown = function (evt) {
	        if (evt.which === 27) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          scope.close();
	        } else if (evt.which === 40 && !scope.isOpen) {
	          scope.isOpen = true;
	        }
	      };
	
	      scope.$watch('isOpen', function (value) {
	        if (value) {
	          scope.$broadcast('datepicker.focus');
	          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	          scope.position.top = scope.position.top + element.prop('offsetHeight');
	
	          $document.bind('click', documentClickBind);
	        } else {
	          $document.unbind('click', documentClickBind);
	        }
	      });
	
	      scope.select = function (date) {
	        if (date === 'today') {
	          var today = new Date();
	          if (angular.isDate(ngModel.$modelValue)) {
	            date = new Date(ngModel.$modelValue);
	            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	          } else {
	            date = new Date(today.setHours(0, 0, 0, 0));
	          }
	        }
	        scope.dateSelection(date);
	      };
	
	      scope.close = function () {
	        scope.isOpen = false;
	        element[0].focus();
	      };
	
	      var $popup = $compile(popupEl)(scope);
	      // Prevent jQuery cache memory leak (template is now redundant after linking)
	      popupEl.remove();
	
	      if (appendToBody) {
	        $document.find('body').append($popup);
	      } else {
	        element.after($popup);
	      }
	
	      scope.$on('$destroy', function () {
	        $popup.remove();
	        element.unbind('keydown', keydown);
	        $document.unbind('click', documentClickBind);
	      });
	    }
	  };
	}]).directive('datepickerPopupWrap', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    templateUrl: 'template/datepicker/popup.html',
	    link: function link(scope, element, attrs) {
	      element.bind('click', function (event) {
	        event.preventDefault();
	        event.stopPropagation();
	      });
	    }
	  };
	});

/***/ },
/* 693 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.dropdown', []).constant('dropdownConfig', {
	  openClass: 'open'
	}).service('dropdownService', ['$document', function ($document) {
	  var openScope = null;
	
	  this.open = function (dropdownScope) {
	    if (!openScope) {
	      $document.bind('click', closeDropdown);
	      $document.bind('keydown', escapeKeyBind);
	    }
	
	    if (openScope && openScope !== dropdownScope) {
	      openScope.isOpen = false;
	    }
	
	    openScope = dropdownScope;
	  };
	
	  this.close = function (dropdownScope) {
	    if (openScope === dropdownScope) {
	      openScope = null;
	      $document.unbind('click', closeDropdown);
	      $document.unbind('keydown', escapeKeyBind);
	    }
	  };
	
	  var closeDropdown = function closeDropdown(evt) {
	    // This method may still be called during the same mouse event that
	    // unbound this event handler. So check openScope before proceeding.
	    if (!openScope) {
	      return;
	    }
	
	    var toggleElement = openScope.getToggleElement();
	    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	      return;
	    }
	
	    openScope.$apply(function () {
	      openScope.isOpen = false;
	    });
	  };
	
	  var escapeKeyBind = function escapeKeyBind(evt) {
	    if (evt.which === 27) {
	      openScope.focusToggleElement();
	      closeDropdown();
	    }
	  };
	}]).controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function ($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
	  var self = this,
	      scope = $scope.$new(),
	      // create a child scope so we are not polluting original one
	  openClass = dropdownConfig.openClass,
	      getIsOpen,
	      setIsOpen = angular.noop,
	      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;
	
	  this.init = function (element) {
	    self.$element = element;
	
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;
	
	      $scope.$watch(getIsOpen, function (value) {
	        scope.isOpen = !!value;
	      });
	    }
	  };
	
	  this.toggle = function (open) {
	    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	  };
	
	  // Allow other directives to watch status
	  this.isOpen = function () {
	    return scope.isOpen;
	  };
	
	  scope.getToggleElement = function () {
	    return self.toggleElement;
	  };
	
	  scope.focusToggleElement = function () {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };
	
	  scope.$watch('isOpen', function (isOpen, wasOpen) {
	    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);
	
	    if (isOpen) {
	      scope.focusToggleElement();
	      dropdownService.open(scope);
	    } else {
	      dropdownService.close(scope);
	    }
	
	    setIsOpen($scope, isOpen);
	    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	      toggleInvoker($scope, { open: !!isOpen });
	    }
	  });
	
	  $scope.$on('$locationChangeSuccess', function () {
	    scope.isOpen = false;
	  });
	
	  $scope.$on('$destroy', function () {
	    scope.$destroy();
	  });
	}]).directive('dropdown', function () {
	  return {
	    controller: 'DropdownController',
	    link: function link(scope, element, attrs, dropdownCtrl) {
	      dropdownCtrl.init(element);
	    }
	  };
	}).directive('dropdownToggle', function () {
	  return {
	    require: '?^dropdown',
	    link: function link(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }
	
	      dropdownCtrl.toggleElement = element;
	
	      var toggleDropdown = function toggleDropdown(event) {
	        event.preventDefault();
	
	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function () {
	            dropdownCtrl.toggle();
	          });
	        }
	      };
	
	      element.bind('click', toggleDropdown);
	
	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
	        element.attr('aria-expanded', !!isOpen);
	      });
	
	      scope.$on('$destroy', function () {
	        element.unbind('click', toggleDropdown);
	      });
	    }
	  };
	});

/***/ },
/* 694 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])
	
	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	.factory('$$stackedMap', function () {
	  return {
	    createNew: function createNew() {
	      var stack = [];
	
	      return {
	        add: function add(key, value) {
	          stack.push({
	            key: key,
	            value: value
	          });
	        },
	        get: function get(key) {
	          for (var i = 0; i < stack.length; i++) {
	            if (key == stack[i].key) {
	              return stack[i];
	            }
	          }
	        },
	        keys: function keys() {
	          var keys = [];
	          for (var i = 0; i < stack.length; i++) {
	            keys.push(stack[i].key);
	          }
	          return keys;
	        },
	        top: function top() {
	          return stack[stack.length - 1];
	        },
	        remove: function remove(key) {
	          var idx = -1;
	          for (var i = 0; i < stack.length; i++) {
	            if (key == stack[i].key) {
	              idx = i;
	              break;
	            }
	          }
	          return stack.splice(idx, 1)[0];
	        },
	        removeTop: function removeTop() {
	          return stack.splice(stack.length - 1, 1)[0];
	        },
	        length: function length() {
	          return stack.length;
	        }
	      };
	    }
	  };
	})
	
	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	.directive('modalBackdrop', ['$timeout', function ($timeout) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/modal/backdrop.html',
	    link: function link(scope, element, attrs) {
	      scope.backdropClass = attrs.backdropClass || '';
	
	      scope.animate = false;
	
	      //trigger CSS transitions
	      $timeout(function () {
	        scope.animate = true;
	      });
	    }
	  };
	}]).directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
	  return {
	    restrict: 'EA',
	    scope: {
	      index: '@',
	      animate: '='
	    },
	    replace: true,
	    transclude: true,
	    templateUrl: function templateUrl(tElement, tAttrs) {
	      return tAttrs.templateUrl || 'template/modal/window.html';
	    },
	    link: function link(scope, element, attrs) {
	      element.addClass(attrs.windowClass || '');
	      scope.size = attrs.size;
	
	      $timeout(function () {
	        // trigger CSS transitions
	        scope.animate = true;
	
	        /**
	         * Auto-focusing of a freshly-opened modal element causes any child elements
	         * with the autofocus attribute to lose focus. This is an issue on touch
	         * based devices which will show and then hide the onscreen keyboard.
	         * Attempts to refocus the autofocus element via JavaScript will not reopen
	         * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	         * the modal element if the modal does not contain an autofocus element.
	         */
	        if (!element[0].querySelectorAll('[autofocus]').length) {
	          element[0].focus();
	        }
	      });
	
	      scope.close = function (evt) {
	        var modal = $modalStack.getTop();
	        if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && evt.target === evt.currentTarget) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          $modalStack.dismiss(modal.key, 'backdrop click');
	        }
	      };
	    }
	  };
	}]).directive('modalTransclude', function () {
	  return {
	    link: function link($scope, $element, $attrs, controller, $transclude) {
	      $transclude($scope.$parent, function (clone) {
	        $element.empty();
	        $element.append(clone);
	      });
	    }
	  };
	}).factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap', function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
	
	  var OPENED_MODAL_CLASS = 'modal-open';
	
	  var backdropDomEl, backdropScope;
	  var openedWindows = $$stackedMap.createNew();
	  var $modalStack = {};
	
	  function backdropIndex() {
	    var topBackdropIndex = -1;
	    var opened = openedWindows.keys();
	    for (var i = 0; i < opened.length; i++) {
	      if (openedWindows.get(opened[i]).value.backdrop) {
	        topBackdropIndex = i;
	      }
	    }
	    return topBackdropIndex;
	  }
	
	  $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
	    if (backdropScope) {
	      backdropScope.index = newBackdropIndex;
	    }
	  });
	
	  function removeModalWindow(modalInstance) {
	
	    var body = $document.find('body').eq(0);
	    var modalWindow = openedWindows.get(modalInstance).value;
	
	    //clean up the stack
	    openedWindows.remove(modalInstance);
	
	    //remove window DOM element
	    removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function () {
	      modalWindow.modalScope.$destroy();
	      body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
	      checkRemoveBackdrop();
	    });
	  }
	
	  function checkRemoveBackdrop() {
	    //remove backdrop if no longer needed
	    if (backdropDomEl && backdropIndex() == -1) {
	      var backdropScopeRef = backdropScope;
	      removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
	        backdropScopeRef.$destroy();
	        backdropScopeRef = null;
	      });
	      backdropDomEl = undefined;
	      backdropScope = undefined;
	    }
	  }
	
	  function removeAfterAnimate(domEl, scope, emulateTime, done) {
	    // Closing animation
	    scope.animate = false;
	
	    var transitionEndEventName = $transition.transitionEndEventName;
	    if (transitionEndEventName) {
	      // transition out
	      var timeout = $timeout(afterAnimating, emulateTime);
	
	      domEl.bind(transitionEndEventName, function () {
	        $timeout.cancel(timeout);
	        afterAnimating();
	        scope.$apply();
	      });
	    } else {
	      // Ensure this call is async
	      $timeout(afterAnimating);
	    }
	
	    function afterAnimating() {
	      if (afterAnimating.done) {
	        return;
	      }
	      afterAnimating.done = true;
	
	      domEl.remove();
	      if (done) {
	        done();
	      }
	    }
	  }
	
	  $document.bind('keydown', function (evt) {
	    var modal;
	
	    if (evt.which === 27) {
	      modal = openedWindows.top();
	      if (modal && modal.value.keyboard) {
	        evt.preventDefault();
	        $rootScope.$apply(function () {
	          $modalStack.dismiss(modal.key, 'escape key press');
	        });
	      }
	    }
	  });
	
	  $modalStack.open = function (modalInstance, modal) {
	
	    openedWindows.add(modalInstance, {
	      deferred: modal.deferred,
	      modalScope: modal.scope,
	      backdrop: modal.backdrop,
	      keyboard: modal.keyboard
	    });
	
	    var body = $document.find('body').eq(0),
	        currBackdropIndex = backdropIndex();
	
	    if (currBackdropIndex >= 0 && !backdropDomEl) {
	      backdropScope = $rootScope.$new(true);
	      backdropScope.index = currBackdropIndex;
	      var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');
	      angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
	      backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
	      body.append(backdropDomEl);
	    }
	
	    var angularDomEl = angular.element('<div modal-window></div>');
	    angularDomEl.attr({
	      'template-url': modal.windowTemplateUrl,
	      'window-class': modal.windowClass,
	      'size': modal.size,
	      'index': openedWindows.length() - 1,
	      'animate': 'animate'
	    }).html(modal.content);
	
	    var modalDomEl = $compile(angularDomEl)(modal.scope);
	    openedWindows.top().value.modalDomEl = modalDomEl;
	    body.append(modalDomEl);
	    body.addClass(OPENED_MODAL_CLASS);
	  };
	
	  $modalStack.close = function (modalInstance, result) {
	    var modalWindow = openedWindows.get(modalInstance);
	    if (modalWindow) {
	      modalWindow.value.deferred.resolve(result);
	      removeModalWindow(modalInstance);
	    }
	  };
	
	  $modalStack.dismiss = function (modalInstance, reason) {
	    var modalWindow = openedWindows.get(modalInstance);
	    if (modalWindow) {
	      modalWindow.value.deferred.reject(reason);
	      removeModalWindow(modalInstance);
	    }
	  };
	
	  $modalStack.dismissAll = function (reason) {
	    var topModal = this.getTop();
	    while (topModal) {
	      this.dismiss(topModal.key, reason);
	      topModal = this.getTop();
	    }
	  };
	
	  $modalStack.getTop = function () {
	    return openedWindows.top();
	  };
	
	  return $modalStack;
	}]).provider('$modal', function () {
	
	  var $modalProvider = {
	    options: {
	      backdrop: true, //can be also false or 'static'
	      keyboard: true
	    },
	    $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack', function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
	
	      var $modal = {};
	
	      function getTemplatePromise(options) {
	        return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, { cache: $templateCache }).then(function (result) {
	          return result.data;
	        });
	      }
	
	      function getResolvePromises(resolves) {
	        var promisesArr = [];
	        angular.forEach(resolves, function (value) {
	          if (angular.isFunction(value) || angular.isArray(value)) {
	            promisesArr.push($q.when($injector.invoke(value)));
	          }
	        });
	        return promisesArr;
	      }
	
	      $modal.open = function (modalOptions) {
	
	        var modalResultDeferred = $q.defer();
	        var modalOpenedDeferred = $q.defer();
	
	        //prepare an instance of a modal to be injected into controllers and returned to a caller
	        var modalInstance = {
	          result: modalResultDeferred.promise,
	          opened: modalOpenedDeferred.promise,
	          close: function close(result) {
	            $modalStack.close(modalInstance, result);
	          },
	          dismiss: function dismiss(reason) {
	            $modalStack.dismiss(modalInstance, reason);
	          }
	        };
	
	        //merge and clean up options
	        modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	        modalOptions.resolve = modalOptions.resolve || {};
	
	        //verify options
	        if (!modalOptions.template && !modalOptions.templateUrl) {
	          throw new Error('One of template or templateUrl options is required.');
	        }
	
	        var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
	
	        templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
	
	          var modalScope = (modalOptions.scope || $rootScope).$new();
	          modalScope.$close = modalInstance.close;
	          modalScope.$dismiss = modalInstance.dismiss;
	
	          var ctrlInstance,
	              ctrlLocals = {};
	          var resolveIter = 1;
	
	          //controllers
	          if (modalOptions.controller) {
	            ctrlLocals.$scope = modalScope;
	            ctrlLocals.$modalInstance = modalInstance;
	            angular.forEach(modalOptions.resolve, function (value, key) {
	              ctrlLocals[key] = tplAndVars[resolveIter++];
	            });
	
	            ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
	            if (modalOptions.controllerAs) {
	              modalScope[modalOptions.controllerAs] = ctrlInstance;
	            }
	          }
	
	          $modalStack.open(modalInstance, {
	            scope: modalScope,
	            deferred: modalResultDeferred,
	            content: tplAndVars[0],
	            backdrop: modalOptions.backdrop,
	            keyboard: modalOptions.keyboard,
	            backdropClass: modalOptions.backdropClass,
	            windowClass: modalOptions.windowClass,
	            windowTemplateUrl: modalOptions.windowTemplateUrl,
	            size: modalOptions.size
	          });
	        }, function resolveError(reason) {
	          modalResultDeferred.reject(reason);
	        });
	
	        templateAndResolvePromise.then(function () {
	          modalOpenedDeferred.resolve(true);
	        }, function () {
	          modalOpenedDeferred.reject(false);
	        });
	
	        return modalInstance;
	      };
	
	      return $modal;
	    }]
	  };
	
	  return $modalProvider;
	});

/***/ },
/* 695 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.pagination', []).controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop },
	      // nullModelCtrl
	  setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	
	  this.init = function (ngModelCtrl_, config) {
	    ngModelCtrl = ngModelCtrl_;
	    this.config = config;
	
	    ngModelCtrl.$render = function () {
	      self.render();
	    };
	
	    if ($attrs.itemsPerPage) {
	      $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {
	        self.itemsPerPage = parseInt(value, 10);
	        $scope.totalPages = self.calculateTotalPages();
	      });
	    } else {
	      this.itemsPerPage = config.itemsPerPage;
	    }
	  };
	
	  this.calculateTotalPages = function () {
	    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
	    return Math.max(totalPages || 0, 1);
	  };
	
	  this.render = function () {
	    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
	  };
	
	  $scope.selectPage = function (page) {
	    if ($scope.page !== page && page > 0 && page <= $scope.totalPages) {
	      ngModelCtrl.$setViewValue(page);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.getText = function (key) {
	    return $scope[key + 'Text'] || self.config[key + 'Text'];
	  };
	  $scope.noPrevious = function () {
	    return $scope.page === 1;
	  };
	  $scope.noNext = function () {
	    return $scope.page === $scope.totalPages;
	  };
	
	  $scope.$watch('totalItems', function () {
	    $scope.totalPages = self.calculateTotalPages();
	  });
	
	  $scope.$watch('totalPages', function (value) {
	    setNumPages($scope.$parent, value); // Readonly variable
	
	    if ($scope.page > value) {
	      $scope.selectPage(value);
	    } else {
	      ngModelCtrl.$render();
	    }
	  });
	}]).constant('paginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true
	}).directive('pagination', ['$parse', 'paginationConfig', function ($parse, paginationConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@'
	    },
	    require: ['pagination', '?ngModel'],
	    controller: 'PaginationController',
	    templateUrl: 'template/pagination/pagination.html',
	    replace: true,
	    link: function link(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	        return; // do nothing if no ng-model
	      }
	
	      // Setup configuration parameters
	      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
	          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
	      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
	      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
	
	      paginationCtrl.init(ngModelCtrl, paginationConfig);
	
	      if (attrs.maxSize) {
	        scope.$parent.$watch($parse(attrs.maxSize), function (value) {
	          maxSize = parseInt(value, 10);
	          paginationCtrl.render();
	        });
	      }
	
	      // Create page object used in template
	      function makePage(number, text, isActive) {
	        return {
	          number: number,
	          text: text,
	          active: isActive
	        };
	      }
	
	      function getPages(currentPage, totalPages) {
	        var pages = [];
	
	        // Default page limits
	        var startPage = 1,
	            endPage = totalPages;
	        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
	
	        // recompute if maxSize
	        if (isMaxSized) {
	          if (rotate) {
	            // Current page is displayed in the middle of the visible ones
	            startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
	            endPage = startPage + maxSize - 1;
	
	            // Adjust if limit is exceeded
	            if (endPage > totalPages) {
	              endPage = totalPages;
	              startPage = endPage - maxSize + 1;
	            }
	          } else {
	            // Visible pages are paginated with maxSize
	            startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
	
	            // Adjust last page if limit is exceeded
	            endPage = Math.min(startPage + maxSize - 1, totalPages);
	          }
	        }
	
	        // Add page number links
	        for (var number = startPage; number <= endPage; number++) {
	          var page = makePage(number, number, number === currentPage);
	          pages.push(page);
	        }
	
	        // Add links to move between page sets
	        if (isMaxSized && !rotate) {
	          if (startPage > 1) {
	            var previousPageSet = makePage(startPage - 1, '...', false);
	            pages.unshift(previousPageSet);
	          }
	
	          if (endPage < totalPages) {
	            var nextPageSet = makePage(endPage + 1, '...', false);
	            pages.push(nextPageSet);
	          }
	        }
	
	        return pages;
	      }
	
	      var originalRender = paginationCtrl.render;
	      paginationCtrl.render = function () {
	        originalRender();
	        if (scope.page > 0 && scope.page <= scope.totalPages) {
	          scope.pages = getPages(scope.page, scope.totalPages);
	        }
	      };
	    }
	  };
	}]).constant('pagerConfig', {
	  itemsPerPage: 10,
	  previousText: ' Previous',
	  nextText: 'Next ',
	  align: true
	}).directive('pager', ['pagerConfig', function (pagerConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@'
	    },
	    require: ['pager', '?ngModel'],
	    controller: 'PaginationController',
	    templateUrl: 'template/pagination/pager.html',
	    replace: true,
	    link: function link(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	        return; // do nothing if no ng-model
	      }
	
	      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
	      paginationCtrl.init(ngModelCtrl, pagerConfig);
	    }
	  };
	}]);

/***/ },
/* 696 */
/***/ function(module, exports) {

	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html popovers, and selector delegatation.
	 */
	'use strict';
	
	angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('popoverPopup', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover.html'
	  };
	}).directive('popover', ['$tooltip', function ($tooltip) {
	  return $tooltip('popover', 'popover', 'click');
	}]);

/***/ },
/* 697 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.position', [])
	
	/**
	 * A set of utility methods that can be use to retrieve position of DOM elements.
	 * It is meant to be used where we need to absolute-position DOM elements in
	 * relation to other, existing elements (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	.factory('$position', ['$document', '$window', function ($document, $window) {
	
	  function getStyle(el, cssprop) {
	    if (el.currentStyle) {
	      //IE
	      return el.currentStyle[cssprop];
	    } else if ($window.getComputedStyle) {
	      return $window.getComputedStyle(el)[cssprop];
	    }
	    // finally try and get inline style
	    return el.style[cssprop];
	  }
	
	  /**
	   * Checks if a given element is statically positioned
	   * @param element - raw DOM element
	   */
	  function isStaticPositioned(element) {
	    return (getStyle(element, 'position') || 'static') === 'static';
	  }
	
	  /**
	   * returns the closest, non-statically positioned parentOffset of a given element
	   * @param element
	   */
	  var parentOffsetEl = function parentOffsetEl(element) {
	    var docDomEl = $document[0];
	    var offsetParent = element.offsetParent || docDomEl;
	    while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
	      offsetParent = offsetParent.offsetParent;
	    }
	    return offsetParent || docDomEl;
	  };
	
	  return {
	    /**
	     * Provides read-only equivalent of jQuery's position function:
	     * http://api.jquery.com/position/
	     */
	    position: function position(element) {
	      var elBCR = this.offset(element);
	      var offsetParentBCR = { top: 0, left: 0 };
	      var offsetParentEl = parentOffsetEl(element[0]);
	      if (offsetParentEl != $document[0]) {
	        offsetParentBCR = this.offset(angular.element(offsetParentEl));
	        offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
	        offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
	      }
	
	      var boundingClientRect = element[0].getBoundingClientRect();
	      return {
	        width: boundingClientRect.width || element.prop('offsetWidth'),
	        height: boundingClientRect.height || element.prop('offsetHeight'),
	        top: elBCR.top - offsetParentBCR.top,
	        left: elBCR.left - offsetParentBCR.left
	      };
	    },
	
	    /**
	     * Provides read-only equivalent of jQuery's offset function:
	     * http://api.jquery.com/offset/
	     */
	    offset: function offset(element) {
	      var boundingClientRect = element[0].getBoundingClientRect();
	      return {
	        width: boundingClientRect.width || element.prop('offsetWidth'),
	        height: boundingClientRect.height || element.prop('offsetHeight'),
	        top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	        left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	      };
	    },
	
	    /**
	     * Provides coordinates for the targetEl in relation to hostEl
	     */
	    positionElements: function positionElements(hostEl, targetEl, positionStr, appendToBody) {
	
	      var positionStrParts = positionStr.split('-');
	      var pos0 = positionStrParts[0],
	          pos1 = positionStrParts[1] || 'center';
	
	      var hostElPos, targetElWidth, targetElHeight, targetElPos;
	
	      hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
	
	      targetElWidth = targetEl.prop('offsetWidth');
	      targetElHeight = targetEl.prop('offsetHeight');
	
	      var shiftWidth = {
	        center: function center() {
	          return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
	        },
	        left: function left() {
	          return hostElPos.left;
	        },
	        right: function right() {
	          return hostElPos.left + hostElPos.width;
	        }
	      };
	
	      var shiftHeight = {
	        center: function center() {
	          return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
	        },
	        top: function top() {
	          return hostElPos.top;
	        },
	        bottom: function bottom() {
	          return hostElPos.top + hostElPos.height;
	        }
	      };
	
	      switch (pos0) {
	        case 'right':
	          targetElPos = {
	            top: shiftHeight[pos1](),
	            left: shiftWidth[pos0]()
	          };
	          break;
	        case 'left':
	          targetElPos = {
	            top: shiftHeight[pos1](),
	            left: hostElPos.left - targetElWidth
	          };
	          break;
	        case 'bottom':
	          targetElPos = {
	            top: shiftHeight[pos0](),
	            left: shiftWidth[pos1]()
	          };
	          break;
	        default:
	          targetElPos = {
	            top: hostElPos.top - targetElHeight,
	            left: shiftWidth[pos1]()
	          };
	          break;
	      }
	
	      return targetElPos;
	    }
	  };
	}]);

/***/ },
/* 698 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.progressbar', []).constant('progressConfig', {
	    animate: true,
	    max: 100
	}).controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function ($scope, $attrs, progressConfig) {
	    var self = this,
	        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
	
	    this.bars = [];
	    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;
	
	    this.addBar = function (bar, element) {
	        if (!animate) {
	            element.css({ 'transition': 'none' });
	        }
	
	        this.bars.push(bar);
	
	        bar.$watch('value', function (value) {
	            bar.percent = +(100 * value / $scope.max).toFixed(2);
	        });
	
	        bar.$on('$destroy', function () {
	            element = null;
	            self.removeBar(bar);
	        });
	    };
	
	    this.removeBar = function (bar) {
	        this.bars.splice(this.bars.indexOf(bar), 1);
	    };
	}]).directive('progress', function () {
	    return {
	        restrict: 'EA',
	        replace: true,
	        transclude: true,
	        controller: 'ProgressController',
	        require: 'progress',
	        scope: {},
	        templateUrl: 'template/progressbar/progress.html'
	    };
	}).directive('bar', function () {
	    return {
	        restrict: 'EA',
	        replace: true,
	        transclude: true,
	        require: '^progress',
	        scope: {
	            value: '=',
	            type: '@'
	        },
	        templateUrl: 'template/progressbar/bar.html',
	        link: function link(scope, element, attrs, progressCtrl) {
	            progressCtrl.addBar(scope, element);
	        }
	    };
	}).directive('progressbar', function () {
	    return {
	        restrict: 'EA',
	        replace: true,
	        transclude: true,
	        controller: 'ProgressController',
	        scope: {
	            value: '=',
	            type: '@'
	        },
	        templateUrl: 'template/progressbar/progressbar.html',
	        link: function link(scope, element, attrs, progressCtrl) {
	            progressCtrl.addBar(scope, angular.element(element.children()[0]));
	        }
	    };
	});

/***/ },
/* 699 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.rating', []).constant('ratingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null
	}).controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function ($scope, $attrs, ratingConfig) {
	  var ngModelCtrl = { $setViewValue: angular.noop };
	
	  this.init = function (ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	
	    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	    $scope.range = this.buildTemplateObjects(ratingStates);
	  };
	
	  this.buildTemplateObjects = function (states) {
	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);
	    }
	    return states;
	  };
	
	  $scope.rate = function (value) {
	    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	      ngModelCtrl.$setViewValue(value);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.enter = function (value) {
	    if (!$scope.readonly) {
	      $scope.value = value;
	    }
	    $scope.onHover({ value: value });
	  };
	
	  $scope.reset = function () {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.onLeave();
	  };
	
	  $scope.onKeydown = function (evt) {
	    if (/(37|38|39|40)/.test(evt.which)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	    }
	  };
	
	  this.render = function () {
	    $scope.value = ngModelCtrl.$viewValue;
	  };
	}]).directive('rating', function () {
	  return {
	    restrict: 'EA',
	    require: ['rating', 'ngModel'],
	    scope: {
	      readonly: '=?',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'RatingController',
	    templateUrl: 'template/rating/rating.html',
	    replace: true,
	    link: function link(scope, element, attrs, ctrls) {
	      var ratingCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        ratingCtrl.init(ngModelCtrl);
	      }
	    }
	  };
	});

/***/ },
/* 700 */
/***/ function(module, exports) {

	
	/**
	 * @ngdoc overview
	 * @name ui.bootstrap.tabs
	 *
	 * @description
	 * AngularJS version of the tabs directive.
	 */
	
	'use strict';
	
	angular.module('ui.bootstrap.tabs', []).controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
	  var ctrl = this,
	      tabs = ctrl.tabs = $scope.tabs = [];
	
	  ctrl.select = function (selectedTab) {
	    angular.forEach(tabs, function (tab) {
	      if (tab.active && tab !== selectedTab) {
	        tab.active = false;
	        tab.onDeselect();
	      }
	    });
	    selectedTab.active = true;
	    selectedTab.onSelect();
	  };
	
	  ctrl.addTab = function addTab(tab) {
	    tabs.push(tab);
	    // we can't run the select function on the first tab
	    // since that would select it twice
	    if (tabs.length === 1) {
	      tab.active = true;
	    } else if (tab.active) {
	      ctrl.select(tab);
	    }
	  };
	
	  ctrl.removeTab = function removeTab(tab) {
	    var index = tabs.indexOf(tab);
	    //Select a new tab if the tab to be removed is selected and not destroyed
	    if (tab.active && tabs.length > 1 && !destroyed) {
	      //If this is the last tab, select the previous tab. else, the next tab.
	      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
	      ctrl.select(tabs[newActiveIndex]);
	    }
	    tabs.splice(index, 1);
	  };
	
	  var destroyed;
	  $scope.$on('$destroy', function () {
	    destroyed = true;
	  });
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabset
	 * @restrict EA
	 *
	 * @description
	 * Tabset is the outer container for the tabs directive
	 *
	 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
	 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab heading="Tab 1"><b>First</b> Content!</tab>
	      <tab heading="Tab 2"><i>Second</i> Content!</tab>
	    </tabset>
	    <hr />
	    <tabset vertical="true">
	      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
	      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
	    </tabset>
	    <tabset justified="true">
	      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
	      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tabset', function () {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@'
	    },
	    controller: 'TabsetController',
	    templateUrl: 'template/tabs/tabset.html',
	    link: function link(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	    }
	  };
	})
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tab
	 * @restrict EA
	 *
	 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
	 * @param {string=} select An expression to evaluate when the tab is selected.
	 * @param {boolean=} active A binding, telling whether or not this tab is selected.
	 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
	 *
	 * @description
	 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <div ng-controller="TabsDemoCtrl">
	      <button class="btn btn-small" ng-click="items[0].active = true">
	        Select item 1, using active binding
	      </button>
	      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
	        Enable/disable item 2, using disabled binding
	      </button>
	      <br />
	      <tabset>
	        <tab heading="Tab 1">First Tab</tab>
	        <tab select="alertMe()">
	          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
	          Second Tab, with alert callback and html heading!
	        </tab>
	        <tab ng-repeat="item in items"
	          heading="{{item.title}}"
	          disabled="item.disabled"
	          active="item.active">
	          {{item.content}}
	        </tab>
	      </tabset>
	    </div>
	  </file>
	  <file name="script.js">
	    function TabsDemoCtrl($scope) {
	      $scope.items = [
	        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
	        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
	      ];
	
	      $scope.alertMe = function() {
	        setTimeout(function() {
	          alert("You've selected the alert tab!");
	        });
	      };
	    };
	  </file>
	</example>
	 */
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabHeading
	 * @restrict EA
	 *
	 * @description
	 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab>
	        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
	        And some content, too!
	      </tab>
	      <tab>
	        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
	        That's right.
	      </tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tab', ['$parse', function ($parse) {
	  return {
	    require: '^tabset',
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/tabs/tab.html',
	    transclude: true,
	    scope: {
	      active: '=?',
	      heading: '@',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	      //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function controller() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    compile: function compile(elm, attrs, transclude) {
	      return function postLink(scope, elm, attrs, tabsetCtrl) {
	        scope.$watch('active', function (active) {
	          if (active) {
	            tabsetCtrl.select(scope);
	          }
	        });
	
	        scope.disabled = false;
	        if (attrs.disabled) {
	          scope.$parent.$watch($parse(attrs.disabled), function (value) {
	            scope.disabled = !!value;
	          });
	        }
	
	        scope.select = function () {
	          if (!scope.disabled) {
	            scope.active = true;
	          }
	        };
	
	        tabsetCtrl.addTab(scope);
	        scope.$on('$destroy', function () {
	          tabsetCtrl.removeTab(scope);
	        });
	
	        //We need to transclude later, once the content container is ready.
	        //when this link happens, we're inside a tab heading.
	        scope.$transcludeFn = transclude;
	      };
	    }
	  };
	}]).directive('tabHeadingTransclude', [function () {
	  return {
	    restrict: 'A',
	    require: '^tab',
	    link: function link(scope, elm, attrs, tabCtrl) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	}]).directive('tabContentTransclude', function () {
	  return {
	    restrict: 'A',
	    require: '^tabset',
	    link: function link(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.tabContentTransclude);
	
	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function (contents) {
	        angular.forEach(contents, function (node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };
	  function isTabHeading(node) {
	    return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading');
	  }
	});

/***/ },
/* 701 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.timepicker', []).constant('timepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  showMeridian: true,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true
	}).controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function ($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
	  var selected = new Date(),
	      ngModelCtrl = { $setViewValue: angular.noop },
	      // nullModelCtrl
	  meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
	
	  this.init = function (ngModelCtrl_, inputs) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    var hoursInputEl = inputs.eq(0),
	        minutesInputEl = inputs.eq(1);
	
	    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
	    if (mousewheel) {
	      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
	    }
	
	    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	    this.setupInputEvents(hoursInputEl, minutesInputEl);
	  };
	
	  var hourStep = timepickerConfig.hourStep;
	  if ($attrs.hourStep) {
	    $scope.$parent.$watch($parse($attrs.hourStep), function (value) {
	      hourStep = parseInt(value, 10);
	    });
	  }
	
	  var minuteStep = timepickerConfig.minuteStep;
	  if ($attrs.minuteStep) {
	    $scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
	      minuteStep = parseInt(value, 10);
	    });
	  }
	
	  // 12H / 24H mode
	  $scope.showMeridian = timepickerConfig.showMeridian;
	  if ($attrs.showMeridian) {
	    $scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
	      $scope.showMeridian = !!value;
	
	      if (ngModelCtrl.$error.time) {
	        // Evaluate from template
	        var hours = getHoursFromTemplate(),
	            minutes = getMinutesFromTemplate();
	        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	          selected.setHours(hours);
	          refresh();
	        }
	      } else {
	        updateTemplate();
	      }
	    });
	  }
	
	  // Get $scope.hours in 24H mode if valid
	  function getHoursFromTemplate() {
	    var hours = parseInt($scope.hours, 10);
	    var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
	    if (!valid) {
	      return undefined;
	    }
	
	    if ($scope.showMeridian) {
	      if (hours === 12) {
	        hours = 0;
	      }
	      if ($scope.meridian === meridians[1]) {
	        hours = hours + 12;
	      }
	    }
	    return hours;
	  }
	
	  function getMinutesFromTemplate() {
	    var minutes = parseInt($scope.minutes, 10);
	    return minutes >= 0 && minutes < 60 ? minutes : undefined;
	  }
	
	  function pad(value) {
	    return angular.isDefined(value) && value.toString().length < 2 ? '0' + value : value;
	  }
	
	  // Respond on mousewheel spin
	  this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl) {
	    var isScrollingUp = function isScrollingUp(e) {
	      if (e.originalEvent) {
	        e = e.originalEvent;
	      }
	      //pick correct delta variable depending on event
	      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
	      return e.detail || delta > 0;
	    };
	
	    hoursInputEl.bind('mousewheel wheel', function (e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	      e.preventDefault();
	    });
	
	    minutesInputEl.bind('mousewheel wheel', function (e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	      e.preventDefault();
	    });
	  };
	
	  this.setupInputEvents = function (hoursInputEl, minutesInputEl) {
	    if ($scope.readonlyInput) {
	      $scope.updateHours = angular.noop;
	      $scope.updateMinutes = angular.noop;
	      return;
	    }
	
	    var invalidate = function invalidate(invalidHours, invalidMinutes) {
	      ngModelCtrl.$setViewValue(null);
	      ngModelCtrl.$setValidity('time', false);
	      if (angular.isDefined(invalidHours)) {
	        $scope.invalidHours = invalidHours;
	      }
	      if (angular.isDefined(invalidMinutes)) {
	        $scope.invalidMinutes = invalidMinutes;
	      }
	    };
	
	    $scope.updateHours = function () {
	      var hours = getHoursFromTemplate();
	
	      if (angular.isDefined(hours)) {
	        selected.setHours(hours);
	        refresh('h');
	      } else {
	        invalidate(true);
	      }
	    };
	
	    hoursInputEl.bind('blur', function (e) {
	      if (!$scope.invalidHours && $scope.hours < 10) {
	        $scope.$apply(function () {
	          $scope.hours = pad($scope.hours);
	        });
	      }
	    });
	
	    $scope.updateMinutes = function () {
	      var minutes = getMinutesFromTemplate();
	
	      if (angular.isDefined(minutes)) {
	        selected.setMinutes(minutes);
	        refresh('m');
	      } else {
	        invalidate(undefined, true);
	      }
	    };
	
	    minutesInputEl.bind('blur', function (e) {
	      if (!$scope.invalidMinutes && $scope.minutes < 10) {
	        $scope.$apply(function () {
	          $scope.minutes = pad($scope.minutes);
	        });
	      }
	    });
	  };
	
	  this.render = function () {
	    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
	
	    if (isNaN(date)) {
	      ngModelCtrl.$setValidity('time', false);
	      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	    } else {
	      if (date) {
	        selected = date;
	      }
	      makeValid();
	      updateTemplate();
	    }
	  };
	
	  // Call internally when we know that model is valid.
	  function refresh(keyboardChange) {
	    makeValid();
	    ngModelCtrl.$setViewValue(new Date(selected));
	    updateTemplate(keyboardChange);
	  }
	
	  function makeValid() {
	    ngModelCtrl.$setValidity('time', true);
	    $scope.invalidHours = false;
	    $scope.invalidMinutes = false;
	  }
	
	  function updateTemplate(keyboardChange) {
	    var hours = selected.getHours(),
	        minutes = selected.getMinutes();
	
	    if ($scope.showMeridian) {
	      hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
	    }
	
	    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
	    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
	    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	  }
	
	  function addMinutes(minutes) {
	    var dt = new Date(selected.getTime() + minutes * 60000);
	    selected.setHours(dt.getHours(), dt.getMinutes());
	    refresh();
	  }
	
	  $scope.incrementHours = function () {
	    addMinutes(hourStep * 60);
	  };
	  $scope.decrementHours = function () {
	    addMinutes(-hourStep * 60);
	  };
	  $scope.incrementMinutes = function () {
	    addMinutes(minuteStep);
	  };
	  $scope.decrementMinutes = function () {
	    addMinutes(-minuteStep);
	  };
	  $scope.toggleMeridian = function () {
	    addMinutes(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
	  };
	}]).directive('timepicker', function () {
	  return {
	    restrict: 'EA',
	    require: ['timepicker', '?^ngModel'],
	    controller: 'TimepickerController',
	    replace: true,
	    scope: {},
	    templateUrl: 'template/timepicker/timepicker.html',
	    link: function link(scope, element, attrs, ctrls) {
	      var timepickerCtrl = ctrls[0],
	          ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	});

/***/ },
/* 702 */
/***/ function(module, exports) {

	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	'use strict';
	
	angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])
	
	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider('$tooltip', function () {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    animation: true,
	    popupDelay: 0
	  };
	
	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'focus': 'blur'
	  };
	
	  // The options specified to the provider globally.
	  var globalOptions = {};
	
	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
	  this.options = function (value) {
	    angular.extend(globalOptions, value);
	  };
	
	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
	   */
	  this.setTriggers = function setTriggers(triggers) {
	    angular.extend(triggerMap, triggers);
	  };
	
	  /**
	   * This is a helper function for translating camel-case to snake-case.
	   */
	  function snake_case(name) {
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function (letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }
	
	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = ['$window', '$compile', '$timeout', '$document', '$position', '$interpolate', function ($window, $compile, $timeout, $document, $position, $interpolate) {
	    return function $tooltip(type, prefix, defaultTriggerShow) {
	      var options = angular.extend({}, defaultOptions, globalOptions);
	
	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers(trigger) {
	        var show = trigger || options.trigger || defaultTriggerShow;
	        var hide = triggerMap[show] || show;
	        return {
	          show: show,
	          hide: hide
	        };
	      }
	
	      var directiveName = snake_case(type);
	
	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template = '<div ' + directiveName + '-popup ' + 'title="' + startSym + 'title' + endSym + '" ' + 'content="' + startSym + 'content' + endSym + '" ' + 'placement="' + startSym + 'placement' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen"' + '>' + '</div>';
	
	      return {
	        restrict: 'EA',
	        compile: function compile(tElem, tAttrs) {
	          var tooltipLinker = $compile(template);
	
	          return function link(scope, element, attrs) {
	            var tooltip;
	            var tooltipLinkedScope;
	            var transitionTimeout;
	            var popupTimeout;
	            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
	            var triggers = getTriggers(undefined);
	            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
	            var ttScope = scope.$new(true);
	
	            var positionTooltip = function positionTooltip() {
	
	              var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
	              ttPosition.top += 'px';
	              ttPosition.left += 'px';
	
	              // Now set the calculated positioning.
	              tooltip.css(ttPosition);
	            };
	
	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            ttScope.isOpen = false;
	
	            function toggleTooltipBind() {
	              if (!ttScope.isOpen) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }
	
	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
	                return;
	              }
	
	              prepareTooltip();
	
	              if (ttScope.popupDelay) {
	                // Do nothing if the tooltip was already scheduled to pop-up.
	                // This happens if show is triggered multiple times before any hide is triggered.
	                if (!popupTimeout) {
	                  popupTimeout = $timeout(show, ttScope.popupDelay, false);
	                  popupTimeout.then(function (reposition) {
	                    reposition();
	                  });
	                }
	              } else {
	                show()();
	              }
	            }
	
	            function hideTooltipBind() {
	              scope.$apply(function () {
	                hide();
	              });
	            }
	
	            // Show the tooltip popup element.
	            function show() {
	
	              popupTimeout = null;
	
	              // If there is a pending remove transition, we must cancel it, lest the
	              // tooltip be mysteriously removed.
	              if (transitionTimeout) {
	                $timeout.cancel(transitionTimeout);
	                transitionTimeout = null;
	              }
	
	              // Don't show empty tooltips.
	              if (!ttScope.content) {
	                return angular.noop;
	              }
	
	              createTooltip();
	
	              // Set the initial positioning.
	              tooltip.css({ top: 0, left: 0, display: 'block' });
	              ttScope.$digest();
	
	              positionTooltip();
	
	              // And show the tooltip.
	              ttScope.isOpen = true;
	              ttScope.$digest(); // digest required as $apply is not called
	
	              // Return positioning function as promise callback for correct
	              // positioning after draw.
	              return positionTooltip;
	            }
	
	            // Hide the tooltip popup element.
	            function hide() {
	              // First things first: we don't show it anymore.
	              ttScope.isOpen = false;
	
	              //if tooltip is going to be shown after delay, we must cancel this
	              $timeout.cancel(popupTimeout);
	              popupTimeout = null;
	
	              // And now we remove it from the DOM. However, if we have animation, we
	              // need to wait for it to expire beforehand.
	              // FIXME: this is a placeholder for a port of the transitions library.
	              if (ttScope.animation) {
	                if (!transitionTimeout) {
	                  transitionTimeout = $timeout(removeTooltip, 500);
	                }
	              } else {
	                removeTooltip();
	              }
	            }
	
	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                removeTooltip();
	              }
	              tooltipLinkedScope = ttScope.$new();
	              tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
	                if (appendToBody) {
	                  $document.find('body').append(tooltip);
	                } else {
	                  element.after(tooltip);
	                }
	              });
	            }
	
	            function removeTooltip() {
	              transitionTimeout = null;
	              if (tooltip) {
	                tooltip.remove();
	                tooltip = null;
	              }
	              if (tooltipLinkedScope) {
	                tooltipLinkedScope.$destroy();
	                tooltipLinkedScope = null;
	              }
	            }
	
	            function prepareTooltip() {
	              prepPlacement();
	              prepPopupDelay();
	            }
	
	            /**
	             * Observe the relevant attributes.
	             */
	            attrs.$observe(type, function (val) {
	              ttScope.content = val;
	
	              if (!val && ttScope.isOpen) {
	                hide();
	              }
	            });
	
	            attrs.$observe(prefix + 'Title', function (val) {
	              ttScope.title = val;
	            });
	
	            function prepPlacement() {
	              var val = attrs[prefix + 'Placement'];
	              ttScope.placement = angular.isDefined(val) ? val : options.placement;
	            }
	
	            function prepPopupDelay() {
	              var val = attrs[prefix + 'PopupDelay'];
	              var delay = parseInt(val, 10);
	              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
	            }
	
	            var unregisterTriggers = function unregisterTriggers() {
	              element.unbind(triggers.show, showTooltipBind);
	              element.unbind(triggers.hide, hideTooltipBind);
	            };
	
	            function prepTriggers() {
	              var val = attrs[prefix + 'Trigger'];
	              unregisterTriggers();
	
	              triggers = getTriggers(val);
	
	              if (triggers.show === triggers.hide) {
	                element.bind(triggers.show, toggleTooltipBind);
	              } else {
	                element.bind(triggers.show, showTooltipBind);
	                element.bind(triggers.hide, hideTooltipBind);
	              }
	            }
	            prepTriggers();
	
	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
	
	            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
	            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
	
	            // if a tooltip is attached to <body> we need to remove it on
	            // location change as its parent scope will probably not be destroyed
	            // by the change.
	            if (appendToBody) {
	              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
	                if (ttScope.isOpen) {
	                  hide();
	                }
	              });
	            }
	
	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              $timeout.cancel(transitionTimeout);
	              $timeout.cancel(popupTimeout);
	              unregisterTriggers();
	              removeTooltip();
	              ttScope = null;
	            });
	          };
	        }
	      };
	    };
	  }];
	}).directive('tooltipPopup', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-popup.html'
	  };
	}).directive('tooltip', ['$tooltip', function ($tooltip) {
	  return $tooltip('tooltip', 'tooltip', 'mouseenter');
	}]).directive('tooltipHtmlUnsafePopup', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
	  };
	}).directive('tooltipHtmlUnsafe', ['$tooltip', function ($tooltip) {
	  return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
	}]);

/***/ },
/* 703 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.transition', [])
	
	/**
	 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
	 * @param  {DOMElement} element  The DOMElement that will be animated.
	 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
	 *   - As a string, it represents the css class to be added to the element.
	 *   - As an object, it represents a hash of style attributes to be applied to the element.
	 *   - As a function, it represents a function to be called that will cause the transition to occur.
	 * @return {Promise}  A promise that is resolved when the transition finishes.
	 */
	.factory('$transition', ['$q', '$timeout', '$rootScope', function ($q, $timeout, $rootScope) {
	
	  var $transition = function $transition(element, trigger, options) {
	    options = options || {};
	    var deferred = $q.defer();
	    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];
	
	    var transitionEndHandler = function transitionEndHandler(event) {
	      $rootScope.$apply(function () {
	        element.unbind(endEventName, transitionEndHandler);
	        deferred.resolve(element);
	      });
	    };
	
	    if (endEventName) {
	      element.bind(endEventName, transitionEndHandler);
	    }
	
	    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
	    $timeout(function () {
	      if (angular.isString(trigger)) {
	        element.addClass(trigger);
	      } else if (angular.isFunction(trigger)) {
	        trigger(element);
	      } else if (angular.isObject(trigger)) {
	        element.css(trigger);
	      }
	      //If browser does not support transitions, instantly resolve
	      if (!endEventName) {
	        deferred.resolve(element);
	      }
	    });
	
	    // Add our custom cancel function to the promise that is returned
	    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
	    // i.e. it will therefore never raise a transitionEnd event for that transition
	    deferred.promise.cancel = function () {
	      if (endEventName) {
	        element.unbind(endEventName, transitionEndHandler);
	      }
	      deferred.reject('Transition cancelled');
	    };
	
	    return deferred.promise;
	  };
	
	  // Work out the name of the transitionEnd event
	  var transElement = document.createElement('trans');
	  var transitionEndEventNames = {
	    'WebkitTransition': 'webkitTransitionEnd',
	    'MozTransition': 'transitionend',
	    'OTransition': 'oTransitionEnd',
	    'transition': 'transitionend'
	  };
	  var animationEndEventNames = {
	    'WebkitTransition': 'webkitAnimationEnd',
	    'MozTransition': 'animationend',
	    'OTransition': 'oAnimationEnd',
	    'transition': 'animationend'
	  };
	  function findEndEventName(endEventNames) {
	    for (var name in endEventNames) {
	      if (transElement.style[name] !== undefined) {
	        return endEventNames[name];
	      }
	    }
	  }
	  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
	  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
	  return $transition;
	}]);

/***/ },
/* 704 */
/***/ function(module, exports) {

	'use strict';
	
	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])
	
	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	.factory('typeaheadParser', ['$parse', function ($parse) {
	
	  //                      00000111000000000000022200000000000000003333333333333330000000000044000
	  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	
	  return {
	    parse: function parse(input) {
	
	      var match = input.match(TYPEAHEAD_REGEXP);
	      if (!match) {
	        throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
	      }
	
	      return {
	        itemName: match[3],
	        source: $parse(match[4]),
	        viewMapper: $parse(match[2] || match[1]),
	        modelMapper: $parse(match[1])
	      };
	    }
	  };
	}]).directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser', function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
	
	  var HOT_KEYS = [9, 13, 27, 38, 40];
	
	  return {
	    require: 'ngModel',
	    link: function link(originalScope, element, attrs, modelCtrl) {
	
	      //SUPPORTED ATTRIBUTES (OPTIONS)
	
	      //minimal no of characters that needs to be entered before typeahead kicks-in
	      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;
	
	      //minimal wait time after last character typed before typehead kicks-in
	      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
	
	      //should it restrict model values to the ones selected from the popup only?
	      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	
	      //binding to a variable that indicates if matches are being retrieved asynchronously
	      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
	
	      //a callback executed when a match is selected
	      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
	
	      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
	
	      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
	
	      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
	
	      //INTERNAL VARIABLES
	
	      //model setter executed upon match selection
	      var $setModelValue = $parse(attrs.ngModel).assign;
	
	      //expressions used by typeahead
	      var parserResult = typeaheadParser.parse(attrs.typeahead);
	
	      var hasFocus;
	
	      //create a child scope for the typeahead directive so we are not polluting original scope
	      //with typeahead-specific data (matches, query etc.)
	      var scope = originalScope.$new();
	      originalScope.$on('$destroy', function () {
	        scope.$destroy();
	      });
	
	      // WAI-ARIA
	      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	      element.attr({
	        'aria-autocomplete': 'list',
	        'aria-expanded': false,
	        'aria-owns': popupId
	      });
	
	      //pop-up element used to display matches
	      var popUpEl = angular.element('<div typeahead-popup></div>');
	      popUpEl.attr({
	        id: popupId,
	        matches: 'matches',
	        active: 'activeIdx',
	        select: 'select(activeIdx)',
	        query: 'query',
	        position: 'position'
	      });
	      //custom item template
	      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	      }
	
	      var resetMatches = function resetMatches() {
	        scope.matches = [];
	        scope.activeIdx = -1;
	        element.attr('aria-expanded', false);
	      };
	
	      var getMatchId = function getMatchId(index) {
	        return popupId + '-option-' + index;
	      };
	
	      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	      // This attribute is added or removed automatically when the `activeIdx` changes.
	      scope.$watch('activeIdx', function (index) {
	        if (index < 0) {
	          element.removeAttr('aria-activedescendant');
	        } else {
	          element.attr('aria-activedescendant', getMatchId(index));
	        }
	      });
	
	      var getMatchesAsync = function getMatchesAsync(inputValue) {
	
	        var locals = { $viewValue: inputValue };
	        isLoadingSetter(originalScope, true);
	        $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
	
	          //it might happen that several async queries were in progress if a user were typing fast
	          //but we are interested only in responses that correspond to the current view value
	          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
	          if (onCurrentRequest && hasFocus) {
	            if (matches.length > 0) {
	
	              scope.activeIdx = focusFirst ? 0 : -1;
	              scope.matches.length = 0;
	
	              //transform labels
	              for (var i = 0; i < matches.length; i++) {
	                locals[parserResult.itemName] = matches[i];
	                scope.matches.push({
	                  id: getMatchId(i),
	                  label: parserResult.viewMapper(scope, locals),
	                  model: matches[i]
	                });
	              }
	
	              scope.query = inputValue;
	              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	              //due to other elements being rendered
	              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	              scope.position.top = scope.position.top + element.prop('offsetHeight');
	
	              element.attr('aria-expanded', true);
	            } else {
	              resetMatches();
	            }
	          }
	          if (onCurrentRequest) {
	            isLoadingSetter(originalScope, false);
	          }
	        }, function () {
	          resetMatches();
	          isLoadingSetter(originalScope, false);
	        });
	      };
	
	      resetMatches();
	
	      //we need to propagate user's query so we can higlight matches
	      scope.query = undefined;
	
	      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	      var timeoutPromise;
	
	      var scheduleSearchWithTimeout = function scheduleSearchWithTimeout(inputValue) {
	        timeoutPromise = $timeout(function () {
	          getMatchesAsync(inputValue);
	        }, waitTime);
	      };
	
	      var cancelPreviousTimeout = function cancelPreviousTimeout() {
	        if (timeoutPromise) {
	          $timeout.cancel(timeoutPromise);
	        }
	      };
	
	      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	      modelCtrl.$parsers.unshift(function (inputValue) {
	
	        hasFocus = true;
	
	        if (inputValue && inputValue.length >= minSearch) {
	          if (waitTime > 0) {
	            cancelPreviousTimeout();
	            scheduleSearchWithTimeout(inputValue);
	          } else {
	            getMatchesAsync(inputValue);
	          }
	        } else {
	          isLoadingSetter(originalScope, false);
	          cancelPreviousTimeout();
	          resetMatches();
	        }
	
	        if (isEditable) {
	          return inputValue;
	        } else {
	          if (!inputValue) {
	            // Reset in case user had typed something previously.
	            modelCtrl.$setValidity('editable', true);
	            return inputValue;
	          } else {
	            modelCtrl.$setValidity('editable', false);
	            return undefined;
	          }
	        }
	      });
	
	      modelCtrl.$formatters.push(function (modelValue) {
	
	        var candidateViewValue, emptyViewValue;
	        var locals = {};
	
	        if (inputFormatter) {
	
	          locals.$model = modelValue;
	          return inputFormatter(originalScope, locals);
	        } else {
	
	          //it might happen that we don't have enough info to properly render input value
	          //we need to check for this situation and simply return model value if we can't apply custom formatting
	          locals[parserResult.itemName] = modelValue;
	          candidateViewValue = parserResult.viewMapper(originalScope, locals);
	          locals[parserResult.itemName] = undefined;
	          emptyViewValue = parserResult.viewMapper(originalScope, locals);
	
	          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
	        }
	      });
	
	      scope.select = function (activeIdx) {
	        //called from within the $digest() cycle
	        var locals = {};
	        var model, item;
	
	        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	        model = parserResult.modelMapper(originalScope, locals);
	        $setModelValue(originalScope, model);
	        modelCtrl.$setValidity('editable', true);
	
	        onSelectCallback(originalScope, {
	          $item: item,
	          $model: model,
	          $label: parserResult.viewMapper(originalScope, locals)
	        });
	
	        resetMatches();
	
	        //return focus to the input element if a match was selected via a mouse click event
	        // use timeout to avoid $rootScope:inprog error
	        $timeout(function () {
	          element[0].focus();
	        }, 0, false);
	      };
	
	      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	      element.bind('keydown', function (evt) {
	
	        //typeahead is open and an "interesting" key was pressed
	        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	          return;
	        }
	
	        // if there's nothing selected (i.e. focusFirst) and enter is hit, don't do anything
	        if (scope.activeIdx == -1 && (evt.which === 13 || evt.which === 9)) {
	          return;
	        }
	
	        evt.preventDefault();
	
	        if (evt.which === 40) {
	          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	          scope.$digest();
	        } else if (evt.which === 38) {
	          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	          scope.$digest();
	        } else if (evt.which === 13 || evt.which === 9) {
	          scope.$apply(function () {
	            scope.select(scope.activeIdx);
	          });
	        } else if (evt.which === 27) {
	          evt.stopPropagation();
	
	          resetMatches();
	          scope.$digest();
	        }
	      });
	
	      element.bind('blur', function (evt) {
	        hasFocus = false;
	      });
	
	      // Keep reference to click handler to unbind it.
	      var dismissClickHandler = function dismissClickHandler(evt) {
	        if (element[0] !== evt.target) {
	          resetMatches();
	          scope.$digest();
	        }
	      };
	
	      $document.bind('click', dismissClickHandler);
	
	      originalScope.$on('$destroy', function () {
	        $document.unbind('click', dismissClickHandler);
	        if (appendToBody) {
	          $popup.remove();
	        }
	      });
	
	      var $popup = $compile(popUpEl)(scope);
	      if (appendToBody) {
	        $document.find('body').append($popup);
	      } else {
	        element.after($popup);
	      }
	    }
	  };
	}]).directive('typeaheadPopup', function () {
	  return {
	    restrict: 'EA',
	    scope: {
	      matches: '=',
	      query: '=',
	      active: '=',
	      position: '=',
	      select: '&'
	    },
	    replace: true,
	    templateUrl: 'template/typeahead/typeahead-popup.html',
	    link: function link(scope, element, attrs) {
	
	      scope.templateUrl = attrs.templateUrl;
	
	      scope.isOpen = function () {
	        return scope.matches.length > 0;
	      };
	
	      scope.isActive = function (matchIdx) {
	        return scope.active == matchIdx;
	      };
	
	      scope.selectActive = function (matchIdx) {
	        scope.active = matchIdx;
	      };
	
	      scope.selectMatch = function (activeIdx) {
	        scope.select({ activeIdx: activeIdx });
	      };
	    }
	  };
	}).directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
	  return {
	    restrict: 'EA',
	    scope: {
	      index: '=',
	      match: '=',
	      query: '='
	    },
	    link: function link(scope, element, attrs) {
	      var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
	      $http.get(tplUrl, { cache: $templateCache }).success(function (tplContent) {
	        element.replaceWith($compile(tplContent.trim())(scope));
	      });
	    }
	  };
	}]).filter('typeaheadHighlight', function () {
	
	  function escapeRegexp(queryToEscape) {
	    return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	  }
	
	  return function (matchItem, query) {
	    return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
	  };
	});

/***/ },
/* 705 */
/***/ function(module, exports) {

	module.exports = "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissable' : null]\" role=\"alert\">\n    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close()\">\n        <span aria-hidden=\"true\">&times;</span>\n        <span class=\"sr-only\">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n"

/***/ },
/* 706 */
/***/ function(module, exports) {

	module.exports = "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n</div>"

/***/ },
/* 707 */
/***/ function(module, exports) {

	module.exports = "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n  <thead>\n    <tr>\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n      <th colspan=\"{{5 + showWeeks}}\"><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-show=\"showWeeks\" class=\"text-center\"></th>\n      <th ng-repeat=\"label in labels track by $index\" class=\"text-center\"><small aria-label=\"{{label.full}}\">{{label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td ng-show=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-muted': dt.secondary, 'text-info': dt.current}\">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ },
/* 708 */
/***/ function(module, exports) {

	module.exports = "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n  <thead>\n    <tr>\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n      <th><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-info': dt.current}\">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ },
/* 709 */
/***/ function(module, exports) {

	module.exports = "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\">\n\t<li ng-transclude></li>\n\t<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n\t\t<span class=\"btn-group pull-left\">\n\t\t\t<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\">{{ getText('current') }}</button>\n\t\t\t<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n\t\t</span>\n\t\t<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n\t</li>\n</ul>\n"

/***/ },
/* 710 */
/***/ function(module, exports) {

	module.exports = "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n  <thead>\n    <tr>\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n      <th colspan=\"3\"><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-info': dt.current}\">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ },
/* 711 */
/***/ function(module, exports) {

	module.exports = "<div class=\"modal-backdrop fade {{ backdropClass }}\"\n     ng-class=\"{in: animate}\"\n     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n></div>\n"

/***/ },
/* 712 */
/***/ function(module, exports) {

	module.exports = "<div tabindex=\"-1\" role=\"dialog\" class=\"modal fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n    <div class=\"modal-dialog\" ng-class=\"{'modal-sm': size == 'sm', 'modal-lg': size == 'lg'}\"><div class=\"modal-content\" modal-transclude></div></div>\n</div>"

/***/ },
/* 713 */
/***/ function(module, exports) {

	module.exports = "<ul class=\"pager\">\n  <li ng-class=\"{disabled: noPrevious(), previous: align}\"><a href ng-click=\"selectPage(page - 1)\">{{getText('previous')}}</a></li>\n  <li ng-class=\"{disabled: noNext(), next: align}\"><a href ng-click=\"selectPage(page + 1)\">{{getText('next')}}</a></li>\n</ul>"

/***/ },
/* 714 */
/***/ function(module, exports) {

	module.exports = "<ul class=\"pagination\">\n  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(1)\">{{getText('first')}}</a></li>\n  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(page - 1)\">{{getText('previous')}}</a></li>\n  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active}\"><a href ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(page + 1)\">{{getText('next')}}</a></li>\n  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(totalPages)\">{{getText('last')}}</a></li>\n</ul>"

/***/ },
/* 715 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n  <div class=\"tooltip-arrow\"></div>\n  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n</div>\n"

/***/ },
/* 716 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n  <div class=\"tooltip-arrow\"></div>\n  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n</div>\n"

/***/ },
/* 717 */
/***/ function(module, exports) {

	module.exports = "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n  <div class=\"arrow\"></div>\n\n  <div class=\"popover-inner\">\n      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n      <div class=\"popover-content\" ng-bind=\"content\"></div>\n  </div>\n</div>\n"

/***/ },
/* 718 */
/***/ function(module, exports) {

	module.exports = "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: percent + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>"

/***/ },
/* 719 */
/***/ function(module, exports) {

	module.exports = "<div class=\"progress\" ng-transclude></div>"

/***/ },
/* 720 */
/***/ function(module, exports) {

	module.exports = "<div class=\"progress\">\n  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: percent + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n</div>"

/***/ },
/* 721 */
/***/ function(module, exports) {

	module.exports = "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n    <i ng-repeat=\"r in range track by $index\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\">\n        <span class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n    </i>\n</span>"

/***/ },
/* 722 */
/***/ function(module, exports) {

	module.exports = "<li ng-class=\"{active: active, disabled: disabled}\">\n  <a href ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n</li>\n"

/***/ },
/* 723 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n  <div class=\"tab-content\">\n    <div class=\"tab-pane\" \n         ng-repeat=\"tab in tabs\" \n         ng-class=\"{active: tab.active}\"\n         tab-content-transclude=\"tab\">\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 724 */
/***/ function(module, exports) {

	module.exports = "<table>\n\t<tbody>\n\t\t<tr class=\"text-center\">\n\t\t\t<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n\t\t\t<td ng-show=\"showMeridian\"></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n\t\t\t\t<input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n\t\t\t</td>\n\t\t\t<td>:</td>\n\t\t\t<td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n\t\t\t\t<input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n\t\t\t</td>\n\t\t\t<td ng-show=\"showMeridian\"><button type=\"button\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n\t\t</tr>\n\t\t<tr class=\"text-center\">\n\t\t\t<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n\t\t\t<td ng-show=\"showMeridian\"></td>\n\t\t</tr>\n\t</tbody>\n</table>\n"

/***/ },
/* 725 */
/***/ function(module, exports) {

	module.exports = "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>"

/***/ },
/* 726 */
/***/ function(module, exports) {

	module.exports = "<ul class=\"dropdown-menu\" ng-show=\"isOpen()\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{match.id}}\">\n        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n    </li>\n</ul>\n"

/***/ },
/* 727 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(728);
	
	__webpack_require__(729);
	
	__webpack_require__(730);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var typeahead = _uiModules2['default'].get('kibana/typeahead');
	
	typeahead.directive('kbnTypeahead', function () {
	  var keyMap = {
	    ESC: 27,
	    UP: 38,
	    DOWN: 40,
	    TAB: 9,
	    ENTER: 13
	  };
	
	  return {
	    restrict: 'A',
	    scope: {
	      historyKey: '@kbnTypeahead'
	    },
	    controllerAs: 'typeahead',
	
	    controller: function controller($scope, $element, $timeout, PersistedLog, config) {
	      var self = this;
	      self.form = $element.closest('form');
	      self.query = '';
	      self.hidden = true;
	      self.focused = false;
	      self.mousedOver = false;
	
	      // instantiate history and add items to the scope
	      self.history = new PersistedLog('typeahead:' + $scope.historyKey, {
	        maxLength: config.get('history:limit'),
	        filterDuplicates: true
	      });
	
	      $scope.items = self.history.get();
	      $scope.filteredItems = [];
	
	      self.setInputModel = function (model) {
	        $scope.inputModel = model;
	
	        // watch for changes to the query parameter, delegate to typeaheadCtrl
	        $scope.$watch('inputModel.$viewValue', self.filterItemsByQuery);
	      };
	
	      self.setHidden = function (hidden) {
	        self.hidden = !!hidden;
	      };
	
	      self.setFocused = function (focused) {
	        self.focused = !!focused;
	      };
	
	      self.setMouseover = function (mousedOver) {
	        self.mousedOver = !!mousedOver;
	      };
	
	      // activation methods
	      self.activateItem = function (item) {
	        self.active = item;
	      };
	
	      self.getActiveIndex = function () {
	        if (!self.active) {
	          return;
	        }
	
	        return $scope.filteredItems.indexOf(self.active);
	      };
	
	      self.getItems = function () {
	        return $scope.filteredItems;
	      };
	
	      self.activateNext = function () {
	        var index = self.getActiveIndex();
	        if (index == null) {
	          index = 0;
	        } else if (index < $scope.filteredItems.length - 1) {
	          ++index;
	        }
	
	        self.activateItem($scope.filteredItems[index]);
	      };
	
	      self.activatePrev = function () {
	        var index = self.getActiveIndex();
	
	        if (index > 0 && index != null) {
	          --index;
	        } else if (index === 0) {
	          self.active = false;
	          return;
	        }
	
	        self.activateItem($scope.filteredItems[index]);
	      };
	
	      self.isActive = function (item) {
	        return item === self.active;
	      };
	
	      // selection methods
	      self.selectItem = function (item, ev) {
	        self.hidden = true;
	        self.active = false;
	        $scope.inputModel.$setViewValue(item);
	        $scope.inputModel.$render();
	        self.persistEntry();
	
	        if (ev && ev.type === 'click') {
	          $timeout(function () {
	            self.submitForm();
	          });
	        }
	      };
	
	      self.submitForm = function () {
	        if (self.form.length) {
	          self.form.submit();
	        }
	      };
	
	      self.persistEntry = function () {
	        if ($scope.inputModel.$viewValue.length) {
	          // push selection into the history
	          $scope.items = self.history.add($scope.inputModel.$viewValue);
	        }
	      };
	
	      self.selectActive = function () {
	        if (self.active) {
	          self.selectItem(self.active);
	        }
	      };
	
	      self.keypressHandler = function (ev) {
	        var keyCode = ev.which || ev.keyCode;
	
	        if (self.focused) {
	          self.hidden = false;
	        }
	
	        // hide on escape
	        if (_lodash2['default'].contains([keyMap.ESC], keyCode)) {
	          self.hidden = true;
	          self.active = false;
	        }
	
	        // change selection with arrow up/down
	        // on down key, attempt to load all items if none are loaded
	        if (_lodash2['default'].contains([keyMap.DOWN], keyCode) && $scope.filteredItems.length === 0) {
	          $scope.filteredItems = $scope.items;
	          $scope.$digest();
	        } else if (_lodash2['default'].contains([keyMap.UP, keyMap.DOWN], keyCode)) {
	          if (self.isVisible() && $scope.filteredItems.length) {
	            ev.preventDefault();
	
	            if (keyCode === keyMap.DOWN) {
	              self.activateNext();
	            } else {
	              self.activatePrev();
	            }
	          }
	        }
	
	        // persist selection on enter, when not selecting from the list
	        if (_lodash2['default'].contains([keyMap.ENTER], keyCode)) {
	          if (!self.active) {
	            self.persistEntry();
	          }
	        }
	
	        // select on enter or tab
	        if (_lodash2['default'].contains([keyMap.ENTER, keyMap.TAB], keyCode)) {
	          self.selectActive();
	          self.hidden = true;
	        }
	      };
	
	      self.filterItemsByQuery = function (query) {
	        // cache query so we can call it again if needed
	        if (query) {
	          self.query = query;
	        }
	
	        // if the query is empty, clear the list items
	        if (!self.query.length) {
	          $scope.filteredItems = [];
	          return;
	        }
	
	        // update the filteredItems using the query
	        var beginningMatches = $scope.items.filter(function (item) {
	          return item.indexOf(query) === 0;
	        });
	
	        var otherMatches = $scope.items.filter(function (item) {
	          return item.indexOf(query) > 0;
	        });
	
	        $scope.filteredItems = beginningMatches.concat(otherMatches);
	      };
	
	      self.isVisible = function () {
	        return !self.hidden && $scope.filteredItems.length > 0 && (self.focused || self.mousedOver);
	      };
	
	      // handle updates to parent scope history
	      $scope.$watch('items', function (items) {
	        if (self.query) {
	          self.filterItemsByQuery(self.query);
	        }
	      });
	
	      // watch for changes to the filtered item list
	      $scope.$watch('filteredItems', function (filteredItems) {
	
	        // if list is empty, or active item is missing, unset active item
	        if (!filteredItems.length || !_lodash2['default'].contains(filteredItems, self.active)) {
	          self.active = false;
	        }
	      });
	    },
	
	    link: function link($scope, $el, attr) {
	      // should be defined via setInput() method
	      if (!$scope.inputModel) {
	        throw new Error('kbn-typeahead-input must be defined');
	      }
	
	      $scope.$watch('typeahead.isVisible()', function (vis) {
	        $el.toggleClass('visible', vis);
	      });
	    }
	  };
	});

/***/ },
/* 728 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 729 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(368);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var typeahead = _uiModules2['default'].get('kibana/typeahead');
	
	typeahead.directive('kbnTypeaheadInput', function ($rootScope) {
	
	  return {
	    restrict: 'A',
	    require: ['^ngModel', '^kbnTypeahead'],
	
	    link: function link($scope, $el, $attr, deps) {
	      var model = deps[0];
	      var typeaheadCtrl = deps[1];
	
	      typeaheadCtrl.setInputModel(model);
	
	      // disable browser autocomplete
	      $el.attr('autocomplete', 'off');
	
	      // handle keypresses
	      $el.on('keydown', function (ev) {
	        typeaheadCtrl.keypressHandler(ev);
	        digest();
	      });
	
	      // update focus state based on the input focus state
	      $el.on('focus', function () {
	        typeaheadCtrl.setFocused(true);
	        digest();
	      });
	
	      $el.on('blur', function () {
	        typeaheadCtrl.setFocused(false);
	        digest();
	      });
	
	      // unbind event listeners
	      $scope.$on('$destroy', function () {
	        $el.off();
	      });
	
	      function digest() {
	        $rootScope.$$phase || $scope.$digest();
	      }
	    }
	  };
	});

/***/ },
/* 730 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiTypeaheadPartialsTypeaheadItemsHtml = __webpack_require__(731);
	
	var _uiTypeaheadPartialsTypeaheadItemsHtml2 = _interopRequireDefault(_uiTypeaheadPartialsTypeaheadItemsHtml);
	
	__webpack_require__(368);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var typeahead = _uiModules2['default'].get('kibana/typeahead');
	
	typeahead.directive('kbnTypeaheadItems', function () {
	  return {
	    restrict: 'E',
	    require: '^kbnTypeahead',
	    replace: true,
	    template: _uiTypeaheadPartialsTypeaheadItemsHtml2['default'],
	
	    link: function link($scope, $el, attr, typeaheadCtrl) {
	      $scope.typeahead = typeaheadCtrl;
	    }
	  };
	});

/***/ },
/* 731 */
/***/ function(module, exports) {

	module.exports = "<div\n  ng-show=\"typeahead.isVisible()\"\n  ng-mouseenter=\"typeahead.setMouseover(true);\"\n  ng-mouseleave=\"typeahead.setMouseover(false);\"\n  class=\"typeahead-items\"\n  >\n\n  <div\n    ng-repeat=\"item in typeahead.getItems()\"\n    ng-class=\"{active: item === typeahead.active}\"\n    ng-click=\"typeahead.selectItem(item, $event);\"\n    ng-mouseenter=\"typeahead.activateItem(item);\"\n    class=\"typeahead-item\"\n    >\n    {{item}}\n  </div>\n</div>\n"

/***/ },
/* 732 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiUtilsParse_interval = __webpack_require__(733);
	
	var _uiUtilsParse_interval2 = _interopRequireDefault(_uiUtilsParse_interval);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('validateDateInterval', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link($scope, $el, attrs, ngModelCntrl) {
	
	      ngModelCntrl.$parsers.push(check);
	      ngModelCntrl.$formatters.push(check);
	
	      function check(value) {
	        ngModelCntrl.$setValidity('dateInterval', (0, _uiUtilsParse_interval2['default'])(value) != null);
	        return value;
	      }
	    }
	  };
	});

/***/ },
/* 733 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = parseInterval;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _elasticDatemath = __webpack_require__(237);
	
	var _elasticDatemath2 = _interopRequireDefault(_elasticDatemath);
	
	// Assume interval is in the form (value)(unit), such as "1h"
	var INTERVAL_STRING_RE = new RegExp('^([0-9\\.]*)\\s*(' + _elasticDatemath2['default'].units.join('|') + ')$');
	
	function parseInterval(interval) {
	  var matches = String(interval).trim().match(INTERVAL_STRING_RE);
	
	  if (!matches) return null;
	
	  try {
	    var _ret = (function () {
	      var value = parseFloat(matches[1]) || 1;
	      var unit = matches[2];
	
	      var duration = _moment2['default'].duration(value, unit);
	
	      // There is an error with moment, where if you have a fractional interval between 0 and 1, then when you add that
	      // interval to an existing moment object, it will remain unchanged, which causes problems in the ordered_x_keys
	      // code. To counteract this, we find the first unit that doesn't result in a value between 0 and 1.
	      // For example, if you have '0.5d', then when calculating the x-axis series, we take the start date and begin
	      // adding 0.5 days until we hit the end date. However, since there is a bug in moment, when you add 0.5 days to
	      // the start date, you get the same exact date (instead of being ahead by 12 hours). So instead of returning
	      // a duration corresponding to 0.5 hours, we return a duration corresponding to 12 hours.
	      var selectedUnit = _lodash2['default'].find(_elasticDatemath2['default'].units, function (unit) {
	        return Math.abs(duration.as(unit)) >= 1;
	      });
	
	      return {
	        v: _moment2['default'].duration(duration.as(selectedUnit), selectedUnit)
	      };
	    })();
	
	    if (typeof _ret === 'object') return _ret.v;
	  } catch (e) {
	    return null;
	  }
	}
	
	module.exports = exports['default'];

/***/ },
/* 734 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _saved_object_save_as_checkboxHtml = __webpack_require__(735);
	
	var _saved_object_save_as_checkboxHtml2 = _interopRequireDefault(_saved_object_save_as_checkboxHtml);
	
	_uiModules2['default'].get('kibana').directive('savedObjectSaveAsCheckBox', function () {
	  return {
	    restrict: 'E',
	    template: _saved_object_save_as_checkboxHtml2['default'],
	    scope: {
	      savedObject: '='
	    }
	  };
	});

/***/ },
/* 735 */
/***/ function(module, exports) {

	module.exports = "<div ng-hide=\"!savedObject.id || savedObject.isSaving\">\n  <div ng-hide=\"!savedObject.isTitleChanged() || savedObject.copyOnSave\" class=\"kuiLocalDropdownWarning\">\n    In previous versions of Kibana, changing the name of a {{savedObject.getDisplayName()}} would make a copy with the new name. Use the 'Save as a new {{savedObject.getDisplayName()}}' checkbox to do this now.\n  </div>\n  <label>\n    <input type=\"checkbox\" ng-model=\"savedObject.copyOnSave\" ng-checked=\"savedObject.copyOnSave\">\n    Save as a new {{savedObject.getDisplayName()}}\n  </label>\n</div>\n"

/***/ },
/* 736 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var context = __webpack_require__(737);
	context.keys().forEach(function (key) {
	  return context(key);
	});

/***/ },
/* 737 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./auto_select_if_only_one.js": 738,
		"./click_focus.js": 739,
		"./confirm_click.js": 740,
		"./css_truncate.js": 741,
		"./field_name.js": 742,
		"./file_upload.js": 743,
		"./inequality.js": 675,
		"./infinite_scroll.js": 744,
		"./info.js": 745,
		"./input_datetime.js": 674,
		"./input_focus.js": 467,
		"./input_number.js": 747,
		"./json_input.js": 591,
		"./kbn_href.js": 394,
		"./kbn_src.js": 393,
		"./paginate.js": 748,
		"./paginated_selectable_list.js": 750,
		"./pretty_duration.js": 752,
		"./render_counter.js": 753,
		"./rows.js": 754,
		"./saved_object_finder.js": 759,
		"./truncated.js": 375,
		"./validate_cidr_mask.js": 764,
		"./validate_date_math.js": 767,
		"./validate_index_name.js": 768,
		"./validate_ip.js": 769,
		"./validate_json.js": 770,
		"./validate_lowercase.js": 771
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 737;


/***/ },
/* 738 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('autoSelectIfOnlyOne', function ($parse) {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link(scope, element, attributes, ngModelCtrl) {
	      attributes.$observe('autoSelectIfOnlyOne', function (result) {
	        var options = $parse(result)(scope);
	        if (options && options.length === 1) {
	          ngModelCtrl.$setViewValue(options[0]);
	          ngModelCtrl.$render();
	        }
	      });
	    }
	  };
	});

/***/ },
/* 739 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('clickFocus', function () {
	  return {
	    scope: {
	      clickFocus: '='
	    },
	    restrict: 'A',
	    link: function link($scope, $elem) {
	      function handler() {
	        var focusElem = _jquery2['default'].find('input[name=' + $scope.clickFocus + ']');
	        if (focusElem[0]) focusElem[0].focus();
	      }
	
	      $elem.bind('click', handler);
	      $scope.$on('$destroy', _lodash2['default'].bindKey($elem, 'unbind', 'click', handler));
	    }
	  };
	});

/***/ },
/* 740 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('confirmClick', function ($window) {
	  return {
	    restrict: 'A',
	    link: function link($scope, $elem, attrs) {
	      $elem.bind('click', function () {
	        var message = attrs.confirmation || 'Are you sure?';
	        if ($window.confirm(message)) {
	          // eslint-disable-line no-alert
	          var action = attrs.confirmClick;
	          if (action) {
	            $scope.$apply($scope.$eval(action));
	          }
	        }
	      });
	
	      $scope.$on('$destroy', function () {
	        $elem.unbind('click');
	      });
	    }
	  };
	});

/***/ },
/* 741 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('cssTruncate', function ($timeout) {
	  return {
	    restrict: 'A',
	    scope: {},
	    link: function link($scope, $elem, attrs) {
	
	      $elem.css({
	        overflow: 'hidden',
	        'white-space': 'nowrap',
	        'text-overflow': 'ellipsis',
	        'word-break': 'break-all'
	      });
	
	      if (attrs.cssTruncateExpandable != null) {
	        $scope.$watch(function () {
	          return $elem.html();
	        }, function () {
	          if ($elem[0].offsetWidth < $elem[0].scrollWidth) {
	            $elem.css({ 'cursor': 'pointer' });
	            $elem.bind('click', function () {
	              $scope.toggle();
	            });
	          }
	        });
	      }
	
	      $scope.toggle = function () {
	        if ($elem.css('white-space') !== 'normal') {
	          $elem.css({ 'white-space': 'normal' });
	        } else {
	          $elem.css({ 'white-space': 'nowrap' });
	        }
	      };
	
	      $scope.$on('$destroy', function () {
	        $elem.unbind('click');
	        $elem.unbind('mouseenter');
	      });
	    }
	  };
	});

/***/ },
/* 742 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	__webpack_require__(482);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('fieldName', function ($compile, $rootScope, $filter) {
	  return {
	    restrict: 'AE',
	    scope: {
	      'field': '=',
	      'fieldName': '=',
	      'fieldType': '='
	    },
	    link: function link($scope, $el) {
	
	      var typeIcon = function typeIcon(fieldType) {
	        switch (fieldType) {
	          case 'source':
	            return '<i title="source" class="fa fa-file-text-o "></i>';
	          case 'string':
	            return '<i title="string"><strong>t</strong></i>';
	          case 'murmur3':
	            return '<i title="murmur3"><strong>h</strong></i>';
	          case 'number':
	            return '<i title="number"><strong>#</strong></i>';
	          case 'date':
	            return '<i title="date" class="fa fa-clock-o"></i>';
	          case 'ip':
	            return '<i title="ip" class="fa fa-laptop"></i>';
	          case 'geo_point':
	            return '<i title="geo_point" class="fa fa-globe"></i>';
	          case 'boolean':
	            return '<i title="boolean" class="fa fa-adjust"></i>';
	          case 'conflict':
	            return '<i title="conflict" class="fa fa-warning"></i>';
	          default:
	            return '<i title="unknown"><strong>?</strong></i>';
	        }
	      };
	
	      $rootScope.$watchMulti.call($scope, ['field', 'fieldName', 'fieldType', 'field.rowCount'], function () {
	
	        var type = $scope.field ? $scope.field.type : $scope.fieldType;
	        var name = $scope.field ? $scope.field.name : $scope.fieldName;
	        var results = $scope.field ? !$scope.field.rowCount && !$scope.field.scripted : false;
	        var scripted = $scope.field ? $scope.field.scripted : false;
	
	        var displayName = $filter('shortDots')(name);
	
	        $el.attr('title', name).toggleClass('no-results', results).toggleClass('scripted', scripted).prepend(typeIcon(type)).append((0, _jquery2['default'])('<span>').text(displayName).addClass('discover-field-name'));
	      });
	    }
	  };
	});

/***/ },
/* 743 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	var html = '<span class="dropzone" ng-transclude></span>';
	
	_module.directive('fileUpload', function () {
	  return {
	    restrict: 'E',
	    transclude: true,
	    scope: {
	      onRead: '&',
	      onLocate: '&',
	      uploadSelector: '@'
	    },
	    template: html,
	    link: function link($scope, $elem, attrs) {
	      var $button = $elem.find($scope.uploadSelector);
	      var $dropzone = $elem.find('.dropzone');
	
	      var handleFile = function handleFile(file) {
	        if (_lodash2['default'].isUndefined(file)) return;
	
	        if (_lodash2['default'].has(attrs, 'onRead')) {
	          var reader = new FileReader();
	          reader.onload = function (e) {
	            $scope.$apply(function () {
	              $scope.onRead({ fileContents: e.target.result });
	            });
	          };
	          reader.readAsText(file);
	        }
	
	        if (_lodash2['default'].has(attrs, 'onLocate')) {
	          $scope.$apply(function () {
	            $scope.onLocate({ file: file });
	          });
	        }
	      };
	
	      $dropzone.on('dragover', function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	      });
	
	      $dropzone.on('dragenter', function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	      });
	
	      $dropzone.on('drop', function (e) {
	        e.stopPropagation();
	        e.preventDefault();
	        var file = _lodash2['default'].get(e, 'originalEvent.dataTransfer.files[0]');
	
	        if (file) {
	          handleFile(file);
	        }
	      });
	
	      if ($button) {
	        (function () {
	          var $fileInput = (0, _jquery2['default'])('<input type="file" style="opacity: 0; position:absolute; right: -999999999px" id="testfile" />');
	          $elem.append($fileInput);
	
	          $fileInput.on('change', function (e) {
	            var target = e.srcElement || e.target;
	            if (_lodash2['default'].get(target, 'files.length')) {
	              handleFile(target.files[0]);
	            }
	          });
	
	          $button.on('click', function (e) {
	            $fileInput.val(null);
	            $fileInput.trigger('click');
	          });
	        })();
	      }
	    }
	  };
	});

/***/ },
/* 744 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('kbnInfiniteScroll', function () {
	  return {
	    restrict: 'E',
	    scope: {
	      more: '='
	    },
	    link: function link($scope, $element, attrs) {
	      var $window = (0, _jquery2['default'])(window);
	      var checkTimer = undefined;
	
	      function onScroll() {
	        if (!$scope.more) return;
	
	        var winHeight = $window.height();
	        var winBottom = winHeight + $window.scrollTop();
	        var elTop = $element.offset().top;
	        var remaining = elTop - winBottom;
	
	        if (remaining <= winHeight * 0.50) {
	          $scope[$scope.$$phase ? '$eval' : '$apply'](function () {
	            var more = $scope.more();
	          });
	        }
	      }
	
	      function scheduleCheck() {
	        if (checkTimer) return;
	        checkTimer = setTimeout(function () {
	          checkTimer = null;
	          onScroll();
	        }, 50);
	      }
	
	      $window.on('scroll', scheduleCheck);
	      $scope.$on('$destroy', function () {
	        clearTimeout(checkTimer);
	        $window.off('scroll', scheduleCheck);
	      });
	      scheduleCheck();
	    }
	  };
	});

/***/ },
/* 745 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiPartialsInfoHtml = __webpack_require__(746);
	
	var _uiPartialsInfoHtml2 = _interopRequireDefault(_uiPartialsInfoHtml);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('kbnInfo', function () {
	  return {
	    restrict: 'E',
	    scope: {
	      info: '@',
	      placement: '@'
	    },
	    template: _uiPartialsInfoHtml2['default'],
	    link: function link($scope) {
	      $scope.placement = $scope.placement || 'top';
	    }
	  };
	});

/***/ },
/* 746 */
/***/ function(module, exports) {

	module.exports = "<i aria-label=\"{{info}}\" class=\"fa fa-info-circle\"\n    tooltip=\"{{info}}\"\n    tooltip-placement=\"{{placement}}\"\n    tooltip-popup-delay=\"250\"></i>"

/***/ },
/* 747 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('inputNumber', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link($scope, $elem, attrs, ngModel) {
	      ngModel.$parsers.push(checkNumber);
	      ngModel.$formatters.push(checkNumber);
	
	      function checkNumber(value) {
	        ngModel.$setValidity('number', !isNaN(parseFloat(value)));
	        return value;
	      }
	    }
	  };
	});

/***/ },
/* 748 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiPartialsPaginate_controlsHtml = __webpack_require__(749);
	
	var _uiPartialsPaginate_controlsHtml2 = _interopRequireDefault(_uiPartialsPaginate_controlsHtml);
	
	var PER_PAGE_DEFAULT = 10;
	
	_uiModules2['default'].get('kibana').directive('paginate', function ($parse, $compile) {
	  return {
	    restrict: 'E',
	    scope: true,
	    link: {
	      pre: function pre($scope, $el, attrs) {
	        if (_lodash2['default'].isUndefined(attrs.bottomControls)) attrs.bottomControls = true;
	        if ($el.find('paginate-controls.paginate-bottom').size() === 0 && attrs.bottomControls) {
	          $el.append($compile('<paginate-controls class="paginate-bottom">')($scope));
	        }
	      },
	      post: function post($scope, $el, attrs) {
	        if (_lodash2['default'].isUndefined(attrs.topControls)) attrs.topControls = false;
	        if ($el.find('paginate-controls.paginate-top').size() === 0 && attrs.topControls) {
	          $el.prepend($compile('<paginate-controls class="paginate-top">')($scope));
	        }
	
	        var paginate = $scope.paginate;
	
	        // add some getters to the controller powered by attributes
	        paginate.getList = $parse(attrs.list);
	        paginate.perPageProp = attrs.perPageProp;
	
	        if (attrs.perPage) {
	          paginate.perPage = attrs.perPage;
	          $scope.showSelector = false;
	        } else {
	          $scope.showSelector = true;
	        }
	
	        paginate.otherWidthGetter = $parse(attrs.otherWidth);
	
	        paginate.init();
	      }
	    },
	    controllerAs: 'paginate',
	    controller: function controller($scope, $document) {
	      var self = this;
	      var ALL = 0;
	
	      self.sizeOptions = [{ title: '10', value: 10 }, { title: '25', value: 25 }, { title: '100', value: 100 }, { title: 'All', value: ALL }];
	
	      // setup the watchers, called in the post-link function
	      self.init = function () {
	
	        self.perPage = _lodash2['default'].parseInt(self.perPage) || $scope[self.perPageProp];
	
	        $scope.$watchMulti(['paginate.perPage', self.perPageProp, self.otherWidthGetter], function (vals, oldVals) {
	          var intChanges = vals[0] !== oldVals[0];
	          var extChanges = vals[1] !== oldVals[1];
	
	          if (intChanges) {
	            if (!setPerPage(self.perPage)) {
	              // if we are not able to set the external value,
	              // render now, otherwise wait for the external value
	              // to trigger the watcher again
	              self.renderList();
	            }
	            return;
	          }
	
	          self.perPage = _lodash2['default'].parseInt(self.perPage) || $scope[self.perPageProp];
	          if (self.perPage == null) {
	            self.perPage = ALL;
	            return;
	          }
	
	          self.renderList();
	        });
	
	        $scope.$watch('page', self.changePage);
	        $scope.$watchCollection(self.getList, function (list) {
	          $scope.list = list;
	          self.renderList();
	        });
	      };
	
	      self.goToPage = function (number) {
	        if (number) {
	          if (number.hasOwnProperty('number')) number = number.number;
	          $scope.page = $scope.pages[number - 1] || $scope.pages[0];
	        }
	      };
	
	      self.goToTop = function goToTop() {
	        $document.scrollTop(0);
	      };
	
	      self.renderList = function () {
	        $scope.pages = [];
	        if (!$scope.list) return;
	
	        var perPage = _lodash2['default'].parseInt(self.perPage);
	        var count = perPage ? Math.ceil($scope.list.length / perPage) : 1;
	
	        _lodash2['default'].times(count, function (i) {
	          var page = undefined;
	
	          if (perPage) {
	            var start = perPage * i;
	            page = $scope.list.slice(start, start + perPage);
	          } else {
	            page = $scope.list.slice(0);
	          }
	
	          page.number = i + 1;
	          page.i = i;
	
	          page.count = count;
	          page.first = page.number === 1;
	          page.last = page.number === count;
	
	          page.prev = $scope.pages[i - 1];
	          if (page.prev) page.prev.next = page;
	
	          $scope.pages.push(page);
	        });
	
	        // set the new page, or restore the previous page number
	        if ($scope.page && $scope.page.i < $scope.pages.length) {
	          $scope.page = $scope.pages[$scope.page.i];
	        } else {
	          $scope.page = $scope.pages[0];
	        }
	      };
	
	      self.changePage = function (page) {
	        if (!page) {
	          $scope.otherPages = null;
	          return;
	        }
	
	        // setup the list of the other pages to link to
	        $scope.otherPages = [];
	        var width = +self.otherWidthGetter($scope) || 5;
	        var left = page.i - Math.round((width - 1) / 2);
	        var right = left + width - 1;
	
	        // shift neg count from left to right
	        if (left < 0) {
	          right += 0 - left;
	          left = 0;
	        }
	
	        // shift extra right nums to left
	        var lastI = page.count - 1;
	        if (right > lastI) {
	          right = lastI;
	          left = right - width + 1;
	        }
	
	        for (var i = left; i <= right; i++) {
	          var other = $scope.pages[i];
	
	          if (!other) continue;
	
	          $scope.otherPages.push(other);
	          if (other.last) $scope.otherPages.containsLast = true;
	          if (other.first) $scope.otherPages.containsFirst = true;
	        }
	      };
	
	      function setPerPage(val) {
	        var $ppParent = $scope;
	
	        while ($ppParent && !_lodash2['default'].has($ppParent, self.perPageProp)) {
	          $ppParent = $ppParent.$parent;
	        }
	
	        if ($ppParent) {
	          $ppParent[self.perPageProp] = val;
	          return true;
	        }
	      }
	    }
	  };
	}).directive('paginateControls', function () {
	  // this directive is automatically added by paginate if not found within it's $el
	  return {
	    restrict: 'E',
	    template: _uiPartialsPaginate_controlsHtml2['default']
	  };
	});

/***/ },
/* 749 */
/***/ function(module, exports) {

	module.exports = "<a\n  class=\"kuiLink\"\n  ng-if=\"linkToTop\"\n  ng-click=\"paginate.goToTop()\"\n  data-test-subj=\"paginateControlsLinkToTop\"\n>\n  Scroll to top\n</a>\n\n<div class=\"pagination-other-pages\">\n  <ul class=\"pagination-other-pages-list pagination-sm\" ng-if=\"page.count > 1\">\n    <li ng-style=\"{'visibility':'hidden'}\" ng-if=\"page.first\">\n      <a ng-click=\"paginate.goToPage(page.prev)\"></a>\n    </li>\n    <li ng-style=\"{'visibility':'visible'}\" ng-if=\"!page.first\">\n      <a ng-click=\"paginate.goToPage(page.prev)\"></a>\n    </li>\n\n    <li ng-if=\"!otherPages.containsFirst\">\n      <a ng-click=\"paginate.goToPage(1)\">1...</a>\n    </li>\n\n    <li\n      ng-repeat=\"other in otherPages\"\n      ng-class=\"{ active: other.number === page.number }\">\n      <a ng-click=\"paginate.goToPage(other)\">{{other.number}}</a>\n    </li>\n\n    <li ng-if=\"!otherPages.containsLast\">\n      <a ng-click=\"paginate.goToPage(page.count)\">...{{page.count}}</a>\n    </li>\n\n    <li ng-style=\"{'visibility':'hidden'}\" ng-if=\"page.last\">\n      <a ng-click=\"paginate.goToPage(page.next)\"></a>\n    </li>\n    <li ng-style=\"{'visibility':'visible'}\" ng-if=\"!page.last\">\n      <a ng-click=\"paginate.goToPage(page.next)\"></a>\n    </li>\n  </ul>\n</div>\n\n<form class=\"form-inline pagination-size\" ng-if=\"showSelector\">\n  <div class=\"form-group\">\n    <label>Page Size</label>\n    <select ng-model=\"paginate.perPage\" ng-options=\"opt.value as opt.title for opt in paginate.sizeOptions\">\n    </select>\n  </div>\n</form>\n"

/***/ },
/* 750 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiPartialsPaginated_selectable_listHtml = __webpack_require__(751);
	
	var _uiPartialsPaginated_selectable_listHtml2 = _interopRequireDefault(_uiPartialsPaginated_selectable_listHtml);
	
	var _module = _uiModules2['default'].get('kibana');
	
	function throwError(message) {
	  throw new Error(message);
	}
	
	_module.directive('paginatedSelectableList', function (kbnUrl) {
	
	  return {
	    restrict: 'E',
	    scope: {
	      perPage: '=?',
	      list: '=',
	      listProperty: '=',
	      userMakeUrl: '=?',
	      userOnSelect: '=?'
	    },
	    template: _uiPartialsPaginated_selectable_listHtml2['default'],
	    controller: function controller($scope, $element, $filter) {
	      // Should specify either user-make-url or user-on-select
	      if (!$scope.userMakeUrl && !$scope.userOnSelect) {
	        throwError('paginatedSelectableList directive expects a makeUrl or onSelect function');
	      }
	
	      // Should specify either user-make-url or user-on-select, but not both.
	      if ($scope.userMakeUrl && $scope.userOnSelect) {
	        throwError('paginatedSelectableList directive expects a makeUrl or onSelect attribute but not both');
	      }
	
	      $scope.perPage = $scope.perPage || 10;
	      $scope.hits = $scope.list = _lodash2['default'].sortBy($scope.list, accessor);
	      $scope.hitCount = $scope.hits.length;
	
	      /**
	       * Boolean that keeps track of whether hits are sorted ascending (true)
	       * or descending (false)
	       * * @type {Boolean}
	       */
	      $scope.isAscending = true;
	
	      /**
	       * Sorts saved object finder hits either ascending or descending
	       * @param  {Array} hits Array of saved finder object hits
	       * @return {Array} Array sorted either ascending or descending
	       */
	      $scope.sortHits = function (hits) {
	        var sortedList = _lodash2['default'].sortBy(hits, accessor);
	
	        $scope.isAscending = !$scope.isAscending;
	        $scope.hits = $scope.isAscending ? sortedList : sortedList.reverse();
	      };
	
	      $scope.makeUrl = function (hit) {
	        return $scope.userMakeUrl(hit);
	      };
	
	      $scope.onSelect = function (hit, $event) {
	        return $scope.userOnSelect(hit, $event);
	      };
	
	      function accessor(val) {
	        var prop = $scope.listProperty;
	        return prop ? val[prop] : val;
	      }
	    }
	  };
	});

/***/ },
/* 751 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"form-inline\">\n  <div class=\"container-fluid\">\n    <div class=\"row\">\n      <div class=\"input-group form-group finder-form col-md-9\">\n        <span class=\"input-group-addon\">\n          <i class=\"fa fa-search\"></i>\n        </span>\n        <input\n          input-focus\n          ng-model=\"query\"\n          placeholder=\"Filter...\"\n          class=\"form-control\"\n          name=\"query\"\n          type=\"text\"\n          autocomplete=\"off\" />\n      </div>\n      <div class=\"finder-hit-count col-md-3\">\n        <span>{{ (hits | filter: query).length }} of {{ hitCount }}</span>\n      </div>\n    </div>\n  </div>\n</form>\n<paginate list=\"hits | filter: query\" per-page=\"{{ perPage }}\">\n  <ul class=\"li-striped list-group list-group-menu\">\n    <li class=\"list-group-item\" ng-click=\"sortHits(hits)\">\n      <span class=\"paginate-heading\">\n        Name\n        <i class=\"fa\" ng-class=\"isAscending ? 'fa-caret-up' : 'fa-caret-down'\"></i>\n      </span>\n    </li>\n    <li class=\"list-group-item list-group-menu-item\" ng-repeat=\"hit in page\">\n      <a ng-show=\"userMakeUrl\" kbn-href=\"{{ makeUrl(hit) }}\">\n        <span>{{ hit }}</span>\n      </a>\n      <div ng-show=\"userOnSelect\" ng-click=\"onSelect(hit, $event)\">\n        <span>{{ hit }}</span>\n      </div>\n    </li>\n    <li class=\"list-group-item list-group-no-results\" ng-if=\"(hits | filter: query).length === 0\">\n      <p>No matches found.</p>\n    </li>\n  </ul>\n</paginate>\n"

/***/ },
/* 752 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _elasticDatemath = __webpack_require__(237);
	
	var _elasticDatemath2 = _interopRequireDefault(_elasticDatemath);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	__webpack_require__(676);
	
	__webpack_require__(678);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('prettyDuration', function (config, quickRanges, timeUnits) {
	  return {
	    restrict: 'E',
	    scope: {
	      from: '=',
	      to: '='
	    },
	    link: function link($scope, $elem) {
	      var dateFormat = config.get('dateFormat');
	
	      var lookupByRange = {};
	      _lodash2['default'].each(quickRanges, function (frame) {
	        lookupByRange[frame.from + ' to ' + frame.to] = frame;
	      });
	
	      function stringify() {
	        var text = undefined;
	        // If both parts are date math, try to look up a reasonable string
	        if ($scope.from && $scope.to && !_moment2['default'].isMoment($scope.from) && !_moment2['default'].isMoment($scope.to)) {
	          var tryLookup = lookupByRange[$scope.from.toString() + ' to ' + $scope.to.toString()];
	          if (tryLookup) {
	            $elem.text(tryLookup.display);
	          } else {
	            var fromParts = $scope.from.toString().split('-');
	            if ($scope.to.toString() === 'now' && fromParts[0] === 'now' && fromParts[1]) {
	              var rounded = fromParts[1].split('/');
	              text = 'Last ' + rounded[0];
	              if (rounded[1]) {
	                text = text + ' rounded to the ' + timeUnits[rounded[1]];
	              }
	              $elem.text(text);
	            } else {
	              cantLookup();
	            }
	          }
	          // If at least one part is a moment, try to make pretty strings by parsing date math
	        } else {
	            cantLookup();
	          }
	      }
	
	      function cantLookup() {
	        var display = {};
	        _lodash2['default'].each(['from', 'to'], function (time) {
	          if ((0, _moment2['default'])($scope[time]).isValid()) {
	            display[time] = (0, _moment2['default'])($scope[time]).format(dateFormat);
	          } else {
	            if ($scope[time] === 'now') {
	              display[time] = 'now';
	            } else {
	              var tryParse = _elasticDatemath2['default'].parse($scope[time], time === 'to' ? true : false);
	              display[time] = _moment2['default'].isMoment(tryParse) ? '~ ' + tryParse.fromNow() : $scope[time];
	            }
	          }
	        });
	        $elem.text(display.from + ' to ' + display.to);
	      }
	
	      $scope.$watch('from', stringify);
	      $scope.$watch('to', stringify);
	    }
	  };
	});

/***/ },
/* 753 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('renderCounter', function () {
	  return {
	    controller: function controller($scope, $element) {
	      var counter = 0;
	
	      var increment = function increment() {
	        counter += 1;
	        $element.attr('render-counter', counter);
	      };
	
	      var teardown = function teardown() {
	        $element.off('renderComplete', increment);
	      };
	
	      var setup = function setup() {
	        $element.attr('render-counter', counter);
	        $element.on('renderComplete', increment);
	        $scope.$on('$destroy', teardown);
	      };
	
	      this.disable = function () {
	        $element.attr('render-counter', 'disabled');
	        teardown();
	      };
	
	      setup();
	    }
	  };
	});

/***/ },
/* 754 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiVisAgg_config_result = __webpack_require__(755);
	
	var _uiVisAgg_config_result2 = _interopRequireDefault(_uiVisAgg_config_result);
	
	var _uiFilter_barFilter_bar_click_handler = __webpack_require__(756);
	
	var _uiFilter_barFilter_bar_click_handler2 = _interopRequireDefault(_uiFilter_barFilter_bar_click_handler);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _partialsTable_cell_filterHtml = __webpack_require__(758);
	
	var _partialsTable_cell_filterHtml2 = _interopRequireDefault(_partialsTable_cell_filterHtml);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('kbnRows', function ($compile, $rootScope, getAppState, Private) {
	  var filterBarClickHandler = Private(_uiFilter_barFilter_bar_click_handler2['default']);
	  return {
	    restrict: 'A',
	    link: function link($scope, $el, attr) {
	      function addCell($tr, contents) {
	        var $cell = (0, _jquery2['default'])(document.createElement('td'));
	
	        // TODO: It would be better to actually check the type of the field, but we don't have
	        // access to it here. This may become a problem with the switch to BigNumber
	        if (_lodash2['default'].isNumeric(contents)) $cell.addClass('numeric-value');
	
	        var createAggConfigResultCell = function createAggConfigResultCell(aggConfigResult) {
	          var $cell = (0, _jquery2['default'])(_partialsTable_cell_filterHtml2['default']);
	
	          var $state = getAppState();
	          var clickHandler = filterBarClickHandler($state);
	          $cell.scope = $scope.$new();
	          $cell.addClass('cell-hover');
	          $cell.scope.clickHandler = function (event, negate) {
	            if ((0, _jquery2['default'])(event.target).is('a')) return; // Don't add filter if a link was clicked
	            clickHandler({ point: { aggConfigResult: aggConfigResult }, negate: negate });
	          };
	          return $compile($cell)($cell.scope);
	        };
	
	        if (contents instanceof _uiVisAgg_config_result2['default']) {
	          if (contents.type === 'bucket' && contents.aggConfig.getField() && contents.aggConfig.getField().filterable) {
	            $cell = createAggConfigResultCell(contents);
	          }
	          contents = contents.toString('html');
	        }
	
	        if (_lodash2['default'].isObject(contents)) {
	          if (contents.attr) {
	            $cell.attr(contents.attr);
	          }
	
	          if (contents['class']) {
	            $cell.addClass(contents['class']);
	          }
	
	          if (contents.scope) {
	            $cell = $compile($cell.prepend(contents.markup))(contents.scope);
	          } else {
	            $cell.prepend(contents.markup);
	          }
	
	          if (contents.attr) {
	            $cell.attr(contents.attr);
	          }
	        } else {
	          if (contents === '') {
	            $cell.prepend('&nbsp;');
	          } else {
	            $cell.prepend(contents);
	          }
	        }
	
	        $tr.append($cell);
	      }
	
	      function maxRowSize(max, row) {
	        return Math.max(max, row.length);
	      }
	
	      $scope.$watchMulti([attr.kbnRows, attr.kbnRowsMin], function (vals) {
	        var rows = vals[0];
	        var min = vals[1];
	
	        $el.empty();
	
	        if (!_lodash2['default'].isArray(rows)) rows = [];
	        var width = rows.reduce(maxRowSize, 0);
	
	        if (isFinite(min) && rows.length < min) {
	          (function () {
	            // clone the rows so that we can add elements to it without upsetting the original
	            rows = _lodash2['default'].clone(rows);
	            // crate the empty row which will be pushed into the row list over and over
	            var emptyRow = new Array(width);
	            // fill the empty row with values
	            _lodash2['default'].times(width, function (i) {
	              emptyRow[i] = '';
	            });
	            // push as many empty rows into the row array as needed
	            _lodash2['default'].times(min - rows.length, function () {
	              rows.push(emptyRow);
	            });
	          })();
	        }
	
	        rows.forEach(function (row) {
	          var $tr = (0, _jquery2['default'])(document.createElement('tr')).appendTo($el);
	          row.forEach(function (cell) {
	            addCell($tr, cell);
	          });
	        });
	      });
	    }
	  };
	});

/***/ },
/* 755 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  var i = 0;
	
	  function AggConfigResult(aggConfig, parent, value, key) {
	    this.key = key;
	    this.value = value;
	    this.aggConfig = aggConfig;
	    this.$parent = parent;
	    this.$order = ++i;
	
	    if (aggConfig.schema.group === 'buckets') {
	      this.type = 'bucket';
	    } else {
	      this.type = 'metric';
	    }
	  }
	
	  /**
	   * Returns an array of the aggConfigResult and parents up the branch
	   * @returns {array} Array of aggConfigResults
	   */
	  AggConfigResult.prototype.getPath = function () {
	    return (function walk(_x, _x2) {
	      var _again = true;
	
	      _function: while (_again) {
	        var result = _x,
	            path = _x2;
	        _again = false;
	
	        path.unshift(result);
	        if (result.$parent) {
	          _x = result.$parent;
	          _x2 = path;
	          _again = true;
	          continue _function;
	        }
	        return path;
	      }
	    })(this, []);
	  };
	
	  /**
	   * Returns an Elasticsearch filter that represents the result.
	   * @returns {object} Elasticsearch filter
	   */
	  AggConfigResult.prototype.createFilter = function () {
	    return this.aggConfig.createFilter(this.key);
	  };
	
	  AggConfigResult.prototype.toString = function (contentType) {
	    return this.aggConfig.fieldFormatter(contentType)(this.value);
	  };
	
	  AggConfigResult.prototype.valueOf = function () {
	    return this.value;
	  };
	
	  return AggConfigResult;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 756 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _libDedup_filters = __webpack_require__(614);
	
	var _libDedup_filters2 = _interopRequireDefault(_libDedup_filters);
	
	var _libUniq_filters = __webpack_require__(613);
	
	var _libUniq_filters2 = _interopRequireDefault(_libUniq_filters);
	
	var _uiUtilsFind_by_param = __webpack_require__(757);
	
	var _uiUtilsFind_by_param2 = _interopRequireDefault(_uiUtilsFind_by_param);
	
	exports['default'] = function (Notifier) {
	  return function ($state) {
	    return function (event, simulate) {
	      var notify = new Notifier({
	        location: 'Filter bar'
	      });
	      var aggConfigResult = undefined;
	
	      // Hierarchical and tabular data set their aggConfigResult parameter
	      // differently because of how the point is rewritten between the two. So
	      // we need to check if the point.orig is set, if not use try the point.aggConfigResult
	      if (event.point.orig) {
	        aggConfigResult = event.point.orig.aggConfigResult;
	      } else if (event.point.values) {
	        aggConfigResult = (0, _uiUtilsFind_by_param2['default'])(event.point.values, 'aggConfigResult');
	      } else {
	        aggConfigResult = event.point.aggConfigResult;
	      }
	
	      if (aggConfigResult) {
	        var isLegendLabel = !!event.point.values;
	        var aggBuckets = _lodash2['default'].filter(aggConfigResult.getPath(), { type: 'bucket' });
	
	        // For legend clicks, use the last bucket in the path
	        if (isLegendLabel) {
	          (function () {
	            // series data has multiple values, use aggConfig on the first
	            // hierarchical data values is an object with the addConfig
	            var aggConfig = (0, _uiUtilsFind_by_param2['default'])(event.point.values, 'aggConfig');
	            aggBuckets = aggBuckets.filter(function (result) {
	              return result.aggConfig && result.aggConfig === aggConfig;
	            });
	          })();
	        }
	
	        var filters = (0, _lodash2['default'])(aggBuckets).map(function (result) {
	          try {
	            return result.createFilter();
	          } catch (e) {
	            if (!simulate) {
	              notify.warning(e.message);
	            }
	          }
	        }).filter(Boolean).value();
	
	        if (!filters.length) return;
	
	        if (event.negate) {
	          _lodash2['default'].each(filters, function (filter) {
	            filter.meta = filter.meta || {};
	            filter.meta.negate = true;
	          });
	        }
	
	        filters = (0, _libDedup_filters2['default'])($state.filters, (0, _libUniq_filters2['default'])(filters), { negate: true });
	        // We need to add a bunch of filter deduping here.
	        if (!simulate) {
	          $state.$newFilters = filters;
	        }
	
	        return filters;
	      }
	    };
	  };
	};
	
	module.exports = exports['default'];

/***/ },
/* 757 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = findByParam;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	// given an object or array of objects, return the value of the passed param
	// if the param is missing, return undefined
	
	function findByParam(values, param) {
	  if (_lodash2['default'].isArray(values)) {
	    // point series chart
	    var index = _lodash2['default'].findIndex(values, param);
	    if (index === -1) return;
	    return values[index][param];
	  }
	  return values[param]; // pie chart
	}
	
	module.exports = exports['default'];

/***/ },
/* 758 */
/***/ function(module, exports) {

	module.exports = "<td>\n  <span class=\"table-cell-filter\">\n    <span\n      ng-click=\"clickHandler($event, false)\"\n      class=\"fa fa-search-plus\"\n      tooltip=\"Filter for value\"\n      tooltip-append-to-body=\"1\"\n    ></span>\n\n    <span\n      ng-click=\"clickHandler($event, true)\"\n      class=\"fa fa-search-minus\"\n      tooltip=\"Filter out value\"\n      tooltip-append-to-body=\"1\"\n    ></span>\n  </span>\n</td>\n"

/***/ },
/* 759 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _risonNode = __webpack_require__(280);
	
	var _risonNode2 = _interopRequireDefault(_risonNode);
	
	var _uiUtilsKey_map = __webpack_require__(760);
	
	var _uiUtilsKey_map2 = _interopRequireDefault(_uiUtilsKey_map);
	
	var _uiSaved_objectsSaved_object_registry = __webpack_require__(761);
	
	var _uiSaved_objectsSaved_object_registry2 = _interopRequireDefault(_uiSaved_objectsSaved_object_registry);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiPartialsSaved_object_finderHtml = __webpack_require__(762);
	
	var _uiPartialsSaved_object_finderHtml2 = _interopRequireDefault(_uiPartialsSaved_object_finderHtml);
	
	__webpack_require__(763);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('savedObjectFinder', function ($location, $injector, kbnUrl, Private, config) {
	
	  var services = Private(_uiSaved_objectsSaved_object_registry2['default']).byLoaderPropertiesName;
	
	  return {
	    restrict: 'E',
	    scope: {
	      type: '@',
	      title: '@?',
	      // optional make-url attr, sets the userMakeUrl in our scope
	      userMakeUrl: '=?makeUrl',
	      // optional on-choose attr, sets the userOnChoose in our scope
	      userOnChoose: '=?onChoose',
	      // optional useLocalManagement attr,  removes link to management section
	      useLocalManagement: '=?useLocalManagement',
	      /**
	       * @type {function} - an optional function. If supplied an `Add new X` button is shown
	       * and this function is called when clicked.
	       */
	      onAddNew: '='
	    },
	    template: _uiPartialsSaved_object_finderHtml2['default'],
	    controllerAs: 'finder',
	    controller: function controller($scope, $element, $timeout) {
	      var self = this;
	
	      // the text input element
	      var $input = $element.find('input[ng-model=filter]');
	
	      // The number of items to show in the list
	      $scope.perPage = config.get('savedObjects:perPage');
	
	      // the list that will hold the suggestions
	      var $list = $element.find('ul');
	
	      // the current filter string, used to check that returned results are still useful
	      var currentFilter = $scope.filter;
	
	      // the most recently entered search/filter
	      var prevSearch = undefined;
	
	      // the list of hits, used to render display
	      self.hits = [];
	
	      self.service = services[$scope.type];
	      self.properties = self.service.loaderProperties;
	
	      filterResults();
	
	      /**
	       * Boolean that keeps track of whether hits are sorted ascending (true)
	       * or descending (false) by title
	       * @type {Boolean}
	       */
	      self.isAscending = true;
	
	      /**
	       * Sorts saved object finder hits either ascending or descending
	       * @param  {Array} hits Array of saved finder object hits
	       * @return {Array} Array sorted either ascending or descending
	       */
	      self.sortHits = function (hits) {
	        self.isAscending = !self.isAscending;
	        self.hits = self.isAscending ? _lodash2['default'].sortBy(hits, 'title') : _lodash2['default'].sortBy(hits, 'title').reverse();
	      };
	
	      /**
	       * Passed the hit objects and will determine if the
	       * hit should have a url in the UI, returns it if so
	       * @return {string|null} - the url or nothing
	       */
	      self.makeUrl = function (hit) {
	        if ($scope.userMakeUrl) {
	          return $scope.userMakeUrl(hit);
	        }
	
	        if (!$scope.userOnChoose) {
	          return hit.url;
	        }
	
	        return '#';
	      };
	
	      self.preventClick = function ($event) {
	        $event.preventDefault();
	      };
	
	      /**
	       * Called when a hit object is clicked, can override the
	       * url behavior if necessary.
	       */
	      self.onChoose = function (hit, $event) {
	        if ($scope.userOnChoose) {
	          $scope.userOnChoose(hit, $event);
	        }
	
	        var url = self.makeUrl(hit);
	        if (!url || url === '#' || url.charAt(0) !== '#') return;
	
	        $event.preventDefault();
	
	        // we want the '/path', not '#/path'
	        kbnUrl.change(url.substr(1));
	      };
	
	      $scope.$watch('filter', function (newFilter) {
	        // ensure that the currentFilter changes from undefined to ''
	        // which triggers
	        currentFilter = newFilter || '';
	        filterResults();
	      });
	
	      //manages the state of the keyboard selector
	      self.selector = {
	        enabled: false,
	        index: -1
	      };
	
	      //key handler for the filter text box
	      self.filterKeyDown = function ($event) {
	        switch (_uiUtilsKey_map2['default'][$event.keyCode]) {
	          case 'tab':
	            if (self.hitCount === 0) return;
	
	            self.selector.index = 0;
	            self.selector.enabled = true;
	
	            selectTopHit();
	
	            $event.preventDefault();
	            break;
	          case 'enter':
	            if (self.hitCount !== 1) return;
	
	            var hit = self.hits[0];
	            if (!hit) return;
	
	            self.onChoose(hit, $event);
	            $event.preventDefault();
	            break;
	        }
	      };
	
	      //key handler for the list items
	      self.hitKeyDown = function ($event, page, paginate) {
	        switch (_uiUtilsKey_map2['default'][$event.keyCode]) {
	          case 'tab':
	            if (!self.selector.enabled) break;
	
	            self.selector.index = -1;
	            self.selector.enabled = false;
	
	            //if the user types shift-tab return to the textbox
	            //if the user types tab, set the focus to the currently selected hit.
	            if ($event.shiftKey) {
	              $input.focus();
	            } else {
	              $list.find('li.active a').focus();
	            }
	
	            $event.preventDefault();
	            break;
	          case 'down':
	            if (!self.selector.enabled) break;
	
	            if (self.selector.index + 1 < page.length) {
	              self.selector.index += 1;
	            }
	            $event.preventDefault();
	            break;
	          case 'up':
	            if (!self.selector.enabled) break;
	
	            if (self.selector.index > 0) {
	              self.selector.index -= 1;
	            }
	            $event.preventDefault();
	            break;
	          case 'right':
	            if (!self.selector.enabled) break;
	
	            if (page.number < page.count) {
	              paginate.goToPage(page.number + 1);
	              self.selector.index = 0;
	              selectTopHit();
	            }
	            $event.preventDefault();
	            break;
	          case 'left':
	            if (!self.selector.enabled) break;
	
	            if (page.number > 1) {
	              paginate.goToPage(page.number - 1);
	              self.selector.index = 0;
	              selectTopHit();
	            }
	            $event.preventDefault();
	            break;
	          case 'escape':
	            if (!self.selector.enabled) break;
	
	            $input.focus();
	            $event.preventDefault();
	            break;
	          case 'enter':
	            if (!self.selector.enabled) break;
	
	            var hitIndex = (page.number - 1) * paginate.perPage + self.selector.index;
	            var hit = self.hits[hitIndex];
	            if (!hit) break;
	
	            self.onChoose(hit, $event);
	            $event.preventDefault();
	            break;
	          case 'shift':
	            break;
	          default:
	            $input.focus();
	            break;
	        }
	      };
	
	      self.hitBlur = function ($event) {
	        self.selector.index = -1;
	        self.selector.enabled = false;
	      };
	
	      self.manageObjects = function (type) {
	        $location.url('/management/kibana/objects?_a=' + _risonNode2['default'].encode({ tab: type }));
	      };
	
	      self.hitCountNoun = function () {
	        return (self.hitCount === 1 ? self.properties.noun : self.properties.nouns).toLowerCase();
	      };
	
	      function selectTopHit() {
	        setTimeout(function () {
	          //triggering a focus event kicks off a new angular digest cycle.
	          $list.find('a:first').focus();
	        }, 0);
	      }
	
	      function filterResults() {
	        if (!self.service) return;
	        if (!self.properties) return;
	
	        // track the filter that we use for this search,
	        // but ensure that we don't search for the same
	        // thing twice. This is called from multiple places
	        // and needs to be smart about when it actually searches
	        var filter = currentFilter;
	        if (prevSearch === filter) return;
	
	        prevSearch = filter;
	        self.service.find(filter).then(function (hits) {
	          // ensure that we don't display old results
	          // as we can't really cancel requests
	          if (currentFilter === filter) {
	            self.hitCount = hits.total;
	            self.hits = _lodash2['default'].sortBy(hits.hits, 'title');
	          }
	        });
	      }
	
	      function scrollIntoView($element, snapTop) {
	        var el = $element[0];
	
	        if (!el) return;
	
	        if ('scrollIntoViewIfNeeded' in el) {
	          el.scrollIntoViewIfNeeded(snapTop);
	        } else if ('scrollIntoView' in el) {
	          el.scrollIntoView(snapTop);
	        }
	      }
	    }
	  };
	});

/***/ },
/* 760 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = {
	  8: 'backspace',
	  9: 'tab',
	  13: 'enter',
	  16: 'shift',
	  17: 'ctrl',
	  18: 'alt',
	  19: 'pause',
	  20: 'capsLock',
	  27: 'escape',
	  32: 'space',
	  33: 'pageUp',
	  34: 'pageDown',
	  35: 'end',
	  36: 'home',
	  37: 'left',
	  38: 'up',
	  39: 'right',
	  40: 'down',
	  45: 'insert',
	  46: 'delete',
	  48: '0',
	  49: '1',
	  50: '2',
	  51: '3',
	  52: '4',
	  53: '5',
	  54: '6',
	  55: '7',
	  56: '8',
	  57: '9',
	  65: 'a',
	  66: 'b',
	  67: 'c',
	  68: 'd',
	  69: 'e',
	  70: 'f',
	  71: 'g',
	  72: 'h',
	  73: 'i',
	  74: 'j',
	  75: 'k',
	  76: 'l',
	  77: 'm',
	  78: 'n',
	  79: 'o',
	  80: 'p',
	  81: 'q',
	  82: 'r',
	  83: 's',
	  84: 't',
	  85: 'u',
	  86: 'v',
	  87: 'w',
	  88: 'x',
	  89: 'y',
	  90: 'z',
	  91: 'leftWindowKey',
	  92: 'rightWindowKey',
	  93: 'selectKey',
	  96: '0',
	  97: '1',
	  98: '2',
	  99: '3',
	  100: '4',
	  101: '5',
	  102: '6',
	  103: '7',
	  104: '8',
	  105: '9',
	  106: 'multiply',
	  107: 'add',
	  109: 'subtract',
	  110: 'period',
	  111: 'divide',
	  112: 'f1',
	  113: 'f2',
	  114: 'f3',
	  115: 'f4',
	  116: 'f5',
	  117: 'f6',
	  118: 'f7',
	  119: 'f8',
	  120: 'f9',
	  121: 'f10',
	  122: 'f11',
	  123: 'f12',
	  144: 'numLock',
	  145: 'scrollLock',
	  186: 'semiColon',
	  187: 'equalSign',
	  188: 'comma',
	  189: 'dash',
	  190: 'period',
	  191: 'forwardSlash',
	  192: 'graveAccent',
	  219: 'openBracket',
	  220: 'backSlash',
	  221: 'closeBraket',
	  222: 'singleQuote',
	  224: 'meta'
	};
	module.exports = exports['default'];

/***/ },
/* 761 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _uiRegistry_registry = __webpack_require__(446);
	
	var _uiRegistry_registry2 = _interopRequireDefault(_uiRegistry_registry);
	
	exports['default'] = (0, _uiRegistry_registry2['default'])({
	  name: 'savedObjects',
	  index: ['loaderProperties.name'],
	  order: ['loaderProperties.name']
	});
	module.exports = exports['default'];

/***/ },
/* 762 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"form-inline\">\n  <div class=\"container-fluid\">\n    <div class=\"row\">\n      <div class=\"input-group form-group finder-form col-md-7\">\n        <span class=\"input-group-addon savedObjectFinderSearchIcon\">\n          <span class=\"fa fa-search\"></span>\n        </span>\n        <input\n          input-focus\n          ng-model=\"filter\"\n          ng-attr-placeholder=\"{{finder.properties.nouns | label }} Filter...\"\n          ng-keydown=\"finder.filterKeyDown($event)\"\n          class=\"form-control\"\n          name=\"filter\"\n          type=\"text\"\n          autocomplete=\"off\"\n        />\n      </div>\n      <div class=\"finder-hit-count col-md-2\">\n        <span>{{finder.hitCount}} of {{finder.hitCount}}</span>\n      </div>\n      <div class=\"finder-manage-object col-md-2\" ng-if=\"onAddNew\">\n        <a class=\"small\" ng-click=\"onAddNew()\">\n          Add new {{finder.properties.noun}}\n        </a>\n      </div>\n      <div class=\"finder-manage-object col-md-2\" ng-if=\"!useLocalManagement\">\n        <a class=\"small\" ng-click=\"finder.manageObjects(finder.properties.name)\">\n          Manage {{finder.properties.nouns}}\n        </a>\n      </div>\n    </div>\n  </div>\n</form>\n<paginate list=\"finder.hits\" per-page=\"20\">\n  <ul class=\"li-striped list-group list-group-menu\" ng-class=\"{'select-mode': finder.selector.enabled}\">\n    <li class=\"list-group-item\" ng-click=\"finder.sortHits(finder.hits)\">\n      <span class=\"paginate-heading\">\n        Name\n        <span\n          class=\"fa\"\n          ng-class=\"finder.isAscending ? 'fa-caret-up' : 'fa-caret-down'\">\n        </span>\n      </span>\n    </li>\n    <li\n      class=\"list-group-item list-group-menu-item\"\n      ng-class=\"{'active': finder.selector.index === $index && finder.selector.enabled}\"\n      ng-repeat=\"hit in page\"\n      ng-keydown=\"finder.hitKeyDown($event, page, paginate)\"\n      ng-click=\"finder.onChoose(hit, $event)\">\n\n      <a ng-href=\"{{finder.makeUrl(hit)}}\"\n          ng-blur=\"finder.hitBlur($event)\"\n          ng-click=\"finder.preventClick($event)\">\n          <span aria-hidden=\"true\" class=\"finder-type fa\" ng-if=\"hit.icon\" ng-class=\"hit.icon\"></span>\n          <span>{{hit.title}}</span>\n          <p ng-if=\"hit.description\" ng-bind=\"hit.description\"></p>\n      </a>\n    </li>\n    <li\n      class=\"list-group-item list-group-no-results\"\n      ng-if=\"finder.hits.length === 0\">\n      <p ng-bind=\"'No matching ' + finder.properties.nouns + ' found.'\"></p>\n    </li>\n  </ul>\n</paginate>\n"

/***/ },
/* 763 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 764 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsCidr_mask = __webpack_require__(765);
	
	var _uiUtilsCidr_mask2 = _interopRequireDefault(_uiUtilsCidr_mask);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('validateCidrMask', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    scope: {
	      'ngModel': '='
	    },
	    link: function link($scope, elem, attr, ngModel) {
	      ngModel.$parsers.unshift(validateCidrMask);
	      ngModel.$formatters.unshift(validateCidrMask);
	
	      function validateCidrMask(mask) {
	        if (mask == null || mask === '') {
	          ngModel.$setValidity('cidrMaskInput', true);
	          return null;
	        }
	
	        try {
	          mask = new _uiUtilsCidr_mask2['default'](mask);
	          ngModel.$setValidity('cidrMaskInput', true);
	          return mask.toString();
	        } catch (e) {
	          ngModel.$setValidity('cidrMaskInput', false);
	        }
	      }
	    }
	  };
	});

/***/ },
/* 765 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _uiUtilsIpv4_address = __webpack_require__(766);
	
	var _uiUtilsIpv4_address2 = _interopRequireDefault(_uiUtilsIpv4_address);
	
	var NUM_BITS = 32;
	
	function throwError(mask) {
	  throw Error('Invalid CIDR mask: ' + mask);
	}
	
	function CidrMask(mask) {
	  var splits = mask.split('\/');
	  if (splits.length !== 2) throwError(mask);
	  this.initialAddress = new _uiUtilsIpv4_address2['default'](splits[0]);
	  this.prefixLength = Number(splits[1]);
	  if (this.prefixLength < 1 || this.prefixLength > NUM_BITS) throwError(mask);
	}
	
	CidrMask.prototype.getRange = function () {
	  var variableBits = NUM_BITS - this.prefixLength;
	  var fromAddress = this.initialAddress.valueOf() >> variableBits << variableBits >>> 0; // >>> 0 coerces to unsigned
	  var numAddresses = Math.pow(2, variableBits);
	  return {
	    from: new _uiUtilsIpv4_address2['default'](fromAddress).toString(),
	    to: new _uiUtilsIpv4_address2['default'](fromAddress + numAddresses - 1).toString()
	  };
	};
	
	CidrMask.prototype.toString = function () {
	  return this.initialAddress.toString() + '/' + this.prefixLength;
	};
	
	exports['default'] = CidrMask;
	module.exports = exports['default'];

/***/ },
/* 766 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  var NUM_BYTES = 4;
	  var BYTE_SIZE = 256;
	
	  function throwError(ipAddress) {
	    throw Error('Invalid IPv4 address: ' + ipAddress);
	  }
	
	  function isIntegerInRange(integer, min, max) {
	    return !isNaN(integer) && integer >= min && integer < max && integer % 1 === 0;
	  }
	
	  function Ipv4Address(ipAddress) {
	    this.value = ipAddress;
	
	    if (typeof ipAddress === 'string') {
	      this.value = 0;
	
	      var bytes = ipAddress.split('.');
	      if (bytes.length !== NUM_BYTES) throwError(ipAddress);
	
	      for (var i = 0; i < bytes.length; i++) {
	        var byte = Number(bytes[i]);
	        if (!isIntegerInRange(byte, 0, BYTE_SIZE)) throwError(ipAddress);
	        this.value += Math.pow(BYTE_SIZE, NUM_BYTES - 1 - i) * byte;
	      }
	    }
	
	    if (!isIntegerInRange(this.value, 0, Math.pow(BYTE_SIZE, NUM_BYTES))) throwError(ipAddress);
	  }
	
	  Ipv4Address.prototype.toString = function () {
	    var value = this.value;
	    var bytes = [];
	    for (var i = 0; i < NUM_BYTES; i++) {
	      bytes.unshift(value % 256);
	      value = Math.floor(value / 256);
	    }
	    return bytes.join('.');
	  };
	
	  Ipv4Address.prototype.valueOf = function () {
	    return this.value;
	  };
	
	  return Ipv4Address;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 767 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _elasticDatemath = __webpack_require__(237);
	
	var _elasticDatemath2 = _interopRequireDefault(_elasticDatemath);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('validateDateMath', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    scope: {
	      'ngModel': '='
	    },
	    link: function link($scope, elem, attr, ngModel) {
	      ngModel.$parsers.unshift(validateDateMath);
	      ngModel.$formatters.unshift(validateDateMath);
	
	      function validateDateMath(input) {
	        if (input == null || input === '') {
	          ngModel.$setValidity('validDateMath', true);
	          return null;
	        }
	
	        var moment = _elasticDatemath2['default'].parse(input);
	        ngModel.$setValidity('validDateMath', moment != null && moment.isValid());
	        return input;
	      }
	    }
	  };
	});

/***/ },
/* 768 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	// See https://github.com/elastic/elasticsearch/issues/6736
	
	_uiModules2['default'].get('kibana').directive('validateIndexName', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link($scope, elem, attr, ngModel) {
	      var illegalCharacters = ['\\', '/', '?', '"', '<', '>', '|', ' ', ','];
	      var allowWildcard = !_lodash2['default'].isUndefined(attr.allowWildcard) && attr.allowWildcard !== 'false';
	      if (!allowWildcard) {
	        illegalCharacters.push('*');
	      }
	
	      var isValid = function isValid(input) {
	        if (input == null || input === '' || input === '.' || input === '..') return false;
	
	        var match = _lodash2['default'].find(illegalCharacters, function (character) {
	          return input.indexOf(character) >= 0;
	        });
	        return !match;
	      };
	
	      ngModel.$validators.indexNameInput = function (modelValue, viewValue) {
	        return isValid(viewValue);
	      };
	    }
	  };
	});

/***/ },
/* 769 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsIpv4_address = __webpack_require__(766);
	
	var _uiUtilsIpv4_address2 = _interopRequireDefault(_uiUtilsIpv4_address);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('validateIp', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    scope: {
	      'ngModel': '='
	    },
	    link: function link($scope, elem, attr, ngModel) {
	      function validateIp(ipAddress) {
	        if (ipAddress == null || ipAddress === '') {
	          ngModel.$setValidity('ipInput', true);
	          return null;
	        }
	
	        try {
	          ipAddress = new _uiUtilsIpv4_address2['default'](ipAddress);
	          ngModel.$setValidity('ipInput', true);
	          return ipAddress.toString();
	        } catch (e) {
	          ngModel.$setValidity('ipInput', false);
	        }
	      }
	
	      // From User
	      ngModel.$parsers.unshift(validateIp);
	
	      // To user
	      ngModel.$formatters.unshift(validateIp);
	    }
	  };
	});

/***/ },
/* 770 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	_module.directive('validateJson', function ($compile) {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    scope: {
	      'ngModel': '=',
	      'queryInput': '=?'
	    },
	    link: function link($scope, $elem, attr, ngModel) {
	      $scope.$watch('ngModel', validator);
	
	      function validator(newValue, oldValue) {
	        if (!newValue || newValue.length === 0) {
	          setValid();
	          return;
	        }
	
	        // We actually need a proper object in all JSON inputs
	        newValue = (newValue || '').trim();
	        if (newValue[0] === '{' || '[') {
	          try {
	            JSON.parse(newValue);
	            setValid();
	          } catch (e) {
	            setInvalid();
	          }
	        } else {
	          setInvalid();
	        }
	      }
	
	      function setValid() {
	        ngModel.$setValidity('jsonInput', true);
	      }
	
	      function setInvalid() {
	        ngModel.$setValidity('jsonInput', false);
	      }
	    }
	  };
	});

/***/ },
/* 771 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').directive('validateLowercase', function () {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link($scope, elem, attr, ctrl) {
	      ctrl.$validators.lowercase = function (modelValue, viewValue) {
	        if (ctrl.$isEmpty(modelValue)) {
	          // consider empty models to be valid per lowercase rules
	          return true;
	        }
	
	        return viewValue.toLowerCase() === viewValue;
	      };
	    }
	  };
	});

/***/ },
/* 772 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var context = __webpack_require__(773);
	context.keys().forEach(function (key) {
	  return context(key);
	});

/***/ },
/* 773 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./comma_list.js": 774,
		"./field_type.js": 775,
		"./label.js": 777,
		"./markdown.js": 371,
		"./match_any.js": 778,
		"./moment.js": 779,
		"./rison.js": 415,
		"./short_dots.js": 482,
		"./start_from.js": 780,
		"./trust_as_html.js": 781,
		"./unique.js": 782,
		"./uriescape.js": 414
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 773;


/***/ },
/* 774 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').filter('commaList', function () {
	  /**
	   * Angular filter that accepts either an array or a comma-seperated string
	   * and outputs either an array, or a comma-seperated string for presentation.
	   *
	   * @param {String|Array} input - The comma-seperated list or array
	   * @param {Boolean} inclusive - Should the list be joined with an "and"?
	   * @return {String}
	   */
	  return function (input, inclusive) {
	    var list = _lodash2['default'].commaSeperatedList(input);
	    if (list.length < 2) {
	      return list.join('');
	    }
	
	    var conj = inclusive ? ' and ' : ' or ';
	    return list.slice(0, -1).join(', ') + conj + _lodash2['default'].last(list);
	  };
	});

/***/ },
/* 775 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiFilters_prop_filter = __webpack_require__(776);
	
	var _uiFilters_prop_filter2 = _interopRequireDefault(_uiFilters_prop_filter);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	// Gets all fields of a given type.
	// You may also pass "*" to get all types
	// Or an array of types to get all fields of that type
	
	_uiModules2['default'].get('kibana').filter('fieldType', function () {
	  return (0, _uiFilters_prop_filter2['default'])('type');
	});

/***/ },
/* 776 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	/**
	 * Filters out a list by a given filter. This is currently used to impelment:
	 *   - fieldType filters a list of fields by their type property
	 *   - aggFilter filters a list of aggs by their name property
	 *
	 * @returns {function} - the filter function which can be registered with angular
	 */
	function propFilter(prop) {
	  /**
	   * List filtering function which accepts an array or list of values that a property
	   * must contain
	   *
	   * @param  {array} list - array of items to filter
	   * @param  {function|array|string} filters - the values to match against the list
	   *   - if a function, it is expected to take the field property as argument and returns true to keep it.
	   *   - Can be also an array, a single value as a string, or a comma-seperated list of items
	   * @return {array} - the filtered list
	   */
	  return function (list, filters) {
	    if (!filters) return filters;
	
	    if (_lodash2['default'].isFunction(filters)) {
	      return list.filter(function (item) {
	        return filters(item[prop]);
	      });
	    }
	
	    if (!_lodash2['default'].isArray(filters)) filters = filters.split(',');
	    if (_lodash2['default'].contains(filters, '*')) return list;
	
	    var options = filters.reduce(function (options, filter) {
	      var type = 'include';
	      var value = filter;
	
	      if (filter.charAt(0) === '!') {
	        type = 'exclude';
	        value = filter.substr(1);
	      }
	
	      if (!options[type]) options[type] = [];
	      options[type].push(value);
	      return options;
	    }, {});
	
	    return list.filter(function (item) {
	      var value = item[prop];
	
	      var excluded = options.exclude && _lodash2['default'].contains(options.exclude, value);
	      if (excluded) return false;
	
	      var included = !options.include || _lodash2['default'].contains(options.include, value);
	      if (included) return true;
	
	      return false;
	    });
	  };
	}
	
	exports['default'] = propFilter;
	module.exports = exports['default'];

/***/ },
/* 777 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _lodash = __webpack_require__(3);
	
	_uiModules2['default'].get('kibana').filter('label', function () {
	  return function (str) {
	    return (0, _lodash.words)(str).map(_lodash.capitalize).join(' ');
	  };
	});

/***/ },
/* 778 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	// Gets all fields of a given type.
	// You may also pass "*" to get all types
	// Or an array of types to get all fields of that type
	
	_uiModules2['default'].get('kibana').filter('matchAny', function () {
	  return function (items, rules) {
	    if (!_lodash2['default'].isArray(rules)) {
	      rules = [rules];
	    }
	
	    return _lodash2['default'].filter(items, function (item) {
	      for (var i = 0; i < rules.length; i++) {
	        if (_lodash2['default'].some([item], rules[i])) {
	          return true;
	        }
	      }
	
	      return false;
	    });
	  };
	});

/***/ },
/* 779 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').filter('moment', function (config) {
	  return function (datetime) {
	    var format = config.get('dateFormat');
	    if (_moment2['default'].isMoment(datetime)) return datetime.format(format);
	    if (_lodash2['default'].isDate(datetime)) return (0, _moment2['default'])(datetime).format(format);
	    return datetime;
	  };
	});

/***/ },
/* 780 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('kibana').filter('startFrom', function () {
	  return function (input, start) {
	    if (!input) return [];
	    start = +start; //parse to int
	    return input.slice(start);
	  };
	});

/***/ },
/* 781 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('kibana');
	
	// Simple filter to allow using ng-bind-html without explicitly calling $sce.trustAsHtml in a controller
	// (See http://goo.gl/mpj9o2)
	_module.filter('trustAsHtml', function ($sce) {
	  return $sce.trustAsHtml;
	});

/***/ },
/* 782 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	// Filters out all duplicate items in an array
	
	_uiModules2['default'].get('kibana').filter('unique', function () {
	  return function (arr) {
	    var list = _lodash2['default'].unique(arr);
	    return list;
	  };
	});

/***/ },
/* 783 */
/***/ function(module, exports, __webpack_require__) {

	// Kibana UI Framework
	'use strict';
	
	__webpack_require__(784);
	
	// All Kibana styles inside of the /styles dir
	var context = __webpack_require__(785);
	context.keys().forEach(function (key) {
	  return context(key);
	});

/***/ },
/* 784 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 785 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./base.less": 786,
		"./callout.less": 787,
		"./config.less": 788,
		"./control_group.less": 789,
		"./dark-theme.less": 790,
		"./dark-variables.less": 791,
		"./hintbox.less": 792,
		"./input.less": 793,
		"./list-group-menu.less": 794,
		"./navbar.less": 795,
		"./pagination.less": 796,
		"./sidebar.less": 797,
		"./spinner.less": 798,
		"./table.less": 799,
		"./theme.less": 800,
		"./truncate.less": 801
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 785;


/***/ },
/* 786 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 787 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 788 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 789 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 790 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 791 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 792 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 793 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 794 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 795 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 796 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 797 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 798 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 799 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 800 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 801 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 802 */,
/* 803 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsScanner = __webpack_require__(804);
	
	var _uiUtilsScanner2 = _interopRequireDefault(_uiUtilsScanner);
	
	__webpack_require__(805);
	
	__webpack_require__(366);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiCourierSaved_objectSaved_object_loader = __webpack_require__(806);
	
	var _module = _uiModules2['default'].get('discover/saved_searches', ['kibana/notify']);
	
	// Register this service with the saved object registry so it can be
	// edited by the object editor.
	__webpack_require__(808).register({
	  service: 'savedSearches',
	  title: 'searches'
	});
	
	_module.service('savedSearches', function (Promise, config, kbnIndex, esAdmin, createNotifier, SavedSearch, kbnUrl) {
	  var savedSearchLoader = new _uiCourierSaved_objectSaved_object_loader.SavedObjectLoader(SavedSearch, kbnIndex, esAdmin, kbnUrl);
	  // Customize loader properties since adding an 's' on type doesn't work for type 'search' .
	  savedSearchLoader.loaderProperties = {
	    name: 'searches',
	    noun: 'Saved Search',
	    nouns: 'saved searches'
	  };
	  savedSearchLoader.urlFor = function (id) {
	    return kbnUrl.eval('#/discover/{{id}}', { id: id });
	  };
	
	  return savedSearchLoader;
	});

/***/ },
/* 804 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Promise = __webpack_require__(331)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var Scanner = function Scanner(client) {
	  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  var index = _ref.index;
	  var type = _ref.type;
	
	  if (!index) throw new Error('Expected index');
	  if (!type) throw new Error('Expected type');
	  if (!client) throw new Error('Expected client');
	
	  this.client = client;
	  this.index = index;
	  this.type = type;
	};
	
	Scanner.prototype.scanAndMap = function (searchString, options, mapFn) {
	  var _this = this;
	
	  var scrollId = undefined;
	  var body = undefined;
	  var allResults = {
	    hits: [],
	    total: 0
	  };
	  var opts = _lodash2['default'].defaults(options || {}, {
	    pageSize: 100,
	    docCount: 1000
	  });
	
	  if (searchString) {
	    body = {
	      query: {
	        simple_query_string: {
	          query: searchString + '*',
	          fields: ['title^3', 'description'],
	          default_operator: 'AND'
	        }
	      }
	    };
	  } else {
	    body = { query: { match_all: {} } };
	  }
	
	  return new _Promise(function (resolve, reject) {
	    var getMoreUntilDone = function getMoreUntilDone(error, response) {
	      if (error) {
	        reject(error);
	        return;
	      }
	      var scanAllResults = opts.docCount === Infinity;
	      allResults.total = scanAllResults ? response.hits.total : Math.min(response.hits.total, opts.docCount);
	      scrollId = response._scroll_id || scrollId;
	
	      var hits = response.hits.hits.slice(0, allResults.total - allResults.hits.length);
	      if (mapFn) hits = hits.map(mapFn);
	
	      allResults.hits = allResults.hits.concat(hits);
	
	      var collectedAllResults = allResults.total === allResults.hits.length;
	      if (collectedAllResults) {
	        resolve(allResults);
	      } else {
	        _this.client.scroll({
	          scrollId: scrollId
	        }, getMoreUntilDone);
	      }
	    };
	
	    _this.client.search({
	      index: _this.index,
	      type: _this.type,
	      size: opts.pageSize,
	      body: body,
	      scroll: '1m',
	      sort: '_doc'
	    }, getMoreUntilDone);
	  });
	};
	
	exports['default'] = Scanner;
	module.exports = exports['default'];

/***/ },
/* 805 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(366);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _module = _uiModules2['default'].get('discover/saved_searches', ['kibana/notify', 'kibana/courier']);
	
	_module.factory('SavedSearch', function (courier) {
	  _lodash2['default']['class'](SavedSearch).inherits(courier.SavedObject);
	  function SavedSearch(id) {
	    courier.SavedObject.call(this, {
	      type: SavedSearch.type,
	      mapping: SavedSearch.mapping,
	      searchSource: SavedSearch.searchSource,
	
	      id: id,
	      defaults: {
	        title: 'New Saved Search',
	        description: '',
	        columns: [],
	        hits: 0,
	        sort: [],
	        version: 1
	      }
	    });
	  }
	
	  SavedSearch.type = 'search';
	
	  SavedSearch.mapping = {
	    title: 'string',
	    description: 'string',
	    hits: 'integer',
	    columns: 'string',
	    sort: 'string',
	    version: 'integer'
	  };
	
	  // Order these fields to the top, the rest are alphabetical
	  SavedSearch.fieldOrder = ['title', 'description'];
	
	  SavedSearch.searchSource = true;
	
	  return SavedSearch;
	});

/***/ },
/* 806 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _Promise = __webpack_require__(331)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsScanner = __webpack_require__(804);
	
	var _uiUtilsScanner2 = _interopRequireDefault(_uiUtilsScanner);
	
	var _uiUtilsString_utils = __webpack_require__(807);
	
	var SavedObjectLoader = (function () {
	  function SavedObjectLoader(SavedObjectClass, kbnIndex, esAdmin, kbnUrl) {
	    _classCallCheck(this, SavedObjectLoader);
	
	    this.type = SavedObjectClass.type;
	    this.Class = SavedObjectClass;
	    this.lowercaseType = this.type.toLowerCase();
	    this.kbnIndex = kbnIndex;
	    this.kbnUrl = kbnUrl;
	    this.esAdmin = esAdmin;
	
	    this.scanner = new _uiUtilsScanner2['default'](esAdmin, {
	      index: kbnIndex,
	      type: this.lowercaseType
	    });
	
	    this.loaderProperties = {
	      name: this.lowercaseType + 's',
	      noun: _uiUtilsString_utils.StringUtils.upperFirst(this.type),
	      nouns: this.lowercaseType + 's'
	    };
	  }
	
	  /**
	   * Retrieve a saved object by id. Returns a promise that completes when the object finishes
	   * initializing.
	   * @param id
	   * @returns {Promise<SavedObject>}
	   */
	
	  _createClass(SavedObjectLoader, [{
	    key: 'get',
	    value: function get(id) {
	      return new this.Class(id).init();
	    }
	  }, {
	    key: 'urlFor',
	    value: function urlFor(id) {
	      return this.kbnUrl.eval('#/' + this.lowercaseType + '/{{id}}', { id: id });
	    }
	  }, {
	    key: 'delete',
	    value: function _delete(ids) {
	      var _this = this;
	
	      ids = !_lodash2['default'].isArray(ids) ? [ids] : ids;
	
	      var deletions = ids.map(function (id) {
	        var savedObject = new _this.Class(id);
	        return savedObject['delete']();
	      });
	
	      return _Promise.all(deletions);
	    }
	
	    /**
	     * Updates hit._source to contain an id and url field, and returns the updated
	     * source object.
	     * @param hit
	     * @returns {hit._source} The modified hit._source object, with an id and url field.
	     */
	  }, {
	    key: 'mapHits',
	    value: function mapHits(hit) {
	      var source = hit._source;
	      source.id = hit._id;
	      source.url = this.urlFor(hit._id);
	      return source;
	    }
	  }, {
	    key: 'scanAll',
	    value: function scanAll(queryString) {
	      var _this2 = this;
	
	      var pageSize = arguments.length <= 1 || arguments[1] === undefined ? 1000 : arguments[1];
	
	      return this.scanner.scanAndMap(queryString, {
	        pageSize: pageSize,
	        docCount: Infinity
	      }, function (hit) {
	        return _this2.mapHits(hit);
	      });
	    }
	
	    /**
	     * TODO: Rather than use a hardcoded limit, implement pagination. See
	     * https://github.com/elastic/kibana/issues/8044 for reference.
	     *
	     * @param searchString
	     * @param size
	     * @returns {Promise}
	     */
	  }, {
	    key: 'find',
	    value: function find(searchString) {
	      var _this3 = this;
	
	      var size = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];
	
	      var body = undefined;
	      if (searchString) {
	        body = {
	          query: {
	            simple_query_string: {
	              query: searchString + '*',
	              fields: ['title^3', 'description'],
	              default_operator: 'AND'
	            }
	          }
	        };
	      } else {
	        body = { query: { match_all: {} } };
	      }
	
	      return this.esAdmin.search({
	        index: this.kbnIndex,
	        type: this.lowercaseType,
	        body: body,
	        size: size
	      }).then(function (resp) {
	        return {
	          total: resp.hits.total,
	          hits: resp.hits.hits.map(function (hit) {
	            return _this3.mapHits(hit);
	          })
	        };
	      });
	    }
	  }]);
	
	  return SavedObjectLoader;
	})();

	exports.SavedObjectLoader = SavedObjectLoader;

/***/ },
/* 807 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var StringUtils = (function () {
	  function StringUtils() {
	    _classCallCheck(this, StringUtils);
	  }
	
	  _createClass(StringUtils, null, [{
	    key: 'upperFirst',
	
	    /**
	     * Returns a version of the string with the first letter capitalized.
	     * @param str {string}
	     * @returns {string}
	     */
	    value: function upperFirst(str) {
	      return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
	    }
	  }]);
	
	  return StringUtils;
	})();

	exports.StringUtils = StringUtils;

/***/ },
/* 808 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var registry = [];
	exports['default'] = {
	  register: function register(service) {
	    registry.push(service);
	  },
	  all: function all() {
	    return registry;
	  },
	  get: function get(id) {
	    return _lodash2['default'].find(registry, { service: id });
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(831), __esModule: true };

/***/ },
/* 831 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(333);
	__webpack_require__(310);
	__webpack_require__(293);
	__webpack_require__(832);
	__webpack_require__(834);
	module.exports = __webpack_require__(34).Map;

/***/ },
/* 832 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(833);
	
	// 23.1 Map Objects
	__webpack_require__(491)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 833 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(14)
	  , hide         = __webpack_require__(301)
	  , redefineAll  = __webpack_require__(347)
	  , ctx          = __webpack_require__(35)
	  , strictNew    = __webpack_require__(335)
	  , defined      = __webpack_require__(30)
	  , forOf        = __webpack_require__(336)
	  , $iterDefine  = __webpack_require__(298)
	  , step         = __webpack_require__(296)
	  , ID           = __webpack_require__(309)('id')
	  , $has         = __webpack_require__(304)
	  , isObject     = __webpack_require__(41)
	  , setSpecies   = __webpack_require__(348)
	  , DESCRIPTORS  = __webpack_require__(303)
	  , isExtensible = Object.isExtensible || isObject
	  , SIZE         = DESCRIPTORS ? '_s' : 'size'
	  , id           = 0;
	
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 834 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(32);
	
	$export($export.P, 'Map', {toJSON: __webpack_require__(835)('Map')});

/***/ },
/* 835 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(336)
	  , classof = __webpack_require__(315);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ },
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */,
/* 862 */,
/* 863 */,
/* 864 */,
/* 865 */,
/* 866 */,
/* 867 */,
/* 868 */,
/* 869 */,
/* 870 */,
/* 871 */,
/* 872 */,
/* 873 */,
/* 874 */,
/* 875 */,
/* 876 */,
/* 877 */,
/* 878 */,
/* 879 */,
/* 880 */,
/* 881 */,
/* 882 */,
/* 883 */,
/* 884 */,
/* 885 */,
/* 886 */,
/* 887 */,
/* 888 */,
/* 889 */,
/* 890 */,
/* 891 */,
/* 892 */,
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */,
/* 909 */,
/* 910 */,
/* 911 */,
/* 912 */,
/* 913 */,
/* 914 */,
/* 915 */,
/* 916 */,
/* 917 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _uiRegistry_registry = __webpack_require__(446);
	
	var _uiRegistry_registry2 = _interopRequireDefault(_uiRegistry_registry);
	
	exports['default'] = (0, _uiRegistry_registry2['default'])({
	  name: 'visTypes',
	  index: ['name'],
	  order: ['title']
	});
	module.exports = exports['default'];

/***/ },
/* 918 */,
/* 919 */,
/* 920 */,
/* 921 */,
/* 922 */,
/* 923 */,
/* 924 */,
/* 925 */,
/* 926 */,
/* 927 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name Vis
	 *
	 * @description This class consists of aggs, params, listeners, title, and type.
	 *  - Aggs: Instances of AggConfig.
	 *  - Params: The settings in the Options tab.
	 *
	 * Not to be confused with vislib/vis.js.
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = VisFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesIndex = __webpack_require__(928);
	
	var _uiAgg_typesIndex2 = _interopRequireDefault(_uiAgg_typesIndex);
	
	var _uiRegistryVis_types = __webpack_require__(917);
	
	var _uiRegistryVis_types2 = _interopRequireDefault(_uiRegistryVis_types);
	
	var _uiVisAgg_configs = __webpack_require__(1007);
	
	var _uiVisAgg_configs2 = _interopRequireDefault(_uiVisAgg_configs);
	
	var _uiPersisted_state = __webpack_require__(417);
	
	function VisFactory(Notifier, Private) {
	
	  var aggTypes = Private(_uiAgg_typesIndex2['default']);
	  var visTypes = Private(_uiRegistryVis_types2['default']);
	  var AggConfigs = Private(_uiVisAgg_configs2['default']);
	
	  var notify = new Notifier({
	    location: 'Vis'
	  });
	
	  function Vis(indexPattern, state, uiState) {
	    state = state || {};
	
	    if (_lodash2['default'].isString(state)) {
	      state = {
	        type: state
	      };
	    }
	
	    this.indexPattern = indexPattern;
	
	    this.setState(state);
	    this.setUiState(uiState);
	  }
	
	  Vis.convertOldState = function (type, oldState) {
	    if (!type || _lodash2['default'].isString(type)) {
	      type = visTypes.byName[type || 'histogram'];
	    }
	
	    var schemas = type.schemas;
	
	    // This was put in place to do migrations at runtime. It's used to support people who had saved
	    // visualizations during the 4.0 betas.
	    var aggs = _lodash2['default'].transform(oldState, function (newConfigs, oldConfigs, oldGroupName) {
	      var schema = schemas.all.byName[oldGroupName];
	
	      if (!schema) {
	        notify.log('unable to match old schema', oldGroupName, 'to a new schema');
	        return;
	      }
	
	      oldConfigs.forEach(function (oldConfig) {
	        var agg = {
	          schema: schema.name,
	          type: oldConfig.agg
	        };
	
	        var aggType = aggTypes.byName[agg.type];
	        if (!aggType) {
	          notify.log('unable to find an agg type for old confg', oldConfig);
	          return;
	        }
	
	        agg.params = _lodash2['default'].pick(oldConfig, _lodash2['default'].keys(aggType.params.byName));
	
	        newConfigs.push(agg);
	      });
	    }, []);
	
	    return {
	      type: type,
	      aggs: aggs
	    };
	  };
	
	  Vis.prototype.type = 'histogram';
	
	  Vis.prototype.setState = function (state) {
	    this.title = state.title || '';
	    var type = state.type || this.type;
	    if (_lodash2['default'].isString(type)) {
	      this.type = visTypes.byName[type];
	      if (!this.type) {
	        throw new Error('Invalid type "' + type + '"');
	      }
	    } else {
	      this.type = type;
	    }
	
	    this.listeners = _lodash2['default'].assign({}, state.listeners, this.type.listeners);
	    this.params = _lodash2['default'].defaults({}, _lodash2['default'].cloneDeep(state.params || {}), _lodash2['default'].cloneDeep(this.type.params.defaults || {}));
	
	    this.aggs = new AggConfigs(this, state.aggs);
	  };
	
	  Vis.prototype.getStateInternal = function (includeDisabled) {
	    return {
	      title: this.title,
	      type: this.type.name,
	      params: this.params,
	      aggs: this.aggs.filter(function (agg) {
	        return includeDisabled || agg.enabled;
	      }).map(function (agg) {
	        return agg.toJSON();
	      }).filter(Boolean),
	      listeners: this.listeners
	    };
	  };
	
	  Vis.prototype.getEnabledState = function () {
	    return this.getStateInternal(false);
	  };
	
	  Vis.prototype.getState = function () {
	    return this.getStateInternal(true);
	  };
	
	  Vis.prototype.createEditableVis = function () {
	    return this._editableVis || (this._editableVis = this.clone());
	  };
	
	  Vis.prototype.getEditableVis = function () {
	    return this._editableVis || undefined;
	  };
	
	  Vis.prototype.clone = function () {
	    var uiJson = this.hasUiState() ? this.getUiState().toJSON() : {};
	    return new Vis(this.indexPattern, this.getState(), uiJson);
	  };
	
	  Vis.prototype.requesting = function () {
	    // Invoke requesting() on each agg. Aggs is an instance of AggConfigs.
	    _lodash2['default'].invoke(this.aggs.getRequestAggs(), 'requesting');
	  };
	
	  Vis.prototype.isHierarchical = function () {
	    if (_lodash2['default'].isFunction(this.type.hierarchicalData)) {
	      return !!this.type.hierarchicalData(this);
	    } else {
	      return !!this.type.hierarchicalData;
	    }
	  };
	
	  Vis.prototype.hasSchemaAgg = function (schemaName, aggTypeName) {
	    var aggs = this.aggs.bySchemaName[schemaName] || [];
	    return aggs.some(function (agg) {
	      if (!agg.type || !agg.type.name) return false;
	      return agg.type.name === aggTypeName;
	    });
	  };
	
	  Vis.prototype.hasUiState = function () {
	    return !!this.__uiState;
	  };
	  Vis.prototype.setUiState = function (uiState) {
	    if (uiState instanceof _uiPersisted_state.PersistedState) {
	      this.__uiState = uiState;
	    }
	  };
	  Vis.prototype.getUiState = function () {
	    return this.__uiState;
	  };
	
	  Vis.prototype.implementsRenderComplete = function () {
	    return this.type.implementsRenderComplete;
	  };
	
	  /**
	   * Currently this is only used to extract map-specific information
	   * (e.g. mapZoom, mapCenter).
	   */
	  Vis.prototype.uiStateVal = function (key, val) {
	    if (this.hasUiState()) {
	      if (_lodash2['default'].isUndefined(val)) {
	        return this.__uiState.get(key);
	      }
	      return this.__uiState.set(key, val);
	    }
	    return val;
	  };
	
	  return Vis;
	}
	
	module.exports = exports['default'];

/***/ },
/* 928 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$keys = __webpack_require__(26)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeService;
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	__webpack_require__(929);
	
	var _uiAgg_typesMetricsCount = __webpack_require__(940);
	
	var _uiAgg_typesMetricsCount2 = _interopRequireDefault(_uiAgg_typesMetricsCount);
	
	var _uiAgg_typesMetricsAvg = __webpack_require__(943);
	
	var _uiAgg_typesMetricsAvg2 = _interopRequireDefault(_uiAgg_typesMetricsAvg);
	
	var _uiAgg_typesMetricsSum = __webpack_require__(944);
	
	var _uiAgg_typesMetricsSum2 = _interopRequireDefault(_uiAgg_typesMetricsSum);
	
	var _uiAgg_typesMetricsMedian = __webpack_require__(945);
	
	var _uiAgg_typesMetricsMedian2 = _interopRequireDefault(_uiAgg_typesMetricsMedian);
	
	var _uiAgg_typesMetricsMin = __webpack_require__(955);
	
	var _uiAgg_typesMetricsMin2 = _interopRequireDefault(_uiAgg_typesMetricsMin);
	
	var _uiAgg_typesMetricsMax = __webpack_require__(956);
	
	var _uiAgg_typesMetricsMax2 = _interopRequireDefault(_uiAgg_typesMetricsMax);
	
	var _uiAgg_typesMetricsTop_hit = __webpack_require__(957);
	
	var _uiAgg_typesMetricsTop_hit2 = _interopRequireDefault(_uiAgg_typesMetricsTop_hit);
	
	var _uiAgg_typesMetricsStd_deviation = __webpack_require__(960);
	
	var _uiAgg_typesMetricsStd_deviation2 = _interopRequireDefault(_uiAgg_typesMetricsStd_deviation);
	
	var _uiAgg_typesMetricsCardinality = __webpack_require__(961);
	
	var _uiAgg_typesMetricsCardinality2 = _interopRequireDefault(_uiAgg_typesMetricsCardinality);
	
	var _uiAgg_typesMetricsPercentiles = __webpack_require__(946);
	
	var _uiAgg_typesMetricsPercentiles2 = _interopRequireDefault(_uiAgg_typesMetricsPercentiles);
	
	var _uiAgg_typesMetricsPercentile_ranks = __webpack_require__(962);
	
	var _uiAgg_typesMetricsPercentile_ranks2 = _interopRequireDefault(_uiAgg_typesMetricsPercentile_ranks);
	
	var _uiAgg_typesBucketsDate_histogram = __webpack_require__(964);
	
	var _uiAgg_typesBucketsDate_histogram2 = _interopRequireDefault(_uiAgg_typesBucketsDate_histogram);
	
	var _uiAgg_typesBucketsHistogram = __webpack_require__(974);
	
	var _uiAgg_typesBucketsHistogram2 = _interopRequireDefault(_uiAgg_typesBucketsHistogram);
	
	var _uiAgg_typesBucketsRange = __webpack_require__(978);
	
	var _uiAgg_typesBucketsRange2 = _interopRequireDefault(_uiAgg_typesBucketsRange);
	
	var _uiAgg_typesBucketsDate_range = __webpack_require__(982);
	
	var _uiAgg_typesBucketsDate_range2 = _interopRequireDefault(_uiAgg_typesBucketsDate_range);
	
	var _uiAgg_typesBucketsIp_range = __webpack_require__(986);
	
	var _uiAgg_typesBucketsIp_range2 = _interopRequireDefault(_uiAgg_typesBucketsIp_range);
	
	var _uiAgg_typesBucketsTerms = __webpack_require__(989);
	
	var _uiAgg_typesBucketsTerms2 = _interopRequireDefault(_uiAgg_typesBucketsTerms);
	
	var _uiAgg_typesBucketsFilters = __webpack_require__(999);
	
	var _uiAgg_typesBucketsFilters2 = _interopRequireDefault(_uiAgg_typesBucketsFilters);
	
	var _uiAgg_typesBucketsSignificant_terms = __webpack_require__(1003);
	
	var _uiAgg_typesBucketsSignificant_terms2 = _interopRequireDefault(_uiAgg_typesBucketsSignificant_terms);
	
	var _uiAgg_typesBucketsGeo_hash = __webpack_require__(1004);
	
	var _uiAgg_typesBucketsGeo_hash2 = _interopRequireDefault(_uiAgg_typesBucketsGeo_hash);
	
	function AggTypeService(Private) {
	
	  var aggs = {
	    metrics: [Private(_uiAgg_typesMetricsCount2['default']), Private(_uiAgg_typesMetricsAvg2['default']), Private(_uiAgg_typesMetricsSum2['default']), Private(_uiAgg_typesMetricsMedian2['default']), Private(_uiAgg_typesMetricsMin2['default']), Private(_uiAgg_typesMetricsMax2['default']), Private(_uiAgg_typesMetricsStd_deviation2['default']), Private(_uiAgg_typesMetricsCardinality2['default']), Private(_uiAgg_typesMetricsPercentiles2['default']), Private(_uiAgg_typesMetricsPercentile_ranks2['default']), Private(_uiAgg_typesMetricsTop_hit2['default'])],
	    buckets: [Private(_uiAgg_typesBucketsDate_histogram2['default']), Private(_uiAgg_typesBucketsHistogram2['default']), Private(_uiAgg_typesBucketsRange2['default']), Private(_uiAgg_typesBucketsDate_range2['default']), Private(_uiAgg_typesBucketsIp_range2['default']), Private(_uiAgg_typesBucketsTerms2['default']), Private(_uiAgg_typesBucketsFilters2['default']), Private(_uiAgg_typesBucketsSignificant_terms2['default']), Private(_uiAgg_typesBucketsGeo_hash2['default'])]
	  };
	
	  _Object$keys(aggs).forEach(function (type) {
	    aggs[type].forEach(function (agg) {
	      agg.type = type;
	    });
	  });
	
	  /**
	   * IndexedArray of Aggregation Types.
	   *
	   * These types form two groups, metric and buckets.
	   *
	   * @module agg_types
	   * @type {IndexedArray}
	   */
	  return new _uiIndexed_array2['default']({
	
	    /**
	     * @type {Array}
	     */
	    index: ['name'],
	
	    /**
	     * [group description]
	     * @type {Array}
	     */
	    group: ['type'],
	    initialSet: aggs.metrics.concat(aggs.buckets)
	  });
	}
	
	// preload
	module.exports = exports['default'];

/***/ },
/* 929 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggParamsFactory;
	
	__webpack_require__(777);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	var _uiAgg_typesParam_typesField = __webpack_require__(930);
	
	var _uiAgg_typesParam_typesField2 = _interopRequireDefault(_uiAgg_typesParam_typesField);
	
	var _uiAgg_typesParam_typesOptioned = __webpack_require__(933);
	
	var _uiAgg_typesParam_typesOptioned2 = _interopRequireDefault(_uiAgg_typesParam_typesOptioned);
	
	var _uiAgg_typesParam_typesRegex = __webpack_require__(934);
	
	var _uiAgg_typesParam_typesRegex2 = _interopRequireDefault(_uiAgg_typesParam_typesRegex);
	
	var _uiAgg_typesParam_typesString = __webpack_require__(936);
	
	var _uiAgg_typesParam_typesString2 = _interopRequireDefault(_uiAgg_typesParam_typesString);
	
	var _uiAgg_typesParam_typesRaw_json = __webpack_require__(938);
	
	var _uiAgg_typesParam_typesRaw_json2 = _interopRequireDefault(_uiAgg_typesParam_typesRaw_json);
	
	var _uiAgg_typesParam_typesBase = __webpack_require__(932);
	
	var _uiAgg_typesParam_typesBase2 = _interopRequireDefault(_uiAgg_typesParam_typesBase);
	
	function AggParamsFactory(Private) {
	
	  var paramTypeMap = {
	    field: Private(_uiAgg_typesParam_typesField2['default']),
	    optioned: Private(_uiAgg_typesParam_typesOptioned2['default']),
	    regex: Private(_uiAgg_typesParam_typesRegex2['default']),
	    string: Private(_uiAgg_typesParam_typesString2['default']),
	    json: Private(_uiAgg_typesParam_typesRaw_json2['default']),
	    _default: Private(_uiAgg_typesParam_typesBase2['default'])
	  };
	
	  /**
	   * Wraps a list of {{#crossLink "AggParam"}}{{/crossLink}} objects; owned by an {{#crossLink "AggType"}}{{/crossLink}}
	   *
	   * used to create:
	   *   - `FieldAggParam`  When the config has `name: "field"`
	   *   - `*AggParam`  When the type matches something in the map above
	   *   - `BaseAggParam`  All other params
	   *
	   * @class AggParams
	   * @constructor
	   * @extends IndexedArray
	   * @param {object[]} params - array of params that get new-ed up as AggParam objects as descibed above
	   */
	  _lodash2['default']['class'](AggParams).inherits(_uiIndexed_array2['default']);
	  function AggParams(params) {
	    AggParams.Super.call(this, {
	      index: ['name'],
	      initialSet: params.map(function (config) {
	        var type = config.name === 'field' ? config.name : config.type;
	        var Class = paramTypeMap[type] || paramTypeMap._default;
	        return new Class(config);
	      })
	    });
	  }
	
	  /**
	   * Reads an aggConfigs
	   *
	   * @method write
	   * @param  {AggConfig} aggConfig
	   *         the AggConfig object who's type owns these aggParams and contains the param values for our param defs
	   * @param  {object} [locals]
	   *         an array of locals that will be available to the write function (can be used to enhance
	   *         the quality of things like date_histogram's "auto" interval)
	   * @return {object} output
	   *         output of the write calls, reduced into a single object. A `params: {}` property is exposed on the
	   *         output object which is used to create the agg dsl for the search request. All other properties
	   *         are dependent on the AggParam#write methods which should be studied for each AggType.
	   */
	  AggParams.prototype.write = function (aggConfig, locals) {
	    var output = { params: {} };
	    locals = locals || {};
	
	    this.forEach(function (param) {
	      if (param.write) {
	        param.write(aggConfig, output, locals);
	      } else {
	        output.params[param.name] = aggConfig.params[param.name];
	      }
	    });
	
	    return output;
	  };
	
	  return AggParams;
	}
	
	module.exports = exports['default'];

/***/ },
/* 930 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FieldAggParamFactory;
	
	var _uiErrors = __webpack_require__(359);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesControlsFieldHtml = __webpack_require__(931);
	
	var _uiAgg_typesControlsFieldHtml2 = _interopRequireDefault(_uiAgg_typesControlsFieldHtml);
	
	var _uiAgg_typesParam_typesBase = __webpack_require__(932);
	
	var _uiAgg_typesParam_typesBase2 = _interopRequireDefault(_uiAgg_typesParam_typesBase);
	
	__webpack_require__(775);
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	function FieldAggParamFactory(Private, $filter) {
	  var BaseAggParam = Private(_uiAgg_typesParam_typesBase2['default']);
	  var notifier = new _uiNotifyNotifier2['default']();
	
	  _lodash2['default']['class'](FieldAggParam).inherits(BaseAggParam);
	  function FieldAggParam(config) {
	    FieldAggParam.Super.call(this, config);
	  }
	
	  FieldAggParam.prototype.editor = _uiAgg_typesControlsFieldHtml2['default'];
	  FieldAggParam.prototype.scriptable = true;
	  FieldAggParam.prototype.filterFieldTypes = '*';
	  // retain only the fields with the aggregatable property if the onlyAggregatable option is true
	  FieldAggParam.prototype.onlyAggregatable = true;
	  // show a warning about the field being analyzed
	  FieldAggParam.prototype.showAnalyzedWarning = true;
	
	  /**
	   * Called to serialize values for saving an aggConfig object
	   *
	   * @param  {field} field - the field that was selected
	   * @return {string}
	   */
	  FieldAggParam.prototype.serialize = function (field) {
	    return field.name;
	  };
	
	  /**
	   * Get the options for this field from the indexPattern
	   */
	  FieldAggParam.prototype.getFieldOptions = function (aggConfig) {
	    var indexPattern = aggConfig.getIndexPattern();
	    var fields = indexPattern.fields.raw;
	
	    if (this.onlyAggregatable) {
	      fields = fields.filter(function (f) {
	        return f.aggregatable;
	      });
	    }
	
	    if (!this.scriptable) {
	      fields = fields.filter(function (field) {
	        return !field.scripted;
	      });
	    }
	
	    if (this.filterFieldTypes) {
	      var filters = this.filterFieldTypes;
	      if (_lodash2['default'].isFunction(this.filterFieldTypes)) {
	        filters = this.filterFieldTypes.bind(this, aggConfig.vis);
	      }
	      fields = $filter('fieldType')(fields, filters);
	      fields = $filter('orderBy')(fields, ['type', 'name']);
	    }
	
	    return new _uiIndexed_array2['default']({
	      index: ['name'],
	      group: ['type'],
	      initialSet: fields
	    });
	  };
	
	  /**
	   * Called to read values from a database record into the
	   * aggConfig object
	   *
	   * @param  {string} fieldName
	   * @return {field}
	   */
	  FieldAggParam.prototype.deserialize = function (fieldName, aggConfig) {
	    var field = aggConfig.getIndexPattern().fields.byName[fieldName];
	
	    if (!field) {
	      throw new _uiErrors.SavedObjectNotFound('index-pattern-field', fieldName);
	    }
	
	    var validField = this.getFieldOptions(aggConfig).byName[fieldName];
	    if (!validField) {
	      notifier.error('Saved "field" parameter is now invalid. Please select a new field.');
	    }
	
	    return validField;
	  };
	
	  /**
	   * Write the aggregation parameter.
	   *
	   * @param  {AggConfig} aggConfig - the entire configuration for this agg
	   * @param  {object} output - the result of calling write on all of the aggregations
	   *                         parameters.
	   * @param  {object} output.params - the final object that will be included as the params
	   *                               for the agg
	   * @return {undefined}
	   */
	  FieldAggParam.prototype.write = function (aggConfig, output) {
	    var field = aggConfig.getField();
	
	    if (!field) {
	      throw new TypeError('"field" is a required parameter');
	    }
	
	    if (field.scripted) {
	      output.params.script = {
	        inline: field.script,
	        lang: field.lang
	      };
	    } else {
	      output.params.field = field.name;
	    }
	  };
	
	  return FieldAggParam;
	}
	
	module.exports = exports['default'];

/***/ },
/* 931 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label for=\"field\">\n    Field\n  </label>\n\n  <span class=\"pull-right text-warning hintbox-label\" ng-show=\"aggParam.showAnalyzedWarning && agg.params.field.analyzed\"\n      ng-click=\"showAnalyzedFieldWarning = !showAnalyzedFieldWarning\">\n    <i class=\"fa fa-warning\"></i> Analyzed Field\n  </span>\n  <div class=\"hintbox\" ng-show=\"showAnalyzedFieldWarning && agg.params.field.analyzed\">\n    <p>\n    <strong>Careful!</strong> The field selected contains analyzed strings. Analyzed strings are highly unique and can use a lot of memory to visualize. Values such as <i>foo-bar</i> will be broken into <i>foo</i> and <i>bar</i>. See <a href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html\" target=\"_blank\">Mapping Types</a> for more information on setting this field as <i>keyword</i> (not analyzed).\n    </p>\n\n    <p ng-show=\"indexedFields.byName[agg.params.field.name + '.keyword'].analyzed == false\">\n      <strong>Tip:</strong> <i>{{agg.params.field.name + '.keyword'}}</i> may be a non analyzed version of this field.\n    </p>\n\n    <p ng-show=\"indexedFields.byName[agg.params.field.name + '.raw'].analyzed == false\">\n      <strong>Tip:</strong> <i>{{agg.params.field.name + '.raw'}}</i> may be a non analyzed version of this field.\n    </p>\n  </div>\n\n  <select\n    class=\"form-control\"\n    name=\"field\"\n    required\n    ng-model=\"agg.params.field\"\n    ng-show=\"indexedFields.length\"\n    auto-select-if-only-one=\"indexedFields\"\n    ng-options=\"field as field.displayName group by field.type for field in indexedFields\"\n    ng-change=\"aggParam.onChange(agg)\">\n  </select>\n\n  <div class=\"hintbox\" ng-if=\"!indexedFields.length\">\n    <p>\n      <i class=\"fa fa-danger text-danger\"></i>\n      <strong>No Compatible Fields:</strong> The \"{{ vis.indexPattern.id }}\" index pattern does not contain any of the following field types: {{ agg.type.params.byName.field.filterFieldTypes | commaList:false }}\n    </p>\n  </div>\n\n</div>\n"

/***/ },
/* 932 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = BaseAggParamFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function BaseAggParamFactory() {
	
	  function BaseAggParam(config) {
	    _lodash2['default'].assign(this, config);
	  }
	
	  return BaseAggParam;
	}
	
	module.exports = exports['default'];

/***/ },
/* 933 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = OptionedAggParamFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	var _uiAgg_typesParam_typesBase = __webpack_require__(932);
	
	var _uiAgg_typesParam_typesBase2 = _interopRequireDefault(_uiAgg_typesParam_typesBase);
	
	function OptionedAggParamFactory(Private) {
	
	  var BaseAggParam = Private(_uiAgg_typesParam_typesBase2['default']);
	
	  _lodash2['default']['class'](OptionedAggParam).inherits(BaseAggParam);
	  function OptionedAggParam(config) {
	    OptionedAggParam.Super.call(this, config);
	
	    this.options = new _uiIndexed_array2['default']({
	      index: ['val'],
	      immutable: true,
	      initialSet: this.options
	    });
	  }
	
	  /**
	   * Serialize a selection to be stored in the database
	   * @param  {object} selected - the option that was selected
	   * @return {any}
	   */
	  OptionedAggParam.prototype.serialize = function (selected) {
	    return selected.val;
	  };
	
	  /**
	   * Take a value that was serialized to the database and
	   * return the option that is represents
	   *
	   * @param  {any} val - the value that was saved
	   * @return {object}
	   */
	  OptionedAggParam.prototype.deserialize = function (val) {
	    return this.options.byVal[val];
	  };
	
	  /**
	   * Write the aggregation parameter.
	   *
	   * @param  {AggConfig} aggConfig - the entire configuration for this agg
	   * @param  {object} output - the result of calling write on all of the aggregations
	   *                         parameters.
	   * @param  {object} output.params - the final object that will be included as the params
	   *                               for the agg
	   * @return {undefined}
	   */
	  OptionedAggParam.prototype.write = function (aggConfig, output) {
	    output.params[this.name] = aggConfig.params[this.name].val;
	  };
	
	  return OptionedAggParam;
	}
	
	module.exports = exports['default'];

/***/ },
/* 934 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RegexAggParamFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesControlsRegular_expressionHtml = __webpack_require__(935);
	
	var _uiAgg_typesControlsRegular_expressionHtml2 = _interopRequireDefault(_uiAgg_typesControlsRegular_expressionHtml);
	
	var _uiAgg_typesParam_typesBase = __webpack_require__(932);
	
	var _uiAgg_typesParam_typesBase2 = _interopRequireDefault(_uiAgg_typesParam_typesBase);
	
	function RegexAggParamFactory(Private) {
	
	  var BaseAggParam = Private(_uiAgg_typesParam_typesBase2['default']);
	
	  _lodash2['default']['class'](RegexAggParam).inherits(BaseAggParam);
	  function RegexAggParam(config) {
	    _lodash2['default'].defaults(config, { pattern: '' });
	    RegexAggParam.Super.call(this, config);
	  }
	
	  RegexAggParam.prototype.editor = _uiAgg_typesControlsRegular_expressionHtml2['default'];
	
	  /**
	   * Disabled state of the agg param
	   *
	   * @return {bool}
	   */
	  RegexAggParam.prototype.disabled = function (aggConfig) {
	    return false;
	  };
	
	  /**
	   * Write the aggregation parameter.
	   *
	   * @param  {AggConfig} aggConfig - the entire configuration for this agg
	   * @param  {object} output - the result of calling write on all of the aggregations
	   *                         parameters.
	   * @param  {object} output.params - the final object that will be included as the params
	   *                               for the agg
	   * @return {undefined}
	   */
	  RegexAggParam.prototype.write = function (aggConfig, output) {
	    var param = aggConfig.params[this.name];
	    var paramType = aggConfig.type.params.byName[this.name];
	
	    // clear aggParam if pattern is not set or is disabled
	    if (!param || !param.pattern || !param.pattern.length || paramType.disabled(aggConfig)) {
	      return;
	    }
	
	    var obj = {
	      pattern: param.pattern
	    };
	
	    output.params[this.name] = obj;
	  };
	
	  return RegexAggParam;
	}
	
	module.exports = exports['default'];

/***/ },
/* 935 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"!aggParam.disabled(agg)\">\n  <div class=\"form-group regex\">\n    <label>{{ aggParam.name | label }} Pattern</label>\n    <input\n      type=\"text\"\n      class=\"form-control\"\n      ng-model=\"agg.params[aggParam.name].pattern\"\n    >\n  </div>\n</div>\n"

/***/ },
/* 936 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FieldAggParamFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesControlsStringHtml = __webpack_require__(937);
	
	var _uiAgg_typesControlsStringHtml2 = _interopRequireDefault(_uiAgg_typesControlsStringHtml);
	
	var _uiAgg_typesParam_typesBase = __webpack_require__(932);
	
	var _uiAgg_typesParam_typesBase2 = _interopRequireDefault(_uiAgg_typesParam_typesBase);
	
	function FieldAggParamFactory(Private) {
	
	  var BaseAggParam = Private(_uiAgg_typesParam_typesBase2['default']);
	
	  _lodash2['default']['class'](ScriptAggParam).inherits(BaseAggParam);
	  function ScriptAggParam(config) {
	    ScriptAggParam.Super.call(this, config);
	  }
	
	  ScriptAggParam.prototype.editor = _uiAgg_typesControlsStringHtml2['default'];
	
	  /**
	   * Write the aggregation parameter.
	   *
	   * @param  {AggConfig} aggConfig - the entire configuration for this agg
	   * @param  {object} output - the result of calling write on all of the aggregations
	   *                         parameters.
	   * @param  {object} output.params - the final object that will be included as the params
	   *                               for the agg
	   * @return {undefined}
	   */
	  ScriptAggParam.prototype.write = function (aggConfig, output) {
	    if (aggConfig.params[this.name] && aggConfig.params[this.name].length) {
	      output.params[this.name] = aggConfig.params[this.name];
	    }
	  };
	
	  return ScriptAggParam;
	}
	
	module.exports = exports['default'];

/***/ },
/* 937 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>{{ aggParam.name | label }}</label>\n  <div>\n    <input type=\"text\" ng-model=\"agg.params[aggParam.name]\" class=\"form-control\">\n  </div>\n</div>"

/***/ },
/* 938 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RawJSONAggParamFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesControlsRaw_jsonHtml = __webpack_require__(939);
	
	var _uiAgg_typesControlsRaw_jsonHtml2 = _interopRequireDefault(_uiAgg_typesControlsRaw_jsonHtml);
	
	var _uiAgg_typesParam_typesBase = __webpack_require__(932);
	
	var _uiAgg_typesParam_typesBase2 = _interopRequireDefault(_uiAgg_typesParam_typesBase);
	
	function RawJSONAggParamFactory(Private) {
	
	  var BaseAggParam = Private(_uiAgg_typesParam_typesBase2['default']);
	
	  _lodash2['default']['class'](RawJSONAggParam).inherits(BaseAggParam);
	  function RawJSONAggParam(config) {
	    // force name override
	    config = _lodash2['default'].defaults(config, { name: 'json' });
	    RawJSONAggParam.Super.call(this, config);
	  }
	
	  RawJSONAggParam.prototype.editor = _uiAgg_typesControlsRaw_jsonHtml2['default'];
	
	  /**
	   * Write the aggregation parameter.
	   *
	   * @param  {AggConfig} aggConfig - the entire configuration for this agg
	   * @param  {object} output - the result of calling write on all of the aggregations
	   *                         parameters.
	   * @param  {object} output.params - the final object that will be included as the params
	   *                               for the agg
	   * @return {undefined}
	   */
	  RawJSONAggParam.prototype.write = function (aggConfig, output) {
	    var paramJSON = undefined;
	    var param = aggConfig.params[this.name];
	
	    if (!param) {
	      return;
	    }
	
	    // handle invalid JSON input
	    try {
	      paramJSON = JSON.parse(param);
	    } catch (err) {
	      return;
	    }
	
	    function filteredCombine(srcA, srcB) {
	      function mergeObjs(a, b) {
	        return (0, _lodash2['default'])(a).keys().union(_lodash2['default'].keys(b)).transform(function (dest, key) {
	          var val = compare(a[key], b[key]);
	          if (val !== undefined) dest[key] = val;
	        }, {}).value();
	      }
	
	      function mergeArrays(a, b) {
	        // attempt to merge each value
	        return _lodash2['default'].times(Math.max(a.length, b.length), function (i) {
	          return compare(a[i], b[i]);
	        });
	      }
	
	      function compare(a, b) {
	        if (_lodash2['default'].isPlainObject(a) && _lodash2['default'].isPlainObject(b)) return mergeObjs(a, b);
	        if (_lodash2['default'].isArray(a) && _lodash2['default'].isArray(b)) return mergeArrays(a, b);
	        if (b === null) return undefined;
	        if (b !== undefined) return b;
	        return a;
	      }
	
	      return compare(srcA, srcB);
	    }
	
	    output.params = filteredCombine(output.params, paramJSON);
	    return;
	  };
	
	  return RawJSONAggParam;
	}
	
	module.exports = exports['default'];

/***/ },
/* 939 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group regex\">\n    <span class=\"hintbox-label\" ng-click=\"showJsonHint = !showJsonHint\">\n      <label>JSON Input</label>\n      <i class=\"fa fa-info-circle\"></i>\n    </span>\n    <div class=\"hintbox\" ng-show=\"showJsonHint\">\n      <p>\n        Any JSON formatted properties you add here will be merged with the elasticsearch aggregation definition for this section. For example <i>shard_size</i> on a <i>terms</i> aggregation\n      </p>\n    </div>\n  <p>\n    <textarea\n      type=\"text\"\n      class=\"form-control\"\n      ng-model=\"agg.params.json\"\n      validate-json\n      ></textarea>\n  </p>\n</div>\n"

/***/ },
/* 940 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricCountProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	function AggTypeMetricCountProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  return new MetricAggType({
	    name: 'count',
	    title: 'Count',
	    hasNoDsl: true,
	    makeLabel: function makeLabel() {
	      return 'Count';
	    },
	    getFormat: function getFormat() {
	      return fieldFormats.getDefaultInstance('number');
	    },
	    getValue: function getValue(agg, bucket) {
	      return bucket.doc_count;
	    }
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 941 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = MetricAggTypeProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesAgg_type = __webpack_require__(942);
	
	var _uiAgg_typesAgg_type2 = _interopRequireDefault(_uiAgg_typesAgg_type);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	function MetricAggTypeProvider(Private) {
	  var AggType = Private(_uiAgg_typesAgg_type2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  _lodash2['default']['class'](MetricAggType).inherits(AggType);
	  function MetricAggType(config) {
	    MetricAggType.Super.call(this, config);
	
	    // allow overriding any value on the prototype
	    _lodash2['default'].forOwn(config, function (val, key) {
	      if (_lodash2['default'].has(MetricAggType.prototype, key)) {
	        this[key] = val;
	      }
	    }, this);
	  }
	
	  /**
	   * Read the values for this metric from the
	   * @param  {[type]} bucket [description]
	   * @return {*}        [description]
	   */
	  MetricAggType.prototype.getValue = function (agg, bucket) {
	    // Metric types where an empty set equals `zero`
	    var isSettableToZero = ['cardinality', 'sum'].indexOf(agg.__type.name) !== -1;
	
	    // Return proper values when no buckets are present
	    // `Count` handles empty sets properly
	    if (!bucket[agg.id] && isSettableToZero) return 0;
	
	    return bucket[agg.id] && bucket[agg.id].value;
	  };
	
	  /**
	   * Pick a format for the values produced by this agg type,
	   * overriden by several metrics that always output a simple
	   * number
	   *
	   * @param  {agg} agg - the agg to pick a format for
	   * @return {FieldFromat}
	   */
	  MetricAggType.prototype.getFormat = function (agg) {
	    var field = agg.getField();
	    return field ? field.format : fieldFormats.getDefaultInstance('number');
	  };
	
	  return MetricAggType;
	}
	
	module.exports = exports['default'];

/***/ },
/* 942 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesAgg_params = __webpack_require__(929);
	
	var _uiAgg_typesAgg_params2 = _interopRequireDefault(_uiAgg_typesAgg_params);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	function AggTypeFactory(Private) {
	  var AggParams = Private(_uiAgg_typesAgg_params2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  /**
	   * Generic AggType Constructor
	   *
	   * Used to create the values exposed by the agg_types module.
	   *
	   * @class AggType
	   * @private
	   * @param {object} config - used to set the properties of the AggType
	   */
	  function AggType(config) {
	
	    /**
	     * the unique, unchanging, name that we have assigned this aggType
	     *
	     * @property name
	     * @type {string}
	     */
	    this.name = config.name;
	
	    /**
	     * the name of the elasticsearch aggregation that this aggType represents. Usually just this.name
	     *
	     * @property name
	     * @type {string}
	     */
	    this.dslName = config.dslName || config.name;
	
	    /**
	     * the user friendly name that will be shown in the ui for this aggType
	     *
	     * @property title
	     * @type {string}
	     */
	    this.title = config.title;
	
	    /**
	     * a function that will be called when this aggType is assigned to
	     * an aggConfig, and that aggConfig is being rendered (in a form, chart, etc.).
	     *
	     * @method makeLabel
	     * @param {AggConfig} aggConfig - an agg config of this type
	     * @returns {string} - label that can be used in the ui to descripe the aggConfig
	     */
	    this.makeLabel = config.makeLabel || _lodash2['default'].constant(this.name);
	
	    /**
	     * Describes if this aggType creates data that is ordered, and if that ordered data
	     * is some sort of time series.
	     *
	     * If the aggType does not create ordered data, set this to something "falsey".
	     *
	     * If this does create orderedData, then the value should be an object.
	     *
	     * If the orderdata is some sort of time series, `this.ordered` should be an object
	     * with the property `date: true`
	     *
	     * @property ordered
	     * @type {object|undefined}
	     */
	    this.ordered = config.ordered;
	
	    /**
	     * Flag that prevents this aggregation from being included in the dsl. This is only
	     * used by the count aggregation (currently) since it doesn't really exist and it's output
	     * is available on every bucket.
	     *
	     * @type {Boolean}
	     */
	    this.hasNoDsl = !!config.hasNoDsl;
	
	    /**
	     * The method to create a filter representation of the bucket
	     * @param {object} aggConfig The instance of the aggConfig
	     * @param {mixed} key The key for the bucket
	     * @returns {object} The filter
	     */
	    this.createFilter = config.createFilter;
	
	    /**
	     * An instance of {{#crossLink "AggParams"}}{{/crossLink}}.
	     *
	     * @property params
	     * @type {AggParams}
	     */
	    this.params = config.params || [];
	    if (!(this.params instanceof AggParams)) {
	      // always append the raw JSON param
	      this.params.push({
	        name: 'json',
	        type: 'json',
	        advanced: true
	      });
	      // always append custom label
	
	      if (config.customLabels !== false) {
	        this.params.push({
	          name: 'customLabel',
	          type: 'string',
	          write: _lodash2['default'].noop
	        });
	      }
	
	      this.params = new AggParams(this.params);
	    }
	
	    /**
	     * Designed for multi-value metric aggs, this method can return a
	     * set of AggConfigs that should replace this aggConfig in result sets
	     * that walk the AggConfig set.
	     *
	     * @method getResponseAggs
	     * @returns {array[AggConfig]|undefined} - an array of aggConfig objects
	     *                                         that should replace this one,
	     *                                         or undefined
	     */
	    this.getResponseAggs = config.getResponseAggs || _lodash2['default'].noop;
	
	    /**
	     * A function that will be called each time an aggConfig of this type
	     * is created, giving the agg type a chance to modify the agg config
	     */
	    this.decorateAggConfig = config.decorateAggConfig || null;
	
	    if (config.getFormat) {
	      this.getFormat = config.getFormat;
	    }
	  }
	
	  /**
	   * Pick a format for the values produced by this agg type,
	   * overriden by several metrics that always output a simple
	   * number
	   *
	   * @param  {agg} agg - the agg to pick a format for
	   * @return {FieldFromat}
	   */
	  AggType.prototype.getFormat = function (agg) {
	    var field = agg.getField();
	    return field ? field.format : fieldFormats.getDefaultInstance('string');
	  };
	
	  return AggType;
	}
	
	module.exports = exports['default'];

/***/ },
/* 943 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricAvgProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	function AggTypeMetricAvgProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	
	  return new MetricAggType({
	    name: 'avg',
	    title: 'Average',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Average ' + aggConfig.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 944 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricSumProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	function AggTypeMetricSumProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	
	  return new MetricAggType({
	    name: 'sum',
	    title: 'Sum',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Sum of ' + aggConfig.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 945 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricMedianProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiAgg_typesMetricsPercentiles = __webpack_require__(946);
	
	var _uiAgg_typesMetricsPercentiles2 = _interopRequireDefault(_uiAgg_typesMetricsPercentiles);
	
	function AggTypeMetricMedianProvider(Private) {
	
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var percentiles = Private(_uiAgg_typesMetricsPercentiles2['default']);
	
	  return new MetricAggType({
	    name: 'median',
	    dslName: 'percentiles',
	    title: 'Median',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Median ' + aggConfig.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }, {
	      name: 'percents',
	      'default': [50]
	    }, {
	      write: function write(agg, output) {
	        output.params.keyed = false;
	      }
	    }],
	    getResponseAggs: percentiles.getResponseAggs,
	    getValue: percentiles.getValue
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 946 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricPercentilesProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsOrdinal_suffix = __webpack_require__(947);
	
	var _uiUtilsOrdinal_suffix2 = _interopRequireDefault(_uiUtilsOrdinal_suffix);
	
	var _uiAgg_typesControlsPercentilesHtml = __webpack_require__(948);
	
	var _uiAgg_typesControlsPercentilesHtml2 = _interopRequireDefault(_uiAgg_typesControlsPercentilesHtml);
	
	__webpack_require__(949);
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiAgg_typesMetricsGet_response_agg_config_class = __webpack_require__(953);
	
	var _uiAgg_typesMetricsGet_response_agg_config_class2 = _interopRequireDefault(_uiAgg_typesMetricsGet_response_agg_config_class);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _percentiles_get_value = __webpack_require__(954);
	
	var _percentiles_get_value2 = _interopRequireDefault(_percentiles_get_value);
	
	function AggTypeMetricPercentilesProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var getResponseAggConfigClass = Private(_uiAgg_typesMetricsGet_response_agg_config_class2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  // required by the percentiles editor
	
	  var valueProps = {
	    makeLabel: function makeLabel() {
	      var label = this.params.customLabel || this.getFieldDisplayName();
	      return (0, _uiUtilsOrdinal_suffix2['default'])(this.key) + ' percentile of ' + label;
	    }
	  };
	
	  return new MetricAggType({
	    name: 'percentiles',
	    title: 'Percentiles',
	    makeLabel: function makeLabel(agg) {
	      return 'Percentiles of ' + agg.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }, {
	      name: 'percents',
	      editor: _uiAgg_typesControlsPercentilesHtml2['default'],
	      'default': [1, 5, 25, 50, 75, 95, 99]
	    }, {
	      write: function write(agg, output) {
	        output.params.keyed = false;
	      }
	    }],
	    getResponseAggs: function getResponseAggs(agg) {
	      var ValueAggConfig = getResponseAggConfigClass(agg, valueProps);
	
	      return agg.params.percents.map(function (percent) {
	        return new ValueAggConfig(percent);
	      });
	    },
	    getValue: _percentiles_get_value2['default']
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 947 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addOrdinalSuffix;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	// adopted from http://stackoverflow.com/questions/3109978/php-display-number-with-ordinal-suffix
	
	function addOrdinalSuffix(num) {
	  return num + '' + suffix(num);
	}
	
	function suffix(num) {
	  var int = Math.floor(parseFloat(num));
	
	  var hunth = int % 100;
	  if (hunth >= 11 && hunth <= 13) return 'th';
	
	  var tenth = int % 10;
	  if (tenth === 1) return 'st';
	  if (tenth === 2) return 'nd';
	  if (tenth === 3) return 'rd';
	  return 'th';
	}
	module.exports = exports['default'];

/***/ },
/* 948 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Percents</label>\n  <kbn-number-list\n    ng-model=\"agg.params.percents\"\n    unit-name=\"percent\"\n    range=\"[0,100]\"\n    >\n  </kbn-number-list>\n</div>\n"

/***/ },
/* 949 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsRange = __webpack_require__(950);
	
	var _uiUtilsRange2 = _interopRequireDefault(_uiUtilsRange);
	
	__webpack_require__(951);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiNumber_listNumber_listHtml = __webpack_require__(952);
	
	var _uiNumber_listNumber_listHtml2 = _interopRequireDefault(_uiNumber_listNumber_listHtml);
	
	_uiModules2['default'].get('kibana').directive('kbnNumberList', function () {
	  return {
	    restrict: 'E',
	    template: _uiNumber_listNumber_listHtml2['default'],
	    controllerAs: 'numberListCntr',
	    require: 'ngModel',
	    controller: function controller($scope, $attrs, $parse) {
	      var self = this;
	
	      // Called from the pre-link function once we have the controllers
	      self.init = function (modelCntr) {
	        self.modelCntr = modelCntr;
	
	        self.getList = function () {
	          return self.modelCntr.$modelValue;
	        };
	
	        self.getUnitName = _lodash2['default'].partial($parse($attrs.unit), $scope);
	
	        var defaultRange = self.range = (0, _uiUtilsRange2['default'])('[0,Infinity)');
	
	        $scope.$watch(function () {
	          return $attrs.range;
	        }, function (range, prev) {
	          if (!range) {
	            self.range = defaultRange;
	            return;
	          }
	
	          try {
	            self.range = (0, _uiUtilsRange2['default'])(range);
	          } catch (e) {
	            throw new TypeError('Unable to parse range: ' + e.message);
	          }
	        });
	
	        /**
	         * Remove an item from list by index
	         * @param  {number} index
	         * @return {undefined}
	         */
	        self.remove = function (index) {
	          var list = self.getList();
	          if (!list) return;
	
	          list.splice(index, 1);
	        };
	
	        /**
	         * Add an item to the end of the list
	         * @return {undefined}
	         */
	        self.add = function () {
	          var list = self.getList();
	          if (!list) return;
	
	          list.push(_lodash2['default'].last(list) + 1);
	        };
	
	        /**
	         * Check to see if the list is too short.
	         *
	         * @return {Boolean}
	         */
	        self.tooShort = function () {
	          return _lodash2['default'].size(self.getList()) < 1;
	        };
	
	        /**
	         * Check to see if the list is too short, but simply
	         * because the user hasn't interacted with it yet
	         *
	         * @return {Boolean}
	         */
	        self.undefinedLength = function () {
	          return self.tooShort() && self.modelCntr.$untouched && self.modelCntr.$pristine;
	        };
	
	        /**
	         * Check to see if the list is too short
	         *
	         * @return {Boolean}
	         */
	        self.invalidLength = function () {
	          return self.tooShort() && !self.undefinedLength();
	        };
	
	        $scope.$watchCollection(self.getList, function () {
	          self.modelCntr.$setValidity('numberListLength', !self.tooShort());
	        });
	      };
	    },
	    link: {
	      pre: function pre($scope, $el, attrs, ngModelCntr) {
	        $scope.numberListCntr.init(ngModelCntr);
	      }
	    }
	  };
	});

/***/ },
/* 950 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	/**
	 * Regexp portion that matches our number
	 *
	 * supports:
	 *   -100
	 *   -100.0
	 *   0
	 *   0.10
	 *   Infinity
	 *   -Infinity
	 *
	 * @type {String}
	 */
	var _RE_NUMBER = '(\\-?(?:\\d+(?:\\.\\d+)?|Infinity))';
	
	/**
	 * Regexp for the interval notation
	 *
	 * supports:
	 *   [num, num]
	 *   ( num , num ]
	 *   [Infinity,num)
	 *
	 * @type {RegExp}
	 */
	var RANGE_RE = new RegExp('^\\s*([\\[|\\(])\\s*' + _RE_NUMBER + '\\s*,\\s*' + _RE_NUMBER + '\\s*([\\]|\\)])\\s*$');
	
	function parse(input) {
	
	  var match = String(input).match(RANGE_RE);
	  if (!match) {
	    throw new TypeError('expected input to be in interval notation eg. (100, 200]');
	  }
	
	  return new Range(match[1] === '[', parseFloat(match[2]), parseFloat(match[3]), match[4] === ']');
	}
	
	function Range() /* minIncl, min, max, maxIncl */{
	  var args = _lodash2['default'].toArray(arguments);
	  if (args[1] > args[2]) args.reverse();
	
	  this.minInclusive = args[0];
	  this.min = args[1];
	  this.max = args[2];
	  this.maxInclusive = args[3];
	}
	
	Range.prototype.within = function (n) {
	  if (this.min === n && !this.minInclusive) return false;
	  if (this.min > n) return false;
	
	  if (this.max === n && !this.maxInclusive) return false;
	  if (this.max < n) return false;
	
	  return true;
	};
	
	exports['default'] = parse;
	module.exports = exports['default'];

/***/ },
/* 951 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _jquery = __webpack_require__(18);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiUtilsKey_map = __webpack_require__(760);
	
	var _uiUtilsKey_map2 = _interopRequireDefault(_uiUtilsKey_map);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var INVALID = {}; // invalid flag
	var FLOATABLE = /^[\d\.e\-\+]+$/i;
	
	var VALIDATION_ERROR = 'numberListRangeAndOrder';
	var DIRECTIVE_ATTR = 'kbn-number-list-input';
	
	_uiModules2['default'].get('kibana').directive('kbnNumberListInput', function ($parse) {
	  return {
	    restrict: 'A',
	    require: ['ngModel', '^kbnNumberList'],
	    link: function link($scope, $el, attrs, controllers) {
	      var ngModelCntr = controllers[0];
	      var numberListCntr = controllers[1];
	
	      var $setModel = $parse(attrs.ngModel).assign;
	      var $repeater = $el.closest('[ng-repeat]');
	
	      var handlers = {
	        up: change(add, 1),
	        'shift-up': change(addTenth, 1),
	
	        down: change(add, -1),
	        'shift-down': change(addTenth, -1),
	
	        tab: go('next'),
	        'shift-tab': go('prev'),
	
	        'shift-enter': numberListCntr.add,
	
	        backspace: removeIfEmpty,
	        'delete': removeIfEmpty
	      };
	
	      function removeIfEmpty(event) {
	        if (!ngModelCntr.$viewValue) {
	          $get('prev').focus();
	          numberListCntr.remove($scope.$index);
	          event.preventDefault();
	        }
	
	        return false;
	      }
	
	      function $get(dir) {
	        return $repeater[dir]().find('[' + DIRECTIVE_ATTR + ']');
	      }
	
	      function go(dir) {
	        return function () {
	          var $to = $get(dir);
	          if ($to.size()) $to.focus();else return false;
	        };
	      }
	
	      function idKey(event) {
	        var id = [];
	        if (event.ctrlKey) id.push('ctrl');
	        if (event.shiftKey) id.push('shift');
	        if (event.metaKey) id.push('meta');
	        if (event.altKey) id.push('alt');
	        id.push(_uiUtilsKey_map2['default'][event.keyCode] || event.keyCode);
	        return id.join('-');
	      }
	
	      function add(n, val) {
	        return parse(val + n);
	      }
	
	      function addTenth(n, val, str) {
	        var int = Math.floor(val);
	        var dec = parseInt(str.split('.')[1] || 0, 10);
	        dec = dec + parseInt(n, 10);
	
	        if (dec < 0 || dec > 9) {
	          int += Math.floor(dec / 10);
	          if (dec < 0) {
	            dec = 10 + dec % 10;
	          } else {
	            dec = dec % 10;
	          }
	        }
	
	        return parse(int + '.' + dec);
	      }
	
	      function change(using, mod) {
	        return function () {
	          var str = String(ngModelCntr.$viewValue);
	          var val = parse(str);
	          if (val === INVALID) return;
	
	          var next = using(mod, val, str);
	          if (next === INVALID) return;
	
	          $el.val(next);
	          ngModelCntr.$setViewValue(next);
	        };
	      }
	
	      function onKeydown(event) {
	        var handler = handlers[idKey(event)];
	        if (!handler) return;
	
	        if (handler(event) !== false) {
	          event.preventDefault();
	        }
	
	        $scope.$apply();
	      }
	
	      $el.on('keydown', onKeydown);
	      $scope.$on('$destroy', function () {
	        $el.off('keydown', onKeydown);
	      });
	
	      function parse(viewValue) {
	        var num = viewValue;
	
	        if (typeof num !== 'number' || isNaN(num)) {
	          // parse non-numbers
	          num = String(viewValue || 0).trim();
	          if (!FLOATABLE.test(num)) return INVALID;
	
	          num = parseFloat(num);
	          if (isNaN(num)) return INVALID;
	        }
	
	        var range = numberListCntr.range;
	        if (!range.within(num)) return INVALID;
	
	        if ($scope.$index > 0) {
	          var i = $scope.$index - 1;
	          var list = numberListCntr.getList();
	          var prev = list[i];
	          if (num <= prev) return INVALID;
	        }
	
	        return num;
	      }
	
	      $scope.$watchMulti(['$index', {
	        fn: $scope.$watchCollection,
	        get: function get() {
	          return numberListCntr.getList();
	        }
	      }], function () {
	        var valid = parse(ngModelCntr.$viewValue) !== INVALID;
	        ngModelCntr.$setValidity(VALIDATION_ERROR, valid);
	      });
	
	      function validate(then) {
	        return function (input) {
	          var value = parse(input);
	          var valid = value !== INVALID;
	          value = valid ? value : input;
	          ngModelCntr.$setValidity(VALIDATION_ERROR, valid);
	          then && then(input, value);
	          return value;
	        };
	      }
	
	      ngModelCntr.$parsers.push(validate());
	      ngModelCntr.$formatters.push(validate(function (input, value) {
	        if (input !== value) $setModel($scope, value);
	      }));
	
	      if (parse(ngModelCntr.$viewValue) === INVALID) {
	        ngModelCntr.$setTouched();
	      }
	    }
	  };
	});

/***/ },
/* 952 */
/***/ function(module, exports) {

	module.exports = "<div\n  ng-repeat=\"value in numberListCntr.getList() track by $index\"\n  class=\"form-group vis-editor-agg-form-row vis-editor-agg-form-row\">\n\n  <input\n    ng-model=\"numberListCntr.getList()[$index]\"\n    kbn-number-list-input\n    input-focus\n    class=\"form-control\">\n\n  <button\n    ng-click=\"numberListCntr.remove($index, 1)\"\n    class=\"btn btn-danger btn-xs\"\n    type=\"button\">\n    <i class=\"fa fa-times\"></i>\n  </button>\n\n</div>\n\n<p ng-show=\"numberListCntr.invalidLength()\" class=\"text-danger text-center\">\n  You must specify at least one {{numberListCntr.getUnitName()}}\n</p>\n\n<p ng-show=\"numberListCntr.undefinedLength()\" class=\"text-primary text-center\">\n  <!-- be a bit more polite when the form is first init'd -->\n  Please specify at least one {{numberListCntr.getUnitName()}}\n</p>\n\n<button\n  ng-click=\"numberListCntr.add()\"\n  type=\"button\"\n  class=\"sidebar-item-button primary\">\n  <i class=\"fa fa-plus\"></i> Add {{numberListCntr.getUnitName()}}\n</button>\n"

/***/ },
/* 953 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$create = __webpack_require__(12)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = ResponseAggConfigProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function ResponseAggConfigProvider() {
	
	  /**
	   * Get the ResponseAggConfig class for an aggConfig,
	   * which might be cached on the aggConfig or created.
	   *
	   * @param  {AggConfig} agg - the AggConfig the VAC should inherit from
	   * @param  {object} props - properties that the VAC should have
	   * @return {Constructor} - a constructor for VAC objects that will inherit the aggConfig
	   */
	  return function getResponseConfigClass(agg, props) {
	    if (agg.$$_ResponseAggConfigClass) {
	      return agg.$$_ResponseAggConfigClass;
	    } else {
	      return agg.$$_ResponseAggConfigClass = create(agg, props);
	    }
	  };
	
	  function create(parentAgg, props) {
	
	    /**
	     * AggConfig "wrapper" for multi-value metric aggs which
	     * need to modify AggConfig behavior for each value produced.
	     *
	     * @param {string|number} key - the key or index that identifies
	     *                            this part of the multi-value
	     */
	    function ResponseAggConfig(key) {
	      this.key = key;
	      this.parentId = this.id;
	
	      var subId = String(key);
	      if (subId.indexOf('.') > -1) {
	        this.id = this.parentId + '[\'' + subId.replace(/'/g, '\\\'') + '\']';
	      } else {
	        this.id = this.parentId + '.' + subId;
	      }
	    }
	
	    ResponseAggConfig.prototype = _Object$create(parentAgg, {
	      constructor: ResponseAggConfig
	    });
	
	    _lodash2['default'].assign(ResponseAggConfig.prototype, props);
	
	    return ResponseAggConfig;
	  }
	}
	
	module.exports = exports['default'];

/***/ },
/* 954 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = getPercentileValue;
	
	var _lodash = __webpack_require__(3);
	
	function getPercentileValue(agg, bucket) {
	  var values = bucket[agg.parentId] && bucket[agg.parentId].values;
	  var percentile = (0, _lodash.find)(values, function (value) {
	    return agg.key === value.key;
	  });
	  return percentile ? percentile.value : NaN;
	}
	
	module.exports = exports['default'];

/***/ },
/* 955 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricMinProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	function AggTypeMetricMinProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	
	  return new MetricAggType({
	    name: 'min',
	    title: 'Min',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Min ' + aggConfig.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number,date'
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 956 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricMaxProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	function AggTypeMetricMaxProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	
	  return new MetricAggType({
	    name: 'max',
	    title: 'Max',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Max ' + aggConfig.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number,date'
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 957 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _defineProperty = __webpack_require__(437)['default'];
	
	var _slicedToArray = __webpack_require__(290)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricTopProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _uiAgg_typesControlsTop_sortHtml = __webpack_require__(958);
	
	var _uiAgg_typesControlsTop_sortHtml2 = _interopRequireDefault(_uiAgg_typesControlsTop_sortHtml);
	
	var _uiAgg_typesControlsTop_aggregate_and_sizeHtml = __webpack_require__(959);
	
	var _uiAgg_typesControlsTop_aggregate_and_sizeHtml2 = _interopRequireDefault(_uiAgg_typesControlsTop_aggregate_and_sizeHtml);
	
	function AggTypeMetricTopProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  var isNumber = function isNumber(type) {
	    return type === 'number';
	  };
	
	  return new MetricAggType({
	    name: 'top_hits',
	    title: 'Top Hit',
	    makeLabel: function makeLabel(aggConfig) {
	      var prefix = aggConfig.params.sortOrder.val === 'desc' ? 'Last' : 'First';
	      if (aggConfig.params.size !== 1) {
	        prefix += ' ' + aggConfig.params.size;
	      }
	      return prefix + ' ' + aggConfig.params.field.displayName;
	    },
	    params: [{
	      name: 'field',
	      onlyAggregatable: false,
	      showAnalyzedWarning: false,
	      filterFieldTypes: function filterFieldTypes(vis, value) {
	        if (vis.type.name === 'table' || vis.type.name === 'metric') {
	          return true;
	        }
	        return value === 'number';
	      },
	      write: function write(agg, output) {
	        var field = agg.params.field;
	        output.params = {};
	
	        if (field.scripted) {
	          output.params.script_fields = _defineProperty({}, field.name, {
	            script: {
	              inline: field.script,
	              lang: field.lang
	            }
	          });
	        } else {
	          if (field.doc_values) {
	            output.params.docvalue_fields = [field.name];
	          }
	          output.params._source = field.name === '_source' ? true : field.name;
	        }
	      }
	    }, {
	      name: 'aggregate',
	      type: 'optioned',
	      editor: _uiAgg_typesControlsTop_aggregate_and_sizeHtml2['default'],
	      options: [{
	        display: 'Min',
	        isCompatibleType: isNumber,
	        isCompatibleVis: _lodash2['default'].constant(true),
	        disabled: true,
	        val: 'min'
	      }, {
	        display: 'Max',
	        isCompatibleType: isNumber,
	        isCompatibleVis: _lodash2['default'].constant(true),
	        disabled: true,
	        val: 'max'
	      }, {
	        display: 'Sum',
	        isCompatibleType: isNumber,
	        isCompatibleVis: _lodash2['default'].constant(true),
	        disabled: true,
	        val: 'sum'
	      }, {
	        display: 'Average',
	        isCompatibleType: isNumber,
	        isCompatibleVis: _lodash2['default'].constant(true),
	        disabled: true,
	        val: 'average'
	      }, {
	        display: 'Concatenate',
	        isCompatibleType: _lodash2['default'].constant(true),
	        isCompatibleVis: function isCompatibleVis(name) {
	          return name === 'metric' || name === 'table';
	        },
	        disabled: true,
	        val: 'concat'
	      }],
	      controller: function controller($scope) {
	        $scope.options = [];
	        $scope.$watchGroup(['agg.vis.type.name', 'agg.params.field.type'], function (_ref2) {
	          var _ref22 = _slicedToArray(_ref2, 2);
	
	          var visName = _ref22[0];
	          var fieldType = _ref22[1];
	
	          if (fieldType && visName) {
	            $scope.options = _lodash2['default'].filter($scope.aggParam.options, function (option) {
	              return option.isCompatibleVis(visName) && option.isCompatibleType(fieldType);
	            });
	            if ($scope.options.length === 1) {
	              $scope.agg.params.aggregate = $scope.options[0];
	            }
	          }
	        });
	      },
	      write: _lodash2['default'].noop
	    }, {
	      name: 'size',
	      editor: null, // size setting is done together with the aggregation setting
	      'default': 1
	    }, {
	      name: 'sortField',
	      type: 'field',
	      editor: null,
	      filterFieldTypes: ['number', 'date', 'ip', 'string'],
	      'default': function _default(agg) {
	        return agg.vis.indexPattern.timeFieldName;
	      },
	      write: _lodash2['default'].noop // prevent default write, it is handled below
	    }, {
	      name: 'sortOrder',
	      type: 'optioned',
	      'default': 'desc',
	      editor: _uiAgg_typesControlsTop_sortHtml2['default'],
	      options: [{ display: 'Descending', val: 'desc' }, { display: 'Ascending', val: 'asc' }],
	      write: function write(agg, output) {
	        var sortField = agg.params.sortField;
	        var sortOrder = agg.params.sortOrder;
	
	        if (sortField.scripted) {
	          output.params.sort = [{
	            _script: {
	              script: {
	                inline: sortField.script,
	                lang: sortField.lang
	              },
	              type: sortField.type,
	              order: sortOrder.val
	            }
	          }];
	        } else {
	          output.params.sort = [_defineProperty({}, sortField.name, {
	            order: sortOrder.val
	          })];
	        }
	      }
	    }],
	    getValue: function getValue(agg, bucket) {
	      var hits = _lodash2['default'].get(bucket, agg.id + '.hits.hits');
	      if (!hits || !hits.length) {
	        return null;
	      }
	      var path = agg.params.field.name;
	
	      var values = (0, _lodash2['default'])(hits).map(function (hit) {
	        return path === '_source' ? hit._source : agg.vis.indexPattern.flattenHit(hit, true)[path];
	      }).flatten().value();
	
	      if (values.length === 1) {
	        values = values[0];
	      }
	
	      if (_lodash2['default'].isArray(values)) {
	        if (!_lodash2['default'].compact(values).length) {
	          return null;
	        }
	        switch (agg.params.aggregate.val) {
	          case 'max':
	            return _lodash2['default'].max(values);
	          case 'min':
	            return _lodash2['default'].min(values);
	          case 'sum':
	            return _lodash2['default'].sum(values);
	          case 'average':
	            return _lodash2['default'].sum(values) / values.length;
	        }
	      }
	      return values;
	    }
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 958 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label for=\"sort\">\n    Sort On\n  </label>\n\n  <select\n    class=\"form-control\"\n    name=\"sortField\"\n    required\n    ng-model=\"agg.params.sortField\"\n    ng-show=\"sortFieldOptions.length\"\n    auto-select-if-only-one=\"sortFieldOptions\"\n    ng-options=\"field as field.displayName group by field.type for field in sortFieldOptions\">\n  </select>\n</div>\n\n<div class=\"form-group\">\n  <label>\n    Order\n  </label>\n\n  <select\n     name=\"sortOrder\"\n     ng-model=\"agg.params.sortOrder\"\n     required\n     ng-options=\"opt as opt.display for opt in aggParam.options track by opt.val\"\n     class=\"form-control\">\n  </select>\n</div>\n"

/***/ },
/* 959 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"aggParam.controller\" class=\"vis-editor-agg-form-row\">\n  <div class=\"form-group\">\n    <label>\n      Aggregate With\n      <kbn-info\n       info=\"Choose a strategy for combining multiple hits or a multi-valued field into a single metric.\"\n       placement=\"right\">\n      </kbn-info>\n    </label>\n\n    <select\n      required\n      name=\"aggregate\"\n      ng-model=\"agg.params.aggregate\"\n      ng-options=\"opt as opt.display for opt in options| orderBy: 'display' track by opt.val\"\n      class=\"form-control\"\n    ></select>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      Size\n      <kbn-info\n       info=\"Request top-K hits. Multiple hits will be combined via 'aggregate with'.\"\n       placement=\"right\">\n      </kbn-info>\n    </label>\n\n    <input\n       required\n       name=\"size\"\n       ng-model=\"agg.params.size\"\n       class=\"form-control\"\n       type=\"number\"\n       min=\"1\"\n    ></input>\n  </div>\n</div>\n"

/***/ },
/* 960 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricStandardDeviationProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiAgg_typesMetricsGet_response_agg_config_class = __webpack_require__(953);
	
	var _uiAgg_typesMetricsGet_response_agg_config_class2 = _interopRequireDefault(_uiAgg_typesMetricsGet_response_agg_config_class);
	
	function AggTypeMetricStandardDeviationProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var getResponseAggConfigClass = Private(_uiAgg_typesMetricsGet_response_agg_config_class2['default']);
	
	  var responseAggConfigProps = {
	    valProp: function valProp() {
	      var details = this.keyedDetails(this.params.customLabel)[this.key];
	      return details.valProp;
	    },
	    makeLabel: function makeLabel() {
	      var fieldDisplayName = this.getFieldDisplayName();
	      var details = this.keyedDetails(this.params.customLabel, fieldDisplayName);
	      return _lodash2['default'].get(details, [this.key, 'title']);
	    },
	    keyedDetails: function keyedDetails(customLabel, fieldDisplayName) {
	      var label = customLabel ? customLabel : 'Standard Deviation of ' + fieldDisplayName;
	      return {
	        std_lower: {
	          valProp: ['std_deviation_bounds', 'lower'],
	          title: 'Lower ' + label
	        },
	        std_upper: {
	          valProp: ['std_deviation_bounds', 'upper'],
	          title: 'Upper ' + label
	        }
	      };
	    }
	  };
	
	  return new MetricAggType({
	    name: 'std_dev',
	    dslName: 'extended_stats',
	    title: 'Standard Deviation',
	    makeLabel: function makeLabel(agg) {
	      return 'Standard Deviation of ' + agg.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }],
	
	    getResponseAggs: function getResponseAggs(agg) {
	      var ValueAggConfig = getResponseAggConfigClass(agg, responseAggConfigProps);
	
	      return [new ValueAggConfig('std_lower'), new ValueAggConfig('std_upper')];
	    },
	
	    getValue: function getValue(agg, bucket) {
	      return _lodash2['default'].get(bucket[agg.parentId], agg.valProp());
	    }
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 961 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricCardinalityProvider;
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	function AggTypeMetricCardinalityProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  return new MetricAggType({
	    name: 'cardinality',
	    title: 'Unique Count',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Unique count of ' + aggConfig.getFieldDisplayName();
	    },
	    getFormat: function getFormat() {
	      return fieldFormats.getDefaultInstance('number');
	    },
	    params: [{
	      name: 'field'
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 962 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggTypeMetricPercentileRanksProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesControlsPercentile_ranksHtml = __webpack_require__(963);
	
	var _uiAgg_typesControlsPercentile_ranksHtml2 = _interopRequireDefault(_uiAgg_typesControlsPercentile_ranksHtml);
	
	__webpack_require__(949);
	
	var _uiAgg_typesMetricsMetric_agg_type = __webpack_require__(941);
	
	var _uiAgg_typesMetricsMetric_agg_type2 = _interopRequireDefault(_uiAgg_typesMetricsMetric_agg_type);
	
	var _uiAgg_typesMetricsGet_response_agg_config_class = __webpack_require__(953);
	
	var _uiAgg_typesMetricsGet_response_agg_config_class2 = _interopRequireDefault(_uiAgg_typesMetricsGet_response_agg_config_class);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _percentiles_get_value = __webpack_require__(954);
	
	var _percentiles_get_value2 = _interopRequireDefault(_percentiles_get_value);
	
	function AggTypeMetricPercentileRanksProvider(Private) {
	  var MetricAggType = Private(_uiAgg_typesMetricsMetric_agg_type2['default']);
	  var getResponseAggConfigClass = Private(_uiAgg_typesMetricsGet_response_agg_config_class2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  // required by the values editor
	
	  var valueProps = {
	    makeLabel: function makeLabel() {
	      var field = this.getField();
	      var format = field && field.format || fieldFormats.getDefaultInstance('number');
	      var label = this.params.customLabel || this.getFieldDisplayName();
	
	      return 'Percentile rank ' + format.convert(this.key, 'text') + ' of "' + label + '"';
	    }
	  };
	
	  return new MetricAggType({
	    name: 'percentile_ranks',
	    title: 'Percentile Ranks',
	    makeLabel: function makeLabel(agg) {
	      return 'Percentile ranks of ' + agg.getFieldDisplayName();
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }, {
	      name: 'values',
	      editor: _uiAgg_typesControlsPercentile_ranksHtml2['default'],
	      'default': []
	    }, {
	      write: function write(agg, output) {
	        output.params.keyed = false;
	      }
	    }],
	    getResponseAggs: function getResponseAggs(agg) {
	      var ValueAggConfig = getResponseAggConfigClass(agg, valueProps);
	
	      return agg.params.values.map(function (value) {
	        return new ValueAggConfig(value);
	      });
	    },
	    getFormat: function getFormat() {
	      return fieldFormats.getInstance('percent') || fieldFormats.getDefaultInstance('number');
	    },
	    getValue: function getValue(agg, bucket) {
	      return (0, _percentiles_get_value2['default'])(agg, bucket) / 100;
	    }
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 963 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Values</label>\n  <kbn-number-list\n    ng-model=\"agg.params.values\"\n    unit-name=\"value\"\n    range=\"[-Infinity,Infinity]\"\n    >\n  </kbn-number-list>\n</div>\n"

/***/ },
/* 964 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DateHistogramAggType;
	
	var _jstimezonedetect = __webpack_require__(965);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	__webpack_require__(775);
	
	__webpack_require__(732);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiTime_buckets = __webpack_require__(967);
	
	var _uiTime_buckets2 = _interopRequireDefault(_uiTime_buckets);
	
	var _uiAgg_typesBucketsCreate_filterDate_histogram = __webpack_require__(970);
	
	var _uiAgg_typesBucketsCreate_filterDate_histogram2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterDate_histogram);
	
	var _uiAgg_typesBuckets_interval_options = __webpack_require__(972);
	
	var _uiAgg_typesBuckets_interval_options2 = _interopRequireDefault(_uiAgg_typesBuckets_interval_options);
	
	var _uiAgg_typesControlsIntervalHtml = __webpack_require__(973);
	
	var _uiAgg_typesControlsIntervalHtml2 = _interopRequireDefault(_uiAgg_typesControlsIntervalHtml);
	
	function DateHistogramAggType(timefilter, config, Private) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var TimeBuckets = Private(_uiTime_buckets2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterDate_histogram2['default']);
	  var intervalOptions = Private(_uiAgg_typesBuckets_interval_options2['default']);
	
	  var detectedTimezone = _jstimezonedetect.jstz.determine().name();
	  var tzOffset = (0, _moment2['default'])().format('Z');
	
	  function getInterval(agg) {
	    var interval = _lodash2['default'].get(agg, ['params', 'interval']);
	    if (interval && interval.val === 'custom') {
	      return _lodash2['default'].get(agg, ['params', 'customInterval']);
	    }
	    return interval;
	  }
	
	  function setBounds(agg, force) {
	    if (agg.buckets._alreadySet && !force) return;
	    agg.buckets._alreadySet = true;
	    agg.buckets.setBounds(agg.fieldIsTimeField() && timefilter.getActiveBounds());
	  }
	
	  return new BucketAggType({
	    name: 'date_histogram',
	    title: 'Date Histogram',
	    ordered: {
	      date: true
	    },
	    makeLabel: function makeLabel(agg) {
	      var output = this.params.write(agg);
	      var params = output.params;
	      var field = agg.getFieldDisplayName();
	      return field + ' per ' + (output.metricScaleText || output.bucketInterval.description);
	    },
	    createFilter: createFilter,
	    decorateAggConfig: function decorateAggConfig() {
	      var buckets = undefined;
	      return {
	        buckets: {
	          configurable: true,
	          get: function get() {
	            if (buckets) return buckets;
	
	            buckets = new TimeBuckets();
	            buckets.setInterval(getInterval(this));
	            setBounds(this);
	
	            return buckets;
	          }
	        }
	      };
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'date',
	      'default': function _default(agg) {
	        return agg.vis.indexPattern.timeFieldName;
	      },
	      onChange: function onChange(agg) {
	        if (_lodash2['default'].get(agg, 'params.interval.val') === 'auto' && !agg.fieldIsTimeField()) {
	          delete agg.params.interval;
	        }
	
	        setBounds(agg, true);
	      }
	    }, {
	      name: 'interval',
	      type: 'optioned',
	      deserialize: function deserialize(state) {
	        var interval = _lodash2['default'].find(intervalOptions, { val: state });
	        return interval || _lodash2['default'].find(intervalOptions, function (option) {
	          // For upgrading from 4.0.x to 4.1.x - intervals are now stored as 'y' instead of 'year',
	          // but this maps the old values to the new values
	          return Number(_moment2['default'].duration(1, state)) === Number(_moment2['default'].duration(1, option.val));
	        });
	      },
	      'default': 'auto',
	      options: intervalOptions,
	      editor: _uiAgg_typesControlsIntervalHtml2['default'],
	      onRequest: function onRequest(agg) {
	        setBounds(agg, true);
	      },
	      write: function write(agg, output) {
	        setBounds(agg);
	        agg.buckets.setInterval(getInterval(agg));
	
	        var interval = agg.buckets.getInterval();
	        output.bucketInterval = interval;
	        output.params.interval = interval.expression;
	
	        var isDefaultTimezone = config.isDefault('dateFormat:tz');
	        if (isDefaultTimezone) {
	          output.params.time_zone = detectedTimezone || tzOffset;
	        } else {
	          output.params.time_zone = config.get('dateFormat:tz');
	        }
	
	        var scaleMetrics = interval.scaled && interval.scale < 1;
	        if (scaleMetrics) {
	          var all = _lodash2['default'].every(agg.vis.aggs.bySchemaGroup.metrics, function (agg) {
	            return agg.type && (agg.type.name === 'count' || agg.type.name === 'sum');
	          });
	          if (all) {
	            output.metricScale = interval.scale;
	            output.metricScaleText = interval.preScaled.description;
	          }
	        }
	      }
	    }, {
	      name: 'customInterval',
	      'default': '2h',
	      write: _lodash2['default'].noop
	    }, {
	      name: 'format'
	    }, {
	      name: 'min_doc_count',
	      'default': 1
	    }, {
	      name: 'extended_bounds',
	      'default': {},
	      write: function write(agg, output) {
	        var val = agg.params.extended_bounds;
	
	        if (val.min != null || val.max != null) {
	          output.params.extended_bounds = {
	            min: (0, _moment2['default'])(val.min).valueOf(),
	            max: (0, _moment2['default'])(val.max).valueOf()
	          };
	
	          return;
	        }
	      }
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 965 */,
/* 966 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = BucketAggTypeProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesAgg_type = __webpack_require__(942);
	
	var _uiAgg_typesAgg_type2 = _interopRequireDefault(_uiAgg_typesAgg_type);
	
	function BucketAggTypeProvider(Private) {
	  var AggType = Private(_uiAgg_typesAgg_type2['default']);
	
	  _lodash2['default']['class'](BucketAggType).inherits(AggType);
	  function BucketAggType(config) {
	    BucketAggType.Super.call(this, config);
	
	    if (_lodash2['default'].isFunction(config.getKey)) {
	      this.getKey = config.getKey;
	    }
	  }
	
	  BucketAggType.prototype.getKey = function (bucket, key) {
	    return key || bucket.key;
	  };
	
	  return BucketAggType;
	}
	
	module.exports = exports['default'];

/***/ },
/* 967 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Object$create = __webpack_require__(12)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IntervalHelperProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _elasticDatemath = __webpack_require__(237);
	
	var _elasticDatemath2 = _interopRequireDefault(_elasticDatemath);
	
	var _uiUtilsParse_interval = __webpack_require__(733);
	
	var _uiUtilsParse_interval2 = _interopRequireDefault(_uiUtilsParse_interval);
	
	var _uiTime_bucketsCalc_auto_interval = __webpack_require__(968);
	
	var _uiTime_bucketsCalc_auto_interval2 = _interopRequireDefault(_uiTime_bucketsCalc_auto_interval);
	
	var _uiTime_bucketsCalc_es_interval = __webpack_require__(969);
	
	var _uiTime_bucketsCalc_es_interval2 = _interopRequireDefault(_uiTime_bucketsCalc_es_interval);
	
	function IntervalHelperProvider(Private, timefilter, config) {
	
	  var calcAuto = Private(_uiTime_bucketsCalc_auto_interval2['default']);
	  var calcEsInterval = Private(_uiTime_bucketsCalc_es_interval2['default']);
	  var tzOffset = (0, _moment2['default'])().format('Z');
	
	  function isValidMoment(m) {
	    return m && 'isValid' in m && m.isValid();
	  }
	
	  /**
	   * Helper class for wrapping the concept of an "Interval",
	   * which describes a timespan that will seperate moments.
	   *
	   * @param {state} object - one of ""
	   * @param {[type]} display [description]
	   */
	  function TimeBuckets() {
	    return TimeBuckets.__cached__(this);
	  }
	
	  /****
	   *  PUBLIC API
	   ****/
	
	  /**
	   * Set the bounds that these buckets are expected to cover.
	   * This is required to support interval "auto" as well
	   * as interval scaling.
	   *
	   * @param {object} input - an object with properties min and max,
	   *                       representing the edges for the time span
	   *                       we should cover
	   *
	   * @returns {undefined}
	   */
	  TimeBuckets.prototype.setBounds = function (input) {
	    if (!input) return this.clearBounds();
	
	    var bounds = undefined;
	    if (_lodash2['default'].isPlainObject(input)) {
	      // accept the response from timefilter.getActiveBounds()
	      bounds = [input.min, input.max];
	    } else {
	      bounds = _lodash2['default'].isArray(input) ? input : [];
	    }
	
	    var moments = (0, _lodash2['default'])(bounds).map(_lodash2['default'].ary(_moment2['default'], 1)).sortBy(Number);
	
	    var valid = moments.size() === 2 && moments.every(isValidMoment);
	    if (!valid) {
	      this.clearBounds();
	      throw new Error('invalid bounds set: ' + input);
	    }
	
	    this._lb = moments.shift();
	    this._ub = moments.pop();
	    if (this.getDuration().asSeconds() < 0) {
	      throw new TypeError('Intervals must be positive');
	    }
	  };
	
	  /**
	   * Clear the stored bounds
	   *
	   * @return {undefined}
	   */
	  TimeBuckets.prototype.clearBounds = function () {
	    this._lb = this._ub = null;
	  };
	
	  /**
	   * Check to see if we have received bounds yet
	   *
	   * @return {Boolean}
	   */
	  TimeBuckets.prototype.hasBounds = function () {
	    return isValidMoment(this._ub) && isValidMoment(this._lb);
	  };
	
	  /**
	   * Return the current bounds, if we have any.
	   *
	   * THIS DOES NOT CLONE THE BOUNDS, so editing them
	   * may have unexpected side-effects. Always
	   * call bounds.min.clone() before editing
	   *
	   * @return {object|undefined} - If bounds are not defined, this
	   *                      returns undefined, else it returns the bounds
	   *                      for these buckets. This object has two props,
	   *                      min and max. Each property will be a moment()
	   *                      object
	   *
	   */
	  TimeBuckets.prototype.getBounds = function () {
	    if (!this.hasBounds()) return;
	    return {
	      min: this._lb,
	      max: this._ub
	    };
	  };
	
	  /**
	   * Get a moment duration object representing
	   * the distance between the bounds, if the bounds
	   * are set.
	   *
	   * @return {moment.duration|undefined}
	   */
	  TimeBuckets.prototype.getDuration = function () {
	    if (!this.hasBounds()) return;
	    return _moment2['default'].duration(this._ub - this._lb, 'ms');
	  };
	
	  /**
	   * Update the interval at which buckets should be
	   * generated.
	   *
	   * Input can be one of the following:
	   *  - Any object from src/ui/agg_types/buckets/_interval_options.js
	   *  - "auto"
	   *  - Pass a valid moment unit
	   *  - a moment.duration object.
	   *
	   * @param {object|string|moment.duration} input - see desc
	   */
	  TimeBuckets.prototype.setInterval = function (input) {
	    var interval = input;
	
	    // selection object -> val
	    if (_lodash2['default'].isObject(input)) {
	      interval = input.val;
	    }
	
	    if (!interval || interval === 'auto') {
	      this._i = 'auto';
	      return;
	    }
	
	    if (_lodash2['default'].isString(interval)) {
	      input = interval;
	      interval = (0, _uiUtilsParse_interval2['default'])(interval);
	      if (+interval === 0) {
	        interval = null;
	      }
	    }
	
	    // if the value wasn't converted to a duration, and isn't
	    // already a duration, we have a problem
	    if (!_moment2['default'].isDuration(interval)) {
	      throw new TypeError('"' + input + '" is not a valid interval.');
	    }
	
	    this._i = interval;
	  };
	
	  /**
	   * Get the interval for the buckets. If the
	   * number of buckets created by the interval set
	   * is larger than config:histogram:maxBars then the
	   * interval will be scaled up. If the number of buckets
	   * created is less than one, the interval is scaled back.
	   *
	   * The interval object returned is a moment.duration
	   * object that has been decorated with the following
	   * properties.
	   *
	   * interval.description: a text description of the interval.
	   *   designed to be used list "field per {{ desc }}".
	   *     - "minute"
	   *     - "10 days"
	   *     - "3 years"
	   *
	   * interval.expr: the elasticsearch expression that creates this
	   *   interval. If the interval does not properly form an elasticsearch
	   *   expression it will be forced into one.
	   *
	   * interval.scaled: the interval was adjusted to
	   *   accomidate the maxBars setting.
	   *
	   * interval.scale: the numer that y-values should be
	   *   multiplied by
	   *
	   * interval.scaleDescription: a description that reflects
	   *   the values which will be produced by using the
	   *   interval.scale.
	   *
	   *
	   * @return {[type]} [description]
	   */
	  TimeBuckets.prototype.getInterval = function () {
	    var self = this;
	    var duration = self.getDuration();
	    return decorateInterval(maybeScaleInterval(readInterval()));
	
	    // either pull the interval from state or calculate the auto-interval
	    function readInterval() {
	      var interval = self._i;
	      if (_moment2['default'].isDuration(interval)) return interval;
	      return calcAuto.near(config.get('histogram:barTarget'), duration);
	    }
	
	    // check to see if the interval should be scaled, and scale it if so
	    function maybeScaleInterval(interval) {
	      if (!self.hasBounds()) return interval;
	
	      var maxLength = config.get('histogram:maxBars');
	      var approxLen = duration / interval;
	      var scaled = undefined;
	
	      if (approxLen > maxLength) {
	        scaled = calcAuto.lessThan(maxLength, duration);
	      } else {
	        return interval;
	      }
	
	      if (+scaled === +interval) return interval;
	
	      decorateInterval(interval);
	      return _lodash2['default'].assign(scaled, {
	        preScaled: interval,
	        scale: interval / scaled,
	        scaled: true
	      });
	    }
	
	    // append some TimeBuckets specific props to the interval
	    function decorateInterval(interval) {
	      var esInterval = calcEsInterval(interval);
	      interval.esValue = esInterval.value;
	      interval.esUnit = esInterval.unit;
	      interval.expression = esInterval.expression;
	      interval.overflow = duration > interval ? _moment2['default'].duration(interval - duration) : false;
	
	      var prettyUnits = _moment2['default'].normalizeUnits(esInterval.unit);
	      if (esInterval.value === 1) {
	        interval.description = prettyUnits;
	      } else {
	        interval.description = esInterval.value + ' ' + prettyUnits + 's';
	      }
	
	      return interval;
	    }
	  };
	
	  /**
	   * Get a date format string that will represent dates that
	   * progress at our interval.
	   *
	   * Since our interval can be as small as 1ms, the default
	   * date format is usually way too much. with `dateFormat:scaled`
	   * users can modify how dates are formatted within series
	   * produced by TimeBuckets
	   *
	   * @return {string}
	   */
	  TimeBuckets.prototype.getScaledDateFormat = function () {
	    var interval = this.getInterval();
	    var rules = config.get('dateFormat:scaled');
	
	    for (var i = rules.length - 1; i >= 0; i--) {
	      var rule = rules[i];
	      if (!rule[0] || interval >= _moment2['default'].duration(rule[0])) {
	        return rule[1];
	      }
	    }
	
	    return config.get('dateFormat');
	  };
	
	  TimeBuckets.__cached__ = function (self) {
	    var cache = {};
	    var sameMoment = same(_moment2['default'].isMoment);
	    var sameDuration = same(_moment2['default'].isDuration);
	
	    var desc = {
	      __cached__: {
	        value: self
	      }
	    };
	
	    var breakers = {
	      setBounds: 'bounds',
	      clearBounds: 'bounds',
	      setInterval: 'interval'
	    };
	
	    var resources = {
	      bounds: {
	        setup: function setup() {
	          return [self._lb, self._ub];
	        },
	        changes: function changes(prev) {
	          return !sameMoment(prev[0], self._lb) || !sameMoment(prev[1], self._ub);
	        }
	      },
	      interval: {
	        setup: function setup() {
	          return self._i;
	        },
	        changes: function changes(prev) {
	          return !sameDuration(prev, this._i);
	        }
	      }
	    };
	
	    function cachedGetter(prop) {
	      return {
	        value: function cachedGetter() {
	          if (cache.hasOwnProperty(prop)) {
	            return cache[prop];
	          }
	
	          return cache[prop] = self[prop]();
	        }
	      };
	    }
	
	    function cacheBreaker(prop) {
	      var resource = resources[breakers[prop]];
	      var setup = resource.setup;
	      var changes = resource.changes;
	      var deps = resource.deps;
	      var fn = self[prop];
	
	      return {
	        value: function cacheBreaker(input) {
	          var prev = setup.call(self);
	          var ret = fn.apply(self, arguments);
	
	          if (changes.call(self, prev)) {
	            cache = {};
	          }
	
	          return ret;
	        }
	      };
	    }
	
	    function same(checkType) {
	      return function (a, b) {
	        if (a === b) return true;
	        if (checkType(a) === checkType(b)) return +a === +b;
	        return false;
	      };
	    }
	
	    _lodash2['default'].forOwn(TimeBuckets.prototype, function (fn, prop) {
	      if (prop[0] === '_') return;
	
	      if (breakers.hasOwnProperty(prop)) {
	        desc[prop] = cacheBreaker(prop);
	      } else {
	        desc[prop] = cachedGetter(prop);
	      }
	    });
	
	    return _Object$create(self, desc);
	  };
	
	  return TimeBuckets;
	}
	
	module.exports = exports['default'];

/***/ },
/* 968 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DateIntervalRoundingRulesProvider;
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function DateIntervalRoundingRulesProvider() {
	  // these are the rounding rules used by roundInterval()
	
	  var roundingRules = [[(0, _moment.duration)(500, 'ms'), (0, _moment.duration)(100, 'ms')], [(0, _moment.duration)(5, 'second'), (0, _moment.duration)(1, 'second')], [(0, _moment.duration)(7.5, 'second'), (0, _moment.duration)(5, 'second')], [(0, _moment.duration)(15, 'second'), (0, _moment.duration)(10, 'second')], [(0, _moment.duration)(45, 'second'), (0, _moment.duration)(30, 'second')], [(0, _moment.duration)(3, 'minute'), (0, _moment.duration)(1, 'minute')], [(0, _moment.duration)(9, 'minute'), (0, _moment.duration)(5, 'minute')], [(0, _moment.duration)(20, 'minute'), (0, _moment.duration)(10, 'minute')], [(0, _moment.duration)(45, 'minute'), (0, _moment.duration)(30, 'minute')], [(0, _moment.duration)(2, 'hour'), (0, _moment.duration)(1, 'hour')], [(0, _moment.duration)(6, 'hour'), (0, _moment.duration)(3, 'hour')], [(0, _moment.duration)(24, 'hour'), (0, _moment.duration)(12, 'hour')], [(0, _moment.duration)(1, 'week'), (0, _moment.duration)(1, 'd')], [(0, _moment.duration)(3, 'week'), (0, _moment.duration)(1, 'week')], [(0, _moment.duration)(1, 'year'), (0, _moment.duration)(1, 'month')], [Infinity, (0, _moment.duration)(1, 'year')]];
	
	  var revRoundingRules = roundingRules.slice(0).reverse();
	
	  function find(rules, check, last) {
	    function pick(buckets, duration) {
	      var target = duration / buckets;
	      var lastResp = undefined;
	
	      for (var i = 0; i < rules.length; i++) {
	        var rule = rules[i];
	        var resp = check(rule[0], rule[1], target);
	
	        if (resp == null) {
	          if (!last) continue;
	          if (lastResp) return lastResp;
	          break;
	        }
	
	        if (!last) return resp;
	        lastResp = resp;
	      }
	
	      // fallback to just a number of milliseconds, ensure ms is >= 1
	      var ms = Math.max(Math.floor(target), 1);
	      return _moment2['default'].duration(ms, 'ms');
	    }
	
	    return function (buckets, duration) {
	      var interval = pick(buckets, duration);
	      if (interval) return _moment2['default'].duration(interval._data);
	    };
	  }
	
	  return {
	    near: find(revRoundingRules, function near(bound, interval, target) {
	      if (bound > target) return interval;
	    }, true),
	
	    lessThan: find(revRoundingRules, function (bound, interval, target) {
	      if (interval < target) return interval;
	    }),
	
	    atLeast: find(revRoundingRules, function atLeast(bound, interval, target) {
	      if (interval <= target) return interval;
	    })
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 969 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _elasticDatemath = __webpack_require__(237);
	
	var _elasticDatemath2 = _interopRequireDefault(_elasticDatemath);
	
	exports['default'] = function () {
	
	  var unitsDesc = _elasticDatemath2['default'].unitsDesc;
	  var largeMax = unitsDesc.indexOf('M');
	
	  /**
	   * Convert a moment.duration into an es
	   * compatible expression, and provide
	   * associated metadata
	   *
	   * @param  {moment.duration} duration
	   * @return {object}
	   */
	  function esDuration(duration) {
	    for (var i = 0; i < unitsDesc.length; i++) {
	      var unit = unitsDesc[i];
	      var val = duration.as(unit);
	      // find a unit that rounds neatly
	      if (val >= 1 && Math.floor(val) === val) {
	
	        // if the unit is "large", like years, but
	        // isn't set to 1 ES will puke. So keep going until
	        // we get out of the "large" units
	        if (i <= largeMax && val !== 1) {
	          continue;
	        }
	
	        return {
	          value: val,
	          unit: unit,
	          expression: val + unit
	        };
	      }
	    }
	
	    var ms = duration.as('ms');
	    return {
	      value: ms,
	      unit: 'ms',
	      expression: ms + 'ms'
	    };
	  }
	
	  return esDuration;
	};
	
	module.exports = exports['default'];

/***/ },
/* 970 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createDateHistogramFilterProvider;
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiFilter_managerLibRange = __webpack_require__(971);
	
	var _uiFilter_managerLibRange2 = _interopRequireDefault(_uiFilter_managerLibRange);
	
	function createDateHistogramFilterProvider(Private) {
	
	  return function (agg, key) {
	    var start = (0, _moment2['default'])(key);
	    var interval = agg.buckets.getInterval();
	
	    return (0, _uiFilter_managerLibRange2['default'])(agg.params.field, {
	      gte: start.valueOf(),
	      lt: start.add(interval).valueOf(),
	      format: 'epoch_millis'
	    }, agg.vis.indexPattern);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 971 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = buildRangeFilter;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var OPERANDS_IN_RANGE = 2;
	
	function buildRangeFilter(field, params, indexPattern, formattedValue) {
	  var filter = { meta: { index: indexPattern.id } };
	  if (formattedValue) filter.meta.formattedValue = formattedValue;
	
	  params = _lodash2['default'].clone(params);
	
	  if ('gte' in params && 'gt' in params) throw new Error('gte and gt are mutually exclusive');
	  if ('lte' in params && 'lt' in params) throw new Error('lte and lt are mutually exclusive');
	
	  var totalInfinite = ['gt', 'lt'].reduce(function (totalInfinite, op) {
	    var key = op in params ? op : op + 'e';
	    var isInfinite = Math.abs(params[key]) === Infinity;
	
	    if (isInfinite) {
	      totalInfinite++;
	      delete params[key];
	    }
	
	    return totalInfinite;
	  }, 0);
	
	  if (totalInfinite === OPERANDS_IN_RANGE) {
	    filter.match_all = {};
	    filter.meta.field = field.name;
	  } else if (field.scripted) {
	    (function () {
	      var operators = {
	        gt: '>',
	        gte: '>=',
	        lte: '<=',
	        lt: '<'
	      };
	      var comparators = {
	        gt: 'boolean gt(Supplier s, def v) {return s.get() > v}',
	        gte: 'boolean gte(Supplier s, def v) {return s.get() >= v}',
	        lte: 'boolean lte(Supplier s, def v) {return s.get() <= v}',
	        lt: 'boolean lt(Supplier s, def v) {return s.get() < v}'
	      };
	
	      var knownParams = _lodash2['default'].pick(params, function (val, key) {
	        return key in operators;
	      });
	      var script = _lodash2['default'].map(knownParams, function (val, key) {
	        return '(' + field.script + ')' + operators[key] + key;
	      }).join(' && ');
	
	      // We must wrap painless scripts in a lambda in case they're more than a simple expression
	      if (field.lang === 'painless') {
	        var currentComparators = _lodash2['default'].reduce(knownParams, function (acc, val, key) {
	          return acc.concat(comparators[key]);
	        }, []).join(' ');
	
	        var comparisons = _lodash2['default'].map(knownParams, function (val, key) {
	          return key + '(() -> { ' + field.script + ' }, params.' + key + ')';
	        }).join(' && ');
	
	        script = '' + currentComparators + comparisons;
	      }
	
	      var value = _lodash2['default'].map(knownParams, function (val, key) {
	        return operators[key] + field.format.convert(val);
	      }).join(' ');
	
	      _lodash2['default'].set(filter, 'script.script', { inline: script, params: knownParams, lang: field.lang });
	      filter.script.script.params.value = value;
	      filter.meta.field = field.name;
	    })();
	  } else {
	    filter.range = {};
	    filter.range[field.name] = params;
	  }
	
	  return filter;
	}
	
	module.exports = exports['default'];

/***/ },
/* 972 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = IntervalOptionsService;
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function IntervalOptionsService(Private) {
	
	  // shorthand
	  var ms = function ms(type) {
	    return _moment2['default'].duration(1, type).asMilliseconds();
	  };
	
	  return [{
	    display: 'Auto',
	    val: 'auto',
	    enabled: function enabled(agg) {
	      // not only do we need a time field, but the selected field needs
	      // to be the time field. (see #3028)
	      return agg.fieldIsTimeField();
	    }
	  }, {
	    display: 'Millisecond',
	    val: 'ms'
	  }, {
	    display: 'Second',
	    val: 's'
	  }, {
	    display: 'Minute',
	    val: 'm'
	  }, {
	    display: 'Hourly',
	    val: 'h'
	  }, {
	    display: 'Daily',
	    val: 'd'
	  }, {
	    display: 'Weekly',
	    val: 'w'
	  }, {
	    display: 'Monthly',
	    val: 'M'
	  }, {
	    display: 'Yearly',
	    val: 'y'
	  }, {
	    display: 'Custom',
	    val: 'custom'
	  }];
	}
	
	module.exports = exports['default'];

/***/ },
/* 973 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>\n    Interval\n    <kbn-info\n      ng-show=\"agg.buckets.getInterval().scaled\"\n      placement=\"right\"\n      class=\"text-warning\"\n      info=\"This interval creates {{ agg.buckets.getInterval().scale > 1 ? 'buckets that are too large' : 'too many buckets' }} to show in the selected time range, so it has been scaled to {{ agg.buckets.getInterval().description }}\">\n    </kbn-info>\n  </label>\n  <select\n    ng-if=\"aggParam.options\"\n    ng-model=\"agg.params.interval\"\n    ng-change=\"agg.write()\"\n    required\n    ng-options=\"opt as opt.display for opt in aggParam.options.raw | filter: optionEnabled\"\n    class=\"form-control\"\n    name=\"interval\">\n    <option value=\"\">-- select a valid interval --</option>\n  </select>\n  <input\n    type=\"text\"\n    name=\"customInterval\"\n    ng-model=\"agg.params.customInterval\"\n    validate-date-interval\n    ng-change=\"aggForm.customInterval.$valid && agg.write()\"\n    ng-if=\"agg.params.interval.val == 'custom'\"\n    class=\"form-control\"\n    required />\n  <input\n    ng-if=\"!aggParam.options\"\n    ng-model=\"agg.params.interval\"\n    required\n    type=\"number\"\n    class=\"form-control\"\n    name=\"interval\"\n    min=\"0\"\n    input-number\n    >\n</div>\n"

/***/ },
/* 974 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = HistogramAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	__webpack_require__(732);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBucketsCreate_filterHistogram = __webpack_require__(975);
	
	var _uiAgg_typesBucketsCreate_filterHistogram2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterHistogram);
	
	var _uiAgg_typesControlsIntervalHtml = __webpack_require__(973);
	
	var _uiAgg_typesControlsIntervalHtml2 = _interopRequireDefault(_uiAgg_typesControlsIntervalHtml);
	
	var _uiAgg_typesControlsMin_doc_countHtml = __webpack_require__(976);
	
	var _uiAgg_typesControlsMin_doc_countHtml2 = _interopRequireDefault(_uiAgg_typesControlsMin_doc_countHtml);
	
	var _uiAgg_typesControlsExtended_boundsHtml = __webpack_require__(977);
	
	var _uiAgg_typesControlsExtended_boundsHtml2 = _interopRequireDefault(_uiAgg_typesControlsExtended_boundsHtml);
	
	function HistogramAggDefinition(Private) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterHistogram2['default']);
	
	  return new BucketAggType({
	    name: 'histogram',
	    title: 'Histogram',
	    ordered: {},
	    makeLabel: function makeLabel(aggConfig) {
	      return aggConfig.getFieldDisplayName();
	    },
	    createFilter: createFilter,
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'number'
	    }, {
	      name: 'interval',
	      editor: _uiAgg_typesControlsIntervalHtml2['default'],
	      write: function write(aggConfig, output) {
	        output.params.interval = parseFloat(aggConfig.params.interval);
	      }
	    }, {
	      name: 'min_doc_count',
	      'default': null,
	      editor: _uiAgg_typesControlsMin_doc_countHtml2['default'],
	      write: function write(aggConfig, output) {
	        if (aggConfig.params.min_doc_count) {
	          output.params.min_doc_count = 0;
	        } else {
	          output.params.min_doc_count = 1;
	        }
	      }
	    }, {
	      name: 'extended_bounds',
	      'default': {},
	      editor: _uiAgg_typesControlsExtended_boundsHtml2['default'],
	      write: function write(aggConfig, output) {
	        var val = aggConfig.params.extended_bounds;
	
	        if (aggConfig.params.min_doc_count && (val.min != null || val.max != null)) {
	          output.params.extended_bounds = {
	            min: val.min,
	            max: val.max
	          };
	        }
	      },
	
	      // called from the editor
	      shouldShow: function shouldShow(aggConfig) {
	        var field = aggConfig.params.field;
	        if (field && (field.type === 'number' || field.type === 'date')) {
	          return aggConfig.params.min_doc_count;
	        }
	      }
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 975 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createHistogramFilterProvider;
	
	var _uiFilter_managerLibRange = __webpack_require__(971);
	
	var _uiFilter_managerLibRange2 = _interopRequireDefault(_uiFilter_managerLibRange);
	
	function createHistogramFilterProvider(Private) {
	  return function (aggConfig, key) {
	    var value = parseInt(key, 10);
	
	    return (0, _uiFilter_managerLibRange2['default'])(aggConfig.params.field, { gte: value, lt: value + aggConfig.params.interval }, aggConfig.vis.indexPattern, aggConfig.fieldFormatter()(key));
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 976 */
/***/ function(module, exports) {

	module.exports = "<div class=\"checkbox ng-scope\">\n  <label>\n    <input ng-model=\"agg.params.min_doc_count\" type=\"checkbox\">\n    Show empty buckets&nbsp;\n    <kbn-info\n      info=\"Show all buckets, not only the buckets with results.\"\n      placement=\"right\">\n      </kbn-info>\n  </label>\n</div>"

/***/ },
/* 977 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"aggParam.shouldShow(agg)\">\n  <div>\n    <label>Extended Bounds</label>\n    <kbn-info info=\"Min and Max do not filter the results, but rather extend the bounds of the result set.\"></kbn-info>\n  </div>\n  <div class=\"vis-editor-agg-form-row\">\n    <div class=\"form-group\">\n      <div>Min <small>(optional)</small></div>\n      <input\n        ng-model=\"agg.params.extended_bounds.min\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"extended_bounds.min\" />\n    </div>\n    <div class=\"form-group\">\n      <div>Max <small>(optional)</small></div>\n      <input\n        ng-model=\"agg.params.extended_bounds.max\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"extended_bounds.max\" />\n    </div>\n  </div>\n</div>"

/***/ },
/* 978 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _WeakMap = __webpack_require__(484)['default'];
	
	var _Map = __webpack_require__(830)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RangeAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBucketsCreate_filterRange = __webpack_require__(979);
	
	var _uiAgg_typesBucketsCreate_filterRange2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterRange);
	
	var _uiIndex_patterns_field_formatField_format = __webpack_require__(537);
	
	var _uiIndex_patterns_field_formatField_format2 = _interopRequireDefault(_uiIndex_patterns_field_formatField_format);
	
	var _range_key = __webpack_require__(980);
	
	var _range_key2 = _interopRequireDefault(_range_key);
	
	var _uiAgg_typesControlsRangesHtml = __webpack_require__(981);
	
	var _uiAgg_typesControlsRangesHtml2 = _interopRequireDefault(_uiAgg_typesControlsRangesHtml);
	
	function RangeAggDefinition(Private) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterRange2['default']);
	  var FieldFormat = Private(_uiIndex_patterns_field_formatField_format2['default']);
	  var RangeKey = Private(_range_key2['default']);
	
	  var keyCaches = new _WeakMap();
	  var formats = new _WeakMap();
	
	  return new BucketAggType({
	    name: 'range',
	    title: 'Range',
	    createFilter: createFilter,
	    makeLabel: function makeLabel(aggConfig) {
	      return aggConfig.getFieldDisplayName() + ' ranges';
	    },
	    getKey: function getKey(bucket, key, agg) {
	      var keys = keyCaches.get(agg);
	
	      if (!keys) {
	        keys = new _Map();
	        keyCaches.set(agg, keys);
	      }
	
	      var id = RangeKey.idBucket(bucket);
	
	      key = keys.get(id);
	      if (!key) {
	        key = new RangeKey(bucket);
	        keys.set(id, key);
	      }
	
	      return key;
	    },
	    getFormat: function getFormat(agg) {
	      var format = formats.get(agg);
	      if (format) return format;
	
	      var RangeFormat = FieldFormat.from(function (range) {
	        var format = agg.fieldOwnFormatter();
	        return format(range.gte) + ' to ' + format(range.lt);
	      });
	
	      format = new RangeFormat();
	
	      formats.set(agg, format);
	      return format;
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: ['number']
	    }, {
	      name: 'ranges',
	      'default': [{ from: 0, to: 1000 }, { from: 1000, to: 2000 }],
	      editor: _uiAgg_typesControlsRangesHtml2['default'],
	      write: function write(aggConfig, output) {
	        output.params.ranges = aggConfig.params.ranges;
	        output.params.keyed = true;
	      }
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 979 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createRangeFilterProvider;
	
	var _uiFilter_managerLibRange = __webpack_require__(971);
	
	var _uiFilter_managerLibRange2 = _interopRequireDefault(_uiFilter_managerLibRange);
	
	function createRangeFilterProvider(Private) {
	  return function (aggConfig, key) {
	    return (0, _uiFilter_managerLibRange2['default'])(aggConfig.params.field, key, aggConfig.vis.indexPattern, aggConfig.fieldFormatter()(key));
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 980 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = __webpack_require__(242)['default'];
	
	var _classCallCheck = __webpack_require__(245)['default'];
	
	var _Symbol = __webpack_require__(547)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	exports['default'] = function () {
	
	  var id = _Symbol('id');
	
	  var RangeKey = (function () {
	    function RangeKey(bucket) {
	      _classCallCheck(this, RangeKey);
	
	      this.gte = bucket.from == null ? -Infinity : bucket.from;
	      this.lt = bucket.to == null ? +Infinity : bucket.to;
	
	      this[id] = RangeKey.idBucket(bucket);
	    }
	
	    _createClass(RangeKey, [{
	      key: 'toString',
	      value: function toString() {
	        return this[id];
	      }
	    }], [{
	      key: 'idBucket',
	      value: function idBucket(bucket) {
	        return 'from:' + bucket.from + ',to:' + bucket.to;
	      }
	    }]);
	
	    return RangeKey;
	  })();
	
	  return RangeKey;
	};
	
	module.exports = exports['default'];

/***/ },
/* 981 */
/***/ function(module, exports) {

	module.exports = "<table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.length\">\n  <tr>\n    <th>\n      <label>From</label>\n    </th>\n    <th colspan=\"2\">\n      <label>To</label>\n    </th>\n  </tr>\n\n  <tr\n    ng-repeat=\"range in agg.params.ranges track by $index\">\n    <td>\n      <input\n        ng-model=\"range.from\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"range.from\"\n        step=\"any\" />\n    </td>\n    <td>\n      <input\n        ng-model=\"range.to\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"range.to\"\n        step=\"any\" />\n    </td>\n    <td>\n      <button\n        type=\"button\"\n        ng-click=\"agg.params.ranges.splice($index, 1)\"\n        class=\"btn btn-danger btn-xs\">\n        <i class=\"fa fa-times\"></i>\n      </button>\n    </td>\n  </tr>\n</table>\n\n<input ng-model=\"agg.params.ranges.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n<div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n  <p>\n    <i class=\"fa fa-danger text-danger\"></i>\n    <strong>Required:</strong> You must specify at least one range.\n  </p>\n</div>\n\n<div\n  ng-click=\"agg.params.ranges.push({})\"\n  class=\"sidebar-item-button primary\">\n  Add Range\n</div>"

/***/ },
/* 982 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = DateRangeAggDefinition;
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _uiUtilsDate_range = __webpack_require__(983);
	
	var _uiUtilsDate_range2 = _interopRequireDefault(_uiUtilsDate_range);
	
	__webpack_require__(767);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBucketsCreate_filterDate_range = __webpack_require__(984);
	
	var _uiAgg_typesBucketsCreate_filterDate_range2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterDate_range);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	var _uiAgg_typesControlsDate_rangesHtml = __webpack_require__(985);
	
	var _uiAgg_typesControlsDate_rangesHtml2 = _interopRequireDefault(_uiAgg_typesControlsDate_rangesHtml);
	
	function DateRangeAggDefinition(Private, config) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterDate_range2['default']);
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  return new BucketAggType({
	    name: 'date_range',
	    title: 'Date Range',
	    createFilter: createFilter,
	    getKey: function getKey(bucket, key, agg) {
	      var formatter = agg.fieldOwnFormatter('text', fieldFormats.getDefaultInstance('date'));
	      return _uiUtilsDate_range2['default'].toString(bucket, formatter);
	    },
	    getFormat: function getFormat() {
	      return fieldFormats.getDefaultInstance('string');
	    },
	    makeLabel: function makeLabel(aggConfig) {
	      return aggConfig.getFieldDisplayName() + ' date ranges';
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'date',
	      'default': function _default(agg) {
	        return agg.vis.indexPattern.timeFieldName;
	      }
	    }, {
	      name: 'ranges',
	      'default': [{
	        from: 'now-1w/w',
	        to: 'now'
	      }],
	      editor: _uiAgg_typesControlsDate_rangesHtml2['default']
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 983 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	exports['default'] = {
	  toString: function toString(range, format) {
	    if (!range.from) {
	      return 'Before ' + format(range.to);
	    } else if (!range.to) {
	      return 'After ' + format(range.from);
	    } else {
	      return format(range.from) + ' to ' + format(range.to);
	    }
	  },
	  parse: function parse(rangeString, format) {
	    var chunks = rangeString.split(' to ');
	    if (chunks.length === 2) return { from: (0, _moment2['default'])(chunks[0], format), to: (0, _moment2['default'])(chunks[1], format) };
	
	    chunks = rangeString.split('Before ');
	    if (chunks.length === 2) return { to: (0, _moment2['default'])(chunks[1], format) };
	
	    chunks = rangeString.split('After ');
	    if (chunks.length === 2) return { from: (0, _moment2['default'])(chunks[1], format) };
	
	    throw new Error('Error attempting to parse date range: ' + rangeString);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 984 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createDateRangeFilterProvider;
	
	var _uiUtilsDate_range = __webpack_require__(983);
	
	var _uiUtilsDate_range2 = _interopRequireDefault(_uiUtilsDate_range);
	
	var _uiFilter_managerLibRange = __webpack_require__(971);
	
	var _uiFilter_managerLibRange2 = _interopRequireDefault(_uiFilter_managerLibRange);
	
	function createDateRangeFilterProvider(config) {
	
	  return function (agg, key) {
	    var range = _uiUtilsDate_range2['default'].parse(key, config.get('dateFormat'));
	
	    var filter = {};
	    if (range.from) filter.gte = +range.from;
	    if (range.to) filter.lt = +range.to;
	    if (range.to && range.from) filter.format = 'epoch_millis';
	
	    return (0, _uiFilter_managerLibRange2['default'])(agg.params.field, filter, agg.vis.indexPattern);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 985 */
/***/ function(module, exports) {

	module.exports = "<div>\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.length\">\n      <tr>\n        <th>\n          <label>From</label>\n        </th>\n        <th colspan=\"2\">\n          <label>To</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges track by $index\">\n        <td class=\"kbn-timepicker\">\n          <input\n            ng-model=\"range.from\"\n            validate-date-math\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td class=\"kbn-timepicker\">\n          <input\n            ng-model=\"range.to\"\n            validate-date-math\n            class=\"form-control\"\n            name=\"range.to\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            ng-click=\"agg.params.ranges.splice($index, 1)\"\n            class=\"btn btn-danger btn-xs\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n      <tr>\n        <td colspan=\"3\">\n          <small>\n            <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#date-math\">Accepted Date Formats <i class=\"fa-link fa\"></i></a>\n          </small>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-model=\"agg.params.ranges.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one date range.\n      </p>\n    </div>\n\n    <div\n      ng-click=\"agg.params.ranges.push({})\"\n      class=\"sidebar-item-button primary\">\n      Add Range\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 986 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RangeAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	__webpack_require__(769);
	
	__webpack_require__(764);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBucketsCreate_filterIp_range = __webpack_require__(987);
	
	var _uiAgg_typesBucketsCreate_filterIp_range2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterIp_range);
	
	var _uiAgg_typesControlsIp_rangesHtml = __webpack_require__(988);
	
	var _uiAgg_typesControlsIp_rangesHtml2 = _interopRequireDefault(_uiAgg_typesControlsIp_rangesHtml);
	
	function RangeAggDefinition(Private) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterIp_range2['default']);
	
	  return new BucketAggType({
	    name: 'ip_range',
	    title: 'IPv4 Range',
	    createFilter: createFilter,
	    getKey: function getKey(bucket, key, agg) {
	      if (key) return key;
	      var from = _lodash2['default'].get(bucket, 'from', '-Infinity');
	      var to = _lodash2['default'].get(bucket, 'to', 'Infinity');
	      return from + ' to ' + to;
	    },
	    makeLabel: function makeLabel(aggConfig) {
	      return aggConfig.getFieldDisplayName() + ' IP ranges';
	    },
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'ip'
	    }, {
	      name: 'ipRangeType',
	      'default': 'fromTo',
	      write: _lodash2['default'].noop
	    }, {
	      name: 'ranges',
	      'default': {
	        fromTo: [{ from: '0.0.0.0', to: '127.255.255.255' }, { from: '128.0.0.0', to: '191.255.255.255' }],
	        mask: [{ mask: '0.0.0.0/1' }, { mask: '128.0.0.0/2' }]
	      },
	      editor: _uiAgg_typesControlsIp_rangesHtml2['default'],
	      write: function write(aggConfig, output) {
	        var ipRangeType = aggConfig.params.ipRangeType;
	        var ranges = aggConfig.params.ranges[ipRangeType];
	
	        if (ipRangeType === 'fromTo') {
	          ranges = _lodash2['default'].map(ranges, function (range) {
	            return _lodash2['default'].omit(range, _lodash2['default'].isNull);
	          });
	        }
	
	        output.params.ranges = ranges;
	      }
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 987 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _slicedToArray = __webpack_require__(290)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createIpRangeFilterProvider;
	
	var _uiUtilsCidr_mask = __webpack_require__(765);
	
	var _uiUtilsCidr_mask2 = _interopRequireDefault(_uiUtilsCidr_mask);
	
	var _uiFilter_managerLibRange = __webpack_require__(971);
	
	var _uiFilter_managerLibRange2 = _interopRequireDefault(_uiFilter_managerLibRange);
	
	function createIpRangeFilterProvider() {
	  return function (aggConfig, key) {
	    var range = undefined;
	    if (aggConfig.params.ipRangeType === 'mask') {
	      range = new _uiUtilsCidr_mask2['default'](key).getRange();
	    } else {
	      var _key$split = key.split(/\s+to\s+/);
	
	      var _key$split2 = _slicedToArray(_key$split, 2);
	
	      var from = _key$split2[0];
	      var to = _key$split2[1];
	
	      range = {
	        from: from === '-Infinity' ? -Infinity : from,
	        to: to === 'Infinity' ? Infinity : to
	      };
	    }
	
	    return (0, _uiFilter_managerLibRange2['default'])(aggConfig.params.field, { gte: range.from, lte: range.to }, aggConfig.vis.indexPattern);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 988 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <p>\n    <button type=\"button\" class=\"btn btn-default\" ng-show=\"agg.params.ipRangeType == 'mask'\" ng-click=\"agg.params.ipRangeType = 'fromTo'\">Use From/To</button>\n    <button type=\"button\" class=\"btn btn-default\" ng-show=\"agg.params.ipRangeType != 'mask'\" ng-click=\"agg.params.ipRangeType = 'mask'\">Use CIDR Masks</button>\n  </p>\n\n  <div ng-show=\"agg.params.ipRangeType != 'mask'\">\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.fromTo.length\">\n      <tr>\n        <th>\n          <label>From</label>\n        </th>\n        <th colspan=\"2\">\n          <label>To</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges.fromTo track by $index\">\n        <td>\n          <input\n            validate-ip\n            ng-model=\"range.from\"\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <input\n            validate-ip\n            ng-model=\"range.to\"\n            class=\"form-control\"\n            name=\"range.to\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            ng-click=\"agg.params.ranges.fromTo.splice($index, 1)\"\n            class=\"btn btn-danger btn-xs\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-if=\"agg.params.ipRangeType != 'mask'\" ng-model=\"agg.params.ranges.fromTo.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one IP range.\n      </p>\n    </div>\n\n    <div\n      ng-click=\"agg.params.ranges.fromTo.push({})\"\n      class=\"sidebar-item-button primary\">\n      Add Range\n    </div>\n  </div>\n\n  <div ng-show=\"agg.params.ipRangeType == 'mask'\">\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.mask.length\">\n      <tr>\n        <th>\n          <label>Mask</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges.mask track by $index\">\n        <td>\n          <input\n            validate-cidr-mask\n            ng-model=\"range.mask\"\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            ng-click=\"agg.params.ranges.mask.splice($index, 1)\"\n            class=\"btn btn-danger btn-xs\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-if=\"agg.params.ipRangeType == 'mask'\" ng-model=\"agg.params.ranges.mask.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one IP range.\n      </p>\n    </div>\n\n    <div\n      ng-click=\"agg.params.ranges.mask.push({})\"\n      class=\"sidebar-item-button primary\">\n      Add Range\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 989 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = __webpack_require__(351)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = TermsAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBuckets_bucket_count_between = __webpack_require__(990);
	
	var _uiAgg_typesBuckets_bucket_count_between2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_count_between);
	
	var _uiVisAgg_config = __webpack_require__(991);
	
	var _uiVisAgg_config2 = _interopRequireDefault(_uiVisAgg_config);
	
	var _uiVisSchemas = __webpack_require__(992);
	
	var _uiVisSchemas2 = _interopRequireDefault(_uiVisSchemas);
	
	var _uiAgg_typesBucketsCreate_filterTerms = __webpack_require__(995);
	
	var _uiAgg_typesBucketsCreate_filterTerms2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterTerms);
	
	var _uiAgg_typesControlsOrder_aggHtml = __webpack_require__(996);
	
	var _uiAgg_typesControlsOrder_aggHtml2 = _interopRequireDefault(_uiAgg_typesControlsOrder_aggHtml);
	
	var _uiAgg_typesControlsOrder_and_sizeHtml = __webpack_require__(997);
	
	var _uiAgg_typesControlsOrder_and_sizeHtml2 = _interopRequireDefault(_uiAgg_typesControlsOrder_and_sizeHtml);
	
	var _uiRoute_based_notifier = __webpack_require__(998);
	
	var _uiRoute_based_notifier2 = _interopRequireDefault(_uiRoute_based_notifier);
	
	function TermsAggDefinition(Private) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var bucketCountBetween = Private(_uiAgg_typesBuckets_bucket_count_between2['default']);
	  var AggConfig = Private(_uiVisAgg_config2['default']);
	  var Schemas = Private(_uiVisSchemas2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterTerms2['default']);
	  var routeBasedNotifier = Private(_uiRoute_based_notifier2['default']);
	
	  var aggFilter = ['!top_hits', '!percentiles', '!median', '!std_dev'];
	  var orderAggSchema = new Schemas([{
	    group: 'none',
	    name: 'orderAgg',
	    title: 'Order Agg',
	    aggFilter: aggFilter
	  }]).all[0];
	
	  function isNotType(type) {
	    return function (agg) {
	      var field = agg.params.field;
	      return !field || field.type !== type;
	    };
	  }
	
	  var migrateIncludeExcludeFormat = {
	    serialize: function serialize(value) {
	      if (!value || _lodash2['default'].isString(value)) return value;else return value.pattern;
	    },
	    write: function write(aggConfig, output) {
	      var value = aggConfig.params[this.name];
	      if (_lodash2['default'].isObject(value)) {
	        output.params[this.name] = value.pattern;
	      } else if (value) {
	        output.params[this.name] = value;
	      }
	    }
	  };
	
	  return new BucketAggType({
	    name: 'terms',
	    title: 'Terms',
	    makeLabel: function makeLabel(agg) {
	      var params = agg.params;
	      return agg.getFieldDisplayName() + ': ' + params.order.display;
	    },
	    createFilter: createFilter,
	    params: [{
	      name: 'field',
	      filterFieldTypes: ['number', 'boolean', 'date', 'ip', 'string']
	    }, _extends({
	      name: 'exclude',
	      type: 'string',
	      advanced: true,
	      disabled: isNotType('string')
	    }, migrateIncludeExcludeFormat), _extends({
	      name: 'include',
	      type: 'string',
	      advanced: true,
	      disabled: isNotType('string')
	    }, migrateIncludeExcludeFormat), {
	      name: 'size',
	      'default': 5
	    }, {
	      name: 'orderAgg',
	      type: AggConfig,
	      'default': null,
	      editor: _uiAgg_typesControlsOrder_aggHtml2['default'],
	      serialize: function serialize(orderAgg) {
	        return orderAgg.toJSON();
	      },
	      deserialize: function deserialize(state, agg) {
	        return this.makeOrderAgg(agg, state);
	      },
	      makeOrderAgg: function makeOrderAgg(termsAgg, state) {
	        state = state || {};
	        state.schema = orderAggSchema;
	        var orderAgg = new AggConfig(termsAgg.vis, state);
	        orderAgg.id = termsAgg.id + '-orderAgg';
	        return orderAgg;
	      },
	      controller: function controller($scope) {
	        $scope.safeMakeLabel = function (agg) {
	          try {
	            return agg.makeLabel();
	          } catch (e) {
	            return '- agg not valid -';
	          }
	        };
	
	        var INIT = {}; // flag to know when prevOrderBy has changed
	        var prevOrderBy = INIT;
	
	        $scope.$watch('responseValueAggs', updateOrderAgg);
	        $scope.$watch('agg.params.orderBy', updateOrderAgg);
	
	        // Returns true if the agg is not compatible with the terms bucket
	        $scope.rejectAgg = function (agg) {
	          // aggFilter elements all starts with a '!'
	          // so the index of agg.type.name in a filter is 1 if it is included
	          return Boolean(aggFilter.find(function (filter) {
	            return filter.indexOf(agg.type.name) === 1;
	          }));
	        };
	
	        function updateOrderAgg() {
	          // abort until we get the responseValueAggs
	          if (!$scope.responseValueAggs) return;
	          var agg = $scope.agg;
	          var params = agg.params;
	          var orderBy = params.orderBy;
	          var paramDef = agg.type.params.byName.orderAgg;
	
	          // setup the initial value of orderBy
	          if (!orderBy && prevOrderBy === INIT) {
	            var respAgg = (0, _lodash2['default'])($scope.responseValueAggs).filter(function (agg) {
	              return !$scope.rejectAgg(agg);
	            }).first();
	            if (!respAgg) {
	              respAgg = { id: '_term' };
	            }
	            params.orderBy = respAgg.id;
	            return;
	          }
	
	          // track the previous value
	          prevOrderBy = orderBy;
	
	          // we aren't creating a custom aggConfig
	          if (!orderBy || orderBy !== 'custom') {
	            params.orderAgg = null;
	            // ensure that orderBy is set to a valid agg
	            var respAgg = (0, _lodash2['default'])($scope.responseValueAggs).filter(function (agg) {
	              return !$scope.rejectAgg(agg);
	            }).find({ id: orderBy });
	            if (!respAgg) {
	              params.orderBy = '_term';
	            }
	            return;
	          }
	
	          params.orderAgg = params.orderAgg || paramDef.makeOrderAgg(agg);
	        }
	      },
	      write: function write(agg, output) {
	        var vis = agg.vis;
	        var dir = agg.params.order.val;
	        var order = output.params.order = {};
	
	        var orderAgg = agg.params.orderAgg || vis.aggs.getResponseAggById(agg.params.orderBy);
	
	        // TODO: This works around an Elasticsearch bug the always casts terms agg scripts to strings
	        // thus causing issues with filtering. This probably causes other issues since float might not
	        // be able to contain the number on the elasticsearch side
	        if (output.params.script) {
	          output.params.valueType = agg.getField().type === 'number' ? 'float' : agg.getField().type;
	        }
	
	        if (!orderAgg) {
	          order[agg.params.orderBy || '_count'] = dir;
	          return;
	        }
	
	        if (orderAgg.type.name === 'count') {
	          if (dir === 'asc') {
	            routeBasedNotifier.warning('Sorting in Ascending order by Count in Terms aggregations is deprecated');
	          }
	          order._count = dir;
	          return;
	        }
	
	        var orderAggId = orderAgg.id;
	        if (orderAgg.parentId) {
	          orderAgg = vis.aggs.byId[orderAgg.parentId];
	        }
	
	        output.subAggs = (output.subAggs || []).concat(orderAgg);
	        order[orderAggId] = dir;
	      }
	    }, {
	      name: 'order',
	      type: 'optioned',
	      'default': 'desc',
	      editor: _uiAgg_typesControlsOrder_and_sizeHtml2['default'],
	      options: [{ display: 'Descending', val: 'desc' }, { display: 'Ascending', val: 'asc' }],
	      write: _lodash2['default'].noop // prevent default write, it's handled by orderAgg
	    }, {
	      name: 'orderBy',
	      write: _lodash2['default'].noop // prevent default write, it's handled by orderAgg
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 990 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = BucketCountBetweenProvider;
	
	function BucketCountBetweenProvider() {
	
	  /**
	   * Count the number of bucket aggs between two agg config objects owned
	   * by the same vis.
	   *
	   * If one of the two aggs was not found in the agg list, returns null.
	   * If a was found after b, the count will be negative
	   * If a was found first, the count will be positive.
	   *
	   * @param  {AggConfig} aggConfigA - the aggConfig that is expected first
	   * @param  {AggConfig} aggConfigB - the aggConfig that is expected second
	   * @return {null|number}
	   */
	  function bucketCountBetween(aggConfigA, aggConfigB) {
	    var aggs = aggConfigA.vis.aggs.getRequestAggs();
	
	    var aIndex = aggs.indexOf(aggConfigA);
	    var bIndex = aggs.indexOf(aggConfigB);
	
	    if (aIndex === -1 || bIndex === -1) {
	      return null;
	    }
	
	    // return a negative distance, if b is before a
	    var negative = aIndex > bIndex;
	
	    var count = aggs.slice(Math.min(aIndex, bIndex), Math.max(aIndex, bIndex)).reduce(function (count, cfg) {
	      if (cfg === aggConfigA || cfg === aggConfigB || cfg.schema.group !== 'buckets') {
	        return count;
	      } else {
	        return count + 1;
	      }
	    }, 0);
	
	    return (negative ? -1 : 1) * count;
	  }
	
	  return bucketCountBetween;
	}
	
	module.exports = exports['default'];

/***/ },
/* 991 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name AggConfig
	 *
	 * @description This class represents an aggregation, which is displayed in the left-hand nav of
	 * the Visualize app.
	 */
	
	'use strict';
	
	var _Object$defineProperties = __webpack_require__(15)['default'];
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggConfigFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiRegistryField_formats = __webpack_require__(494);
	
	var _uiRegistryField_formats2 = _interopRequireDefault(_uiRegistryField_formats);
	
	function AggConfigFactory(Private, fieldTypeFilter) {
	  var fieldFormats = Private(_uiRegistryField_formats2['default']);
	
	  function AggConfig(vis, opts) {
	    var self = this;
	
	    self.id = String(opts.id || AggConfig.nextId(vis.aggs));
	    self.vis = vis;
	    self._opts = opts = opts || {};
	    self.enabled = typeof opts.enabled === 'boolean' ? opts.enabled : true;
	
	    // setters
	    self.type = opts.type;
	    self.schema = opts.schema;
	
	    // resolve the params
	    self.fillDefaults(opts.params);
	  }
	
	  /**
	   * Ensure that all of the objects in the list have ids, the objects
	   * and list are modified by reference.
	   *
	   * @param  {array[object]} list - a list of objects, objects can be anything really
	   * @return {array} - the list that was passed in
	   */
	  AggConfig.ensureIds = function (list) {
	    var have = [];
	    var haveNot = [];
	    list.forEach(function (obj) {
	      (obj.id ? have : haveNot).push(obj);
	    });
	
	    var nextId = AggConfig.nextId(have);
	    haveNot.forEach(function (obj) {
	      obj.id = String(nextId++);
	    });
	
	    return list;
	  };
	
	  /**
	   * Calculate the next id based on the ids in this list
	   *
	   * @return {array} list - a list of objects with id properties
	   */
	  AggConfig.nextId = function (list) {
	    return 1 + list.reduce(function (max, obj) {
	      return Math.max(max, +obj.id || 0);
	    }, 0);
	  };
	
	  _Object$defineProperties(AggConfig.prototype, {
	    type: {
	      get: function get() {
	        return this.__type;
	      },
	      set: function set(type) {
	        if (this.__typeDecorations) {
	          _lodash2['default'].forOwn(this.__typeDecorations, function (prop, name) {
	            delete this[name];
	          }, this);
	        }
	
	        if (_lodash2['default'].isString(type)) {
	          type = AggConfig.aggTypes.byName[type];
	        }
	
	        if (type && _lodash2['default'].isFunction(type.decorateAggConfig)) {
	          this.__typeDecorations = type.decorateAggConfig();
	          _Object$defineProperties(this, this.__typeDecorations);
	        }
	
	        this.__type = type;
	      }
	    },
	    schema: {
	      get: function get() {
	        return this.__schema;
	      },
	      set: function set(schema) {
	        if (_lodash2['default'].isString(schema)) {
	          schema = this.vis.type.schemas.all.byName[schema];
	        }
	
	        this.__schema = schema;
	      }
	    }
	  });
	
	  /**
	   * Write the current values to this.params, filling in the defaults as we go
	   *
	   * @param  {object} [from] - optional object to read values from,
	   *                         used when initializing
	   * @return {undefined}
	   */
	  AggConfig.prototype.fillDefaults = function (from) {
	    var self = this;
	    from = from || self.params || {};
	    var to = self.params = {};
	
	    self.getAggParams().forEach(function (aggParam) {
	      var val = from[aggParam.name];
	
	      if (val == null) {
	        if (aggParam['default'] == null) return;
	
	        if (!_lodash2['default'].isFunction(aggParam['default'])) {
	          val = aggParam['default'];
	        } else {
	          val = aggParam['default'](self);
	          if (val == null) return;
	        }
	      }
	
	      if (aggParam.deserialize) {
	        var isTyped = _lodash2['default'].isFunction(aggParam.type);
	
	        var isType = isTyped && val instanceof aggParam.type;
	        var isObject = !isTyped && _lodash2['default'].isObject(val);
	        var isDeserialized = isType || isObject;
	
	        if (!isDeserialized) {
	          val = aggParam.deserialize(val, self);
	        }
	
	        to[aggParam.name] = val;
	        return;
	      }
	
	      to[aggParam.name] = _lodash2['default'].cloneDeep(val);
	    });
	  };
	
	  /**
	   * Clear the parameters for this aggConfig
	   *
	   * @return {object} the new params object
	   */
	  AggConfig.prototype.resetParams = function () {
	    var field = undefined;
	    var fieldOptions = this.getFieldOptions();
	
	    if (fieldOptions) {
	      var prevField = fieldOptions.byName[this.fieldName()] || null;
	      var filters = fieldOptions.filterFieldTypes;
	      if (_lodash2['default'].isFunction(fieldOptions.filterFieldTypes)) {
	        filters = fieldOptions.filterFieldTypes.bind(this, this.vis);
	      }
	      var fieldOpts = fieldTypeFilter(this.vis.indexPattern.fields, filters);
	      field = _lodash2['default'].contains(fieldOpts, prevField) ? prevField : null;
	    }
	
	    return this.fillDefaults({ row: this.params.row, field: field });
	  };
	
	  AggConfig.prototype.write = function () {
	    return this.type.params.write(this);
	  };
	
	  AggConfig.prototype.createFilter = function (key) {
	    if (!_lodash2['default'].isFunction(this.type.createFilter)) {
	      throw new TypeError('The "' + this.type.title + '" aggregation does not support filtering.');
	    }
	
	    var field = this.getField();
	    var label = this.getFieldDisplayName();
	    if (field && !field.filterable) {
	      var message = 'The "' + label + '" field can not be used for filtering.';
	      if (field.scripted) {
	        message = 'The "' + label + '" field is scripted and can not be used for filtering.';
	      }
	      throw new TypeError(message);
	    }
	
	    return this.type.createFilter(this, key);
	  };
	
	  /**
	   * Hook into param onRequest handling, and tell the aggConfig that it
	   * is being sent to elasticsearch.
	   *
	   * @return {[type]} [description]
	   */
	  AggConfig.prototype.requesting = function () {
	    var self = this;
	    self.type && self.type.params.forEach(function (param) {
	      if (param.onRequest) param.onRequest(self);
	    });
	  };
	
	  /**
	   * Convert this aggConfig to its dsl syntax.
	   *
	   * Adds params and adhoc subaggs to a pojo, then returns it
	   *
	   * @param  {AggConfig} aggConfig - the config object to convert
	   * @return {void|Object} - if the config has a dsl representation, it is
	   *                         returned, else undefined is returned
	   */
	  AggConfig.prototype.toDsl = function () {
	    if (this.type.hasNoDsl) return;
	    var output = this.write();
	
	    var configDsl = {};
	    configDsl[this.type.dslName || this.type.name] = output.params;
	
	    // if the config requires subAggs, write them to the dsl as well
	    if (output.subAggs) {
	      (function () {
	        var subDslLvl = configDsl.aggs || (configDsl.aggs = {});
	        output.subAggs.forEach(function nestAdhocSubAggs(subAggConfig) {
	          subDslLvl[subAggConfig.id] = subAggConfig.toDsl();
	        });
	      })();
	    }
	
	    return configDsl;
	  };
	
	  AggConfig.prototype.toJSON = function () {
	    var self = this;
	    var params = self.params;
	
	    var outParams = _lodash2['default'].transform(self.getAggParams(), function (out, aggParam) {
	      var val = params[aggParam.name];
	
	      // don't serialize undefined/null values
	      if (val == null) return;
	      if (aggParam.serialize) val = aggParam.serialize(val, self);
	      if (val == null) return;
	
	      // to prevent accidental leaking, we will clone all complex values
	      out[aggParam.name] = _lodash2['default'].cloneDeep(val);
	    }, {});
	
	    return {
	      id: self.id,
	      enabled: self.enabled,
	      type: self.type && self.type.name,
	      schema: self.schema && self.schema.name,
	      params: outParams
	    };
	  };
	
	  AggConfig.prototype.getAggParams = function () {
	    return [].concat(this.type ? this.type.params.raw : [], this.schema ? this.schema.params.raw : []);
	  };
	
	  AggConfig.prototype.getResponseAggs = function () {
	    if (!this.type) return;
	    return this.type.getResponseAggs(this) || [this];
	  };
	
	  AggConfig.prototype.getValue = function (bucket) {
	    return this.type.getValue(this, bucket);
	  };
	
	  AggConfig.prototype.getKey = function (bucket, key) {
	    return this.type.getKey(bucket, key, this);
	  };
	
	  AggConfig.prototype.getFieldDisplayName = function () {
	    var field = this.getField();
	    return field ? field.displayName || this.fieldName() : '';
	  };
	
	  AggConfig.prototype.getField = function () {
	    return this.params.field;
	  };
	
	  AggConfig.prototype.makeLabel = function () {
	    if (this.params.customLabel) {
	      return this.params.customLabel;
	    }
	
	    if (!this.type) return '';
	    var pre = _lodash2['default'].get(this.vis, 'params.mode') === 'percentage' ? 'Percentage of ' : '';
	    return pre += this.type.makeLabel(this);
	  };
	
	  AggConfig.prototype.getIndexPattern = function () {
	    return this.vis.indexPattern;
	  };
	
	  AggConfig.prototype.getFieldOptions = function () {
	    var fieldParamType = this.type && this.type.params.byName.field;
	
	    if (!fieldParamType || !fieldParamType.getFieldOptions) {
	      return null;
	    }
	
	    return fieldParamType.getFieldOptions(this);
	  };
	
	  AggConfig.prototype.fieldFormatter = function (contentType, defaultFormat) {
	    var format = this.type && this.type.getFormat(this);
	    if (format) return format.getConverterFor(contentType);
	    return this.fieldOwnFormatter(contentType, defaultFormat);
	  };
	
	  AggConfig.prototype.fieldOwnFormatter = function (contentType, defaultFormat) {
	    var field = this.getField();
	    var format = field && field.format;
	    if (!format) format = defaultFormat;
	    if (!format) format = fieldFormats.getDefaultInstance('string');
	    return format.getConverterFor(contentType);
	  };
	
	  AggConfig.prototype.fieldName = function () {
	    var field = this.getField();
	    return field ? field.name : '';
	  };
	
	  AggConfig.prototype.fieldIsTimeField = function () {
	    var timeFieldName = this.vis.indexPattern.timeFieldName;
	    return timeFieldName && this.fieldName() === timeFieldName;
	  };
	
	  return AggConfig;
	}
	
	module.exports = exports['default'];

/***/ },
/* 992 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = VisTypeSchemasFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	var _uiAgg_typesAgg_params = __webpack_require__(929);
	
	var _uiAgg_typesAgg_params2 = _interopRequireDefault(_uiAgg_typesAgg_params);
	
	function VisTypeSchemasFactory(Private) {
	  var AggParams = Private(_uiAgg_typesAgg_params2['default']);
	
	  function Schemas(schemas) {
	    var self = this;
	
	    (0, _lodash2['default'])(schemas || []).map(function (schema) {
	      if (!schema.name) throw new Error('all schema must have a unique name');
	
	      if (schema.name === 'split') {
	        schema.params = [{
	          name: 'row',
	          'default': true
	        }];
	        schema.editor = __webpack_require__(993);
	      } else if (schema.name === 'radius') {
	        schema.editor = __webpack_require__(994);
	      }
	
	      _lodash2['default'].defaults(schema, {
	        min: 0,
	        max: Infinity,
	        group: 'buckets',
	        title: schema.name,
	        aggFilter: '*',
	        editor: false,
	        params: [],
	        deprecate: false
	      });
	
	      // convert the params into a params registry
	      schema.params = new AggParams(schema.params);
	
	      return schema;
	    }).tap(function (schemas) {
	      self.all = new _uiIndexed_array2['default']({
	        index: ['name'],
	        group: ['group'],
	        immutable: true,
	        initialSet: schemas
	      });
	    }).groupBy('group').forOwn(function (group, groupName) {
	      self[groupName] = new _uiIndexed_array2['default']({
	        index: ['name'],
	        immutable: true,
	        initialSet: group
	      });
	    }).commit();
	  }
	
	  return Schemas;
	}
	
	module.exports = exports['default'];

/***/ },
/* 993 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <div class=\"btn-group\">\n    <button\n      type=\"button\"\n      class=\"btn btn-xs btn-default\"\n      ng-model=\"agg.params.row\"\n      btn-radio=\"true\">\n      Rows\n    </button>\n    <button\n      type=\"button\"\n      class=\"btn btn-xs btn-default\"\n      ng-model=\"agg.params.row\"\n      btn-radio=\"false\">\n      Columns\n    </button>\n  </div>\n</div>"

/***/ },
/* 994 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <label>\n    Dot Size Ratio:\n    <kbn-info\n      placement=\"right\"\n      info=\"Change the ratio of the radius of the smallest point to the largest point.\">\n    </kbn-info>\n  </label>\n  <input type=\"range\" step=\"2\" min=\"1\" max=\"100\" class=\"form-control\" ng-model=\"vis.params.radiusRatio\" />\n</div>\n"

/***/ },
/* 995 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createTermsFilterProvider;
	
	var _uiFilter_managerLibPhrase = __webpack_require__(616);
	
	var _uiFilter_managerLibPhrase2 = _interopRequireDefault(_uiFilter_managerLibPhrase);
	
	function createTermsFilterProvider(Private) {
	  return function (aggConfig, key) {
	    return (0, _uiFilter_managerLibPhrase2['default'])(aggConfig.params.field, key, aggConfig.vis.indexPattern);
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 996 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"aggParam.controller\">\n  <div class=\"form-group\">\n    <label>Order By</label>\n    <select\n      name=\"orderBy\"\n      ng-model=\"agg.params.orderBy\"\n      required\n      class=\"form-control\">\n      <option\n        ng-repeat=\"respAgg in responseValueAggs track by respAgg.id\"\n        value=\"{{respAgg.id}}\"\n        ng-disabled=\"rejectAgg(respAgg)\"\n        ng-selected=\"agg.params.orderBy === respAgg.id\">\n        metric: {{safeMakeLabel(respAgg)}}\n      </option>\n      <option value=\"custom\" ng-selected=\"agg.params.orderBy === 'custom'\">\n        Custom Metric\n      </option>\n       <option value=\"_term\" ng-selected=\"agg.params.orderBy === '_term'\">\n        Term\n      </option>\n    </select>\n  </div>\n  <div ng-show=\"agg.params.orderAgg\" class=\"vis-editor-agg-order-agg\">\n    <vis-editor-agg-params\n      agg=\"agg.params.orderAgg\"\n      ng-if=\"agg.params.orderAgg\"\n      group-name=\"'metrics'\">\n    </vis-editor-agg-params>\n  </div>\n</div>\n"

/***/ },
/* 997 */
/***/ function(module, exports) {

	module.exports = "<div class=\"vis-editor-agg-form-row\">\n  <div ng-if=\"agg.type.params.byName.order\" class=\"form-group\">\n    <label>Order</label>\n    <select\n      name=\"order\"\n      ng-model=\"agg.params.order\"\n      required\n      ng-options=\"opt as opt.display for opt in aggParam.options\"\n      class=\"form-control\">\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Size</label>\n    <input\n      name=\"size\"\n      ng-model=\"agg.params.size\"\n      required\n      class=\"form-control\"\n      type=\"number\"\n      min=\"1\"\n    >\n  </div>\n</div>\n"

/***/ },
/* 998 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = routeBasedNotifierProvider;
	
	var _lodash = __webpack_require__(3);
	
	var _uiNotifyNotifier = __webpack_require__(284);
	
	var _uiNotifyNotifier2 = _interopRequireDefault(_uiNotifyNotifier);
	
	/*
	 * Caches notification attempts so each one is only actually sent to the
	 * notifier service once per route.
	 */
	
	function routeBasedNotifierProvider($rootScope) {
	  var notifier = new _uiNotifyNotifier2['default']();
	
	  var notifications = {
	    warnings: []
	  };
	
	  // empty the tracked notifications whenever the route changes so we can start
	  // fresh for the next route cycle
	  $rootScope.$on('$routeChangeSuccess', function () {
	    notifications = (0, _lodash.mapValues)(notifications, function () {
	      return [];
	    });
	  });
	
	  // Executes the given notify function if the message has not been seen in
	  // this route cycle
	  function executeIfNew(messages, message, notifyFn) {
	    if ((0, _lodash.includes)(messages, message)) {
	      return;
	    }
	
	    messages.push(message);
	    notifyFn.call(notifier, message);
	  }
	
	  return {
	    /**
	     * Notify a given warning once in this route cycle
	     * @param {string} message
	     */
	    warning: function warning(message) {
	      executeIfNew(notifications.warnings, message, notifier.warning);
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 999 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = FiltersAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _angular = __webpack_require__(17);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBucketsCreate_filterFilters = __webpack_require__(1000);
	
	var _uiAgg_typesBucketsCreate_filterFilters2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterFilters);
	
	var _uiCourierData_source_decorate_query = __webpack_require__(523);
	
	var _uiCourierData_source_decorate_query2 = _interopRequireDefault(_uiCourierData_source_decorate_query);
	
	var _uiAgg_typesControlsFiltersHtml = __webpack_require__(1002);
	
	var _uiAgg_typesControlsFiltersHtml2 = _interopRequireDefault(_uiAgg_typesControlsFiltersHtml);
	
	function FiltersAggDefinition(Private, Notifier) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterFilters2['default']);
	  var decorateQuery = Private(_uiCourierData_source_decorate_query2['default']);
	  var notif = new Notifier({ location: 'Filters Agg' });
	
	  return new BucketAggType({
	    name: 'filters',
	    title: 'Filters',
	    createFilter: createFilter,
	    customLabels: false,
	    params: [{
	      name: 'filters',
	      editor: _uiAgg_typesControlsFiltersHtml2['default'],
	      'default': [{ input: {}, label: '' }],
	      write: function write(aggConfig, output) {
	        var inFilters = aggConfig.params.filters;
	        if (!_lodash2['default'].size(inFilters)) return;
	
	        var outFilters = _lodash2['default'].transform(inFilters, function (filters, filter) {
	          var input = filter.input;
	          if (!input) return notif.log('malformed filter agg params, missing "input" query');
	
	          var query = input.query;
	          if (!query) return notif.log('malformed filter agg params, missing "query" on input');
	
	          decorateQuery(query);
	
	          var label = filter.label || _lodash2['default'].get(query, 'query_string.query') || _angular2['default'].toJson(query);
	          filters[label] = input;
	        }, {});
	
	        if (!_lodash2['default'].size(outFilters)) return;
	
	        var params = output.params || (output.params = {});
	        params.filters = outFilters;
	      }
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 1000 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = CreateFilterFiltersProvider;
	
	var _uiFilter_managerLibQuery = __webpack_require__(1001);
	
	var _uiFilter_managerLibQuery2 = _interopRequireDefault(_uiFilter_managerLibQuery);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function CreateFilterFiltersProvider(Private) {
	  return function (aggConfig, key) {
	    // have the aggConfig write agg dsl params
	    var dslFilters = _lodash2['default'].get(aggConfig.toDsl(), 'filters.filters');
	    var filter = dslFilters[key];
	
	    if (filter) {
	      return (0, _uiFilter_managerLibQuery2['default'])(filter.query, aggConfig.vis.indexPattern.id);
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 1001 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = buildQueryFilter;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function buildQueryFilter(query, index) {
	  return {
	    query: query,
	    meta: {
	      index: index
	    }
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 1002 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <div ng-repeat=\"filter in agg.params.filters\">\n    <div class=\"vis-editor-agg-header\">\n      <label>\n          Filter {{$index + 1}}\n          <span ng-if=\"filter.label\">- {{ filter.label }}</span>\n      </label>\n\n      <div class=\"btn-group\">\n        <button\n          ng-click=\"showConfig = !showConfig\"\n          type=\"button\"\n          class=\"btn btn-default btn-xs\">\n          <i class=\"fa fa-tag\"></i>\n        </button>\n        <button\n          type=\"button\"\n          ng-click=\"agg.params.filters.splice($index, 1)\"\n          class=\"btn btn-danger btn-xs\">\n          <i class=\"fa fa-times\"></i>\n        </button>\n      </div>\n    </div>\n\n    <div class=\"form-group\">\n      <input\n        parse-query\n        ng-model=\"filter.input.query\"\n        type=\"text\"\n        class=\"form-control\"\n        name=\"filter{{$index}}\">\n    </div>\n\n    <div class=\"form-group\" ng-show=\"showConfig\">\n      <label>Filter {{$index + 1}} label</label>\n      <input\n        ng-model=\"filter.label\"\n        placeholder=\"Label\"\n        type=\"text\"\n        class=\"form-control\"\n        name=\"label{{$index}}\">\n    </div>\n  </div>\n</div>\n\n<input ng-model=\"agg.params.filters.length\" name=\"filterLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n<div class=\"hintbox\" ng-show=\"aggForm.filterLength.$invalid\">\n  <p>\n    <i class=\"fa fa-danger text-danger\"></i>\n    <strong>Required:</strong> You must specify at least one filter.\n  </p>\n</div>\n\n<div\n  click-focus=\"'filter'+(agg.params.filters.length-1)\"\n  ng-click=\"agg.params.filters.push({input:{}})\"\n  class=\"sidebar-item-button primary\">\n  Add Filter\n</div>\n"

/***/ },
/* 1003 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = SignificantTermsAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesBucketsCreate_filterTerms = __webpack_require__(995);
	
	var _uiAgg_typesBucketsCreate_filterTerms2 = _interopRequireDefault(_uiAgg_typesBucketsCreate_filterTerms);
	
	var _uiAgg_typesControlsOrder_and_sizeHtml = __webpack_require__(997);
	
	var _uiAgg_typesControlsOrder_and_sizeHtml2 = _interopRequireDefault(_uiAgg_typesControlsOrder_and_sizeHtml);
	
	function SignificantTermsAggDefinition(Private) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var createFilter = Private(_uiAgg_typesBucketsCreate_filterTerms2['default']);
	
	  return new BucketAggType({
	    name: 'significant_terms',
	    title: 'Significant Terms',
	    makeLabel: function makeLabel(aggConfig) {
	      return 'Top ' + aggConfig.params.size + ' unusual terms in ' + aggConfig.getFieldDisplayName();
	    },
	    createFilter: createFilter,
	    params: [{
	      name: 'field',
	      scriptable: false,
	      filterFieldTypes: 'string'
	    }, {
	      name: 'size',
	      editor: _uiAgg_typesControlsOrder_and_sizeHtml2['default']
	    }, {
	      name: 'exclude',
	      type: 'regex',
	      advanced: true
	    }, {
	      name: 'include',
	      type: 'regex',
	      advanced: true
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 1004 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = GeoHashAggDefinition;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiAgg_typesBuckets_bucket_agg_type = __webpack_require__(966);
	
	var _uiAgg_typesBuckets_bucket_agg_type2 = _interopRequireDefault(_uiAgg_typesBuckets_bucket_agg_type);
	
	var _uiAgg_typesControlsPrecisionHtml = __webpack_require__(1005);
	
	var _uiAgg_typesControlsPrecisionHtml2 = _interopRequireDefault(_uiAgg_typesControlsPrecisionHtml);
	
	var _uiUtilsDecode_geo_hash = __webpack_require__(1006);
	
	function GeoHashAggDefinition(Private, config) {
	  var BucketAggType = Private(_uiAgg_typesBuckets_bucket_agg_type2['default']);
	  var defaultPrecision = 2;
	  var maxPrecision = parseInt(config.get('visualization:tileMap:maxPrecision'), 10) || 12;
	  /**
	   * Map Leaflet zoom levels to geohash precision levels.
	   * The size of a geohash column-width on the map should be at least `minGeohashPixels` pixels wide.
	   */
	  var zoomPrecision = {};
	  var minGeohashPixels = 16;
	  for (var zoom = 0; zoom <= 21; zoom += 1) {
	    var worldPixels = 256 * Math.pow(2, zoom);
	    zoomPrecision[zoom] = 1;
	    for (var precision = 2; precision <= maxPrecision; precision += 1) {
	      var columns = (0, _uiUtilsDecode_geo_hash.geohashColumns)(precision);
	      if (worldPixels / columns >= minGeohashPixels) {
	        zoomPrecision[zoom] = precision;
	      } else {
	        break;
	      }
	    }
	  }
	
	  function getPrecision(precision) {
	
	    precision = parseInt(precision, 10);
	
	    if (isNaN(precision)) {
	      precision = defaultPrecision;
	    }
	
	    if (precision > maxPrecision) {
	      return maxPrecision;
	    }
	
	    return precision;
	  }
	
	  return new BucketAggType({
	    name: 'geohash_grid',
	    title: 'Geohash',
	    params: [{
	      name: 'field',
	      filterFieldTypes: 'geo_point'
	    }, {
	      name: 'autoPrecision',
	      'default': true,
	      write: _lodash2['default'].noop
	    }, {
	      name: 'mapZoom',
	      write: _lodash2['default'].noop
	    }, {
	      name: 'mapCenter',
	      write: _lodash2['default'].noop
	    }, {
	      name: 'precision',
	      editor: _uiAgg_typesControlsPrecisionHtml2['default'],
	      'default': defaultPrecision,
	      deserialize: getPrecision,
	      controller: function controller($scope) {},
	      write: function write(aggConfig, output) {
	        var vis = aggConfig.vis;
	        var currZoom = undefined;
	        if (vis.hasUiState()) {
	          currZoom = parseInt(vis.uiStateVal('mapZoom'), 10);
	        }
	        var autoPrecisionVal = zoomPrecision[currZoom >= 0 ? currZoom : parseInt(vis.params.mapZoom)];
	        output.params.precision = aggConfig.params.autoPrecision ? autoPrecisionVal : getPrecision(aggConfig.params.precision);
	      }
	    }]
	  });
	}
	
	module.exports = exports['default'];

/***/ },
/* 1005 */
/***/ function(module, exports) {

	module.exports = "<div class=\"vis-editor-agg-form-row\" ng-controller=\"agg.type.params.byName.precision.controller\">\n  <div ng-if=\"!agg.params.autoPrecision\" class=\"form-group\">\n    <label>Precision</label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        name=\"precision\"\n        ng-model=\"agg.params.precision\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"1\"\n        max=\"{{config.get('visualization:tileMap:maxPrecision')}}\"\n        >\n      <div class=\"form-group vis-editor-agg-form-value\">\n        {{agg.params.precision}}\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"vis-option-item\">\n  <label>\n    <input type=\"checkbox\"\n    name=\"autoPrecision\"\n    ng-model=\"agg.params.autoPrecision\">\n    Change precision on map zoom\n  </label>\n</div>\n\n"

/***/ },
/* 1006 */
/***/ function(module, exports) {

	/* eslint-disable */
	/*
	 * Decodes geohash to object containing
	 * top-left and bottom-right corners of
	 * rectangle and center point.
	 *
	 * geohash.js
	 * Geohash library for Javascript
	 * (c) 2008 David Troy
	 * Distributed under the MIT License
	 *
	 * @method refine_interval
	 * @param interval {Array} [long, lat]
	 * @param cd {Number}
	 * @param mask {Number}
	 * @return {Object} interval
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.geohashColumns = geohashColumns;
	function decodeGeoHash(geohash) {
	  var BITS = [16, 8, 4, 2, 1];
	  var BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';
	  var is_even = 1;
	  var lat = [];
	  var lon = [];
	  lat[0] = -90.0;
	  lat[1] = 90.0;
	  lon[0] = -180.0;
	  lon[1] = 180.0;
	  var lat_err = 90.0;
	  var lon_err = 180.0;
	  for (var i = 0; i < geohash.length; i++) {
	    var c = geohash[i];
	    var cd = BASE32.indexOf(c);
	    for (var j = 0; j < 5; j++) {
	      var mask = BITS[j];
	      if (is_even) {
	        lon_err /= 2;
	        refine_interval(lon, cd, mask);
	      } else {
	        lat_err /= 2;
	        refine_interval(lat, cd, mask);
	      }
	      is_even = !is_even;
	    }
	  }
	  lat[2] = (lat[0] + lat[1]) / 2;
	  lon[2] = (lon[0] + lon[1]) / 2;
	  return { latitude: lat, longitude: lon };
	}
	
	function refine_interval(interval, cd, mask) {
	  if (cd & mask) {
	    interval[0] = (interval[0] + interval[1]) / 2;
	  } else {
	    interval[1] = (interval[0] + interval[1]) / 2;
	  }
	}
	
	exports['default'] = decodeGeoHash;
	
	/**
	 * Get the number of geohash cells for a given precision
	 *
	 * @param {number} precision the geohash precision (1<=precision<=12).
	 * @param {number} axis constant for the axis 0=lengthwise (ie. columns, along longitude), 1=heightwise (ie. rows, along latitude).
	 * @returns {number} Number of geohash cells (rows or columns) at that precision
	 */
	function geohashCells(precision, axis) {
	  var cells = 1;
	  for (var i = 1; i <= precision; i += 1) {
	    //On odd precisions, rows divide by 4 and columns by 8. Vice-versa on even precisions.
	    cells *= i % 2 === axis ? 4 : 8;
	  }
	  return cells;
	}
	
	/**
	 * Get the number of geohash columns (world-wide) for a given precision
	 * @param precision the geohash precision
	 * @returns {number} the number of columns
	 */
	
	function geohashColumns(precision) {
	  return geohashCells(precision, 0);
	}

/***/ },
/* 1007 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name AggConfig
	 *
	 * @extends IndexedArray
	 *
	 * @description A "data structure"-like class with methods for indexing and
	 * accessing instances of AggConfig.
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = AggConfigsFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiIndexed_array = __webpack_require__(447);
	
	var _uiIndexed_array2 = _interopRequireDefault(_uiIndexed_array);
	
	var _uiVisAgg_config = __webpack_require__(991);
	
	var _uiVisAgg_config2 = _interopRequireDefault(_uiVisAgg_config);
	
	var _uiAgg_typesIndex = __webpack_require__(928);
	
	var _uiAgg_typesIndex2 = _interopRequireDefault(_uiAgg_typesIndex);
	
	function AggConfigsFactory(Private) {
	  var AggConfig = Private(_uiVisAgg_config2['default']);
	
	  AggConfig.aggTypes = Private(_uiAgg_typesIndex2['default']);
	
	  _lodash2['default']['class'](AggConfigs).inherits(_uiIndexed_array2['default']);
	  function AggConfigs(vis, configStates) {
	    var self = this;
	    self.vis = vis;
	
	    configStates = AggConfig.ensureIds(configStates || []);
	
	    AggConfigs.Super.call(self, {
	      index: ['id'],
	      group: ['schema.group', 'type.name', 'schema.name'],
	      initialSet: configStates.map(function (aggConfigState) {
	        if (aggConfigState instanceof AggConfig) return aggConfigState;
	        return new AggConfig(vis, aggConfigState);
	      })
	    });
	
	    // Set the defaults for any schema which has them. If the defaults
	    // for some reason has more then the max only set the max number
	    // of defaults (not sure why a someone define more...
	    // but whatever). Also if a schema.name is already set then don't
	    // set anything.
	    if (vis && vis.type && vis.type.schemas && vis.type.schemas.all) {
	      (0, _lodash2['default'])(vis.type.schemas.all).filter(function (schema) {
	        return _lodash2['default'].isArray(schema.defaults) && schema.defaults.length > 0;
	      }).each(function (schema) {
	        if (!self.bySchemaName[schema.name]) {
	          var defaults = schema.defaults.slice(0, schema.max);
	          _lodash2['default'].each(defaults, function (defaultState) {
	            var state = _lodash2['default'].defaults({ id: AggConfig.nextId(self) }, defaultState);
	            self.push(new AggConfig(vis, state));
	          });
	        }
	      }).commit();
	    }
	  }
	
	  /**
	   * Data-by-data comparison of this Aggregation
	   * Ignores the non-array indexes
	   * @param aggConfigs an AggConfigs instance
	   */
	  AggConfigs.prototype.jsonDataEquals = function (aggConfigs) {
	    if (aggConfigs.length !== this.length) {
	      return false;
	    }
	    for (var i = 0; i < this.length; i += 1) {
	      if (!_lodash2['default'].isEqual(aggConfigs[i].toJSON(), this[i].toJSON())) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	  AggConfigs.prototype.toDsl = function () {
	    var dslTopLvl = {};
	    var dslLvlCursor = undefined;
	    var nestedMetrics = undefined;
	
	    if (this.vis.isHierarchical()) {
	      // collect all metrics, and filter out the ones that we won't be copying
	      nestedMetrics = (0, _lodash2['default'])(this.vis.aggs.bySchemaGroup.metrics).filter(function (agg) {
	        return agg.type.name !== 'count';
	      }).map(function (agg) {
	        return {
	          config: agg,
	          dsl: agg.toDsl()
	        };
	      }).value();
	    }
	
	    this.getRequestAggs().filter(function (config) {
	      return !config.type.hasNoDsl;
	    }).forEach(function nestEachConfig(config, i, list) {
	      if (!dslLvlCursor) {
	        // start at the top level
	        dslLvlCursor = dslTopLvl;
	      } else {
	        var prevConfig = list[i - 1];
	        var prevDsl = dslLvlCursor[prevConfig.id];
	
	        // advance the cursor and nest under the previous agg, or
	        // put it on the same level if the previous agg doesn't accept
	        // sub aggs
	        dslLvlCursor = prevDsl.aggs || dslLvlCursor;
	      }
	
	      var dsl = dslLvlCursor[config.id] = config.toDsl();
	      var subAggs = undefined;
	
	      if (config.schema.group === 'buckets' && i < list.length - 1) {
	        // buckets that are not the last item in the list accept sub-aggs
	        subAggs = dsl.aggs || (dsl.aggs = {});
	      }
	
	      if (subAggs && nestedMetrics) {
	        nestedMetrics.forEach(function (agg) {
	          subAggs[agg.config.id] = agg.dsl;
	        });
	      }
	    });
	
	    return dslTopLvl;
	  };
	
	  AggConfigs.prototype.getRequestAggs = function () {
	    return _lodash2['default'].sortBy(this, function (agg) {
	      return agg.schema.group === 'metrics' ? 1 : 0;
	    });
	  };
	
	  /**
	   * Gets the AggConfigs (and possibly ResponseAggConfigs) that
	   * represent the values that will be produced when all aggs
	   * are run.
	   *
	   * With multi-value metric aggs it is possible for a single agg
	   * request to result in multiple agg values, which is why the length
	   * of a vis' responseValuesAggs may be different than the vis' aggs
	   *
	   * @return {array[AggConfig]}
	   */
	  AggConfigs.prototype.getResponseAggs = function () {
	    return this.getRequestAggs().reduce(function (responseValuesAggs, agg) {
	      var aggs = agg.getResponseAggs();
	      return aggs ? responseValuesAggs.concat(aggs) : responseValuesAggs;
	    }, []);
	  };
	
	  /**
	   * Find a response agg by it's id. This may be an agg in the aggConfigs, or one
	   * created specifically for a response value
	   *
	   * @param  {string} id - the id of the agg to find
	   * @return {AggConfig}
	   */
	  AggConfigs.prototype.getResponseAggById = function (id) {
	    id = String(id);
	    var reqAgg = _lodash2['default'].find(this.getRequestAggs(), function (agg) {
	      return id.substr(0, String(agg.id).length) === agg.id;
	    });
	    if (!reqAgg) return;
	    return _lodash2['default'].find(reqAgg.getResponseAggs(), { id: id });
	  };
	
	  return AggConfigs;
	}
	
	module.exports = exports['default'];

/***/ },
/* 1008 */,
/* 1009 */,
/* 1010 */,
/* 1011 */,
/* 1012 */,
/* 1013 */,
/* 1014 */,
/* 1015 */,
/* 1016 */,
/* 1017 */,
/* 1018 */,
/* 1019 */,
/* 1020 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	__webpack_require__(1021);
	
	var _uiRegistryVis_types = __webpack_require__(917);
	
	var _uiRegistryVis_types2 = _interopRequireDefault(_uiRegistryVis_types);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _uiCourierSaved_objectSaved_object_loader = __webpack_require__(806);
	
	var app = _uiModules2['default'].get('app/visualize');
	
	// Register this service with the saved object registry so it can be
	// edited by the object editor.
	__webpack_require__(808).register({
	  service: 'savedVisualizations',
	  title: 'visualizations'
	});
	
	app.service('savedVisualizations', function (Promise, esAdmin, kbnIndex, SavedVis, Private, Notifier, kbnUrl) {
	  var visTypes = Private(_uiRegistryVis_types2['default']);
	  var notify = new Notifier({
	    location: 'Saved Visualization Service'
	  });
	
	  var saveVisualizationLoader = new _uiCourierSaved_objectSaved_object_loader.SavedObjectLoader(SavedVis, kbnIndex, esAdmin, kbnUrl);
	  saveVisualizationLoader.mapHits = function (hit) {
	    var source = hit._source;
	    source.id = hit._id;
	    source.url = this.urlFor(hit._id);
	
	    var typeName = source.typeName;
	    if (source.visState) {
	      try {
	        typeName = JSON.parse(source.visState).type;
	      } catch (e) {} /* missing typename handled below */ // eslint-disable-line no-empty
	    }
	
	    if (!typeName || !visTypes.byName[typeName]) {
	      if (!typeName) notify.error('Visualization type is missing. Please add a type to this visualization.', hit);else notify.error('Visualization type of "' + typeName + '" is invalid. Please change to a valid type.', hit);
	      return kbnUrl.redirect('/management/kibana/objects/savedVisualizations/{{id}}', { id: source.id });
	    }
	
	    source.type = visTypes.byName[typeName];
	    source.icon = source.type.icon;
	    return source;
	  };
	
	  saveVisualizationLoader.urlFor = function (id) {
	    return kbnUrl.eval('#/visualize/edit/{{id}}', { id: id });
	  };
	
	  return saveVisualizationLoader;
	});

/***/ },
/* 1021 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SavedVis
	 *
	 * @extends SavedObject.
	 *
	 * NOTE: It's a type of SavedObject, but specific to visualizations.
	 */
	
	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiVis = __webpack_require__(927);
	
	var _uiVis2 = _interopRequireDefault(_uiVis);
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	_uiModules2['default'].get('app/visualize').factory('SavedVis', function (config, $injector, courier, Promise, savedSearches, Private, Notifier) {
	  var Vis = Private(_uiVis2['default']);
	
	  var notify = new Notifier({
	    location: 'SavedVis'
	  });
	
	  _lodash2['default']['class'](SavedVis).inherits(courier.SavedObject);
	  function SavedVis(opts) {
	    var self = this;
	    opts = opts || {};
	    if (typeof opts !== 'object') opts = { id: opts };
	
	    SavedVis.Super.call(self, {
	      type: SavedVis.type,
	      mapping: SavedVis.mapping,
	      searchSource: SavedVis.searchSource,
	
	      id: opts.id,
	      indexPattern: opts.indexPattern,
	      defaults: {
	        title: 'New Visualization',
	        visState: (function () {
	          if (!opts.type) return null;
	          var def = {};
	          def.type = opts.type;
	          return def;
	        })(),
	        uiStateJSON: '{}',
	        description: '',
	        savedSearchId: opts.savedSearchId,
	        version: 1
	      },
	
	      afterESResp: this._afterEsResp
	    });
	  }
	
	  SavedVis.type = 'visualization';
	
	  SavedVis.mapping = {
	    title: 'string',
	    visState: 'json',
	    uiStateJSON: 'string',
	    description: 'string',
	    savedSearchId: 'string',
	    version: 'integer'
	  };
	
	  // Order these fields to the top, the rest are alphabetical
	  SavedVis.fieldOrder = ['title', 'description'];
	
	  SavedVis.searchSource = true;
	
	  SavedVis.prototype._afterEsResp = function () {
	    var self = this;
	
	    return self._getLinkedSavedSearch().then(function () {
	      self.searchSource.size(0);
	
	      return self.vis ? self._updateVis() : self._createVis();
	    }).then(function (vis) {
	      self.searchSource.aggs(function () {
	        self.vis.requesting();
	        return self.vis.aggs.toDsl();
	      });
	
	      return self;
	    });
	  };
	
	  SavedVis.prototype._getLinkedSavedSearch = Promise.method(function () {
	    var self = this;
	    var linkedSearch = !!self.savedSearchId;
	    var current = self.savedSearch;
	
	    if (linkedSearch && current && current.id === self.savedSearchId) {
	      return;
	    }
	
	    if (self.savedSearch) {
	      self.searchSource.inherits(self.savedSearch.searchSource.getParent());
	      self.savedSearch.destroy();
	      self.savedSearch = null;
	    }
	
	    if (linkedSearch) {
	      return savedSearches.get(self.savedSearchId).then(function (savedSearch) {
	        self.savedSearch = savedSearch;
	        self.searchSource.inherits(self.savedSearch.searchSource);
	      });
	    }
	  });
	
	  SavedVis.prototype._createVis = function () {
	    var self = this;
	
	    if (self.stateJSON) {
	      self.visState = Vis.convertOldState(self.typeName, JSON.parse(self.stateJSON));
	    }
	
	    // visState doesn't yet exist when importing a visualization, so we can't
	    // assume that exists at this point. If it does exist, then we're not
	    // importing a visualization, so we want to sync the title.
	    if (self.visState) {
	      self.visState.title = self.title;
	    }
	    self.vis = new Vis(self.searchSource.get('index'), self.visState);
	
	    return self.vis;
	  };
	
	  SavedVis.prototype._updateVis = function () {
	    var self = this;
	
	    self.vis.indexPattern = self.searchSource.get('index');
	    self.visState.title = self.title;
	    self.vis.setState(self.visState);
	  };
	
	  return SavedVis;
	});

/***/ },
/* 1022 */,
/* 1023 */,
/* 1024 */,
/* 1025 */,
/* 1026 */,
/* 1027 */,
/* 1028 */,
/* 1029 */,
/* 1030 */,
/* 1031 */,
/* 1032 */,
/* 1033 */,
/* 1034 */,
/* 1035 */,
/* 1036 */,
/* 1037 */,
/* 1038 */,
/* 1039 */,
/* 1040 */,
/* 1041 */,
/* 1042 */,
/* 1043 */,
/* 1044 */,
/* 1045 */,
/* 1046 */,
/* 1047 */,
/* 1048 */,
/* 1049 */,
/* 1050 */,
/* 1051 */,
/* 1052 */,
/* 1053 */,
/* 1054 */,
/* 1055 */,
/* 1056 */,
/* 1057 */,
/* 1058 */,
/* 1059 */,
/* 1060 */,
/* 1061 */,
/* 1062 */,
/* 1063 */,
/* 1064 */,
/* 1065 */,
/* 1066 */,
/* 1067 */,
/* 1068 */,
/* 1069 */,
/* 1070 */,
/* 1071 */,
/* 1072 */,
/* 1073 */,
/* 1074 */,
/* 1075 */,
/* 1076 */,
/* 1077 */,
/* 1078 */,
/* 1079 */,
/* 1080 */,
/* 1081 */,
/* 1082 */,
/* 1083 */,
/* 1084 */,
/* 1085 */,
/* 1086 */,
/* 1087 */,
/* 1088 */,
/* 1089 */,
/* 1090 */,
/* 1091 */,
/* 1092 */,
/* 1093 */,
/* 1094 */,
/* 1095 */,
/* 1096 */,
/* 1097 */,
/* 1098 */,
/* 1099 */,
/* 1100 */,
/* 1101 */,
/* 1102 */,
/* 1103 */,
/* 1104 */,
/* 1105 */,
/* 1106 */,
/* 1107 */,
/* 1108 */,
/* 1109 */,
/* 1110 */,
/* 1111 */,
/* 1112 */,
/* 1113 */,
/* 1114 */,
/* 1115 */,
/* 1116 */,
/* 1117 */,
/* 1118 */,
/* 1119 */,
/* 1120 */,
/* 1121 */,
/* 1122 */,
/* 1123 */,
/* 1124 */,
/* 1125 */,
/* 1126 */,
/* 1127 */,
/* 1128 */,
/* 1129 */,
/* 1130 */,
/* 1131 */,
/* 1132 */,
/* 1133 */,
/* 1134 */,
/* 1135 */,
/* 1136 */,
/* 1137 */,
/* 1138 */,
/* 1139 */,
/* 1140 */,
/* 1141 */,
/* 1142 */,
/* 1143 */,
/* 1144 */,
/* 1145 */,
/* 1146 */,
/* 1147 */,
/* 1148 */,
/* 1149 */,
/* 1150 */,
/* 1151 */,
/* 1152 */,
/* 1153 */,
/* 1154 */,
/* 1155 */,
/* 1156 */,
/* 1157 */,
/* 1158 */,
/* 1159 */,
/* 1160 */,
/* 1161 */,
/* 1162 */,
/* 1163 */,
/* 1164 */,
/* 1165 */,
/* 1166 */,
/* 1167 */,
/* 1168 */,
/* 1169 */,
/* 1170 */,
/* 1171 */,
/* 1172 */,
/* 1173 */,
/* 1174 */,
/* 1175 */,
/* 1176 */,
/* 1177 */,
/* 1178 */,
/* 1179 */,
/* 1180 */,
/* 1181 */,
/* 1182 */,
/* 1183 */,
/* 1184 */,
/* 1185 */,
/* 1186 */,
/* 1187 */,
/* 1188 */,
/* 1189 */,
/* 1190 */,
/* 1191 */,
/* 1192 */,
/* 1193 */,
/* 1194 */,
/* 1195 */,
/* 1196 */,
/* 1197 */,
/* 1198 */,
/* 1199 */,
/* 1200 */,
/* 1201 */,
/* 1202 */,
/* 1203 */,
/* 1204 */,
/* 1205 */,
/* 1206 */,
/* 1207 */,
/* 1208 */,
/* 1209 */,
/* 1210 */,
/* 1211 */,
/* 1212 */,
/* 1213 */,
/* 1214 */,
/* 1215 */,
/* 1216 */,
/* 1217 */,
/* 1218 */,
/* 1219 */,
/* 1220 */,
/* 1221 */,
/* 1222 */,
/* 1223 */,
/* 1224 */,
/* 1225 */,
/* 1226 */,
/* 1227 */,
/* 1228 */,
/* 1229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = VisTypeFactory;
	
	var _schemas = __webpack_require__(992);
	
	var _schemas2 = _interopRequireDefault(_schemas);
	
	function VisTypeFactory(Private) {
	  var VisTypeSchemas = Private(_schemas2['default']);
	
	  function VisType(opts) {
	    opts = opts || {};
	
	    this.name = opts.name;
	    this.title = opts.title;
	    this.responseConverter = opts.responseConverter;
	    this.hierarchicalData = opts.hierarchicalData || false;
	    this.icon = opts.icon;
	    this.description = opts.description;
	    this.schemas = opts.schemas || new VisTypeSchemas();
	    this.params = opts.params || {};
	    this.requiresSearch = opts.requiresSearch == null ? true : opts.requiresSearch; // Default to true unless otherwise specified
	    this.fullEditor = opts.fullEditor == null ? false : opts.fullEditor;
	    this.implementsRenderComplete = opts.implementsRenderComplete || false;
	  }
	
	  VisType.prototype.createRenderbot = function (vis, $el, uiState) {
	    throw new Error('not implemented');
	  };
	
	  return VisType;
	}
	
	module.exports = exports['default'];

/***/ },
/* 1230 */,
/* 1231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = RenderbotFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function RenderbotFactory(Private) {
	
	  /**
	   * "Abstract" renderbot class which just defines the expected API
	   *
	   * @param {Vis} vis - the vis object that contains all configuration data required to render the vis
	   * @param {jQuery<DOMElement>} $el - a jQuery wrapped element to render into
	   */
	  function Renderbot(vis, $el, uiState) {
	    this.vis = vis;
	    this.$el = $el;
	    this.uiState = uiState;
	  }
	
	  /**
	   * Each renderbot should implement a #render() method which
	   * should accept an elasticsearch response and update the underlying visualization
	   *
	   * @override
	   * @param {object} esResp - The raw elasticsearch response
	   * @return {undefined}
	   */
	  Renderbot.prototype.render = function (esResp) {
	    throw new Error('not implemented');
	  };
	
	  /**
	   * Each renderbot should implement the #destroy() method which
	   * should tear down the owned element, remove event listeners, etc.
	   *
	   * @override
	   * @return {undefined}
	   */
	  Renderbot.prototype.destroy = function () {
	    throw new Error('not implemented');
	  };
	
	  /**
	   * Each renderbot can optionally implement the #updateParams() method which
	   * is used to pass in new vis params. It should not re-render the vis
	   *
	   * @override
	   * @return {undefined}
	   */
	  Renderbot.prototype.updateParams = _lodash2['default'].noop;
	
	  return Renderbot;
	}
	
	module.exports = exports['default'];

/***/ },
/* 1232 */,
/* 1233 */,
/* 1234 */,
/* 1235 */,
/* 1236 */,
/* 1237 */,
/* 1238 */,
/* 1239 */,
/* 1240 */,
/* 1241 */,
/* 1242 */,
/* 1243 */,
/* 1244 */,
/* 1245 */,
/* 1246 */,
/* 1247 */,
/* 1248 */,
/* 1249 */,
/* 1250 */,
/* 1251 */,
/* 1252 */,
/* 1253 */,
/* 1254 */,
/* 1255 */,
/* 1256 */,
/* 1257 */,
/* 1258 */,
/* 1259 */,
/* 1260 */,
/* 1261 */,
/* 1262 */,
/* 1263 */,
/* 1264 */,
/* 1265 */,
/* 1266 */,
/* 1267 */,
/* 1268 */,
/* 1269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = TemplateVisTypeFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiVisVis_type = __webpack_require__(1229);
	
	var _uiVisVis_type2 = _interopRequireDefault(_uiVisVis_type);
	
	var _uiTemplate_vis_typeTemplate_renderbot = __webpack_require__(1270);
	
	var _uiTemplate_vis_typeTemplate_renderbot2 = _interopRequireDefault(_uiTemplate_vis_typeTemplate_renderbot);
	
	function TemplateVisTypeFactory(Private) {
	  var VisType = Private(_uiVisVis_type2['default']);
	  var TemplateRenderbot = Private(_uiTemplate_vis_typeTemplate_renderbot2['default']);
	
	  _lodash2['default']['class'](TemplateVisType).inherits(VisType);
	  function TemplateVisType() {
	    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    TemplateVisType.Super.call(this, opts);
	
	    this.template = opts.template;
	    if (!this.template) {
	      throw new Error('Missing template for TemplateVisType');
	    }
	  }
	
	  TemplateVisType.prototype.createRenderbot = function (vis, $el, uiState) {
	    return new TemplateRenderbot(vis, $el, uiState);
	  };
	
	  return TemplateVisType;
	}
	
	module.exports = exports['default'];

/***/ },
/* 1270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = TemplateRenderbotFactory;
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _uiVisRenderbot = __webpack_require__(1231);
	
	var _uiVisRenderbot2 = _interopRequireDefault(_uiVisRenderbot);
	
	function TemplateRenderbotFactory(Private, $compile, $rootScope) {
	  var Renderbot = Private(_uiVisRenderbot2['default']);
	
	  _lodash2['default']['class'](TemplateRenderbot).inherits(Renderbot);
	  function TemplateRenderbot(vis, $el, uiState) {
	    TemplateRenderbot.Super.call(this, vis, $el, uiState);
	
	    this.$scope = $rootScope.$new();
	    this.$scope.vis = vis;
	    this.$scope.uiState = uiState;
	
	    $el.html($compile(this.vis.type.template)(this.$scope));
	  }
	
	  TemplateRenderbot.prototype.render = function (esResponse) {
	    this.$scope.esResponse = esResponse;
	  };
	
	  TemplateRenderbot.prototype.destroy = function () {
	    this.$scope.$destroy();
	  };
	
	  return TemplateRenderbot;
	}
	
	module.exports = exports['default'];

/***/ },
/* 1271 */,
/* 1272 */,
/* 1273 */,
/* 1274 */,
/* 1275 */,
/* 1276 */,
/* 1277 */,
/* 1278 */,
/* 1279 */,
/* 1280 */,
/* 1281 */,
/* 1282 */,
/* 1283 */,
/* 1284 */,
/* 1285 */,
/* 1286 */,
/* 1287 */,
/* 1288 */,
/* 1289 */,
/* 1290 */,
/* 1291 */,
/* 1292 */,
/* 1293 */,
/* 1294 */,
/* 1295 */,
/* 1296 */,
/* 1297 */,
/* 1298 */,
/* 1299 */,
/* 1300 */,
/* 1301 */,
/* 1302 */,
/* 1303 */,
/* 1304 */,
/* 1305 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(1306);
	__webpack_require__(1314);
	__webpack_require__(1335);
	__webpack_require__(917);
	__webpack_require__(1269);
	__webpack_require__(1336);
	__webpack_require__(1337);
	
	'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // we also need to load the controller and used by the template
	  __webpack_require__(1306);
	  __webpack_require__(1314);
	
	  // Stylin
	  __webpack_require__(1335);
	
	  // register the provider with the visTypes registry so that other know it exists
	  __webpack_require__(917).register(TimelionVisProvider);
	
	  function TimelionVisProvider(Private) {
	    var TemplateVisType = Private(__webpack_require__(1269));
	
	    // return the visType object, which kibana will use to display and configure new
	    // Vis object of this type.
	    return new TemplateVisType({
	      name: 'timelion',
	      title: 'Timeseries',
	      icon: 'fa-clock-o',
	      description: 'Create timeseries charts using the timelion expression language. ' + 'Perfect for computing and combining timeseries sets with functions such as derivatives and moving averages',
	      template: __webpack_require__(1336),
	      params: {
	        editor: __webpack_require__(1337)
	      },
	      requiresSearch: false,
	      implementsRenderComplete: true
	    });
	  }
	
	  // export the provider so that the visType can be required with Private()
	  return TimelionVisProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 1306 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(1307);
	__webpack_require__(1309);
	__webpack_require__(1311);
	__webpack_require__(416);
	__webpack_require__(3);
	__webpack_require__(24);
	__webpack_require__(609);
	__webpack_require__(1312);
	__webpack_require__(1313);
	
	'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(1307);
	  __webpack_require__(1309);
	  __webpack_require__(1311);
	  __webpack_require__(416);
	
	  var _ = __webpack_require__(3);
	  var module = __webpack_require__(24).get('kibana/timelion_vis', ['kibana']);
	  module.controller('TimelionVisController', function ($scope, $element, Private, Notifier, $http, $rootScope, timefilter, getAppState) {
	    var queryFilter = Private(__webpack_require__(609));
	    var timezone = Private(__webpack_require__(1312))();
	    var dashboardContext = Private(__webpack_require__(1313));
	
	    var notify = new Notifier({
	      location: 'Timelion'
	    });
	
	    $scope.search = function run() {
	      var expression = $scope.vis.params.expression;
	      if (!expression) return;
	
	      $http.post('../api/timelion/run', {
	        sheet: [expression],
	        extended: {
	          es: {
	            filter: dashboardContext()
	          }
	        },
	        time: _.extend(timefilter.time, {
	          interval: $scope.vis.params.interval,
	          timezone: timezone
	        })
	      })
	      // data, status, headers, config
	      .success(function (resp) {
	        $scope.sheet = resp.sheet;
	      }).error(function (resp) {
	        $scope.sheet = [];
	        var err = new Error(resp.message);
	        err.stack = resp.stack;
	        notify.error(err);
	      });
	    };
	
	    // This is bad, there should be a single event that triggers a refresh of data.
	
	    // When the expression updates
	    $scope.$watchMulti(['vis.params.expression', 'vis.params.interval'], $scope.search);
	
	    // When the time filter changes
	    $scope.$listen(timefilter, 'fetch', $scope.search);
	
	    // When a filter is added to the filter bar?
	    $scope.$listen(queryFilter, 'fetch', $scope.search);
	
	    // When auto refresh happens
	    $scope.$on('courier:searchRefresh', $scope.search);
	
	    $scope.$on('fetch', $scope.search);
	
	    $scope.$on('renderComplete', function (event) {
	      event.stopPropagation();
	      $element.trigger('renderComplete');
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 1307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var panelRegistryProvider = __webpack_require__(1308);
	
	__webpack_require__(24).get('apps/timelion', []).directive('chart', function (Private) {
	  return {
	    restrict: 'A',
	    scope: {
	      seriesList: '=chart', // The flot object, data, config and all
	      search: '=', // The function to execute to kick off a search
	      interval: '=' // Required for formatting x-axis ticks
	    },
	    link: function link($scope, $elem) {
	
	      var panelRegistry = Private(panelRegistryProvider);
	      var panelScope = $scope.$new(true);
	
	      function render(seriesList) {
	        panelScope.$destroy();
	
	        if (!seriesList) return;
	
	        seriesList.render = seriesList.render || {
	          type: 'timechart'
	        };
	
	        var panelSchema = panelRegistry.byName[seriesList.render.type];
	
	        if (!panelSchema) {
	          $elem.text('No such panel type: ' + seriesList.render.type);
	          return;
	        }
	
	        panelScope = $scope.$new(true);
	        panelScope.seriesList = seriesList;
	        panelScope.interval = $scope.interval;
	        panelScope.search = $scope.search;
	
	        panelSchema.render(panelScope, $elem);
	      }
	
	      $scope.$watch('seriesList', render);
	    }
	  };
	});

/***/ },
/* 1308 */,
/* 1309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	var moment = __webpack_require__(235);
	
	var app = __webpack_require__(24).get('apps/timelion', []);
	var html = __webpack_require__(1310);
	
	app.directive('timelionInterval', function ($compile, $timeout, timefilter) {
	  return {
	    restrict: 'E',
	    scope: {
	      model: '=' },
	    // The interval model
	    template: html,
	    link: function link($scope, $elem) {
	      $scope.intervalOptions = ['auto', '1s', '1m', '1h', '1d', '1w', '1M', '1y', 'other'];
	
	      $scope.$watch('model', function (newVal, oldVal) {
	        // Only run this on initialization
	        if (newVal !== oldVal || oldVal == null) return;
	
	        if (_.contains($scope.intervalOptions, newVal)) {
	          $scope.interval = newVal;
	        } else {
	          $scope.interval = 'other';
	        }
	
	        if (newVal !== 'other') {
	          $scope.otherInterval = newVal;
	        }
	      });
	
	      $scope.$watch('interval', function (newVal, oldVal) {
	        if (newVal === oldVal) return;
	
	        if (newVal === 'other') {
	          $scope.otherInterval = oldVal;
	          $scope.model = $scope.otherInterval;
	          $timeout(function () {
	            $('input', $elem).select();
	          }, 0);
	        } else {
	          $scope.otherInterval = $scope.interval;
	          $scope.model = $scope.interval;
	        }
	      });
	
	      $scope.$watch('otherInterval', function (newVal, oldVal) {
	        if (newVal === oldVal) return;
	        $scope.model = newVal;
	      });
	    }
	  };
	});

/***/ },
/* 1310 */
/***/ function(module, exports) {

	module.exports = "<input input-focus ng-show=\"interval === 'other'\"\n  class=\"form-control timelion-interval\"\n  ng-model=\"otherInterval\">\n\n<select class=\"form-control timelion-interval timelion-interval--select\"\n  ng-options=\"i for i in intervalOptions\"\n  ng-class=\"{'timelion-interval-other': interval == 'other'}\"\n  ng-model=\"interval\"></select>\n"

/***/ },
/* 1311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	
	var app = __webpack_require__(24).get('apps/timelion', []);
	
	app.directive('refreshHack', function ($rootScope) {
	  return {
	    restrict: 'A',
	    link: function link($scope) {
	      function broadcast() {
	        $scope.$broadcast('fetch');
	      }
	
	      $scope.$on('$destroy', function () {
	        $('[name="queryInput"]').unbind('submit', broadcast);
	        $('[ng-click="fetch()"]').unbind('click', broadcast);
	      });
	
	      $('[name="queryInput"]').submit(broadcast);
	      $('[ng-click="fetch()"]').click(broadcast);
	    }
	  };
	});

/***/ },
/* 1312 */,
/* 1313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	__webpack_require__(416);
	
	module.exports = function dashboardContext(Private, getAppState) {
	  return function () {
	    var queryFilter = Private(__webpack_require__(609));
	    var bool = { must: [], must_not: [] };
	    var filterBarFilters = queryFilter.getFilters();
	    var queryBarFilter = getAppState().query;
	
	    // Add the query bar filter, its handled differently.
	    bool.must.push(queryBarFilter);
	
	    // Add each of the filter bar filters
	    _.each(filterBarFilters, function (filter) {
	      var esFilter = _.omit(filter, function (val, key) {
	        if (key === 'meta' || key[0] === '$') return true;
	        return false;
	      });
	
	      if (filter.meta.disabled) return;
	      if (filter.meta.negate) {
	        bool.must_not.push(esFilter.query || esFilter);
	      } else {
	        bool.must.push(esFilter.query || esFilter);
	      }
	    });
	
	    return { bool: bool };
	  };
	};

/***/ },
/* 1314 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(1315);
	__webpack_require__(24);
	
	'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(1315);
	
	  var module = __webpack_require__(24).get('kibana/timelion_vis', ['kibana']);
	  module.controller('TimelionVisParamsController', function ($scope, $rootScope) {
	    $scope.vis.params.expression = $scope.vis.params.expression || '.es(*)';
	    $scope.vis.params.interval = $scope.vis.params.interval || '1m';
	
	    $scope.search = function () {
	      $rootScope.$broadcast('courier:searchRefresh');
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 1315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	var grammar = __webpack_require__(1316);
	var PEG = __webpack_require__(1317);
	var Parser = PEG.buildParser(grammar);
	var template = __webpack_require__(1334);
	
	var app = __webpack_require__(24).get('apps/timelion', []);
	
	/*
	Autocomplete proposal, this file doesn't actually work like this
	
	function names
	Do not auto complete .sometext(, rather insert a closing ) whenever a ( is typed.
	
	.| (single dot)
	.func|
	
	argument names
	Well need to sort out which function were inside, must be inside a function though
	
	.function(|) // Suggest the first name aka most important arg, e.g. foo=
	.function(fo|) // Suggest foo=
	.function(foo=|) // Suggest [bar,baz]
	
	.function(arg=bar, |) Suggest 2nd arg name, and so on
	
	argument values
	Only named arguments, necessarily provided optional by a plugin.
	Must be inside a function, and start must be adjacent to the argument name
	
	.function(arg=b|)
	
	
	*/
	
	app.directive('timelionExpression', function ($compile, $http, $timeout, $rootScope, config) {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function link($scope, $elem, $attrs, ngModelCtrl) {
	
	      var keys = {
	        ESC: 27,
	        UP: 38,
	        DOWN: 40,
	        TAB: 9,
	        ENTER: 13
	      };
	
	      var functionReference = {};
	
	      function init() {
	        resetSuggestions();
	        $elem.on('mouseup', function () {
	          suggest($attrs.timelionExpression);
	          digest();
	        });
	        $elem.on('keydown', keyDownHandler);
	        $elem.on('keyup', keyUpHandler);
	        $elem.on('blur', function () {
	          $timeout(function () {
	            $scope.suggestions.show = false;
	          }, 100);
	        });
	
	        $elem.after($compile(template)($scope));
	        $http.get('../api/timelion/functions').then(function (resp) {
	          functionReference.byName = _.indexBy(resp.data, 'name');
	          functionReference.list = resp.data;
	        });
	      }
	
	      $scope.$on('$destroy', function () {
	        $elem.off('mouseup');
	        $elem.off('keydown');
	        $elem.off('keyup');
	        $elem.off('blur');
	      });
	
	      function suggest(val) {
	        try {
	          // Inside an existing function providing suggestion only as a reference. Maybe suggest an argument?
	          var possible = findFunction(getCaretPos(), Parser.parse(val).functions);
	          // TODO: Reference suggestors. Only supporting completion right now;
	          resetSuggestions();
	          return;
	
	          if (functionReference.byName) {
	            if (functionReference.byName[possible['function']]) {
	              $scope.suggestions.list = [functionReference.byName[possible['function']]];
	              $scope.suggestions.show = true;
	            } else {
	              resetSuggestions();
	            }
	          }
	        } catch (e) {
	          try {
	            // Is this a structured exception?
	            e = JSON.parse(e.message);
	            if (e.location.min > getCaretPos() || e.location.max <= getCaretPos()) {
	              resetSuggestions();
	              return;
	            }
	            // TODO: Abstract structured exception handling;
	            if (e.type === 'incompleteFunction') {
	              if (e['function'] == null) {
	                $scope.suggestions.list = functionReference.list;
	              } else {
	                $scope.suggestions.list = _.compact(_.map(functionReference.list, function (func) {
	                  if (_.startsWith(func.name, e['function'])) {
	                    return func;
	                  }
	                }));
	              }
	              $scope.suggestions.show = true;
	            }
	            $scope.suggestions.location = e.location;
	          } catch (e) {
	            resetSuggestions();
	          }
	        }
	        digest();
	      }
	
	      function validateSelection() {
	        var maxSelection = $scope.suggestions.list.length - 1;
	        if ($scope.suggestions.selected > maxSelection) $scope.suggestions.selected = maxSelection;else if ($scope.suggestions.selected < 0) $scope.suggestions.selected = 0;
	      }
	
	      $scope.completeExpression = function (selected) {
	        if (!$scope.suggestions.list.length) return;
	        var expression = $attrs.timelionExpression;
	        var startOf = expression.slice(0, $scope.suggestions.location.min);
	        var endOf = expression.slice($scope.suggestions.location.max, expression.length);
	
	        var completeFunction = $scope.suggestions.list[selected].name + '()';
	
	        var newVal = startOf + completeFunction + endOf;
	
	        $elem.val(newVal);
	        $elem[0].selectionStart = $elem[0].selectionEnd = (startOf + completeFunction).length - 1;
	        ngModelCtrl.$setViewValue(newVal);
	
	        resetSuggestions();
	      };
	
	      function keyDownHandler(e) {
	        if (_.contains(_.values(keys), e.keyCode)) e.preventDefault();
	        switch (e.keyCode) {
	          case keys.UP:
	            if ($scope.suggestions.selected > 0) $scope.suggestions.selected--;
	            break;
	          case keys.DOWN:
	            $scope.suggestions.selected++;
	            break;
	          case keys.TAB:
	            $scope.completeExpression($scope.suggestions.selected);
	            break;
	          case keys.ENTER:
	            if ($scope.suggestions.list.length) {
	              $scope.completeExpression($scope.suggestions.selected);
	            } else {
	              $elem.submit();
	            }
	            break;
	          case keys.ESC:
	            $scope.suggestions.show = false;
	            break;
	        }
	        scrollTo($scope.suggestions);
	        digest();
	      }
	
	      function keyUpHandler(e) {
	        if (_.contains(_.values(keys), e.keyCode)) return;
	
	        suggest($attrs.timelionExpression);
	        validateSelection();
	        digest();
	      }
	
	      function resetSuggestions() {
	        $scope.suggestions = {
	          selected: 0,
	          list: [],
	          position: {},
	          show: false
	        };
	        return $scope.suggestions;
	      }
	
	      function scrollTo(suggestions) {
	        validateSelection();
	        var suggestionsListElem = $('.suggestions');
	        var suggestedElem = $($('.suggestion')[suggestions.selected]);
	
	        if (!suggestedElem.position() || !suggestedElem.position().top) return;
	
	        suggestionsListElem.scrollTop(suggestionsListElem.scrollTop() + suggestedElem.position().top);
	      }
	
	      function findFunction(position, functionList) {
	        var bestFunction = undefined;
	
	        _.each(functionList, function (func) {
	          if (func.location.min < position && position < func.location.max) {
	            if (!bestFunction || func.text.length < bestFunction.text.length) {
	              bestFunction = func;
	            }
	          }
	        });
	
	        return bestFunction;
	      }
	
	      function getCaretPos() {
	        return $elem[0].selectionStart;
	      }
	
	      function digest() {
	        $rootScope.$$phase || $scope.$digest();
	      }
	
	      init();
	    }
	  };
	});

/***/ },
/* 1316 */
/***/ function(module, exports) {

	module.exports = "/*\n * Timelion syntax parser\n */\n\n{\n function ltoo (literal) {\n  return {type: 'literal', value: literal}\n }\n\n function simpleLocation (location) {\n  return {\n   min: location.start.column,\n   max: location.end.column\n  }\n }\n\n var functions = [];\n var args = [];\n var variables = {};\n\n}\n\nstart\n = tree:series+ {\n  return {\n    tree: tree.filter(function (o) {return o != null}),\n    functions: functions,\n    args: args,\n    variables: variables\n  }\n }\n\narg_list\n = first:argument rest:more_args* {\n  return [first].concat(rest);\n }\n\nmore_args\n = ','? space? arg:argument {return arg;}\n\nargument\n = name:function_name '=' value:arg_type {\n  return {\n   type: 'namedArg',\n   name: name,\n   value: value,\n   location: simpleLocation(location()),\n   text: text()\n  }\n }\n / element:arg_type {return element}\n\narg_type\n = variable_get\n / series_type\n / literal:literal {\n  var result = ltoo(literal);\n  result.location = simpleLocation(location()),\n  result.text = text();\n  return result;\n }\n\nvariable_get\n = '$' name:function_name {\n  if (variables[name]) {\n   return variables[name];\n  } else {\n   error('$' + name + ' is not defined')\n  }\n }\n\nvariable_set\n = '$' name:function_name space? '=' space? value:arg_type {\n  variables[name] = value;\n }\n\nseries_type\n = variable_set\n / variable_get\n / group\n / chain\n / reference\n\nseries\n = series:series_type ','? space? { return series }\n\nfunction_name\n = (first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* ) { return first.join('') + rest.join('') }\n\nfunction \"function\"\n = '.' name:function_name '(' space? arg_list:arg_list? space? ')' {\n  var result = {\n    type: 'function',\n    function: name,\n    arguments: arg_list || [],\n    location: simpleLocation(location()),\n    text: text()\n  }\n\n  result.arguments.forEach(function (arg) {\n   arg.function = name;\n   args.push(arg);\n  })\n\n  functions.push(result)\n  return result;\n }\n / '.' func:function_name? {\n  var exception = {\n   type: 'incompleteFunction',\n   function: func,\n   location: simpleLocation(location()),\n   text: text()\n  }\n  error(JSON.stringify(exception));\n }\n\nreference\n = '@' plot:integer ':' series:integer {\n  return {\n   type: 'reference',\n   plot: plot,\n   series: series\n  }\n }\n / '@' plot:integer {\n  return {\n   type: 'reference',\n   plot: plot\n  }\n }\n\n\nchain\n = func:function rest:function* {return {type: 'chain', chain: [func].concat(rest)}}\n\ngroup\n = '(' space? grouped:series+ space? ')' functions:function* {\n  var first = {\n    type: 'chainList',\n    list: grouped\n  }\n  first.label = text();\n\n  return {type: \"chain\", chain: [first].concat(functions)};\n }\n\n /* ----- Core types ----- */\n\nliteral \"literal\"\n  =  '\"' chars:dq_char* '\"' { return chars.join(''); } // double quoted string\n  / \"'\" chars:sq_char* \"'\" { return chars.join(''); } // single quoted string\n  / 'true'  { return true; } // unquoted literals from here down\n  / 'false' { return false; }\n  / 'null'  { return null; }\n  / string:[^()\"',=\\ \\t]+ { // this also matches numbers via Number()\n   var result = string.join('');\n   // Sort of hacky, but PEG doesn't have backtracking so\n   // a number rule is hard to read, and performs worse\n   if (isNaN(Number(result))) return result;\n   return Number(result)\n  }\n\nspace\n = [\\ \\t]+\n\ndq_char\n  = \"\\\\\" sequence:('\"' / \"\\\\\") { return sequence; }\n  / [^\"] // everything except \"\n\nsq_char\n  = \"\\\\\" sequence:(\"'\" / \"\\\\\") { return sequence; }\n  / [^'] // everything except '\n\ninteger\n = digits:[0-9]+ {return parseInt(digits.join(''))}\n"

/***/ },
/* 1317 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays  = __webpack_require__(1318),
	    objects = __webpack_require__(1319);
	
	var PEG = {
	  /* PEG.js version (uses semantic versioning). */
	  VERSION: "0.9.0",
	
	  GrammarError: __webpack_require__(1320),
	  parser:       __webpack_require__(1322),
	  compiler:     __webpack_require__(1323),
	
	  /*
	   * Generates a parser from a specified grammar and returns it.
	   *
	   * The grammar must be a string in the format described by the metagramar in
	   * the parser.pegjs file.
	   *
	   * Throws |PEG.parser.SyntaxError| if the grammar contains a syntax error or
	   * |PEG.GrammarError| if it contains a semantic error. Note that not all
	   * errors are detected during the generation and some may protrude to the
	   * generated parser and cause its malfunction.
	   */
	  buildParser: function(grammar) {
	    function convertPasses(passes) {
	      var converted = {}, stage;
	
	      for (stage in passes) {
	        if (passes.hasOwnProperty(stage)) {
	          converted[stage] = objects.values(passes[stage]);
	        }
	      }
	
	      return converted;
	    }
	
	    var options = arguments.length > 1 ? objects.clone(arguments[1]) : {},
	        plugins = "plugins" in options ? options.plugins : [],
	        config  = {
	          parser: this.parser,
	          passes: convertPasses(this.compiler.passes)
	        };
	
	    arrays.each(plugins, function(p) { p.use(config, options); });
	
	    return this.compiler.compile(
	      config.parser.parse(grammar),
	      config.passes,
	      options
	    );
	  }
	};
	
	module.exports = PEG;


/***/ },
/* 1318 */
/***/ function(module, exports) {

	"use strict";
	
	/* Array utilities. */
	var arrays = {
	  range: function(start, stop) {
	    var length = stop - start,
	        result = new Array(length),
	        i, j;
	
	    for (i = 0, j = start; i < length; i++, j++) {
	      result[i] = j;
	    }
	
	    return result;
	  },
	
	  find: function(array, valueOrPredicate) {
	    var length = array.length, i;
	
	    if (typeof valueOrPredicate === "function") {
	      for (i = 0; i < length; i++) {
	        if (valueOrPredicate(array[i])) {
	          return array[i];
	        }
	      }
	    } else {
	      for (i = 0; i < length; i++) {
	        if (array[i] === valueOrPredicate) {
	          return array[i];
	        }
	      }
	    }
	  },
	
	  indexOf: function(array, valueOrPredicate) {
	    var length = array.length, i;
	
	    if (typeof valueOrPredicate === "function") {
	      for (i = 0; i < length; i++) {
	        if (valueOrPredicate(array[i])) {
	          return i;
	        }
	      }
	    } else {
	      for (i = 0; i < length; i++) {
	        if (array[i] === valueOrPredicate) {
	          return i;
	        }
	      }
	    }
	
	    return -1;
	  },
	
	  contains: function(array, valueOrPredicate) {
	    return arrays.indexOf(array, valueOrPredicate) !== -1;
	  },
	
	  each: function(array, iterator) {
	    var length = array.length, i;
	
	    for (i = 0; i < length; i++) {
	      iterator(array[i], i);
	    }
	  },
	
	  map: function(array, iterator) {
	    var length = array.length,
	        result = new Array(length),
	        i;
	
	    for (i = 0; i < length; i++) {
	      result[i] = iterator(array[i], i);
	    }
	
	    return result;
	  },
	
	  pluck: function(array, key) {
	    return arrays.map(array, function (e) { return e[key]; });
	  },
	
	  every: function(array, predicate) {
	    var length = array.length, i;
	
	    for (i = 0; i < length; i++) {
	      if (!predicate(array[i])) {
	        return false;
	      }
	    }
	
	    return true;
	  },
	
	  some: function(array, predicate) {
	    var length = array.length, i;
	
	    for (i = 0; i < length; i++) {
	      if (predicate(array[i])) {
	        return true;
	      }
	    }
	
	    return false;
	  }
	};
	
	module.exports = arrays;


/***/ },
/* 1319 */
/***/ function(module, exports) {

	"use strict";
	
	/* Object utilities. */
	var objects = {
	  keys: function(object) {
	    var result = [], key;
	
	    for (key in object) {
	      if (object.hasOwnProperty(key)) {
	        result.push(key);
	      }
	    }
	
	    return result;
	  },
	
	  values: function(object) {
	    var result = [], key;
	
	    for (key in object) {
	      if (object.hasOwnProperty(key)) {
	        result.push(object[key]);
	      }
	    }
	
	    return result;
	  },
	
	  clone: function(object) {
	    var result = {}, key;
	
	    for (key in object) {
	      if (object.hasOwnProperty(key)) {
	        result[key] = object[key];
	      }
	    }
	
	    return result;
	  },
	
	  defaults: function(object, defaults) {
	    var key;
	
	    for (key in defaults) {
	      if (defaults.hasOwnProperty(key)) {
	        if (!(key in object)) {
	          object[key] = defaults[key];
	        }
	      }
	    }
	  }
	};
	
	module.exports = objects;


/***/ },
/* 1320 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var classes = __webpack_require__(1321);
	
	/* Thrown when the grammar contains an error. */
	function GrammarError(message, location) {
	  this.name = "GrammarError";
	  this.message = message;
	  this.location = location;
	
	  if (typeof Error.captureStackTrace === "function") {
	    Error.captureStackTrace(this, GrammarError);
	  }
	}
	
	classes.subclass(GrammarError, Error);
	
	module.exports = GrammarError;


/***/ },
/* 1321 */
/***/ function(module, exports) {

	"use strict";
	
	/* Class utilities */
	var classes = {
	  subclass: function(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	};
	
	module.exports = classes;


/***/ },
/* 1322 */
/***/ function(module, exports) {

	module.exports = (function() {
	  "use strict";
	
	  /*
	   * Generated by PEG.js 0.9.0.
	   *
	   * http://pegjs.org/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";
	
	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }
	
	  peg$subclass(peg$SyntaxError, Error);
	
	  function peg$parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	        parser  = this,
	
	        peg$FAILED = {},
	
	        peg$startRuleFunctions = { Grammar: peg$parseGrammar },
	        peg$startRuleFunction  = peg$parseGrammar,
	
	        peg$c0 = function(initializer, rules) {
	              return {
	                type:        "grammar",
	                initializer: extractOptional(initializer, 0),
	                rules:       extractList(rules, 0),
	                location:    location()
	              };
	            },
	        peg$c1 = function(code) {
	              return { type: "initializer", code: code, location: location() };
	            },
	        peg$c2 = "=",
	        peg$c3 = { type: "literal", value: "=", description: "\"=\"" },
	        peg$c4 = function(name, displayName, expression) {
	              return {
	                type:        "rule",
	                name:        name,
	                expression:  displayName !== null
	                  ? {
	                      type:       "named",
	                      name:       displayName[0],
	                      expression: expression,
	                      location:   location()
	                    }
	                  : expression,
	                location:    location()
	              };
	            },
	        peg$c5 = "/",
	        peg$c6 = { type: "literal", value: "/", description: "\"/\"" },
	        peg$c7 = function(first, rest) {
	              return rest.length > 0
	                ? {
	                    type:         "choice",
	                    alternatives: buildList(first, rest, 3),
	                    location:     location()
	                  }
	                : first;
	            },
	        peg$c8 = function(expression, code) {
	              return code !== null
	                ? {
	                    type:       "action",
	                    expression: expression,
	                    code:       code[1],
	                    location:   location()
	                  }
	                : expression;
	            },
	        peg$c9 = function(first, rest) {
	              return rest.length > 0
	                ? {
	                    type:     "sequence",
	                    elements: buildList(first, rest, 1),
	                    location: location()
	                  }
	                : first;
	            },
	        peg$c10 = ":",
	        peg$c11 = { type: "literal", value: ":", description: "\":\"" },
	        peg$c12 = function(label, expression) {
	              return {
	                type:       "labeled",
	                label:      label,
	                expression: expression,
	                location:   location()
	              };
	            },
	        peg$c13 = function(operator, expression) {
	              return {
	                type:       OPS_TO_PREFIXED_TYPES[operator],
	                expression: expression,
	                location:   location()
	              };
	            },
	        peg$c14 = "$",
	        peg$c15 = { type: "literal", value: "$", description: "\"$\"" },
	        peg$c16 = "&",
	        peg$c17 = { type: "literal", value: "&", description: "\"&\"" },
	        peg$c18 = "!",
	        peg$c19 = { type: "literal", value: "!", description: "\"!\"" },
	        peg$c20 = function(expression, operator) {
	              return {
	                type:       OPS_TO_SUFFIXED_TYPES[operator],
	                expression: expression,
	                location:   location()
	              };
	            },
	        peg$c21 = "?",
	        peg$c22 = { type: "literal", value: "?", description: "\"?\"" },
	        peg$c23 = "*",
	        peg$c24 = { type: "literal", value: "*", description: "\"*\"" },
	        peg$c25 = "+",
	        peg$c26 = { type: "literal", value: "+", description: "\"+\"" },
	        peg$c27 = "(",
	        peg$c28 = { type: "literal", value: "(", description: "\"(\"" },
	        peg$c29 = ")",
	        peg$c30 = { type: "literal", value: ")", description: "\")\"" },
	        peg$c31 = function(expression) { return expression; },
	        peg$c32 = function(name) {
	              return { type: "rule_ref", name: name, location: location() };
	            },
	        peg$c33 = function(operator, code) {
	              return {
	                type:     OPS_TO_SEMANTIC_PREDICATE_TYPES[operator],
	                code:     code,
	                location: location()
	              };
	            },
	        peg$c34 = { type: "any", description: "any character" },
	        peg$c35 = { type: "other", description: "whitespace" },
	        peg$c36 = "\t",
	        peg$c37 = { type: "literal", value: "\t", description: "\"\\t\"" },
	        peg$c38 = "\x0B",
	        peg$c39 = { type: "literal", value: "\x0B", description: "\"\\x0B\"" },
	        peg$c40 = "\f",
	        peg$c41 = { type: "literal", value: "\f", description: "\"\\f\"" },
	        peg$c42 = " ",
	        peg$c43 = { type: "literal", value: " ", description: "\" \"" },
	        peg$c44 = "\xA0",
	        peg$c45 = { type: "literal", value: "\xA0", description: "\"\\xA0\"" },
	        peg$c46 = "\uFEFF",
	        peg$c47 = { type: "literal", value: "\uFEFF", description: "\"\\uFEFF\"" },
	        peg$c48 = /^[\n\r\u2028\u2029]/,
	        peg$c49 = { type: "class", value: "[\\n\\r\\u2028\\u2029]", description: "[\\n\\r\\u2028\\u2029]" },
	        peg$c50 = { type: "other", description: "end of line" },
	        peg$c51 = "\n",
	        peg$c52 = { type: "literal", value: "\n", description: "\"\\n\"" },
	        peg$c53 = "\r\n",
	        peg$c54 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	        peg$c55 = "\r",
	        peg$c56 = { type: "literal", value: "\r", description: "\"\\r\"" },
	        peg$c57 = "\u2028",
	        peg$c58 = { type: "literal", value: "\u2028", description: "\"\\u2028\"" },
	        peg$c59 = "\u2029",
	        peg$c60 = { type: "literal", value: "\u2029", description: "\"\\u2029\"" },
	        peg$c61 = { type: "other", description: "comment" },
	        peg$c62 = "/*",
	        peg$c63 = { type: "literal", value: "/*", description: "\"/*\"" },
	        peg$c64 = "*/",
	        peg$c65 = { type: "literal", value: "*/", description: "\"*/\"" },
	        peg$c66 = "//",
	        peg$c67 = { type: "literal", value: "//", description: "\"//\"" },
	        peg$c68 = function(name) { return name; },
	        peg$c69 = { type: "other", description: "identifier" },
	        peg$c70 = function(first, rest) { return first + rest.join(""); },
	        peg$c71 = "_",
	        peg$c72 = { type: "literal", value: "_", description: "\"_\"" },
	        peg$c73 = "\\",
	        peg$c74 = { type: "literal", value: "\\", description: "\"\\\\\"" },
	        peg$c75 = function(sequence) { return sequence; },
	        peg$c76 = "\u200C",
	        peg$c77 = { type: "literal", value: "\u200C", description: "\"\\u200C\"" },
	        peg$c78 = "\u200D",
	        peg$c79 = { type: "literal", value: "\u200D", description: "\"\\u200D\"" },
	        peg$c80 = { type: "other", description: "literal" },
	        peg$c81 = "i",
	        peg$c82 = { type: "literal", value: "i", description: "\"i\"" },
	        peg$c83 = function(value, ignoreCase) {
	              return {
	                type:       "literal",
	                value:      value,
	                ignoreCase: ignoreCase !== null,
	                location:   location()
	              };
	            },
	        peg$c84 = { type: "other", description: "string" },
	        peg$c85 = "\"",
	        peg$c86 = { type: "literal", value: "\"", description: "\"\\\"\"" },
	        peg$c87 = function(chars) { return chars.join(""); },
	        peg$c88 = "'",
	        peg$c89 = { type: "literal", value: "'", description: "\"'\"" },
	        peg$c90 = function() { return text(); },
	        peg$c91 = { type: "other", description: "character class" },
	        peg$c92 = "[",
	        peg$c93 = { type: "literal", value: "[", description: "\"[\"" },
	        peg$c94 = "^",
	        peg$c95 = { type: "literal", value: "^", description: "\"^\"" },
	        peg$c96 = "]",
	        peg$c97 = { type: "literal", value: "]", description: "\"]\"" },
	        peg$c98 = function(inverted, parts, ignoreCase) {
	              return {
	                type:       "class",
	                parts:      filterEmptyStrings(parts),
	                inverted:   inverted !== null,
	                ignoreCase: ignoreCase !== null,
	                rawText:    text(),
	                location:   location()
	              };
	            },
	        peg$c99 = "-",
	        peg$c100 = { type: "literal", value: "-", description: "\"-\"" },
	        peg$c101 = function(begin, end) {
	              if (begin.charCodeAt(0) > end.charCodeAt(0)) {
	                error(
	                  "Invalid character range: " + text() + "."
	                );
	              }
	
	              return [begin, end];
	            },
	        peg$c102 = function() { return ""; },
	        peg$c103 = "0",
	        peg$c104 = { type: "literal", value: "0", description: "\"0\"" },
	        peg$c105 = function() { return "\0"; },
	        peg$c106 = "b",
	        peg$c107 = { type: "literal", value: "b", description: "\"b\"" },
	        peg$c108 = function() { return "\b";   },
	        peg$c109 = "f",
	        peg$c110 = { type: "literal", value: "f", description: "\"f\"" },
	        peg$c111 = function() { return "\f";   },
	        peg$c112 = "n",
	        peg$c113 = { type: "literal", value: "n", description: "\"n\"" },
	        peg$c114 = function() { return "\n";   },
	        peg$c115 = "r",
	        peg$c116 = { type: "literal", value: "r", description: "\"r\"" },
	        peg$c117 = function() { return "\r";   },
	        peg$c118 = "t",
	        peg$c119 = { type: "literal", value: "t", description: "\"t\"" },
	        peg$c120 = function() { return "\t";   },
	        peg$c121 = "v",
	        peg$c122 = { type: "literal", value: "v", description: "\"v\"" },
	        peg$c123 = function() { return "\x0B"; },
	        peg$c124 = "x",
	        peg$c125 = { type: "literal", value: "x", description: "\"x\"" },
	        peg$c126 = "u",
	        peg$c127 = { type: "literal", value: "u", description: "\"u\"" },
	        peg$c128 = function(digits) {
	              return String.fromCharCode(parseInt(digits, 16));
	            },
	        peg$c129 = /^[0-9]/,
	        peg$c130 = { type: "class", value: "[0-9]", description: "[0-9]" },
	        peg$c131 = /^[0-9a-f]/i,
	        peg$c132 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" },
	        peg$c133 = ".",
	        peg$c134 = { type: "literal", value: ".", description: "\".\"" },
	        peg$c135 = function() { return { type: "any", location: location() }; },
	        peg$c136 = { type: "other", description: "code block" },
	        peg$c137 = "{",
	        peg$c138 = { type: "literal", value: "{", description: "\"{\"" },
	        peg$c139 = "}",
	        peg$c140 = { type: "literal", value: "}", description: "\"}\"" },
	        peg$c141 = function(code) { return code; },
	        peg$c142 = /^[{}]/,
	        peg$c143 = { type: "class", value: "[{}]", description: "[{}]" },
	        peg$c144 = /^[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137-\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148-\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C-\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA-\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9-\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC-\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF-\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F-\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0-\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB-\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE-\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6-\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FC7\u1FD0-\u1FD3\u1FD6-\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6-\u1FF7\u210A\u210E-\u210F\u2113\u212F\u2134\u2139\u213C-\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65-\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73-\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3-\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]/,
	        peg$c145 = { type: "class", value: "[\\u0061-\\u007A\\u00B5\\u00DF-\\u00F6\\u00F8-\\u00FF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137-\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148-\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C-\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA-\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9-\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC-\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF-\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F-\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0-\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB-\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE-\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0561-\\u0587\\u13F8-\\u13FD\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6-\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FC7\\u1FD0-\\u1FD3\\u1FD6-\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6-\\u1FF7\\u210A\\u210E-\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C-\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65-\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73-\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3-\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7B5\\uA7B7\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB65\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]", description: "[\\u0061-\\u007A\\u00B5\\u00DF-\\u00F6\\u00F8-\\u00FF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137-\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148-\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C-\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA-\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9-\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC-\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF-\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F-\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0-\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB-\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE-\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0561-\\u0587\\u13F8-\\u13FD\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6-\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FC7\\u1FD0-\\u1FD3\\u1FD6-\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6-\\u1FF7\\u210A\\u210E-\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C-\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65-\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73-\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3-\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7B5\\uA7B7\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB65\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]" },
	        peg$c146 = /^[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5-\u06E6\u07F4-\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C-\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D-\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C-\uA69D\uA717-\uA71F\uA770\uA788\uA7F8-\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3-\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E-\uFF9F]/,
	        peg$c147 = { type: "class", value: "[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5-\\u06E6\\u07F4-\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8-\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F]", description: "[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5-\\u06E6\\u07F4-\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8-\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F]" },
	        peg$c148 = /^[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A-\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
	        peg$c149 = { type: "class", value: "[\\u00AA\\u00BA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E-\\u066F\\u0671-\\u06D3\\u06D5\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0-\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0-\\u0CE1\\u0CF1-\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065-\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE-\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5-\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A-\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]", description: "[\\u00AA\\u00BA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E-\\u066F\\u0671-\\u06D3\\u06D5\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0-\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0-\\u0CE1\\u0CF1-\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065-\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE-\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5-\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A-\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]" },
	        peg$c150 = /^[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
	        peg$c151 = { type: "class", value: "[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]", description: "[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]" },
	        peg$c152 = /^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178-\u0179\u017B\u017D\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018B\u018E-\u0191\u0193-\u0194\u0196-\u0198\u019C-\u019D\u019F-\u01A0\u01A2\u01A4\u01A6-\u01A7\u01A9\u01AC\u01AE-\u01AF\u01B1-\u01B3\u01B5\u01B7-\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A-\u023B\u023D-\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9-\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0-\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E-\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D-\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]/,
	        peg$c153 = { type: "class", value: "[\\u0041-\\u005A\\u00C0-\\u00D6\\u00D8-\\u00DE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178-\\u0179\\u017B\\u017D\\u0181-\\u0182\\u0184\\u0186-\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193-\\u0194\\u0196-\\u0198\\u019C-\\u019D\\u019F-\\u01A0\\u01A2\\u01A4\\u01A6-\\u01A7\\u01A9\\u01AC\\u01AE-\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7-\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A-\\u023B\\u023D-\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9-\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0-\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E-\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D-\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AD\\uA7B0-\\uA7B4\\uA7B6\\uFF21-\\uFF3A]", description: "[\\u0041-\\u005A\\u00C0-\\u00D6\\u00D8-\\u00DE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178-\\u0179\\u017B\\u017D\\u0181-\\u0182\\u0184\\u0186-\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193-\\u0194\\u0196-\\u0198\\u019C-\\u019D\\u019F-\\u01A0\\u01A2\\u01A4\\u01A6-\\u01A7\\u01A9\\u01AC\\u01AE-\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7-\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A-\\u023B\\u023D-\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9-\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0-\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E-\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D-\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AD\\uA7B0-\\uA7B4\\uA7B6\\uFF21-\\uFF3A]" },
	        peg$c154 = /^[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E-\u094F\u0982-\u0983\u09BE-\u09C0\u09C7-\u09C8\u09CB-\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB-\u0ACC\u0B02-\u0B03\u0B3E\u0B40\u0B47-\u0B48\u0B4B-\u0B4C\u0B57\u0BBE-\u0BBF\u0BC1-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82-\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7-\u0CC8\u0CCA-\u0CCB\u0CD5-\u0CD6\u0D02-\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82-\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2-\u0DF3\u0F3E-\u0F3F\u0F7F\u102B-\u102C\u1031\u1038\u103B-\u103C\u1056-\u1057\u1062-\u1064\u1067-\u106D\u1083-\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7-\u17C8\u1923-\u1926\u1929-\u192B\u1930-\u1931\u1933-\u1938\u1A19-\u1A1A\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B44\u1B82\u1BA1\u1BA6-\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1BF3\u1C24-\u1C2B\u1C34-\u1C35\u1CE1\u1CF2-\u1CF3\u302E-\u302F\uA823-\uA824\uA827\uA880-\uA881\uA8B4-\uA8C3\uA952-\uA953\uA983\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uA9C0\uAA2F-\uAA30\uAA33-\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE-\uAAEF\uAAF5\uABE3-\uABE4\uABE6-\uABE7\uABE9-\uABEA\uABEC]/,
	        peg$c155 = { type: "class", value: "[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F3E-\\u0F3F\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083-\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B44\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1BF3\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CE1\\u1CF2-\\u1CF3\\u302E-\\u302F\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952-\\uA953\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9C0\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\uABEC]", description: "[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F3E-\\u0F3F\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083-\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B44\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1BF3\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CE1\\u1CF2-\\u1CF3\\u302E-\\u302F\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952-\\uA953\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9C0\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\uABEC]" },
	        peg$c156 = /^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62-\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC-\u0CCD\u0CE2-\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62-\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099-\u309A\uA66F\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/,
	        peg$c157 = { type: "class", value: "[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2-\\u09E3\\u0A01-\\u0A02\\u0A3C\\u0A41-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70-\\u0A71\\u0A75\\u0A81-\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7-\\u0AC8\\u0ACD\\u0AE2-\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62-\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56\\u0C62-\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC-\\u0CCD\\u0CE2-\\u0CE3\\u0D01\\u0D41-\\u0D44\\u0D4D\\u0D62-\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039-\\u103A\\u103D-\\u103E\\u1058-\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085-\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B4-\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193B\\u1A17-\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80-\\u1B81\\u1BA2-\\u1BA5\\u1BA8-\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8-\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8-\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099-\\u309A\\uA66F\\uA674-\\uA67D\\uA69E-\\uA69F\\uA6F0-\\uA6F1\\uA802\\uA806\\uA80B\\uA825-\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9E5\\uAA29-\\uAA2E\\uAA31-\\uAA32\\uAA35-\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7-\\uAAB8\\uAABE-\\uAABF\\uAAC1\\uAAEC-\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]", description: "[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2-\\u09E3\\u0A01-\\u0A02\\u0A3C\\u0A41-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70-\\u0A71\\u0A75\\u0A81-\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7-\\u0AC8\\u0ACD\\u0AE2-\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62-\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56\\u0C62-\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC-\\u0CCD\\u0CE2-\\u0CE3\\u0D01\\u0D41-\\u0D44\\u0D4D\\u0D62-\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039-\\u103A\\u103D-\\u103E\\u1058-\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085-\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B4-\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193B\\u1A17-\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80-\\u1B81\\u1BA2-\\u1BA5\\u1BA8-\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8-\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8-\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099-\\u309A\\uA66F\\uA674-\\uA67D\\uA69E-\\uA69F\\uA6F0-\\uA6F1\\uA802\\uA806\\uA80B\\uA825-\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9E5\\uAA29-\\uAA2E\\uAA31-\\uAA32\\uAA35-\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7-\\uAAB8\\uAABE-\\uAABF\\uAAC1\\uAAEC-\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]" },
	        peg$c158 = /^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/,
	        peg$c159 = { type: "class", value: "[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]", description: "[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]" },
	        peg$c160 = /^[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/,
	        peg$c161 = { type: "class", value: "[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]", description: "[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]" },
	        peg$c162 = /^[_\u203F-\u2040\u2054\uFE33-\uFE34\uFE4D-\uFE4F\uFF3F]/,
	        peg$c163 = { type: "class", value: "[\\u005F\\u203F-\\u2040\\u2054\\uFE33-\\uFE34\\uFE4D-\\uFE4F\\uFF3F]", description: "[\\u005F\\u203F-\\u2040\\u2054\\uFE33-\\uFE34\\uFE4D-\\uFE4F\\uFF3F]" },
	        peg$c164 = /^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
	        peg$c165 = { type: "class", value: "[\\u0020\\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]", description: "[\\u0020\\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]" },
	        peg$c166 = "break",
	        peg$c167 = { type: "literal", value: "break", description: "\"break\"" },
	        peg$c168 = "case",
	        peg$c169 = { type: "literal", value: "case", description: "\"case\"" },
	        peg$c170 = "catch",
	        peg$c171 = { type: "literal", value: "catch", description: "\"catch\"" },
	        peg$c172 = "class",
	        peg$c173 = { type: "literal", value: "class", description: "\"class\"" },
	        peg$c174 = "const",
	        peg$c175 = { type: "literal", value: "const", description: "\"const\"" },
	        peg$c176 = "continue",
	        peg$c177 = { type: "literal", value: "continue", description: "\"continue\"" },
	        peg$c178 = "debugger",
	        peg$c179 = { type: "literal", value: "debugger", description: "\"debugger\"" },
	        peg$c180 = "default",
	        peg$c181 = { type: "literal", value: "default", description: "\"default\"" },
	        peg$c182 = "delete",
	        peg$c183 = { type: "literal", value: "delete", description: "\"delete\"" },
	        peg$c184 = "do",
	        peg$c185 = { type: "literal", value: "do", description: "\"do\"" },
	        peg$c186 = "else",
	        peg$c187 = { type: "literal", value: "else", description: "\"else\"" },
	        peg$c188 = "enum",
	        peg$c189 = { type: "literal", value: "enum", description: "\"enum\"" },
	        peg$c190 = "export",
	        peg$c191 = { type: "literal", value: "export", description: "\"export\"" },
	        peg$c192 = "extends",
	        peg$c193 = { type: "literal", value: "extends", description: "\"extends\"" },
	        peg$c194 = "false",
	        peg$c195 = { type: "literal", value: "false", description: "\"false\"" },
	        peg$c196 = "finally",
	        peg$c197 = { type: "literal", value: "finally", description: "\"finally\"" },
	        peg$c198 = "for",
	        peg$c199 = { type: "literal", value: "for", description: "\"for\"" },
	        peg$c200 = "function",
	        peg$c201 = { type: "literal", value: "function", description: "\"function\"" },
	        peg$c202 = "if",
	        peg$c203 = { type: "literal", value: "if", description: "\"if\"" },
	        peg$c204 = "import",
	        peg$c205 = { type: "literal", value: "import", description: "\"import\"" },
	        peg$c206 = "instanceof",
	        peg$c207 = { type: "literal", value: "instanceof", description: "\"instanceof\"" },
	        peg$c208 = "in",
	        peg$c209 = { type: "literal", value: "in", description: "\"in\"" },
	        peg$c210 = "new",
	        peg$c211 = { type: "literal", value: "new", description: "\"new\"" },
	        peg$c212 = "null",
	        peg$c213 = { type: "literal", value: "null", description: "\"null\"" },
	        peg$c214 = "return",
	        peg$c215 = { type: "literal", value: "return", description: "\"return\"" },
	        peg$c216 = "super",
	        peg$c217 = { type: "literal", value: "super", description: "\"super\"" },
	        peg$c218 = "switch",
	        peg$c219 = { type: "literal", value: "switch", description: "\"switch\"" },
	        peg$c220 = "this",
	        peg$c221 = { type: "literal", value: "this", description: "\"this\"" },
	        peg$c222 = "throw",
	        peg$c223 = { type: "literal", value: "throw", description: "\"throw\"" },
	        peg$c224 = "true",
	        peg$c225 = { type: "literal", value: "true", description: "\"true\"" },
	        peg$c226 = "try",
	        peg$c227 = { type: "literal", value: "try", description: "\"try\"" },
	        peg$c228 = "typeof",
	        peg$c229 = { type: "literal", value: "typeof", description: "\"typeof\"" },
	        peg$c230 = "var",
	        peg$c231 = { type: "literal", value: "var", description: "\"var\"" },
	        peg$c232 = "void",
	        peg$c233 = { type: "literal", value: "void", description: "\"void\"" },
	        peg$c234 = "while",
	        peg$c235 = { type: "literal", value: "while", description: "\"while\"" },
	        peg$c236 = "with",
	        peg$c237 = { type: "literal", value: "with", description: "\"with\"" },
	        peg$c238 = ";",
	        peg$c239 = { type: "literal", value: ";", description: "\";\"" },
	
	        peg$currPos          = 0,
	        peg$savedPos         = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$savedPos, peg$currPos);
	    }
	
	    function location() {
	      return peg$computeLocation(peg$savedPos, peg$currPos);
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        input.substring(peg$savedPos, peg$currPos),
	        peg$computeLocation(peg$savedPos, peg$currPos)
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(
	        message,
	        null,
	        input.substring(peg$savedPos, peg$currPos),
	        peg$computeLocation(peg$savedPos, peg$currPos)
	      );
	    }
	
	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos],
	          p, ch;
	
	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }
	
	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column,
	          seenCR: details.seenCR
	        };
	
	        while (p < pos) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	
	          p++;
	        }
	
	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }
	
	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);
	
	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, found, location) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new peg$SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }
	
	    function peg$parseGrammar() {
	      var s0, s1, s2, s3, s4, s5, s6;
	
	      s0 = peg$currPos;
	      s1 = peg$parse__();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$parseInitializer();
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parse__();
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = [];
	          s4 = peg$currPos;
	          s5 = peg$parseRule();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse__();
	            if (s6 !== peg$FAILED) {
	              s5 = [s5, s6];
	              s4 = s5;
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            while (s4 !== peg$FAILED) {
	              s3.push(s4);
	              s4 = peg$currPos;
	              s5 = peg$parseRule();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse__();
	                if (s6 !== peg$FAILED) {
	                  s5 = [s5, s6];
	                  s4 = s5;
	                } else {
	                  peg$currPos = s4;
	                  s4 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            }
	          } else {
	            s3 = peg$FAILED;
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c0(s2, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseInitializer() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = peg$parseCodeBlock();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseEOS();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c1(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseRule() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;
	
	      s0 = peg$currPos;
	      s1 = peg$parseIdentifierName();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$currPos;
	          s4 = peg$parseStringLiteral();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parse__();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	          if (s3 === peg$FAILED) {
	            s3 = null;
	          }
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	              s4 = peg$c2;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c3); }
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse__();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parseChoiceExpression();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseEOS();
	                  if (s7 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s3, s6);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseChoiceExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;
	
	      s0 = peg$currPos;
	      s1 = peg$parseActionExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse__();
	        if (s4 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 47) {
	            s5 = peg$c5;
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c6); }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse__();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseActionExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse__();
	          if (s4 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 47) {
	              s5 = peg$c5;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c6); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse__();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseActionExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c7(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseActionExpression() {
	      var s0, s1, s2, s3, s4;
	
	      s0 = peg$currPos;
	      s1 = peg$parseSequenceExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$parse__();
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseCodeBlock();
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c8(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseSequenceExpression() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      s1 = peg$parseLabeledExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse__();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseLabeledExpression();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse__();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseLabeledExpression();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c9(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseLabeledExpression() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      s1 = peg$parseIdentifier();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 58) {
	            s3 = peg$c10;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c11); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse__();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsePrefixedExpression();
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c12(s1, s5);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parsePrefixedExpression();
	      }
	
	      return s0;
	    }
	
	    function peg$parsePrefixedExpression() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      s1 = peg$parsePrefixedOperator();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseSuffixedExpression();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c13(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseSuffixedExpression();
	      }
	
	      return s0;
	    }
	
	    function peg$parsePrefixedOperator() {
	      var s0;
	
	      if (input.charCodeAt(peg$currPos) === 36) {
	        s0 = peg$c14;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c15); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 38) {
	          s0 = peg$c16;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c17); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 33) {
	            s0 = peg$c18;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c19); }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseSuffixedExpression() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      s1 = peg$parsePrimaryExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseSuffixedOperator();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c20(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parsePrimaryExpression();
	      }
	
	      return s0;
	    }
	
	    function peg$parseSuffixedOperator() {
	      var s0;
	
	      if (input.charCodeAt(peg$currPos) === 63) {
	        s0 = peg$c21;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c22); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 42) {
	          s0 = peg$c23;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c24); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 43) {
	            s0 = peg$c25;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c26); }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parsePrimaryExpression() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$parseLiteralMatcher();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseCharacterClassMatcher();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseAnyMatcher();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseRuleReferenceExpression();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseSemanticPredicateExpression();
	              if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 40) {
	                  s1 = peg$c27;
	                  peg$currPos++;
	                } else {
	                  s1 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c28); }
	                }
	                if (s1 !== peg$FAILED) {
	                  s2 = peg$parse__();
	                  if (s2 !== peg$FAILED) {
	                    s3 = peg$parseChoiceExpression();
	                    if (s3 !== peg$FAILED) {
	                      s4 = peg$parse__();
	                      if (s4 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 41) {
	                          s5 = peg$c29;
	                          peg$currPos++;
	                        } else {
	                          s5 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c30); }
	                        }
	                        if (s5 !== peg$FAILED) {
	                          peg$savedPos = s0;
	                          s1 = peg$c31(s3);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseRuleReferenceExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;
	
	      s0 = peg$currPos;
	      s1 = peg$parseIdentifierName();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$currPos;
	        s4 = peg$parse__();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$currPos;
	          s6 = peg$parseStringLiteral();
	          if (s6 !== peg$FAILED) {
	            s7 = peg$parse__();
	            if (s7 !== peg$FAILED) {
	              s6 = [s6, s7];
	              s5 = s6;
	            } else {
	              peg$currPos = s5;
	              s5 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s5;
	            s5 = peg$FAILED;
	          }
	          if (s5 === peg$FAILED) {
	            s5 = null;
	          }
	          if (s5 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	              s6 = peg$c2;
	              peg$currPos++;
	            } else {
	              s6 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c3); }
	            }
	            if (s6 !== peg$FAILED) {
	              s4 = [s4, s5, s6];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c32(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseSemanticPredicateExpression() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      s1 = peg$parseSemanticPredicateOperator();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseCodeBlock();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c33(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseSemanticPredicateOperator() {
	      var s0;
	
	      if (input.charCodeAt(peg$currPos) === 38) {
	        s0 = peg$c16;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c17); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 33) {
	          s0 = peg$c18;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c19); }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseSourceCharacter() {
	      var s0;
	
	      if (input.length > peg$currPos) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c34); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseWhiteSpace() {
	      var s0, s1;
	
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 9) {
	        s0 = peg$c36;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c37); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 11) {
	          s0 = peg$c38;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c39); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 12) {
	            s0 = peg$c40;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c41); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 32) {
	              s0 = peg$c42;
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c43); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 160) {
	                s0 = peg$c44;
	                peg$currPos++;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c45); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 65279) {
	                  s0 = peg$c46;
	                  peg$currPos++;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c47); }
	                }
	                if (s0 === peg$FAILED) {
	                  s0 = peg$parseZs();
	                }
	              }
	            }
	          }
	        }
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c35); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLineTerminator() {
	      var s0;
	
	      if (peg$c48.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c49); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLineTerminatorSequence() {
	      var s0, s1;
	
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 10) {
	        s0 = peg$c51;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c52); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c53) {
	          s0 = peg$c53;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c54); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 13) {
	            s0 = peg$c55;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c56); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 8232) {
	              s0 = peg$c57;
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c58); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 8233) {
	                s0 = peg$c59;
	                peg$currPos++;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c60); }
	              }
	            }
	          }
	        }
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c50); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseComment() {
	      var s0, s1;
	
	      peg$silentFails++;
	      s0 = peg$parseMultiLineComment();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseSingleLineComment();
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c61); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseMultiLineComment() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c62) {
	        s1 = peg$c62;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c63); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        if (input.substr(peg$currPos, 2) === peg$c64) {
	          s5 = peg$c64;
	          peg$currPos += 2;
	        } else {
	          s5 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c65); }
	        }
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          if (input.substr(peg$currPos, 2) === peg$c64) {
	            s5 = peg$c64;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c65); }
	          }
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c64) {
	            s3 = peg$c64;
	            peg$currPos += 2;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c65); }
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = [s1, s2, s3];
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseMultiLineCommentNoLineTerminator() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c62) {
	        s1 = peg$c62;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c63); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        if (input.substr(peg$currPos, 2) === peg$c64) {
	          s5 = peg$c64;
	          peg$currPos += 2;
	        } else {
	          s5 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c65); }
	        }
	        if (s5 === peg$FAILED) {
	          s5 = peg$parseLineTerminator();
	        }
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          if (input.substr(peg$currPos, 2) === peg$c64) {
	            s5 = peg$c64;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c65); }
	          }
	          if (s5 === peg$FAILED) {
	            s5 = peg$parseLineTerminator();
	          }
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c64) {
	            s3 = peg$c64;
	            peg$currPos += 2;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c65); }
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = [s1, s2, s3];
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseSingleLineComment() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c66) {
	        s1 = peg$c66;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c67); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        s5 = peg$parseLineTerminator();
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          s5 = peg$parseLineTerminator();
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseIdentifier() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      s2 = peg$parseReservedWord();
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseIdentifierName();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c68(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseIdentifierName() {
	      var s0, s1, s2, s3;
	
	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$parseIdentifierStart();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseIdentifierPart();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseIdentifierPart();
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c70(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c69); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseIdentifierStart() {
	      var s0, s1, s2;
	
	      s0 = peg$parseUnicodeLetter();
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 36) {
	          s0 = peg$c14;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c15); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 95) {
	            s0 = peg$c71;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c72); }
	          }
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 92) {
	              s1 = peg$c73;
	              peg$currPos++;
	            } else {
	              s1 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c74); }
	            }
	            if (s1 !== peg$FAILED) {
	              s2 = peg$parseUnicodeEscapeSequence();
	              if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c75(s2);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseIdentifierPart() {
	      var s0;
	
	      s0 = peg$parseIdentifierStart();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseUnicodeCombiningMark();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseNd();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parsePc();
	            if (s0 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 8204) {
	                s0 = peg$c76;
	                peg$currPos++;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c77); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 8205) {
	                  s0 = peg$c78;
	                  peg$currPos++;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c79); }
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseUnicodeLetter() {
	      var s0;
	
	      s0 = peg$parseLu();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseLl();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseLt();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseLm();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseLo();
	              if (s0 === peg$FAILED) {
	                s0 = peg$parseNl();
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseUnicodeCombiningMark() {
	      var s0;
	
	      s0 = peg$parseMn();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseMc();
	      }
	
	      return s0;
	    }
	
	    function peg$parseReservedWord() {
	      var s0;
	
	      s0 = peg$parseKeyword();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseFutureReservedWord();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseNullToken();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseBooleanLiteral();
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseKeyword() {
	      var s0;
	
	      s0 = peg$parseBreakToken();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseCaseToken();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseCatchToken();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseContinueToken();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseDebuggerToken();
	              if (s0 === peg$FAILED) {
	                s0 = peg$parseDefaultToken();
	                if (s0 === peg$FAILED) {
	                  s0 = peg$parseDeleteToken();
	                  if (s0 === peg$FAILED) {
	                    s0 = peg$parseDoToken();
	                    if (s0 === peg$FAILED) {
	                      s0 = peg$parseElseToken();
	                      if (s0 === peg$FAILED) {
	                        s0 = peg$parseFinallyToken();
	                        if (s0 === peg$FAILED) {
	                          s0 = peg$parseForToken();
	                          if (s0 === peg$FAILED) {
	                            s0 = peg$parseFunctionToken();
	                            if (s0 === peg$FAILED) {
	                              s0 = peg$parseIfToken();
	                              if (s0 === peg$FAILED) {
	                                s0 = peg$parseInstanceofToken();
	                                if (s0 === peg$FAILED) {
	                                  s0 = peg$parseInToken();
	                                  if (s0 === peg$FAILED) {
	                                    s0 = peg$parseNewToken();
	                                    if (s0 === peg$FAILED) {
	                                      s0 = peg$parseReturnToken();
	                                      if (s0 === peg$FAILED) {
	                                        s0 = peg$parseSwitchToken();
	                                        if (s0 === peg$FAILED) {
	                                          s0 = peg$parseThisToken();
	                                          if (s0 === peg$FAILED) {
	                                            s0 = peg$parseThrowToken();
	                                            if (s0 === peg$FAILED) {
	                                              s0 = peg$parseTryToken();
	                                              if (s0 === peg$FAILED) {
	                                                s0 = peg$parseTypeofToken();
	                                                if (s0 === peg$FAILED) {
	                                                  s0 = peg$parseVarToken();
	                                                  if (s0 === peg$FAILED) {
	                                                    s0 = peg$parseVoidToken();
	                                                    if (s0 === peg$FAILED) {
	                                                      s0 = peg$parseWhileToken();
	                                                      if (s0 === peg$FAILED) {
	                                                        s0 = peg$parseWithToken();
	                                                      }
	                                                    }
	                                                  }
	                                                }
	                                              }
	                                            }
	                                          }
	                                        }
	                                      }
	                                    }
	                                  }
	                                }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseFutureReservedWord() {
	      var s0;
	
	      s0 = peg$parseClassToken();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseConstToken();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseEnumToken();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseExportToken();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseExtendsToken();
	              if (s0 === peg$FAILED) {
	                s0 = peg$parseImportToken();
	                if (s0 === peg$FAILED) {
	                  s0 = peg$parseSuperToken();
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseBooleanLiteral() {
	      var s0;
	
	      s0 = peg$parseTrueToken();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseFalseToken();
	      }
	
	      return s0;
	    }
	
	    function peg$parseLiteralMatcher() {
	      var s0, s1, s2;
	
	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$parseStringLiteral();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 105) {
	          s2 = peg$c81;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c82); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c83(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c80); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseStringLiteral() {
	      var s0, s1, s2, s3;
	
	      peg$silentFails++;
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s1 = peg$c85;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c86); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseDoubleStringCharacter();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseDoubleStringCharacter();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s3 = peg$c85;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c86); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c87(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 39) {
	          s1 = peg$c88;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c89); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = [];
	          s3 = peg$parseSingleStringCharacter();
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parseSingleStringCharacter();
	          }
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 39) {
	              s3 = peg$c88;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c89); }
	            }
	            if (s3 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c87(s2);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c84); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseDoubleStringCharacter() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s2 = peg$c85;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c86); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c73;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c74); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseLineTerminator();
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c90();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s1 = peg$c73;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c74); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseEscapeSequence();
	          if (s2 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c75(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseLineContinuation();
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseSingleStringCharacter() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 39) {
	        s2 = peg$c88;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c89); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c73;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c74); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseLineTerminator();
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c90();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s1 = peg$c73;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c74); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseEscapeSequence();
	          if (s2 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c75(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseLineContinuation();
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseCharacterClassMatcher() {
	      var s0, s1, s2, s3, s4, s5;
	
	      peg$silentFails++;
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 91) {
	        s1 = peg$c92;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c93); }
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 94) {
	          s2 = peg$c94;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c95); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = [];
	          s4 = peg$parseClassCharacterRange();
	          if (s4 === peg$FAILED) {
	            s4 = peg$parseClassCharacter();
	          }
	          while (s4 !== peg$FAILED) {
	            s3.push(s4);
	            s4 = peg$parseClassCharacterRange();
	            if (s4 === peg$FAILED) {
	              s4 = peg$parseClassCharacter();
	            }
	          }
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 93) {
	              s4 = peg$c96;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c97); }
	            }
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 105) {
	                s5 = peg$c81;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c82); }
	              }
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c98(s2, s3, s5);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c91); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseClassCharacterRange() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      s1 = peg$parseClassCharacter();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 45) {
	          s2 = peg$c99;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c100); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseClassCharacter();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c101(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseClassCharacter() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 93) {
	        s2 = peg$c96;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c97); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c73;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c74); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseLineTerminator();
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c90();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s1 = peg$c73;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c74); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseEscapeSequence();
	          if (s2 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c75(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseLineContinuation();
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLineContinuation() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 92) {
	        s1 = peg$c73;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c74); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseLineTerminatorSequence();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c102();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseEscapeSequence() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$parseCharacterEscapeSequence();
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 48) {
	          s1 = peg$c103;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c104); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$currPos;
	          peg$silentFails++;
	          s3 = peg$parseDecimalDigit();
	          peg$silentFails--;
	          if (s3 === peg$FAILED) {
	            s2 = void 0;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	          if (s2 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c105();
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseHexEscapeSequence();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseUnicodeEscapeSequence();
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseCharacterEscapeSequence() {
	      var s0;
	
	      s0 = peg$parseSingleEscapeCharacter();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseNonEscapeCharacter();
	      }
	
	      return s0;
	    }
	
	    function peg$parseSingleEscapeCharacter() {
	      var s0, s1;
	
	      if (input.charCodeAt(peg$currPos) === 39) {
	        s0 = peg$c88;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c89); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 34) {
	          s0 = peg$c85;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c86); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 92) {
	            s0 = peg$c73;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c74); }
	          }
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 98) {
	              s1 = peg$c106;
	              peg$currPos++;
	            } else {
	              s1 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c107); }
	            }
	            if (s1 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c108();
	            }
	            s0 = s1;
	            if (s0 === peg$FAILED) {
	              s0 = peg$currPos;
	              if (input.charCodeAt(peg$currPos) === 102) {
	                s1 = peg$c109;
	                peg$currPos++;
	              } else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c110); }
	              }
	              if (s1 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c111();
	              }
	              s0 = s1;
	              if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 110) {
	                  s1 = peg$c112;
	                  peg$currPos++;
	                } else {
	                  s1 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c113); }
	                }
	                if (s1 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c114();
	                }
	                s0 = s1;
	                if (s0 === peg$FAILED) {
	                  s0 = peg$currPos;
	                  if (input.charCodeAt(peg$currPos) === 114) {
	                    s1 = peg$c115;
	                    peg$currPos++;
	                  } else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c116); }
	                  }
	                  if (s1 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c117();
	                  }
	                  s0 = s1;
	                  if (s0 === peg$FAILED) {
	                    s0 = peg$currPos;
	                    if (input.charCodeAt(peg$currPos) === 116) {
	                      s1 = peg$c118;
	                      peg$currPos++;
	                    } else {
	                      s1 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c119); }
	                    }
	                    if (s1 !== peg$FAILED) {
	                      peg$savedPos = s0;
	                      s1 = peg$c120();
	                    }
	                    s0 = s1;
	                    if (s0 === peg$FAILED) {
	                      s0 = peg$currPos;
	                      if (input.charCodeAt(peg$currPos) === 118) {
	                        s1 = peg$c121;
	                        peg$currPos++;
	                      } else {
	                        s1 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c122); }
	                      }
	                      if (s1 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c123();
	                      }
	                      s0 = s1;
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseNonEscapeCharacter() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      s2 = peg$parseEscapeCharacter();
	      if (s2 === peg$FAILED) {
	        s2 = peg$parseLineTerminator();
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c90();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseEscapeCharacter() {
	      var s0;
	
	      s0 = peg$parseSingleEscapeCharacter();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseDecimalDigit();
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 120) {
	            s0 = peg$c124;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c125); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 117) {
	              s0 = peg$c126;
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c127); }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseHexEscapeSequence() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 120) {
	        s1 = peg$c124;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c125); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        s4 = peg$parseHexDigit();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseHexDigit();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s2 = input.substring(s2, peg$currPos);
	        } else {
	          s2 = s3;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c128(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseUnicodeEscapeSequence() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 117) {
	        s1 = peg$c126;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c127); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        s4 = peg$parseHexDigit();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseHexDigit();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parseHexDigit();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseHexDigit();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s2 = input.substring(s2, peg$currPos);
	        } else {
	          s2 = s3;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c128(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseDecimalDigit() {
	      var s0;
	
	      if (peg$c129.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c130); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseHexDigit() {
	      var s0;
	
	      if (peg$c131.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c132); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseAnyMatcher() {
	      var s0, s1;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 46) {
	        s1 = peg$c133;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c134); }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c135();
	      }
	      s0 = s1;
	
	      return s0;
	    }
	
	    function peg$parseCodeBlock() {
	      var s0, s1, s2, s3;
	
	      peg$silentFails++;
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 123) {
	        s1 = peg$c137;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c138); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseCode();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 125) {
	            s3 = peg$c139;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c140); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c141(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c136); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseCode() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      s1 = [];
	      s2 = [];
	      s3 = peg$currPos;
	      s4 = peg$currPos;
	      peg$silentFails++;
	      if (peg$c142.test(input.charAt(peg$currPos))) {
	        s5 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s5 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c143); }
	      }
	      peg$silentFails--;
	      if (s5 === peg$FAILED) {
	        s4 = void 0;
	      } else {
	        peg$currPos = s4;
	        s4 = peg$FAILED;
	      }
	      if (s4 !== peg$FAILED) {
	        s5 = peg$parseSourceCharacter();
	        if (s5 !== peg$FAILED) {
	          s4 = [s4, s5];
	          s3 = s4;
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s3;
	        s3 = peg$FAILED;
	      }
	      if (s3 !== peg$FAILED) {
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          if (peg$c142.test(input.charAt(peg$currPos))) {
	            s5 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c143); }
	          }
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	      } else {
	        s2 = peg$FAILED;
	      }
	      if (s2 === peg$FAILED) {
	        s2 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 123) {
	          s3 = peg$c137;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c138); }
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseCode();
	          if (s4 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 125) {
	              s5 = peg$c139;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c140); }
	            }
	            if (s5 !== peg$FAILED) {
	              s3 = [s3, s4, s5];
	              s2 = s3;
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	      }
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        if (peg$c142.test(input.charAt(peg$currPos))) {
	          s5 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s5 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c143); }
	        }
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$currPos;
	            s4 = peg$currPos;
	            peg$silentFails++;
	            if (peg$c142.test(input.charAt(peg$currPos))) {
	              s5 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c143); }
	            }
	            peg$silentFails--;
	            if (s5 === peg$FAILED) {
	              s4 = void 0;
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseSourceCharacter();
	              if (s5 !== peg$FAILED) {
	                s4 = [s4, s5];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          }
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$currPos;
	          if (input.charCodeAt(peg$currPos) === 123) {
	            s3 = peg$c137;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c138); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseCode();
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 125) {
	                s5 = peg$c139;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c140); }
	              }
	              if (s5 !== peg$FAILED) {
	                s3 = [s3, s4, s5];
	                s2 = s3;
	              } else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s0 = input.substring(s0, peg$currPos);
	      } else {
	        s0 = s1;
	      }
	
	      return s0;
	    }
	
	    function peg$parseLl() {
	      var s0;
	
	      if (peg$c144.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c145); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLm() {
	      var s0;
	
	      if (peg$c146.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c147); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLo() {
	      var s0;
	
	      if (peg$c148.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c149); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLt() {
	      var s0;
	
	      if (peg$c150.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c151); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseLu() {
	      var s0;
	
	      if (peg$c152.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c153); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseMc() {
	      var s0;
	
	      if (peg$c154.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c155); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseMn() {
	      var s0;
	
	      if (peg$c156.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c157); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseNd() {
	      var s0;
	
	      if (peg$c158.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c159); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseNl() {
	      var s0;
	
	      if (peg$c160.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c161); }
	      }
	
	      return s0;
	    }
	
	    function peg$parsePc() {
	      var s0;
	
	      if (peg$c162.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c163); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseZs() {
	      var s0;
	
	      if (peg$c164.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c165); }
	      }
	
	      return s0;
	    }
	
	    function peg$parseBreakToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c166) {
	        s1 = peg$c166;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c167); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseCaseToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c168) {
	        s1 = peg$c168;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c169); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseCatchToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c170) {
	        s1 = peg$c170;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c171); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseClassToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c172) {
	        s1 = peg$c172;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c173); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseConstToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c174) {
	        s1 = peg$c174;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c175); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseContinueToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 8) === peg$c176) {
	        s1 = peg$c176;
	        peg$currPos += 8;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c177); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseDebuggerToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 8) === peg$c178) {
	        s1 = peg$c178;
	        peg$currPos += 8;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c179); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseDefaultToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c180) {
	        s1 = peg$c180;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c181); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseDeleteToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 6) === peg$c182) {
	        s1 = peg$c182;
	        peg$currPos += 6;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c183); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseDoToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c184) {
	        s1 = peg$c184;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c185); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseElseToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c186) {
	        s1 = peg$c186;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c187); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseEnumToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c188) {
	        s1 = peg$c188;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c189); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseExportToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 6) === peg$c190) {
	        s1 = peg$c190;
	        peg$currPos += 6;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c191); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseExtendsToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c192) {
	        s1 = peg$c192;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c193); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseFalseToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c194) {
	        s1 = peg$c194;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c195); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseFinallyToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c196) {
	        s1 = peg$c196;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c197); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseForToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 3) === peg$c198) {
	        s1 = peg$c198;
	        peg$currPos += 3;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c199); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseFunctionToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 8) === peg$c200) {
	        s1 = peg$c200;
	        peg$currPos += 8;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c201); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseIfToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c202) {
	        s1 = peg$c202;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c203); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseImportToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 6) === peg$c204) {
	        s1 = peg$c204;
	        peg$currPos += 6;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c205); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseInstanceofToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 10) === peg$c206) {
	        s1 = peg$c206;
	        peg$currPos += 10;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c207); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseInToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c208) {
	        s1 = peg$c208;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c209); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseNewToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 3) === peg$c210) {
	        s1 = peg$c210;
	        peg$currPos += 3;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c211); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseNullToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c212) {
	        s1 = peg$c212;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c213); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseReturnToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 6) === peg$c214) {
	        s1 = peg$c214;
	        peg$currPos += 6;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c215); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseSuperToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c216) {
	        s1 = peg$c216;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c217); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseSwitchToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 6) === peg$c218) {
	        s1 = peg$c218;
	        peg$currPos += 6;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c219); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseThisToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c220) {
	        s1 = peg$c220;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c221); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseThrowToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c222) {
	        s1 = peg$c222;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c223); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseTrueToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c224) {
	        s1 = peg$c224;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c225); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseTryToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 3) === peg$c226) {
	        s1 = peg$c226;
	        peg$currPos += 3;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c227); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseTypeofToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 6) === peg$c228) {
	        s1 = peg$c228;
	        peg$currPos += 6;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c229); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseVarToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 3) === peg$c230) {
	        s1 = peg$c230;
	        peg$currPos += 3;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c231); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseVoidToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c232) {
	        s1 = peg$c232;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c233); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseWhileToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 5) === peg$c234) {
	        s1 = peg$c234;
	        peg$currPos += 5;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c235); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parseWithToken() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c236) {
	        s1 = peg$c236;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c237); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parse__() {
	      var s0, s1;
	
	      s0 = [];
	      s1 = peg$parseWhiteSpace();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseLineTerminatorSequence();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseComment();
	        }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        s1 = peg$parseWhiteSpace();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseLineTerminatorSequence();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseComment();
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parse_() {
	      var s0, s1;
	
	      s0 = [];
	      s1 = peg$parseWhiteSpace();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseMultiLineCommentNoLineTerminator();
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        s1 = peg$parseWhiteSpace();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseMultiLineCommentNoLineTerminator();
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseEOS() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      s1 = peg$parse__();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 59) {
	          s2 = peg$c238;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c239); }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parse_();
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseSingleLineComment();
	          if (s2 === peg$FAILED) {
	            s2 = null;
	          }
	          if (s2 !== peg$FAILED) {
	            s3 = peg$parseLineTerminatorSequence();
	            if (s3 !== peg$FAILED) {
	              s1 = [s1, s2, s3];
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parse__();
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parseEOF();
	            if (s2 !== peg$FAILED) {
	              s1 = [s1, s2];
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseEOF() {
	      var s0, s1;
	
	      s0 = peg$currPos;
	      peg$silentFails++;
	      if (input.length > peg$currPos) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c34); }
	      }
	      peg$silentFails--;
	      if (s1 === peg$FAILED) {
	        s0 = void 0;
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	
	      var OPS_TO_PREFIXED_TYPES = {
	        "$": "text",
	        "&": "simple_and",
	        "!": "simple_not"
	      };
	
	      var OPS_TO_SUFFIXED_TYPES = {
	        "?": "optional",
	        "*": "zero_or_more",
	        "+": "one_or_more"
	      };
	
	      var OPS_TO_SEMANTIC_PREDICATE_TYPES = {
	        "&": "semantic_and",
	        "!": "semantic_not"
	      };
	
	      function filterEmptyStrings(array) {
	        var result = [], i;
	
	        for (i = 0; i < array.length; i++) {
	          if (array[i] !== "") {
	            result.push(array[i]);
	          }
	        }
	
	        return result;
	      }
	
	      function extractOptional(optional, index) {
	        return optional ? optional[index] : null;
	      }
	
	      function extractList(list, index) {
	        var result = new Array(list.length), i;
	
	        for (i = 0; i < list.length; i++) {
	          result[i] = list[i][index];
	        }
	
	        return result;
	      }
	
	      function buildList(first, rest, index) {
	        return [first].concat(extractList(rest, index));
	      }
	
	
	    peg$result = peg$startRuleFunction();
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(
	        null,
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }
	
	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();


/***/ },
/* 1323 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays  = __webpack_require__(1318),
	    objects = __webpack_require__(1319);
	
	var compiler = {
	  /*
	   * Compiler passes.
	   *
	   * Each pass is a function that is passed the AST. It can perform checks on it
	   * or modify it as needed. If the pass encounters a semantic error, it throws
	   * |PEG.GrammarError|.
	   */
	  passes: {
	    check: {
	      reportMissingRules:  __webpack_require__(1324),
	      reportLeftRecursion: __webpack_require__(1327),
	      reportInfiniteLoops: __webpack_require__(1328)
	    },
	    transform: {
	      removeProxyRules:    __webpack_require__(1329)
	    },
	    generate: {
	      generateBytecode:    __webpack_require__(1330),
	      generateJavascript:  __webpack_require__(1333)
	    }
	  },
	
	  /*
	   * Generates a parser from a specified grammar AST. Throws |PEG.GrammarError|
	   * if the AST contains a semantic error. Note that not all errors are detected
	   * during the generation and some may protrude to the generated parser and
	   * cause its malfunction.
	   */
	  compile: function(ast, passes) {
	    var options = arguments.length > 2 ? objects.clone(arguments[2]) : {},
	        stage;
	
	    objects.defaults(options, {
	      allowedStartRules:  [ast.rules[0].name],
	      cache:              false,
	      trace:              false,
	      optimize:           "speed",
	      output:             "parser"
	    });
	
	    for (stage in passes) {
	      if (passes.hasOwnProperty(stage)) {
	        arrays.each(passes[stage], function(p) { p(ast, options); });
	      }
	    }
	
	    switch (options.output) {
	      case "parser": return eval(ast.code);
	      case "source": return ast.code;
	    }
	  }
	};
	
	module.exports = compiler;


/***/ },
/* 1324 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var GrammarError = __webpack_require__(1320),
	    asts         = __webpack_require__(1325),
	    visitor      = __webpack_require__(1326);
	
	/* Checks that all referenced rules exist. */
	function reportMissingRules(ast) {
	  var check = visitor.build({
	    rule_ref: function(node) {
	      if (!asts.findRule(ast, node.name)) {
	        throw new GrammarError(
	          "Referenced rule \"" + node.name + "\" does not exist.",
	          node.location
	        );
	      }
	    }
	  });
	
	  check(ast);
	}
	
	module.exports = reportMissingRules;


/***/ },
/* 1325 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays  = __webpack_require__(1318),
	    visitor = __webpack_require__(1326);
	
	/* AST utilities. */
	var asts = {
	  findRule: function(ast, name) {
	    return arrays.find(ast.rules, function(r) { return r.name === name; });
	  },
	
	  indexOfRule: function(ast, name) {
	    return arrays.indexOf(ast.rules, function(r) { return r.name === name; });
	  },
	
	  alwaysAdvancesOnSuccess: function(ast, node) {
	    function advancesTrue()  { return true;  }
	    function advancesFalse() { return false; }
	
	    function advancesExpression(node) {
	      return advances(node.expression);
	    }
	
	    var advances = visitor.build({
	      rule:  advancesExpression,
	      named: advancesExpression,
	
	      choice: function(node) {
	        return arrays.every(node.alternatives, advances);
	      },
	
	      action: advancesExpression,
	
	      sequence: function(node) {
	        return arrays.some(node.elements, advances);
	      },
	
	      labeled:      advancesExpression,
	      text:         advancesExpression,
	      simple_and:   advancesFalse,
	      simple_not:   advancesFalse,
	      optional:     advancesFalse,
	      zero_or_more: advancesFalse,
	      one_or_more:  advancesExpression,
	      semantic_and: advancesFalse,
	      semantic_not: advancesFalse,
	
	      rule_ref: function(node) {
	        return advances(asts.findRule(ast, node.name));
	      },
	
	      literal: function(node) {
	        return node.value !== "";
	      },
	
	      "class": advancesTrue,
	      any:     advancesTrue
	    });
	
	    return advances(node);
	  }
	};
	
	module.exports = asts;


/***/ },
/* 1326 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var objects = __webpack_require__(1319),
	    arrays  = __webpack_require__(1318);
	
	/* Simple AST node visitor builder. */
	var visitor = {
	  build: function(functions) {
	    function visit(node) {
	      return functions[node.type].apply(null, arguments);
	    }
	
	    function visitNop() { }
	
	    function visitExpression(node) {
	      var extraArgs = Array.prototype.slice.call(arguments, 1);
	
	      visit.apply(null, [node.expression].concat(extraArgs));
	    }
	
	    function visitChildren(property) {
	      return function(node) {
	        var extraArgs = Array.prototype.slice.call(arguments, 1);
	
	        arrays.each(node[property], function(child) {
	          visit.apply(null, [child].concat(extraArgs));
	        });
	      };
	    }
	
	    var DEFAULT_FUNCTIONS = {
	          grammar: function(node) {
	            var extraArgs = Array.prototype.slice.call(arguments, 1);
	
	            if (node.initializer) {
	              visit.apply(null, [node.initializer].concat(extraArgs));
	            }
	
	            arrays.each(node.rules, function(rule) {
	              visit.apply(null, [rule].concat(extraArgs));
	            });
	          },
	
	          initializer:  visitNop,
	          rule:         visitExpression,
	          named:        visitExpression,
	          choice:       visitChildren("alternatives"),
	          action:       visitExpression,
	          sequence:     visitChildren("elements"),
	          labeled:      visitExpression,
	          text:         visitExpression,
	          simple_and:   visitExpression,
	          simple_not:   visitExpression,
	          optional:     visitExpression,
	          zero_or_more: visitExpression,
	          one_or_more:  visitExpression,
	          semantic_and: visitNop,
	          semantic_not: visitNop,
	          rule_ref:     visitNop,
	          literal:      visitNop,
	          "class":      visitNop,
	          any:          visitNop
	        };
	
	    objects.defaults(functions, DEFAULT_FUNCTIONS);
	
	    return visit;
	  }
	};
	
	module.exports = visitor;


/***/ },
/* 1327 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays       = __webpack_require__(1318),
	    GrammarError = __webpack_require__(1320),
	    asts         = __webpack_require__(1325),
	    visitor      = __webpack_require__(1326);
	
	/*
	 * Reports left recursion in the grammar, which prevents infinite recursion in
	 * the generated parser.
	 *
	 * Both direct and indirect recursion is detected. The pass also correctly
	 * reports cases like this:
	 *
	 *   start = "a"? start
	 *
	 * In general, if a rule reference can be reached without consuming any input,
	 * it can lead to left recursion.
	 */
	function reportLeftRecursion(ast) {
	  var visitedRules = [];
	
	  var check = visitor.build({
	    rule: function(node) {
	      visitedRules.push(node.name);
	      check(node.expression);
	      visitedRules.pop(node.name);
	    },
	
	    sequence: function(node) {
	      arrays.every(node.elements, function(element) {
	        check(element);
	
	        return !asts.alwaysAdvancesOnSuccess(ast, element);
	      });
	    },
	
	    rule_ref: function(node) {
	      if (arrays.contains(visitedRules, node.name)) {
	        throw new GrammarError(
	          "Left recursion detected for rule \"" + node.name + "\".",
	          node.location
	        );
	      }
	
	      check(asts.findRule(ast, node.name));
	    }
	  });
	
	  check(ast);
	}
	
	module.exports = reportLeftRecursion;


/***/ },
/* 1328 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var GrammarError = __webpack_require__(1320),
	    asts         = __webpack_require__(1325),
	    visitor      = __webpack_require__(1326);
	
	/*
	 * Reports expressions that don't consume any input inside |*| or |+| in the
	 * grammar, which prevents infinite loops in the generated parser.
	 */
	function reportInfiniteLoops(ast) {
	  var check = visitor.build({
	    zero_or_more: function(node) {
	      if (!asts.alwaysAdvancesOnSuccess(ast, node.expression)) {
	        throw new GrammarError("Infinite loop detected.", node.location);
	      }
	    },
	
	    one_or_more: function(node) {
	      if (!asts.alwaysAdvancesOnSuccess(ast, node.expression)) {
	        throw new GrammarError("Infinite loop detected.", node.location);
	      }
	    }
	  });
	
	  check(ast);
	}
	
	module.exports = reportInfiniteLoops;


/***/ },
/* 1329 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays  = __webpack_require__(1318),
	    visitor = __webpack_require__(1326);
	
	/*
	 * Removes proxy rules -- that is, rules that only delegate to other rule.
	 */
	function removeProxyRules(ast, options) {
	  function isProxyRule(node) {
	    return node.type === "rule" && node.expression.type === "rule_ref";
	  }
	
	  function replaceRuleRefs(ast, from, to) {
	    var replace = visitor.build({
	      rule_ref: function(node) {
	        if (node.name === from) {
	          node.name = to;
	        }
	      }
	    });
	
	    replace(ast);
	  }
	
	  var indices = [];
	
	  arrays.each(ast.rules, function(rule, i) {
	    if (isProxyRule(rule)) {
	      replaceRuleRefs(ast, rule.name, rule.expression.name);
	      if (!arrays.contains(options.allowedStartRules, rule.name)) {
	        indices.push(i);
	      }
	    }
	  });
	
	  indices.reverse();
	
	  arrays.each(indices, function(i) { ast.rules.splice(i, 1); });
	}
	
	module.exports = removeProxyRules;


/***/ },
/* 1330 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays  = __webpack_require__(1318),
	    objects = __webpack_require__(1319),
	    asts    = __webpack_require__(1325),
	    visitor = __webpack_require__(1326),
	    op      = __webpack_require__(1331),
	    js      = __webpack_require__(1332);
	
	/* Generates bytecode.
	 *
	 * Instructions
	 * ============
	 *
	 * Stack Manipulation
	 * ------------------
	 *
	 *  [0] PUSH c
	 *
	 *        stack.push(consts[c]);
	 *
	 *  [1] PUSH_UNDEFINED
	 *
	 *        stack.push(undefined);
	 *
	 *  [2] PUSH_NULL
	 *
	 *        stack.push(null);
	 *
	 *  [3] PUSH_FAILED
	 *
	 *        stack.push(FAILED);
	 *
	 *  [4] PUSH_EMPTY_ARRAY
	 *
	 *        stack.push([]);
	 *
	 *  [5] PUSH_CURR_POS
	 *
	 *        stack.push(currPos);
	 *
	 *  [6] POP
	 *
	 *        stack.pop();
	 *
	 *  [7] POP_CURR_POS
	 *
	 *        currPos = stack.pop();
	 *
	 *  [8] POP_N n
	 *
	 *        stack.pop(n);
	 *
	 *  [9] NIP
	 *
	 *        value = stack.pop();
	 *        stack.pop();
	 *        stack.push(value);
	 *
	 * [10] APPEND
	 *
	 *        value = stack.pop();
	 *        array = stack.pop();
	 *        array.push(value);
	 *        stack.push(array);
	 *
	 * [11] WRAP n
	 *
	 *        stack.push(stack.pop(n));
	 *
	 * [12] TEXT
	 *
	 *        stack.push(input.substring(stack.pop(), currPos));
	 *
	 * Conditions and Loops
	 * --------------------
	 *
	 * [13] IF t, f
	 *
	 *        if (stack.top()) {
	 *          interpret(ip + 3, ip + 3 + t);
	 *        } else {
	 *          interpret(ip + 3 + t, ip + 3 + t + f);
	 *        }
	 *
	 * [14] IF_ERROR t, f
	 *
	 *        if (stack.top() === FAILED) {
	 *          interpret(ip + 3, ip + 3 + t);
	 *        } else {
	 *          interpret(ip + 3 + t, ip + 3 + t + f);
	 *        }
	 *
	 * [15] IF_NOT_ERROR t, f
	 *
	 *        if (stack.top() !== FAILED) {
	 *          interpret(ip + 3, ip + 3 + t);
	 *        } else {
	 *          interpret(ip + 3 + t, ip + 3 + t + f);
	 *        }
	 *
	 * [16] WHILE_NOT_ERROR b
	 *
	 *        while(stack.top() !== FAILED) {
	 *          interpret(ip + 2, ip + 2 + b);
	 *        }
	 *
	 * Matching
	 * --------
	 *
	 * [17] MATCH_ANY a, f, ...
	 *
	 *        if (input.length > currPos) {
	 *          interpret(ip + 3, ip + 3 + a);
	 *        } else {
	 *          interpret(ip + 3 + a, ip + 3 + a + f);
	 *        }
	 *
	 * [18] MATCH_STRING s, a, f, ...
	 *
	 *        if (input.substr(currPos, consts[s].length) === consts[s]) {
	 *          interpret(ip + 4, ip + 4 + a);
	 *        } else {
	 *          interpret(ip + 4 + a, ip + 4 + a + f);
	 *        }
	 *
	 * [19] MATCH_STRING_IC s, a, f, ...
	 *
	 *        if (input.substr(currPos, consts[s].length).toLowerCase() === consts[s]) {
	 *          interpret(ip + 4, ip + 4 + a);
	 *        } else {
	 *          interpret(ip + 4 + a, ip + 4 + a + f);
	 *        }
	 *
	 * [20] MATCH_REGEXP r, a, f, ...
	 *
	 *        if (consts[r].test(input.charAt(currPos))) {
	 *          interpret(ip + 4, ip + 4 + a);
	 *        } else {
	 *          interpret(ip + 4 + a, ip + 4 + a + f);
	 *        }
	 *
	 * [21] ACCEPT_N n
	 *
	 *        stack.push(input.substring(currPos, n));
	 *        currPos += n;
	 *
	 * [22] ACCEPT_STRING s
	 *
	 *        stack.push(consts[s]);
	 *        currPos += consts[s].length;
	 *
	 * [23] FAIL e
	 *
	 *        stack.push(FAILED);
	 *        fail(consts[e]);
	 *
	 * Calls
	 * -----
	 *
	 * [24] LOAD_SAVED_POS p
	 *
	 *        savedPos = stack[p];
	 *
	 * [25] UPDATE_SAVED_POS
	 *
	 *        savedPos = currPos;
	 *
	 * [26] CALL f, n, pc, p1, p2, ..., pN
	 *
	 *        value = consts[f](stack[p1], ..., stack[pN]);
	 *        stack.pop(n);
	 *        stack.push(value);
	 *
	 * Rules
	 * -----
	 *
	 * [27] RULE r
	 *
	 *        stack.push(parseRule(r));
	 *
	 * Failure Reporting
	 * -----------------
	 *
	 * [28] SILENT_FAILS_ON
	 *
	 *        silentFails++;
	 *
	 * [29] SILENT_FAILS_OFF
	 *
	 *        silentFails--;
	 */
	function generateBytecode(ast) {
	  var consts = [];
	
	  function addConst(value) {
	    var index = arrays.indexOf(consts, value);
	
	    return index === -1 ? consts.push(value) - 1 : index;
	  }
	
	  function addFunctionConst(params, code) {
	    return addConst(
	      "function(" + params.join(", ") + ") {" + code + "}"
	    );
	  }
	
	  function buildSequence() {
	    return Array.prototype.concat.apply([], arguments);
	  }
	
	  function buildCondition(condCode, thenCode, elseCode) {
	    return condCode.concat(
	      [thenCode.length, elseCode.length],
	      thenCode,
	      elseCode
	    );
	  }
	
	  function buildLoop(condCode, bodyCode) {
	    return condCode.concat([bodyCode.length], bodyCode);
	  }
	
	  function buildCall(functionIndex, delta, env, sp) {
	    var params = arrays.map(objects.values(env), function(p) { return sp - p; });
	
	    return [op.CALL, functionIndex, delta, params.length].concat(params);
	  }
	
	  function buildSimplePredicate(expression, negative, context) {
	    return buildSequence(
	      [op.PUSH_CURR_POS],
	      [op.SILENT_FAILS_ON],
	      generate(expression, {
	        sp:     context.sp + 1,
	        env:    objects.clone(context.env),
	        action: null
	      }),
	      [op.SILENT_FAILS_OFF],
	      buildCondition(
	        [negative ? op.IF_ERROR : op.IF_NOT_ERROR],
	        buildSequence(
	          [op.POP],
	          [negative ? op.POP : op.POP_CURR_POS],
	          [op.PUSH_UNDEFINED]
	        ),
	        buildSequence(
	          [op.POP],
	          [negative ? op.POP_CURR_POS : op.POP],
	          [op.PUSH_FAILED]
	        )
	      )
	    );
	  }
	
	  function buildSemanticPredicate(code, negative, context) {
	    var functionIndex = addFunctionConst(objects.keys(context.env), code);
	
	    return buildSequence(
	      [op.UPDATE_SAVED_POS],
	      buildCall(functionIndex, 0, context.env, context.sp),
	      buildCondition(
	        [op.IF],
	        buildSequence(
	          [op.POP],
	          negative ? [op.PUSH_FAILED] : [op.PUSH_UNDEFINED]
	        ),
	        buildSequence(
	          [op.POP],
	          negative ? [op.PUSH_UNDEFINED] : [op.PUSH_FAILED]
	        )
	      )
	    );
	  }
	
	  function buildAppendLoop(expressionCode) {
	    return buildLoop(
	      [op.WHILE_NOT_ERROR],
	      buildSequence([op.APPEND], expressionCode)
	    );
	  }
	
	  var generate = visitor.build({
	    grammar: function(node) {
	      arrays.each(node.rules, generate);
	
	      node.consts = consts;
	    },
	
	    rule: function(node) {
	      node.bytecode = generate(node.expression, {
	        sp:     -1,    // stack pointer
	        env:    { },   // mapping of label names to stack positions
	        action: null   // action nodes pass themselves to children here
	      });
	    },
	
	    named: function(node, context) {
	      var nameIndex = addConst(
	        '{ type: "other", description: "' + js.stringEscape(node.name) + '" }'
	      );
	
	      /*
	       * The code generated below is slightly suboptimal because |FAIL| pushes
	       * to the stack, so we need to stick a |POP| in front of it. We lack a
	       * dedicated instruction that would just report the failure and not touch
	       * the stack.
	       */
	      return buildSequence(
	        [op.SILENT_FAILS_ON],
	        generate(node.expression, context),
	        [op.SILENT_FAILS_OFF],
	        buildCondition([op.IF_ERROR], [op.FAIL, nameIndex], [])
	      );
	    },
	
	    choice: function(node, context) {
	      function buildAlternativesCode(alternatives, context) {
	        return buildSequence(
	          generate(alternatives[0], {
	            sp:     context.sp,
	            env:    objects.clone(context.env),
	            action: null
	          }),
	          alternatives.length > 1
	            ? buildCondition(
	                [op.IF_ERROR],
	                buildSequence(
	                  [op.POP],
	                  buildAlternativesCode(alternatives.slice(1), context)
	                ),
	                []
	              )
	            : []
	        );
	      }
	
	      return buildAlternativesCode(node.alternatives, context);
	    },
	
	    action: function(node, context) {
	      var env            = objects.clone(context.env),
	          emitCall       = node.expression.type !== "sequence"
	                        || node.expression.elements.length === 0,
	          expressionCode = generate(node.expression, {
	            sp:     context.sp + (emitCall ? 1 : 0),
	            env:    env,
	            action: node
	          }),
	          functionIndex  = addFunctionConst(objects.keys(env), node.code);
	
	      return emitCall
	        ? buildSequence(
	            [op.PUSH_CURR_POS],
	            expressionCode,
	            buildCondition(
	              [op.IF_NOT_ERROR],
	              buildSequence(
	                [op.LOAD_SAVED_POS, 1],
	                buildCall(functionIndex, 1, env, context.sp + 2)
	              ),
	              []
	            ),
	            [op.NIP]
	          )
	        : expressionCode;
	    },
	
	    sequence: function(node, context) {
	      function buildElementsCode(elements, context) {
	        var processedCount, functionIndex;
	
	        if (elements.length > 0) {
	          processedCount = node.elements.length - elements.slice(1).length;
	
	          return buildSequence(
	            generate(elements[0], {
	              sp:     context.sp,
	              env:    context.env,
	              action: null
	            }),
	            buildCondition(
	              [op.IF_NOT_ERROR],
	              buildElementsCode(elements.slice(1), {
	                sp:     context.sp + 1,
	                env:    context.env,
	                action: context.action
	              }),
	              buildSequence(
	                processedCount > 1 ? [op.POP_N, processedCount] : [op.POP],
	                [op.POP_CURR_POS],
	                [op.PUSH_FAILED]
	              )
	            )
	          );
	        } else {
	          if (context.action) {
	            functionIndex = addFunctionConst(
	              objects.keys(context.env),
	              context.action.code
	            );
	
	            return buildSequence(
	              [op.LOAD_SAVED_POS, node.elements.length],
	              buildCall(
	                functionIndex,
	                node.elements.length,
	                context.env,
	                context.sp
	              ),
	              [op.NIP]
	            );
	          } else {
	            return buildSequence([op.WRAP, node.elements.length], [op.NIP]);
	          }
	        }
	      }
	
	      return buildSequence(
	        [op.PUSH_CURR_POS],
	        buildElementsCode(node.elements, {
	          sp:     context.sp + 1,
	          env:    context.env,
	          action: context.action
	        })
	      );
	    },
	
	    labeled: function(node, context) {
	      var env = objects.clone(context.env);
	
	      context.env[node.label] = context.sp + 1;
	
	      return generate(node.expression, {
	        sp:     context.sp,
	        env:    env,
	        action: null
	      });
	    },
	
	    text: function(node, context) {
	      return buildSequence(
	        [op.PUSH_CURR_POS],
	        generate(node.expression, {
	          sp:     context.sp + 1,
	          env:    objects.clone(context.env),
	          action: null
	        }),
	        buildCondition(
	          [op.IF_NOT_ERROR],
	          buildSequence([op.POP], [op.TEXT]),
	          [op.NIP]
	        )
	      );
	    },
	
	    simple_and: function(node, context) {
	      return buildSimplePredicate(node.expression, false, context);
	    },
	
	    simple_not: function(node, context) {
	      return buildSimplePredicate(node.expression, true, context);
	    },
	
	    optional: function(node, context) {
	      return buildSequence(
	        generate(node.expression, {
	          sp:     context.sp,
	          env:    objects.clone(context.env),
	          action: null
	        }),
	        buildCondition(
	          [op.IF_ERROR],
	          buildSequence([op.POP], [op.PUSH_NULL]),
	          []
	        )
	      );
	    },
	
	    zero_or_more: function(node, context) {
	      var expressionCode = generate(node.expression, {
	            sp:     context.sp + 1,
	            env:    objects.clone(context.env),
	            action: null
	          });
	
	      return buildSequence(
	        [op.PUSH_EMPTY_ARRAY],
	        expressionCode,
	        buildAppendLoop(expressionCode),
	        [op.POP]
	      );
	    },
	
	    one_or_more: function(node, context) {
	      var expressionCode = generate(node.expression, {
	            sp:     context.sp + 1,
	            env:    objects.clone(context.env),
	            action: null
	          });
	
	      return buildSequence(
	        [op.PUSH_EMPTY_ARRAY],
	        expressionCode,
	        buildCondition(
	          [op.IF_NOT_ERROR],
	          buildSequence(buildAppendLoop(expressionCode), [op.POP]),
	          buildSequence([op.POP], [op.POP], [op.PUSH_FAILED])
	        )
	      );
	    },
	
	    semantic_and: function(node, context) {
	      return buildSemanticPredicate(node.code, false, context);
	    },
	
	    semantic_not: function(node, context) {
	      return buildSemanticPredicate(node.code, true, context);
	    },
	
	    rule_ref: function(node) {
	      return [op.RULE, asts.indexOfRule(ast, node.name)];
	    },
	
	    literal: function(node) {
	      var stringIndex, expectedIndex;
	
	      if (node.value.length > 0) {
	        stringIndex = addConst('"'
	          + js.stringEscape(
	              node.ignoreCase ? node.value.toLowerCase() : node.value
	            )
	          + '"'
	        );
	        expectedIndex = addConst([
	          '{',
	          'type: "literal",',
	          'value: "' + js.stringEscape(node.value) + '",',
	          'description: "'
	             + js.stringEscape('"' + js.stringEscape(node.value) + '"')
	             + '"',
	          '}'
	        ].join(' '));
	
	        /*
	         * For case-sensitive strings the value must match the beginning of the
	         * remaining input exactly. As a result, we can use |ACCEPT_STRING| and
	         * save one |substr| call that would be needed if we used |ACCEPT_N|.
	         */
	        return buildCondition(
	          node.ignoreCase
	            ? [op.MATCH_STRING_IC, stringIndex]
	            : [op.MATCH_STRING, stringIndex],
	          node.ignoreCase
	            ? [op.ACCEPT_N, node.value.length]
	            : [op.ACCEPT_STRING, stringIndex],
	          [op.FAIL, expectedIndex]
	        );
	      } else {
	        stringIndex = addConst('""');
	
	        return [op.PUSH, stringIndex];
	      }
	    },
	
	    "class": function(node) {
	      var regexp, regexpIndex, expectedIndex;
	
	      if (node.parts.length > 0) {
	        regexp = '/^['
	          + (node.inverted ? '^' : '')
	          + arrays.map(node.parts, function(part) {
	              return part instanceof Array
	                ? js.regexpClassEscape(part[0])
	                  + '-'
	                  + js.regexpClassEscape(part[1])
	                : js.regexpClassEscape(part);
	            }).join('')
	          + ']/' + (node.ignoreCase ? 'i' : '');
	      } else {
	        /*
	         * IE considers regexps /[]/ and /[^]/ as syntactically invalid, so we
	         * translate them into euqivalents it can handle.
	         */
	        regexp = node.inverted ? '/^[\\S\\s]/' : '/^(?!)/';
	      }
	
	      regexpIndex   = addConst(regexp);
	      expectedIndex = addConst([
	        '{',
	        'type: "class",',
	        'value: "' + js.stringEscape(node.rawText) + '",',
	        'description: "' + js.stringEscape(node.rawText) + '"',
	        '}'
	      ].join(' '));
	
	      return buildCondition(
	        [op.MATCH_REGEXP, regexpIndex],
	        [op.ACCEPT_N, 1],
	        [op.FAIL, expectedIndex]
	      );
	    },
	
	    any: function() {
	      var expectedIndex = addConst('{ type: "any", description: "any character" }');
	
	      return buildCondition(
	        [op.MATCH_ANY],
	        [op.ACCEPT_N, 1],
	        [op.FAIL, expectedIndex]
	      );
	    }
	  });
	
	  generate(ast);
	}
	
	module.exports = generateBytecode;


/***/ },
/* 1331 */
/***/ function(module, exports) {

	"use strict";
	
	/* Bytecode instruction opcodes. */
	var opcodes = {
	  /* Stack Manipulation */
	
	  PUSH:             0,    // PUSH c
	  PUSH_UNDEFINED:   1,    // PUSH_UNDEFINED
	  PUSH_NULL:        2,    // PUSH_NULL
	  PUSH_FAILED:      3,    // PUSH_FAILED
	  PUSH_EMPTY_ARRAY: 4,    // PUSH_EMPTY_ARRAY
	  PUSH_CURR_POS:    5,    // PUSH_CURR_POS
	  POP:              6,    // POP
	  POP_CURR_POS:     7,    // POP_CURR_POS
	  POP_N:            8,    // POP_N n
	  NIP:              9,    // NIP
	  APPEND:           10,   // APPEND
	  WRAP:             11,   // WRAP n
	  TEXT:             12,   // TEXT
	
	  /* Conditions and Loops */
	
	  IF:               13,   // IF t, f
	  IF_ERROR:         14,   // IF_ERROR t, f
	  IF_NOT_ERROR:     15,   // IF_NOT_ERROR t, f
	  WHILE_NOT_ERROR:  16,   // WHILE_NOT_ERROR b
	
	  /* Matching */
	
	  MATCH_ANY:        17,   // MATCH_ANY a, f, ...
	  MATCH_STRING:     18,   // MATCH_STRING s, a, f, ...
	  MATCH_STRING_IC:  19,   // MATCH_STRING_IC s, a, f, ...
	  MATCH_REGEXP:     20,   // MATCH_REGEXP r, a, f, ...
	  ACCEPT_N:         21,   // ACCEPT_N n
	  ACCEPT_STRING:    22,   // ACCEPT_STRING s
	  FAIL:             23,   // FAIL e
	
	  /* Calls */
	
	  LOAD_SAVED_POS:   24,   // LOAD_SAVED_POS p
	  UPDATE_SAVED_POS: 25,   // UPDATE_SAVED_POS
	  CALL:             26,   // CALL f, n, pc, p1, p2, ..., pN
	
	  /* Rules */
	
	  RULE:             27,   // RULE r
	
	  /* Failure Reporting */
	
	  SILENT_FAILS_ON:  28,   // SILENT_FAILS_ON
	  SILENT_FAILS_OFF: 29    // SILENT_FAILS_OFF
	};
	
	module.exports = opcodes;


/***/ },
/* 1332 */
/***/ function(module, exports) {

	"use strict";
	
	function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	/* JavaScript code generation helpers. */
	var javascript = {
	  stringEscape: function(s) {
	    /*
	     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
	     * literal except for the closing quote character, backslash, carriage
	     * return, line separator, paragraph separator, and line feed. Any character
	     * may appear in the form of an escape sequence.
	     *
	     * For portability, we also escape all control and non-ASCII characters.
	     * Note that "\0" and "\v" escape sequences are not used because JSHint does
	     * not like the first and IE the second.
	     */
	    return s
	      .replace(/\\/g,   '\\\\')   // backslash
	      .replace(/"/g,    '\\"')    // closing double quote
	      .replace(/\x08/g, '\\b')    // backspace
	      .replace(/\t/g,   '\\t')    // horizontal tab
	      .replace(/\n/g,   '\\n')    // line feed
	      .replace(/\f/g,   '\\f')    // form feed
	      .replace(/\r/g,   '\\r')    // carriage return
	      .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	      .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	      .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	      .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	  },
	
	  regexpClassEscape: function(s) {
	    /*
	     * Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.
	     *
	     * For portability, we also escape all control and non-ASCII characters.
	     */
	    return s
	      .replace(/\\/g, '\\\\')    // backslash
	      .replace(/\//g, '\\/')     // closing slash
	      .replace(/\]/g, '\\]')     // closing bracket
	      .replace(/\^/g, '\\^')     // caret
	      .replace(/-/g,  '\\-')     // dash
	      .replace(/\0/g, '\\0')     // null
	      .replace(/\t/g, '\\t')     // horizontal tab
	      .replace(/\n/g, '\\n')     // line feed
	      .replace(/\v/g, '\\x0B')   // vertical tab
	      .replace(/\f/g, '\\f')     // form feed
	      .replace(/\r/g, '\\r')     // carriage return
	      .replace(/[\x00-\x08\x0E\x0F]/g,  function(ch) { return '\\x0' + hex(ch); })
	      .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) { return '\\x'  + hex(ch); })
	      .replace(/[\u0100-\u0FFF]/g,      function(ch) { return '\\u0' + hex(ch); })
	      .replace(/[\u1000-\uFFFF]/g,      function(ch) { return '\\u'  + hex(ch); });
	  }
	};
	
	module.exports = javascript;


/***/ },
/* 1333 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var arrays = __webpack_require__(1318),
	    asts   = __webpack_require__(1325),
	    op     = __webpack_require__(1331),
	    js     = __webpack_require__(1332);
	
	/* Generates parser JavaScript code. */
	function generateJavascript(ast, options) {
	  /* These only indent non-empty lines to avoid trailing whitespace. */
	  function indent2(code)  { return code.replace(/^(.+)$/gm, '  $1');         }
	  function indent4(code)  { return code.replace(/^(.+)$/gm, '    $1');       }
	  function indent8(code)  { return code.replace(/^(.+)$/gm, '        $1');   }
	  function indent10(code) { return code.replace(/^(.+)$/gm, '          $1'); }
	
	  function generateTables() {
	    if (options.optimize === "size") {
	      return [
	        'peg$consts = [',
	           indent2(ast.consts.join(',\n')),
	        '],',
	        '',
	        'peg$bytecode = [',
	           indent2(arrays.map(ast.rules, function(rule) {
	             return 'peg$decode("'
	                   + js.stringEscape(arrays.map(
	                       rule.bytecode,
	                       function(b) { return String.fromCharCode(b + 32); }
	                     ).join(''))
	                   + '")';
	           }).join(',\n')),
	        '],'
	      ].join('\n');
	    } else {
	      return arrays.map(
	        ast.consts,
	        function(c, i) { return 'peg$c' + i + ' = ' + c + ','; }
	      ).join('\n');
	    }
	  }
	
	  function generateRuleHeader(ruleNameCode, ruleIndexCode) {
	    var parts = [];
	
	    parts.push('');
	
	    if (options.trace) {
	      parts.push([
	        'peg$tracer.trace({',
	        '  type:     "rule.enter",',
	        '  rule:     ' + ruleNameCode + ',',
	        '  location: peg$computeLocation(startPos, startPos)',
	        '});',
	        ''
	      ].join('\n'));
	    }
	
	    if (options.cache) {
	      parts.push([
	        'var key    = peg$currPos * ' + ast.rules.length + ' + ' + ruleIndexCode + ',',
	        '    cached = peg$resultsCache[key];',
	        '',
	        'if (cached) {',
	        '  peg$currPos = cached.nextPos;',
	        '',
	      ].join('\n'));
	
	      if (options.trace) {
	        parts.push([
	          'if (cached.result !== peg$FAILED) {',
	          '  peg$tracer.trace({',
	          '    type:   "rule.match",',
	          '    rule:   ' + ruleNameCode + ',',
	          '    result: cached.result,',
	          '    location: peg$computeLocation(startPos, peg$currPos)',
	          '  });',
	          '} else {',
	          '  peg$tracer.trace({',
	          '    type: "rule.fail",',
	          '    rule: ' + ruleNameCode + ',',
	          '    location: peg$computeLocation(startPos, startPos)',
	          '  });',
	          '}',
	          ''
	        ].join('\n'));
	      }
	
	      parts.push([
	        '  return cached.result;',
	        '}',
	        ''
	      ].join('\n'));
	    }
	
	    return parts.join('\n');
	  }
	
	  function generateRuleFooter(ruleNameCode, resultCode) {
	    var parts = [];
	
	    if (options.cache) {
	      parts.push([
	        '',
	        'peg$resultsCache[key] = { nextPos: peg$currPos, result: ' + resultCode + ' };'
	      ].join('\n'));
	    }
	
	    if (options.trace) {
	      parts.push([
	          '',
	          'if (' + resultCode + ' !== peg$FAILED) {',
	          '  peg$tracer.trace({',
	          '    type:   "rule.match",',
	          '    rule:   ' + ruleNameCode + ',',
	          '    result: ' + resultCode + ',',
	          '    location: peg$computeLocation(startPos, peg$currPos)',
	          '  });',
	          '} else {',
	          '  peg$tracer.trace({',
	          '    type: "rule.fail",',
	          '    rule: ' + ruleNameCode + ',',
	          '    location: peg$computeLocation(startPos, startPos)',
	          '  });',
	          '}'
	      ].join('\n'));
	    }
	
	    parts.push([
	      '',
	      'return ' + resultCode + ';'
	    ].join('\n'));
	
	    return parts.join('\n');
	  }
	
	  function generateInterpreter() {
	    var parts = [];
	
	    function generateCondition(cond, argsLength) {
	      var baseLength      = argsLength + 3,
	          thenLengthCode = 'bc[ip + ' + (baseLength - 2) + ']',
	          elseLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';
	
	      return [
	        'ends.push(end);',
	        'ips.push(ip + ' + baseLength + ' + ' + thenLengthCode + ' + ' + elseLengthCode + ');',
	        '',
	        'if (' + cond + ') {',
	        '  end = ip + ' + baseLength + ' + ' + thenLengthCode + ';',
	        '  ip += ' + baseLength + ';',
	        '} else {',
	        '  end = ip + ' + baseLength + ' + ' + thenLengthCode + ' + ' + elseLengthCode + ';',
	        '  ip += ' + baseLength + ' + ' + thenLengthCode + ';',
	        '}',
	        '',
	        'break;'
	      ].join('\n');
	    }
	
	    function generateLoop(cond) {
	      var baseLength     = 2,
	          bodyLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';
	
	      return [
	        'if (' + cond + ') {',
	        '  ends.push(end);',
	        '  ips.push(ip);',
	        '',
	        '  end = ip + ' + baseLength + ' + ' + bodyLengthCode + ';',
	        '  ip += ' + baseLength + ';',
	        '} else {',
	        '  ip += ' + baseLength + ' + ' + bodyLengthCode + ';',
	        '}',
	        '',
	        'break;'
	      ].join('\n');
	    }
	
	    function generateCall() {
	      var baseLength       = 4,
	          paramsLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';
	
	      return [
	        'params = bc.slice(ip + ' + baseLength + ', ip + ' + baseLength + ' + ' + paramsLengthCode + ');',
	        'for (i = 0; i < ' + paramsLengthCode + '; i++) {',
	        '  params[i] = stack[stack.length - 1 - params[i]];',
	        '}',
	        '',
	        'stack.splice(',
	        '  stack.length - bc[ip + 2],',
	        '  bc[ip + 2],',
	        '  peg$consts[bc[ip + 1]].apply(null, params)',
	        ');',
	        '',
	        'ip += ' + baseLength + ' + ' + paramsLengthCode + ';',
	        'break;'
	      ].join('\n');
	    }
	
	    parts.push([
	      'function peg$decode(s) {',
	      '  var bc = new Array(s.length), i;',
	      '',
	      '  for (i = 0; i < s.length; i++) {',
	      '    bc[i] = s.charCodeAt(i) - 32;',
	      '  }',
	      '',
	      '  return bc;',
	      '}',
	      '',
	      'function peg$parseRule(index) {',
	    ].join('\n'));
	
	    if (options.trace) {
	      parts.push([
	        '  var bc       = peg$bytecode[index],',
	        '      ip       = 0,',
	        '      ips      = [],',
	        '      end      = bc.length,',
	        '      ends     = [],',
	        '      stack    = [],',
	        '      startPos = peg$currPos,',
	        '      params, i;',
	      ].join('\n'));
	    } else {
	      parts.push([
	        '  var bc    = peg$bytecode[index],',
	        '      ip    = 0,',
	        '      ips   = [],',
	        '      end   = bc.length,',
	        '      ends  = [],',
	        '      stack = [],',
	        '      params, i;',
	      ].join('\n'));
	    }
	
	    parts.push(indent2(generateRuleHeader('peg$ruleNames[index]', 'index')));
	
	    parts.push([
	      /*
	       * The point of the outer loop and the |ips| & |ends| stacks is to avoid
	       * recursive calls for interpreting parts of bytecode. In other words, we
	       * implement the |interpret| operation of the abstract machine without
	       * function calls. Such calls would likely slow the parser down and more
	       * importantly cause stack overflows for complex grammars.
	       */
	      '  while (true) {',
	      '    while (ip < end) {',
	      '      switch (bc[ip]) {',
	      '        case ' + op.PUSH + ':',               // PUSH c
	      '          stack.push(peg$consts[bc[ip + 1]]);',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.PUSH_UNDEFINED + ':',     // PUSH_UNDEFINED
	      '          stack.push(void 0);',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.PUSH_NULL + ':',          // PUSH_NULL
	      '          stack.push(null);',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.PUSH_FAILED + ':',        // PUSH_FAILED
	      '          stack.push(peg$FAILED);',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.PUSH_EMPTY_ARRAY + ':',   // PUSH_EMPTY_ARRAY
	      '          stack.push([]);',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.PUSH_CURR_POS + ':',      // PUSH_CURR_POS
	      '          stack.push(peg$currPos);',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.POP + ':',                // POP
	      '          stack.pop();',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.POP_CURR_POS + ':',       // POP_CURR_POS
	      '          peg$currPos = stack.pop();',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.POP_N + ':',              // POP_N n
	      '          stack.length -= bc[ip + 1];',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.NIP + ':',                // NIP
	      '          stack.splice(-2, 1);',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.APPEND + ':',             // APPEND
	      '          stack[stack.length - 2].push(stack.pop());',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.WRAP + ':',               // WRAP n
	      '          stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.TEXT + ':',               // TEXT
	      '          stack.push(input.substring(stack.pop(), peg$currPos));',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.IF + ':',                 // IF t, f
	                 indent10(generateCondition('stack[stack.length - 1]', 0)),
	      '',
	      '        case ' + op.IF_ERROR + ':',           // IF_ERROR t, f
	                 indent10(generateCondition(
	                   'stack[stack.length - 1] === peg$FAILED',
	                   0
	                 )),
	      '',
	      '        case ' + op.IF_NOT_ERROR + ':',       // IF_NOT_ERROR t, f
	                 indent10(
	                   generateCondition('stack[stack.length - 1] !== peg$FAILED',
	                   0
	                 )),
	      '',
	      '        case ' + op.WHILE_NOT_ERROR + ':',    // WHILE_NOT_ERROR b
	                 indent10(generateLoop('stack[stack.length - 1] !== peg$FAILED')),
	      '',
	      '        case ' + op.MATCH_ANY + ':',          // MATCH_ANY a, f, ...
	                 indent10(generateCondition('input.length > peg$currPos', 0)),
	      '',
	      '        case ' + op.MATCH_STRING + ':',       // MATCH_STRING s, a, f, ...
	                 indent10(generateCondition(
	                   'input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]',
	                   1
	                 )),
	      '',
	      '        case ' + op.MATCH_STRING_IC + ':',    // MATCH_STRING_IC s, a, f, ...
	                 indent10(generateCondition(
	                   'input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]',
	                   1
	                 )),
	      '',
	      '        case ' + op.MATCH_REGEXP + ':',       // MATCH_REGEXP r, a, f, ...
	                 indent10(generateCondition(
	                   'peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))',
	                   1
	                 )),
	      '',
	      '        case ' + op.ACCEPT_N + ':',           // ACCEPT_N n
	      '          stack.push(input.substr(peg$currPos, bc[ip + 1]));',
	      '          peg$currPos += bc[ip + 1];',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.ACCEPT_STRING + ':',      // ACCEPT_STRING s
	      '          stack.push(peg$consts[bc[ip + 1]]);',
	      '          peg$currPos += peg$consts[bc[ip + 1]].length;',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.FAIL + ':',               // FAIL e
	      '          stack.push(peg$FAILED);',
	      '          if (peg$silentFails === 0) {',
	      '            peg$fail(peg$consts[bc[ip + 1]]);',
	      '          }',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.LOAD_SAVED_POS + ':',     // LOAD_SAVED_POS p
	      '          peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.UPDATE_SAVED_POS + ':',   // UPDATE_SAVED_POS
	      '          peg$savedPos = peg$currPos;',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.CALL + ':',               // CALL f, n, pc, p1, p2, ..., pN
	                 indent10(generateCall()),
	      '',
	      '        case ' + op.RULE + ':',               // RULE r
	      '          stack.push(peg$parseRule(bc[ip + 1]));',
	      '          ip += 2;',
	      '          break;',
	      '',
	      '        case ' + op.SILENT_FAILS_ON + ':',    // SILENT_FAILS_ON
	      '          peg$silentFails++;',
	      '          ip++;',
	      '          break;',
	      '',
	      '        case ' + op.SILENT_FAILS_OFF + ':',   // SILENT_FAILS_OFF
	      '          peg$silentFails--;',
	      '          ip++;',
	      '          break;',
	      '',
	      '        default:',
	      '          throw new Error("Invalid opcode: " + bc[ip] + ".");',
	      '      }',
	      '    }',
	      '',
	      '    if (ends.length > 0) {',
	      '      end = ends.pop();',
	      '      ip = ips.pop();',
	      '    } else {',
	      '      break;',
	      '    }',
	      '  }'
	    ].join('\n'));
	
	    parts.push(indent2(generateRuleFooter('peg$ruleNames[index]', 'stack[0]')));
	    parts.push('}');
	
	    return parts.join('\n');
	  }
	
	  function generateRuleFunction(rule) {
	    var parts = [], code;
	
	    function c(i) { return "peg$c" + i; } // |consts[i]| of the abstract machine
	    function s(i) { return "s"     + i; } // |stack[i]| of the abstract machine
	
	    var stack = {
	          sp:    -1,
	          maxSp: -1,
	
	          push: function(exprCode) {
	            var code = s(++this.sp) + ' = ' + exprCode + ';';
	
	            if (this.sp > this.maxSp) { this.maxSp = this.sp; }
	
	            return code;
	          },
	
	          pop: function() {
	            var n, values;
	
	            if (arguments.length === 0) {
	              return s(this.sp--);
	            } else {
	              n = arguments[0];
	              values = arrays.map(arrays.range(this.sp - n + 1, this.sp + 1), s);
	              this.sp -= n;
	
	              return values;
	            }
	          },
	
	          top: function() {
	            return s(this.sp);
	          },
	
	          index: function(i) {
	            return s(this.sp - i);
	          }
	        };
	
	    function compile(bc) {
	      var ip    = 0,
	          end   = bc.length,
	          parts = [],
	          value;
	
	      function compileCondition(cond, argCount) {
	        var baseLength = argCount + 3,
	            thenLength = bc[ip + baseLength - 2],
	            elseLength = bc[ip + baseLength - 1],
	            baseSp     = stack.sp,
	            thenCode, elseCode, thenSp, elseSp;
	
	        ip += baseLength;
	        thenCode = compile(bc.slice(ip, ip + thenLength));
	        thenSp = stack.sp;
	        ip += thenLength;
	
	        if (elseLength > 0) {
	          stack.sp = baseSp;
	          elseCode = compile(bc.slice(ip, ip + elseLength));
	          elseSp = stack.sp;
	          ip += elseLength;
	
	          if (thenSp !== elseSp) {
	            throw new Error(
	              "Branches of a condition must move the stack pointer in the same way."
	            );
	          }
	        }
	
	        parts.push('if (' + cond + ') {');
	        parts.push(indent2(thenCode));
	        if (elseLength > 0) {
	          parts.push('} else {');
	          parts.push(indent2(elseCode));
	        }
	        parts.push('}');
	      }
	
	      function compileLoop(cond) {
	        var baseLength = 2,
	            bodyLength = bc[ip + baseLength - 1],
	            baseSp     = stack.sp,
	            bodyCode, bodySp;
	
	        ip += baseLength;
	        bodyCode = compile(bc.slice(ip, ip + bodyLength));
	        bodySp = stack.sp;
	        ip += bodyLength;
	
	        if (bodySp !== baseSp) {
	          throw new Error("Body of a loop can't move the stack pointer.");
	        }
	
	        parts.push('while (' + cond + ') {');
	        parts.push(indent2(bodyCode));
	        parts.push('}');
	      }
	
	      function compileCall() {
	        var baseLength   = 4,
	            paramsLength = bc[ip + baseLength - 1];
	
	        var value = c(bc[ip + 1]) + '('
	              + arrays.map(
	                  bc.slice(ip + baseLength, ip + baseLength + paramsLength),
	                  function(p) { return stack.index(p); }
	                ).join(', ')
	              + ')';
	        stack.pop(bc[ip + 2]);
	        parts.push(stack.push(value));
	        ip += baseLength + paramsLength;
	      }
	
	      while (ip < end) {
	        switch (bc[ip]) {
	          case op.PUSH:               // PUSH c
	            parts.push(stack.push(c(bc[ip + 1])));
	            ip += 2;
	            break;
	
	          case op.PUSH_CURR_POS:      // PUSH_CURR_POS
	            parts.push(stack.push('peg$currPos'));
	            ip++;
	            break;
	
	          case op.PUSH_UNDEFINED:      // PUSH_UNDEFINED
	            parts.push(stack.push('void 0'));
	            ip++;
	            break;
	
	          case op.PUSH_NULL:          // PUSH_NULL
	            parts.push(stack.push('null'));
	            ip++;
	            break;
	
	          case op.PUSH_FAILED:        // PUSH_FAILED
	            parts.push(stack.push('peg$FAILED'));
	            ip++;
	            break;
	
	          case op.PUSH_EMPTY_ARRAY:   // PUSH_EMPTY_ARRAY
	            parts.push(stack.push('[]'));
	            ip++;
	            break;
	
	          case op.POP:                // POP
	            stack.pop();
	            ip++;
	            break;
	
	          case op.POP_CURR_POS:       // POP_CURR_POS
	            parts.push('peg$currPos = ' + stack.pop() + ';');
	            ip++;
	            break;
	
	          case op.POP_N:              // POP_N n
	            stack.pop(bc[ip + 1]);
	            ip += 2;
	            break;
	
	          case op.NIP:                // NIP
	            value = stack.pop();
	            stack.pop();
	            parts.push(stack.push(value));
	            ip++;
	            break;
	
	          case op.APPEND:             // APPEND
	            value = stack.pop();
	            parts.push(stack.top() + '.push(' + value + ');');
	            ip++;
	            break;
	
	          case op.WRAP:               // WRAP n
	            parts.push(
	              stack.push('[' + stack.pop(bc[ip + 1]).join(', ') + ']')
	            );
	            ip += 2;
	            break;
	
	          case op.TEXT:               // TEXT
	            parts.push(
	              stack.push('input.substring(' + stack.pop() + ', peg$currPos)')
	            );
	            ip++;
	            break;
	
	          case op.IF:                 // IF t, f
	            compileCondition(stack.top(), 0);
	            break;
	
	          case op.IF_ERROR:           // IF_ERROR t, f
	            compileCondition(stack.top() + ' === peg$FAILED', 0);
	            break;
	
	          case op.IF_NOT_ERROR:       // IF_NOT_ERROR t, f
	            compileCondition(stack.top() + ' !== peg$FAILED', 0);
	            break;
	
	          case op.WHILE_NOT_ERROR:    // WHILE_NOT_ERROR b
	            compileLoop(stack.top() + ' !== peg$FAILED', 0);
	            break;
	
	          case op.MATCH_ANY:          // MATCH_ANY a, f, ...
	            compileCondition('input.length > peg$currPos', 0);
	            break;
	
	          case op.MATCH_STRING:       // MATCH_STRING s, a, f, ...
	            compileCondition(
	              eval(ast.consts[bc[ip + 1]]).length > 1
	                ? 'input.substr(peg$currPos, '
	                    + eval(ast.consts[bc[ip + 1]]).length
	                    + ') === '
	                    + c(bc[ip + 1])
	                : 'input.charCodeAt(peg$currPos) === '
	                    + eval(ast.consts[bc[ip + 1]]).charCodeAt(0),
	              1
	            );
	            break;
	
	          case op.MATCH_STRING_IC:    // MATCH_STRING_IC s, a, f, ...
	            compileCondition(
	              'input.substr(peg$currPos, '
	                + eval(ast.consts[bc[ip + 1]]).length
	                + ').toLowerCase() === '
	                + c(bc[ip + 1]),
	              1
	            );
	            break;
	
	          case op.MATCH_REGEXP:       // MATCH_REGEXP r, a, f, ...
	            compileCondition(
	              c(bc[ip + 1]) + '.test(input.charAt(peg$currPos))',
	              1
	            );
	            break;
	
	          case op.ACCEPT_N:           // ACCEPT_N n
	            parts.push(stack.push(
	              bc[ip + 1] > 1
	                ? 'input.substr(peg$currPos, ' + bc[ip + 1] + ')'
	                : 'input.charAt(peg$currPos)'
	            ));
	            parts.push(
	              bc[ip + 1] > 1
	                ? 'peg$currPos += ' + bc[ip + 1] + ';'
	                : 'peg$currPos++;'
	            );
	            ip += 2;
	            break;
	
	          case op.ACCEPT_STRING:      // ACCEPT_STRING s
	            parts.push(stack.push(c(bc[ip + 1])));
	            parts.push(
	              eval(ast.consts[bc[ip + 1]]).length > 1
	                ? 'peg$currPos += ' + eval(ast.consts[bc[ip + 1]]).length + ';'
	                : 'peg$currPos++;'
	            );
	            ip += 2;
	            break;
	
	          case op.FAIL:               // FAIL e
	            parts.push(stack.push('peg$FAILED'));
	            parts.push('if (peg$silentFails === 0) { peg$fail(' + c(bc[ip + 1]) + '); }');
	            ip += 2;
	            break;
	
	          case op.LOAD_SAVED_POS:     // LOAD_SAVED_POS p
	            parts.push('peg$savedPos = ' + stack.index(bc[ip + 1]) + ';');
	            ip += 2;
	            break;
	
	          case op.UPDATE_SAVED_POS:   // UPDATE_SAVED_POS
	            parts.push('peg$savedPos = peg$currPos;');
	            ip++;
	            break;
	
	          case op.CALL:               // CALL f, n, pc, p1, p2, ..., pN
	            compileCall();
	            break;
	
	          case op.RULE:               // RULE r
	            parts.push(stack.push("peg$parse" + ast.rules[bc[ip + 1]].name + "()"));
	            ip += 2;
	            break;
	
	          case op.SILENT_FAILS_ON:    // SILENT_FAILS_ON
	            parts.push('peg$silentFails++;');
	            ip++;
	            break;
	
	          case op.SILENT_FAILS_OFF:   // SILENT_FAILS_OFF
	            parts.push('peg$silentFails--;');
	            ip++;
	            break;
	
	          default:
	            throw new Error("Invalid opcode: " + bc[ip] + ".");
	        }
	      }
	
	      return parts.join('\n');
	    }
	
	    code = compile(rule.bytecode);
	
	    parts.push('function peg$parse' + rule.name + '() {');
	
	    if (options.trace) {
	      parts.push([
	        '  var ' + arrays.map(arrays.range(0, stack.maxSp + 1), s).join(', ') + ',',
	        '      startPos = peg$currPos;'
	      ].join('\n'));
	    } else {
	      parts.push(
	        '  var ' + arrays.map(arrays.range(0, stack.maxSp + 1), s).join(', ') + ';'
	      );
	    }
	
	    parts.push(indent2(generateRuleHeader(
	      '"' + js.stringEscape(rule.name) + '"',
	      asts.indexOfRule(ast, rule.name)
	    )));
	    parts.push(indent2(code));
	    parts.push(indent2(generateRuleFooter(
	      '"' + js.stringEscape(rule.name) + '"',
	      s(0)
	    )));
	
	    parts.push('}');
	
	    return parts.join('\n');
	  }
	
	  var parts = [],
	      startRuleIndices,   startRuleIndex,
	      startRuleFunctions, startRuleFunction,
	      ruleNames;
	
	  parts.push([
	    '(function() {',
	    '  "use strict";',
	    '',
	    '  /*',
	    '   * Generated by PEG.js 0.9.0.',
	    '   *',
	    '   * http://pegjs.org/',
	    '   */',
	    '',
	    '  function peg$subclass(child, parent) {',
	    '    function ctor() { this.constructor = child; }',
	    '    ctor.prototype = parent.prototype;',
	    '    child.prototype = new ctor();',
	    '  }',
	    '',
	    '  function peg$SyntaxError(message, expected, found, location) {',
	    '    this.message  = message;',
	    '    this.expected = expected;',
	    '    this.found    = found;',
	    '    this.location = location;',
	    '    this.name     = "SyntaxError";',
	    '',
	    '    if (typeof Error.captureStackTrace === "function") {',
	    '      Error.captureStackTrace(this, peg$SyntaxError);',
	    '    }',
	    '  }',
	    '',
	    '  peg$subclass(peg$SyntaxError, Error);',
	    ''
	  ].join('\n'));
	
	  if (options.trace) {
	    parts.push([
	      '  function peg$DefaultTracer() {',
	      '    this.indentLevel = 0;',
	      '  }',
	      '',
	      '  peg$DefaultTracer.prototype.trace = function(event) {',
	      '    var that = this;',
	      '',
	      '    function log(event) {',
	      '      function repeat(string, n) {',
	      '         var result = "", i;',
	      '',
	      '         for (i = 0; i < n; i++) {',
	      '           result += string;',
	      '         }',
	      '',
	      '         return result;',
	      '      }',
	      '',
	      '      function pad(string, length) {',
	      '        return string + repeat(" ", length - string.length);',
	      '      }',
	      '',
	      '      if (typeof console === "object") {',   // IE 8-10
	      '        console.log(',
	      '          event.location.start.line + ":" + event.location.start.column + "-"',
	      '            + event.location.end.line + ":" + event.location.end.column + " "',
	      '            + pad(event.type, 10) + " "',
	      '            + repeat("  ", that.indentLevel) + event.rule',
	      '        );',
	      '      }',
	      '    }',
	      '',
	      '    switch (event.type) {',
	      '      case "rule.enter":',
	      '        log(event);',
	      '        this.indentLevel++;',
	      '        break;',
	      '',
	      '      case "rule.match":',
	      '        this.indentLevel--;',
	      '        log(event);',
	      '        break;',
	      '',
	      '      case "rule.fail":',
	      '        this.indentLevel--;',
	      '        log(event);',
	      '        break;',
	      '',
	      '      default:',
	      '        throw new Error("Invalid event type: " + event.type + ".");',
	      '    }',
	      '  };',
	      ''
	    ].join('\n'));
	  }
	
	  parts.push([
	    '  function peg$parse(input) {',
	    '    var options = arguments.length > 1 ? arguments[1] : {},',
	    '        parser  = this,',
	    '',
	    '        peg$FAILED = {},',
	    ''
	  ].join('\n'));
	
	  if (options.optimize === "size") {
	    startRuleIndices = '{ '
	                     + arrays.map(
	                         options.allowedStartRules,
	                         function(r) { return r + ': ' + asts.indexOfRule(ast, r); }
	                       ).join(', ')
	                     + ' }';
	    startRuleIndex = asts.indexOfRule(ast, options.allowedStartRules[0]);
	
	    parts.push([
	      '        peg$startRuleIndices = ' + startRuleIndices + ',',
	      '        peg$startRuleIndex   = ' + startRuleIndex + ','
	    ].join('\n'));
	  } else {
	    startRuleFunctions = '{ '
	                     + arrays.map(
	                         options.allowedStartRules,
	                         function(r) { return r + ': peg$parse' + r; }
	                       ).join(', ')
	                     + ' }';
	    startRuleFunction = 'peg$parse' + options.allowedStartRules[0];
	
	    parts.push([
	      '        peg$startRuleFunctions = ' + startRuleFunctions + ',',
	      '        peg$startRuleFunction  = ' + startRuleFunction + ','
	    ].join('\n'));
	  }
	
	  parts.push('');
	
	  parts.push(indent8(generateTables()));
	
	  parts.push([
	    '',
	    '        peg$currPos          = 0,',
	    '        peg$savedPos         = 0,',
	    '        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],',
	    '        peg$maxFailPos       = 0,',
	    '        peg$maxFailExpected  = [],',
	    '        peg$silentFails      = 0,',   // 0 = report failures, > 0 = silence failures
	    ''
	  ].join('\n'));
	
	  if (options.cache) {
	    parts.push([
	      '        peg$resultsCache = {},',
	      ''
	    ].join('\n'));
	  }
	
	  if (options.trace) {
	    if (options.optimize === "size") {
	      ruleNames = '['
	                + arrays.map(
	                    ast.rules,
	                    function(r) { return '"' + js.stringEscape(r.name) + '"'; }
	                  ).join(', ')
	                + ']';
	
	      parts.push([
	        '        peg$ruleNames = ' + ruleNames + ',',
	        ''
	      ].join('\n'));
	    }
	
	    parts.push([
	      '        peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer(),',
	      ''
	    ].join('\n'));
	  }
	
	  parts.push([
	    '        peg$result;',
	    ''
	  ].join('\n'));
	
	  if (options.optimize === "size") {
	    parts.push([
	      '    if ("startRule" in options) {',
	      '      if (!(options.startRule in peg$startRuleIndices)) {',
	      '        throw new Error("Can\'t start parsing from rule \\"" + options.startRule + "\\".");',
	      '      }',
	      '',
	      '      peg$startRuleIndex = peg$startRuleIndices[options.startRule];',
	      '    }'
	    ].join('\n'));
	  } else {
	    parts.push([
	      '    if ("startRule" in options) {',
	      '      if (!(options.startRule in peg$startRuleFunctions)) {',
	      '        throw new Error("Can\'t start parsing from rule \\"" + options.startRule + "\\".");',
	      '      }',
	      '',
	      '      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];',
	      '    }'
	    ].join('\n'));
	  }
	
	  parts.push([
	    '',
	    '    function text() {',
	    '      return input.substring(peg$savedPos, peg$currPos);',
	    '    }',
	    '',
	    '    function location() {',
	    '      return peg$computeLocation(peg$savedPos, peg$currPos);',
	    '    }',
	    '',
	    '    function expected(description) {',
	    '      throw peg$buildException(',
	    '        null,',
	    '        [{ type: "other", description: description }],',
	    '        input.substring(peg$savedPos, peg$currPos),',
	    '        peg$computeLocation(peg$savedPos, peg$currPos)',
	    '      );',
	    '    }',
	    '',
	    '    function error(message) {',
	    '      throw peg$buildException(',
	    '        message,',
	    '        null,',
	    '        input.substring(peg$savedPos, peg$currPos),',
	    '        peg$computeLocation(peg$savedPos, peg$currPos)',
	    '      );',
	    '    }',
	    '',
	    '    function peg$computePosDetails(pos) {',
	    '      var details = peg$posDetailsCache[pos],',
	    '          p, ch;',
	    '',
	    '      if (details) {',
	    '        return details;',
	    '      } else {',
	    '        p = pos - 1;',
	    '        while (!peg$posDetailsCache[p]) {',
	    '          p--;',
	    '        }',
	    '',
	    '        details = peg$posDetailsCache[p];',
	    '        details = {',
	    '          line:   details.line,',
	    '          column: details.column,',
	    '          seenCR: details.seenCR',
	    '        };',
	    '',
	    '        while (p < pos) {',
	    '          ch = input.charAt(p);',
	    '          if (ch === "\\n") {',
	    '            if (!details.seenCR) { details.line++; }',
	    '            details.column = 1;',
	    '            details.seenCR = false;',
	    '          } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
	    '            details.line++;',
	    '            details.column = 1;',
	    '            details.seenCR = true;',
	    '          } else {',
	    '            details.column++;',
	    '            details.seenCR = false;',
	    '          }',
	    '',
	    '          p++;',
	    '        }',
	    '',
	    '        peg$posDetailsCache[pos] = details;',
	    '        return details;',
	    '      }',
	    '    }',
	    '',
	    '    function peg$computeLocation(startPos, endPos) {',
	    '      var startPosDetails = peg$computePosDetails(startPos),',
	    '          endPosDetails   = peg$computePosDetails(endPos);',
	    '',
	    '      return {',
	    '        start: {',
	    '          offset: startPos,',
	    '          line:   startPosDetails.line,',
	    '          column: startPosDetails.column',
	    '        },',
	    '        end: {',
	    '          offset: endPos,',
	    '          line:   endPosDetails.line,',
	    '          column: endPosDetails.column',
	    '        }',
	    '      };',
	    '    }',
	    '',
	    '    function peg$fail(expected) {',
	    '      if (peg$currPos < peg$maxFailPos) { return; }',
	    '',
	    '      if (peg$currPos > peg$maxFailPos) {',
	    '        peg$maxFailPos = peg$currPos;',
	    '        peg$maxFailExpected = [];',
	    '      }',
	    '',
	    '      peg$maxFailExpected.push(expected);',
	    '    }',
	    '',
	    '    function peg$buildException(message, expected, found, location) {',
	    '      function cleanupExpected(expected) {',
	    '        var i = 1;',
	    '',
	    '        expected.sort(function(a, b) {',
	    '          if (a.description < b.description) {',
	    '            return -1;',
	    '          } else if (a.description > b.description) {',
	    '            return 1;',
	    '          } else {',
	    '            return 0;',
	    '          }',
	    '        });',
	    '',
	    /*
	     * This works because the bytecode generator guarantees that every
	     * expectation object exists only once, so it's enough to use |===| instead
	     * of deeper structural comparison.
	     */
	    '        while (i < expected.length) {',
	    '          if (expected[i - 1] === expected[i]) {',
	    '            expected.splice(i, 1);',
	    '          } else {',
	    '            i++;',
	    '          }',
	    '        }',
	    '      }',
	    '',
	    '      function buildMessage(expected, found) {',
	    '        function stringEscape(s) {',
	    '          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }',
	    '',
	    /*
	     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
	     * literal except for the closing quote character, backslash, carriage
	     * return, line separator, paragraph separator, and line feed. Any character
	     * may appear in the form of an escape sequence.
	     *
	     * For portability, we also escape all control and non-ASCII characters.
	     * Note that "\0" and "\v" escape sequences are not used because JSHint does
	     * not like the first and IE the second.
	     */
	    '          return s',
	    '            .replace(/\\\\/g,   \'\\\\\\\\\')',   // backslash
	    '            .replace(/"/g,    \'\\\\"\')',        // closing double quote
	    '            .replace(/\\x08/g, \'\\\\b\')',       // backspace
	    '            .replace(/\\t/g,   \'\\\\t\')',       // horizontal tab
	    '            .replace(/\\n/g,   \'\\\\n\')',       // line feed
	    '            .replace(/\\f/g,   \'\\\\f\')',       // form feed
	    '            .replace(/\\r/g,   \'\\\\r\')',       // carriage return
	    '            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return \'\\\\x0\' + hex(ch); })',
	    '            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return \'\\\\x\'  + hex(ch); })',
	    '            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return \'\\\\u0\' + hex(ch); })',
	    '            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return \'\\\\u\'  + hex(ch); });',
	    '        }',
	    '',
	    '        var expectedDescs = new Array(expected.length),',
	    '            expectedDesc, foundDesc, i;',
	    '',
	    '        for (i = 0; i < expected.length; i++) {',
	    '          expectedDescs[i] = expected[i].description;',
	    '        }',
	    '',
	    '        expectedDesc = expected.length > 1',
	    '          ? expectedDescs.slice(0, -1).join(", ")',
	    '              + " or "',
	    '              + expectedDescs[expected.length - 1]',
	    '          : expectedDescs[0];',
	    '',
	    '        foundDesc = found ? "\\"" + stringEscape(found) + "\\"" : "end of input";',
	    '',
	    '        return "Expected " + expectedDesc + " but " + foundDesc + " found.";',
	    '      }',
	    '',
	    '      if (expected !== null) {',
	    '        cleanupExpected(expected);',
	    '      }',
	    '',
	    '      return new peg$SyntaxError(',
	    '        message !== null ? message : buildMessage(expected, found),',
	    '        expected,',
	    '        found,',
	    '        location',
	    '      );',
	    '    }',
	    ''
	  ].join('\n'));
	
	  if (options.optimize === "size") {
	    parts.push(indent4(generateInterpreter()));
	    parts.push('');
	  } else {
	    arrays.each(ast.rules, function(rule) {
	      parts.push(indent4(generateRuleFunction(rule)));
	      parts.push('');
	    });
	  }
	
	  if (ast.initializer) {
	    parts.push(indent4(ast.initializer.code));
	    parts.push('');
	  }
	
	  if (options.optimize === "size") {
	    parts.push('    peg$result = peg$parseRule(peg$startRuleIndex);');
	  } else {
	    parts.push('    peg$result = peg$startRuleFunction();');
	  }
	
	  parts.push([
	    '',
	    '    if (peg$result !== peg$FAILED && peg$currPos === input.length) {',
	    '      return peg$result;',
	    '    } else {',
	    '      if (peg$result !== peg$FAILED && peg$currPos < input.length) {',
	    '        peg$fail({ type: "end", description: "end of input" });',
	    '      }',
	    '',
	    '      throw peg$buildException(',
	    '        null,',
	    '        peg$maxFailExpected,',
	    '        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,',
	    '        peg$maxFailPos < input.length',
	    '          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)',
	    '          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)',
	    '      );',
	    '    }',
	    '  }',
	    '',
	    '  return {'
	  ].join('\n'));
	
	  if (options.trace) {
	    parts.push([
	      '    SyntaxError:   peg$SyntaxError,',
	      '    DefaultTracer: peg$DefaultTracer,',
	      '    parse:         peg$parse'
	    ].join('\n'));
	  } else {
	    parts.push([
	      '    SyntaxError: peg$SyntaxError,',
	      '    parse:       peg$parse'
	    ].join('\n'));
	  }
	
	  parts.push([
	    '  };',
	    '})()'
	  ].join('\n'));
	
	  ast.code = parts.join('\n');
	}
	
	module.exports = generateJavascript;


/***/ },
/* 1334 */
/***/ function(module, exports) {

	module.exports = "<div class=\"suggestions\" ng-show=\"suggestions.show\">\n  <div class=\"suggestion\"\n    ng-click=\"completeExpression($index)\"\n    ng-class=\"{active: $index === suggestions.selected}\"\n    ng-repeat=\"suggestion in suggestions.list track by $index | orderBy:'name'\">\n    <h4>\n      <strong>.{{suggestion.name}}()</strong>\n      <small>\n        {{suggestion.help}}\n        {{suggestion.chainable ? '(Chainable)' : '(Data Source)'}}\n      </small>\n    </h4>\n\n    <div ng-show=\"suggestion.args.length > (suggestion.chainable ? 1: 0)\">\n      <div ng-show=\"suggestions.list.length > 1\">\n        <strong>Arguments:</strong>\n        <span ng-repeat=\"arg in suggestion.args\" ng-hide=\"$index < 1 && suggestion.chainable\">\n          <strong>{{arg.name}}</strong>=(<em>{{arg.types.join(' | ')}}</em>)\n          <em ng-show=\"!$last\">,</em>\n        </span>\n      </div>\n\n      <div class=\"suggestion-details\" ng-show=\"suggestions.list.length === 1\">\n        <table class=\"table table-striped table-condensed table-bordered\">\n        <thead>\n          <th>Argument Name</th>\n          <th>Accepted Types</th>\n          <th>Information</th>\n        </thead>\n        <tr ng-repeat=\"arg in suggestion.args\" ng-hide=\"$index < 1 && suggestion.chainable\">\n          <td>{{arg.name}}</td>\n          <td><em>{{arg.types.join(', ')}}</em></td>\n          <td>{{arg.help}}</td>\n        </tr>\n        </table>\n      </div>\n    </div>\n  </div>\n</div>"

/***/ },
/* 1335 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 1336 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"TimelionVisController\" class=\"timelion-vis\">\n    <div refresh-hack chart=\"sheet[0]\" interval=\"vis.params.interval\"></div>\n</div>\n"

/***/ },
/* 1337 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"TimelionVisParamsController\">\n  <div class=\"form-group\">\n    <label>Interval</label>\n    <timelion-interval model=\"vis.params.interval\"></timelion-interval>\n  </div>\n\n  <div class=\"form-group\">\n    <div class=\"timelion-vis-editor-expression\">\n      <div>\n        <label>Timelion Expression</label>\n      </div>\n      <textarea\n        ng-model=\"vis.params.expression\" class=\"form-control\" timelion-expression=\"{{vis.params.expression}}\"\n        rows=\"5\"></textarea>\n    </div>\n  </div>\n\n</div>\n"

/***/ },
/* 1338 */,
/* 1339 */,
/* 1340 */,
/* 1341 */,
/* 1342 */,
/* 1343 */,
/* 1344 */,
/* 1345 */,
/* 1346 */,
/* 1347 */,
/* 1348 */,
/* 1349 */,
/* 1350 */,
/* 1351 */,
/* 1352 */,
/* 1353 */,
/* 1354 */,
/* 1355 */,
/* 1356 */,
/* 1357 */,
/* 1358 */,
/* 1359 */,
/* 1360 */,
/* 1361 */,
/* 1362 */,
/* 1363 */,
/* 1364 */,
/* 1365 */,
/* 1366 */,
/* 1367 */,
/* 1368 */,
/* 1369 */,
/* 1370 */,
/* 1371 */,
/* 1372 */,
/* 1373 */,
/* 1374 */,
/* 1375 */,
/* 1376 */,
/* 1377 */,
/* 1378 */,
/* 1379 */,
/* 1380 */,
/* 1381 */,
/* 1382 */,
/* 1383 */,
/* 1384 */,
/* 1385 */,
/* 1386 */,
/* 1387 */,
/* 1388 */,
/* 1389 */,
/* 1390 */,
/* 1391 */,
/* 1392 */,
/* 1393 */,
/* 1394 */,
/* 1395 */,
/* 1396 */,
/* 1397 */,
/* 1398 */,
/* 1399 */,
/* 1400 */,
/* 1401 */,
/* 1402 */,
/* 1403 */,
/* 1404 */,
/* 1405 */,
/* 1406 */,
/* 1407 */,
/* 1408 */,
/* 1409 */,
/* 1410 */,
/* 1411 */,
/* 1412 */,
/* 1413 */,
/* 1414 */,
/* 1415 */,
/* 1416 */,
/* 1417 */,
/* 1418 */,
/* 1419 */,
/* 1420 */,
/* 1421 */,
/* 1422 */,
/* 1423 */,
/* 1424 */,
/* 1425 */,
/* 1426 */,
/* 1427 */,
/* 1428 */,
/* 1429 */,
/* 1430 */,
/* 1431 */,
/* 1432 */,
/* 1433 */,
/* 1434 */,
/* 1435 */,
/* 1436 */,
/* 1437 */,
/* 1438 */,
/* 1439 */,
/* 1440 */,
/* 1441 */,
/* 1442 */,
/* 1443 */,
/* 1444 */,
/* 1445 */,
/* 1446 */,
/* 1447 */,
/* 1448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(464);
	__webpack_require__(1449);

/***/ },
/* 1449 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var logoUrl = __webpack_require__(1450);
	var moment = __webpack_require__(460);
	
	__webpack_require__(1451);
	__webpack_require__(1455);
	__webpack_require__(1309);
	__webpack_require__(1315);
	__webpack_require__(1457);
	__webpack_require__(1458);
	
	__webpack_require__(1460);
	
	document.title = 'Timelion - Kibana';
	
	__webpack_require__(1);
	
	var app = __webpack_require__(24).get('apps/timelion', []);
	
	__webpack_require__(1461);
	__webpack_require__(1462);
	
	__webpack_require__(1020);
	__webpack_require__(803);
	__webpack_require__(1305);
	
	__webpack_require__(761).register(__webpack_require__(1463));
	
	// TODO: Expose an api for dismissing notifications
	var unsafeNotifications = __webpack_require__(366)._notifs;
	
	__webpack_require__(350).enable();
	
	__webpack_require__(350).when('/:id?', {
	  template: __webpack_require__(1464),
	  reloadOnSearch: false,
	  resolve: {
	    savedSheet: function savedSheet(courier, savedSheets, $route) {
	      return savedSheets.get($route.current.params.id)['catch'](courier.redirectWhenMissing({
	        'search': '/'
	      }));
	    }
	  }
	});
	
	app.controller('timelion', function ($scope, $http, timefilter, AppState, courier, $route, $routeParams, kbnUrl, Notifier, config, $timeout, Private, savedVisualizations, confirmModal) {
	
	  // TODO: For some reason the Kibana core doesn't correctly do this for all apps.
	  moment.tz.setDefault(config.get('dateFormat:tz'));
	
	  timefilter.enabled = true;
	  var notify = new Notifier({
	    location: 'Timelion'
	  });
	
	  var timezone = Private(__webpack_require__(1312))();
	  var docTitle = Private(__webpack_require__(585));
	
	  var defaultExpression = '.es(*)';
	  var savedSheet = $route.current.locals.savedSheet;
	
	  $scope.topNavMenu = [{
	    key: 'new',
	    description: 'New Sheet',
	    run: function run() {
	      kbnUrl.change('/');
	    },
	    testId: 'timelionNewButton'
	  }, {
	    key: 'add',
	    description: 'Add a chart',
	    run: function run() {
	      $scope.newCell();
	    },
	    testId: 'timelionAddChartButton'
	  }, {
	    key: 'save',
	    description: 'Save Sheet',
	    template: __webpack_require__(1465),
	    testId: 'timelionSaveButton'
	  }, {
	    key: 'delete',
	    description: 'Delete current sheet',
	    disableButton: function disableButton() {
	      return !savedSheet.id;
	    },
	    run: function run() {
	      var title = savedSheet.title;
	      function doDelete() {
	        savedSheet['delete']().then(function () {
	          notify.info('Deleted ' + title);
	          kbnUrl.change('/');
	        })['catch'](notify.fatal);
	      }
	
	      var confirmModalOptions = {
	        onConfirm: doDelete,
	        confirmButtonText: 'Delete sheet'
	      };
	      confirmModal('Are you sure you want to delete the sheet ' + title + '?', confirmModalOptions);
	    },
	    testId: 'timelionDeleteButton'
	  }, {
	    key: 'open',
	    description: 'Open Sheet',
	    template: __webpack_require__(1466),
	    testId: 'timelionOpenButton'
	  }, {
	    key: 'options',
	    description: 'Options',
	    template: __webpack_require__(1467),
	    testId: 'timelionOptionsButton'
	  }, {
	    key: 'docs',
	    description: 'Documentation',
	    template: '<timelion-docs></timelion-docs>',
	    testId: 'timelionDocsButton'
	  }];
	
	  $timeout(function () {
	    if (config.get('timelion:showTutorial', true)) {
	      $scope.kbnTopNav.open('docs');
	    }
	  }, 0);
	
	  $scope.transient = {};
	  $scope.state = new AppState(getStateDefaults());
	  function getStateDefaults() {
	    return {
	      sheet: savedSheet.timelion_sheet,
	      selected: 0,
	      columns: savedSheet.timelion_columns,
	      rows: savedSheet.timelion_rows,
	      interval: savedSheet.timelion_interval
	    };
	  }
	
	  var init = function init() {
	    $scope.running = false;
	    $scope.search();
	
	    $scope.$listen($scope.state, 'fetch_with_changes', $scope.search);
	    $scope.$listen(timefilter, 'fetch', $scope.search);
	
	    $scope.opts = {
	      saveExpression: saveExpression,
	      saveSheet: saveSheet,
	      savedSheet: savedSheet,
	      state: $scope.state,
	      search: $scope.search,
	      dontShowHelp: function dontShowHelp() {
	        config.set('timelion:showTutorial', false);
	        $scope.kbnTopNav.close('docs');
	      }
	    };
	  };
	
	  var refresher = undefined;
	  $scope.$watchCollection('timefilter.refreshInterval', function (interval) {
	    if (refresher) $timeout.cancel(refresher);
	    if (interval.value > 0 && !interval.pause) {
	      (function () {
	        var startRefresh = function startRefresh() {
	          refresher = $timeout(function () {
	            if (!$scope.running) $scope.search();
	            startRefresh();
	          }, interval.value);
	        };
	
	        startRefresh();
	      })();
	    }
	  });
	
	  $scope.$watch(function () {
	    return savedSheet.lastSavedTitle;
	  }, function (newTitle) {
	    docTitle.change(savedSheet.id ? newTitle : undefined);
	  });
	
	  $scope.toggle = function (property) {
	    $scope[property] = !$scope[property];
	  };
	
	  $scope.newSheet = function () {
	    kbnUrl.change('/', {});
	  };
	
	  $scope.newCell = function () {
	    $scope.state.sheet.push(defaultExpression);
	    $scope.state.selected = $scope.state.sheet.length - 1;
	    $scope.safeSearch();
	  };
	
	  $scope.setActiveCell = function (cell) {
	    $scope.state.selected = cell;
	  };
	
	  $scope.search = function () {
	    $scope.state.save();
	    $scope.running = true;
	
	    $http.post('../api/timelion/run', {
	      sheet: $scope.state.sheet,
	      time: _.extend(timefilter.time, {
	        interval: $scope.state.interval,
	        timezone: timezone
	      })
	    })
	    // data, status, headers, config
	    .success(function (resp) {
	      dismissNotifications();
	      $scope.stats = resp.stats;
	      $scope.sheet = resp.sheet;
	      _.each(resp.sheet, function (cell) {
	        if (cell.exception) {
	          $scope.state.selected = cell.plot;
	        }
	      });
	      $scope.running = false;
	    }).error(function (resp) {
	      $scope.sheet = [];
	      $scope.running = false;
	
	      var err = new Error(resp.message);
	      err.stack = resp.stack;
	      notify.error(err);
	    });
	  };
	
	  $scope.safeSearch = _.debounce($scope.search, 500);
	
	  function saveSheet() {
	    savedSheet.timelion_sheet = $scope.state.sheet;
	    savedSheet.timelion_interval = $scope.state.interval;
	    savedSheet.timelion_columns = $scope.state.columns;
	    savedSheet.timelion_rows = $scope.state.rows;
	    savedSheet.save().then(function (id) {
	      if (id) {
	        notify.info('Saved sheet as "' + savedSheet.title + '"');
	        if (savedSheet.id !== $routeParams.id) {
	          kbnUrl.change('/{{id}}', { id: savedSheet.id });
	        }
	      }
	    });
	  }
	
	  function saveExpression(title) {
	    savedVisualizations.get({ type: 'timelion' }).then(function (savedExpression) {
	      savedExpression.visState.params = {
	        expression: $scope.state.sheet[$scope.state.selected],
	        interval: $scope.state.interval
	      };
	      savedExpression.title = title;
	      savedExpression.visState.title = title;
	      savedExpression.save().then(function (id) {
	        if (id) notify.info('Saved expression as "' + savedExpression.title + '"');
	      });
	    });
	  }
	
	  function dismissNotifications() {
	    unsafeNotifications.splice(0, unsafeNotifications.length);
	  }
	
	  init();
	});

/***/ },
/* 1450 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABBCAYAAABrYJlFAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAABygAAAcoBzLZ1MQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAACAASURBVHic7Z13fFvV+f8/z7lXwzuemWQnTiLJCYRdRqBQCKuQWEmhzG/p4lvg21JiO6H9qqWJ7dBCG1YZP6C0TCeEAi2UtpACLasuiXUVZw+y7cRTkjXuPc/vD8m2bEuy7Dhp6Nfv1yuvyDrnnnPu0HPPec4zqKqqKgdAC+Lzdnl5+SUJyob5D8LpdI5i5gMJil9bvXr1V4/rgIY5brgAEbKj0FDMBULIApawgDgntg4BYSbyKgZ5DQ43WCUaXB54j/dY1ePd4TDDDPPv4VtzYSqUptnMxhkMskFiGghTg8B4AELAACRAAMB9jydmSGIQKQgKoGI2fABvBdE2Am2VkmsljI9X1mHvsTqHYYE1zDD/wZSdbJotpDGfiOazjtMkZFpUJHX9dxRkADQHjDkMBhGgQEHFbOxj4F3B+IPZMN52edB01D1FGRZYwwzzH0b5HEwkVm8B+CZIOQEgcJwZEwAQESxmBapKMKkCqqpAUQg+fxjt3hAAwGJRkJtjBTMQNiSMsIRuGAiFJMK6jNfsWAKuZ8L1QVUxKmbjrww85fMZrz64DcGjObdhgTXMMP8hlM1WzxHgZWB8BWDRu1xVBTLSTchIV5GeZobVImC2qHEnWocafV0Cy2pRMXZ0Ztw+pWQEAgY6gjr8/jB8/hD8HQa4W0IqAL5CwFcyM5SmpSX0KIf0Byo34chgznFYYA0zzBecihLTGSBZCfAFvcsyMkzIyTYjJ8uKtLT4wuloEIKQnq4iPV1Ffq4VQESItbaH0NYWRGtbMHYWlsfEy2BR7qyYTQ9ZrHql62O0Dai/IR7/MMMMc5wom4ucijnKIyD5DwB9hFVWphlTJuZgdFEm0o+BsEqEEITcHAsmnJSNsaMzoYg+PWcCXB4MKBsrZisLBtT20A1zmGGGOV5UlKjnCl3ZCMZ3Ef0dq6roIZTavSHUb2nqWtodTyQzdu1pw649bTBktwLNYlFixzgWwJqls5WXlxQjK5V2hwXWMMN8waiYI/4HxO8AGANEZjSjR2aiZGYBZkzPR0a6qatuOCyxdXszDjb4jtv4gkEDm7Y24UhTR9d3QhDGjMrArOJ8zCwuQGZG9xgZcKoW9eMKB2b01/awDmuYYb44UMVs5Vdg3N75RXq6CZNOyobVGvkpp6epKJ6Wh8ZGP/Ye8IKZwQD2HfAirEuMG5PVZ2nIADr8Ory+EHwdYYTDEoGAHikgoN0bxqatTTCZBNLTVGRkmJGZboLou9RDR8DAth3NCIWNru8y0lVMnjACZrMCAEizKpg+NQ+Hj3Rg7/52SMlg4pkg5cNls8UlyzeEP0l0AYYF1jDDfDGICCt0C6v8XCvGn5QNQT0FBwEoKkxHZqYZ23e1IBSKCI+GRj90XWLi+IgRu9cbxpHmDjS3BCBlPEvRyH9SSvj8EcV5S2sQgA8gIDvDjPy8NIzIsUAIgt+vY+vOZugxpg7JxliYn4bMdBO2725FMKgDwAgJ+fayEtOly+vCH8W7CMMCa5hhvgCUl4gfIyqsCMDYsVkYWZDeVR4KGwiHI3ZRoZABECCIMGpkBhoO+RCICq2m5gCCIQldl51CIi5EBGtGBlhKBDs6Ys0UIjDQ5g2hzRuCohByc6xoihV8FBFIWRlmHGkKQBoSqknApCowmRRYzAJCENLSVMycmostO5rh79ABIEeS/OM9dpz2Mw3be49rWGANM8wJztI56sXM/CMgIqzGjclCUUE6AgEdhw770dYW6rEE6w+fr6cSXjGpGDNpAoomjMPICSchJ38ELBkZPWZFoUAA7c2taNyzDw1792P/tl3wt0dcCQ2DcThGXwUAYKDxcAcaD/f6PgoBSEs3oSDXivy8NEyfkostO1rg94cBINdQxNoflsizfl6HHsq3YyqwXn75ZWX79u19tlsBgIgOlZeXu4+m/eXLl49WVXWClLLTqq1ZUZR9S5YsOXg07cbj/vvvTzMMY5phGCOY2awoSljX9UOhUGiHy+U6/tswUaqqqnKYORcAgsFgk8vlGpBdy0BxOp1zpJQF8crWrFnzlyFoP80wjBFElCaEaM/NzW15/PHHw0fb7mC54YYbMkKh0FgpZRYAKIpyJDs7e9/xGtOy2RgrmV9CxAATI4syUFSYDp8vjE3bm+L6/KVK/piRKJ47B5NLZsJstSata7ZakT/aivzRIzHj9FPAUmLftp3Y+i83dm/cDJnIlD4BDMDvD+NzfxiHmzowc3o+pk0agfotTVHhSw6VlFWA8Y3Y446pwNq5c2c6Ef05XhkRvQTgawNp77777sswDGMhgKsBnA8gj5lBMW8CKSWqqqoaAbwH4FVFUdbefffdg9oiWbFixVmKoixk5vmhUKgY0YeGiCClhBACVqtVr6qqqgXwJ2b+bUVFxbbB9JUqlZWVc4noamY+n4gcAEZ0nr/VakVVVVUzM9cBWEdEa472pRCH5UR0WYKyAZv6OJ3OQmZ2ArgIwFxmPklEtbnMjKampnBpaekOZv6QiP5ERL+vqamJ/9oeAubPn29JT0+/goiuYubzOjo6JsaW67reOaZNzPwOM9e88sorfz9W45FQfg4gFwCyM80YE7U4b/MGu4SVEAIFY0chuyAPGVlZSMvKgFBVhDoC0MM6Orw+NB04hMP7DoCZkZ2fh7kXn4eJs2aABmmcRUJg3PQpGDd9CpobDuOff16HPZsij74lLQ0jJ4xDTkEezFYLTGYzhElFyN8Bv9cHf1s7GvcegK818m71B3TohoSqCkyZNAKbtzZBMoOAW8oc6m+q3fp7nf1+IZaEy5cvH6mq6l2GYXwbQHYKhxQCWAhgoWEYh6urqx/q6Oj4hcvlSikcRnV19VXMvAzA6X3W7n1RAZwB4Awi+lFVVdVbAFaUl5d/kEpfqeByucwWi+VGIcSdzGwH0ENI9yKXiM5HRKD/b1SYrgoEAs+7XK7ESovjzIIFC04hoiXMfA0Ac5KqJgDFRFQM4GZmbiktLX1SVdUHXnzxxf1DNZ5rr722IBQK3U5EtwEoAJJeYxMABxE5iOjO0tLSjUR0X2Nj4+/WrVs3ZNe44mT1fEheDACKQpgwPrvrjeD1dU/wrvzOTcgfPbLf9nytbWjcsx/jZ02HEENn0ZRbVICLv16Kg7v2IOD14aQZ06CoSr/Hvb/2j9j6rzqAI+czItuC9DQVo0dmYN9BLwCQEPKXTidOq6mBAZzgdljMTNXV1d9TFGUzM9+N1IRVbwqY2WW1WjdXVlYuTlaxsrJyalVV1Z+Z+fcATh9EXwRgPoD3q6urn1+xYkXhINroPaaLrFarm4ie6BRWA2QugN9YrdYN1dXVcZfnx5NrrrmmqLS09DdCiH8S0WIkF1bxGAHgh7quby0tLV36rW99y9TvEcmhhQsXficcDm8hoh8jKqwGyCxmfrqwsPAzp9N5zlGOpxvJ9yI6ax09MgNmU7cQCIYiO3FCCOSOKkqpuYycbEy0zxhSYRXLqIknYaJ9RkrCCgAKxnQL2WCoWwdXVJgOi6VzLkUnT9milHaWnbACq6qqKqe6uvp1Zn4QQE6/B/TPGCJ6sbq6+olVq1ZZehdWV1eXElEtIkuTo4aZrxVCrK+qqhrUA/zyyy8r1dXVK4nobQDTh2BIs5j5L1VVVZUvv/xyak/UELNgwYILFEVZD+BGHH1wk3QAy5uamt5fsGDBhME0cPXVV48oLS19jYgeRXTZdTQws52Z1zmdzh/jKM9vaYnpFADnAoDZpKAoZkcQAMJRJbs1M6Ic1w2JxmYvDh5uw6Ej7Whp70BHMJwwSsPxIhQ20OoNoLHZi0NH2tHQ1I6OQGR2mJ7dbdyuh7tNIYQgjB3V7WxNMaYcJ6TAuu+++4oArANw+VC3zcy3+v3+N+67776Mzu+qq6tv44hiczAzuGSMAfDn6urqqwZy0KpVqyw7dux4KTqrHEoXMAGgfMeOHS/FE9rHkoULF14rhHgLwOghbvoMIcQ/nE6nYyAHLViwYLSqqu8BuGKIx6Mw809KS0ufnjdv3qBVLgx5R+fnosK0PsvTTjkklMi7p90XwKEj7Tjc4kNjsxd7D7Vg+57D2LW/6d8mtBqbvdiyuwF7Djbj0JF2NDZ70dDkRWNLRDPTY6bXa4wjRlhgMXe9V79U7jDNBU5AgeVyubINw3gLwJxj2M1FhmG84nK51MrKypuZ+WEcu2thZeaaysrKr6RS+eWXX1b8fv9ziOjgjhUL/X7/WpfLlXxraIgoLS39KhE9i4Ev/1JlDDO/s3jx4pmpVHY6nTmKorwJYEBCboDclJ+f/5TL5Rrwc+WywQzCAiAy2yjIS+tTp9PkQA9GNqiDob6qs4w0MyaMye1SrDMD7U2JoqEfHR0+H8LBnpvlhbmZKMrrG5amc6zhULcejkQcw9KC7vMmhb8G9K90n1RZWVk2kIFHeaeiouLTgR4U1Vk9A+DkFA/5LLojtl8IIaSUY4hoLoBZKRz7FYvFsoaIUo1Z3wxgHTPvIaIWZi4goimIKLf7++GbiejlysrKU/vbRdyxY0cVUhdW+5j5MwBHAKhENBbAqQDiBy/qyXyr1fqKy+Va4HK5Ain2N2CcTuccZn4RqW3wSAD1AD4H4AVQyMwTiWhiCscWGIbxxtVXXz331VdfTfirdLlcwuPxvMTMs1NoEwC2Rsd0gJktRDQKwGkA8vs7kIhu0DRtE4AVKfYFAAiY1fNIchYQ2RlUlL4yz2widBhAsMMPPdzXwsJiVjF+dF4PW6oDO3fjT8+8gDFTJmHGGafgpOKpfSzQB8qhz/eh/uNa7PJsxqkXnw/7l3qqfovysqAbjKbWvhv1vtbWrs8mU99x5OZYsXd/dJ+McRmAu/t7iKYRUdVAT4KZfwhgwAKrqqrqG0R0TT/VAkT0sJTykYqKih3xKqxYsWKGEOJ7AL6JJG91IkplqfaxlPKn+fn5f/72t7/d58lwuVyZaWlp10QN+6YlaSeHiJ5zuVxnuVyuuGEaq6qqLgFwVz/j0YnoSV3XH162bJkWZzyq1Wq9GMD9QL/OpPMsFosDg7hXqXDzzTdbvV7vi+hfoO9m5vtNJtPqeDt/TqfTwcxfB/DfSC6MJ6uq+hiAhJsrmqbdAaC/l1QIwK+J6Mmampo+ZiHz5s1T8/Pz5wkhvs/MiUw8Ovmp0+n8S01NTUL/uN6QxPzOz9nZkZW7lIyOgA5dj1izEwkABpiBpoMNEBnd2gxVEZg4Jq9PWJdwKARmYN+2ndi3bScyc7Lx5a8vTGmHsTfBjgDefPp5NB1o6G4/GN8ccXRBNoIhHb6OSLDRTiF5ZP+h7vaCEk0tAaiqgMUkYDGrMJsVpKWp6OjQAfCse0ow6YQxa7j//vvzQqFQdT/VPgawqKys7PNklZYuXboJwPdWrlz5gJRyDYBU36axBIjotiVLljxDRAm1AFFTid+6XK4XrFbrUgAuJNY7nW6xWP4LwJO9C1atWmXx+/0PJTkWADyKolx399131yUZj15VVZUFYEqSdgCgg5mvGsxMOFW8Xm8ZgOIkVXQA9xDRA6tXr05ofBsVGuXXXHPN/YqiPATAmaTNRaWlpf9v9erVb/cucDqdY5n5p8nGTEQfAbiupqZmZ6I6UdOFvwD4S2lp6TwALwAYlaC6ElU5nI5UzTyZz+p8Cvz+MLRGP0JBPeHB+7buxOTTT+36e3RhDkxxdurGTp6InII8tB6OhlgXAll5I1IaUm8saVZY07qXbGaLBVPnxN/EJgJOGjUC2z5vhG5IWC0mSGbs37G7q86hxp4zMEUhZKSboKrds0splLNOGB1WMBj8HwB5Saq8GggE5pWXlycVVrEsWbJkeyAQOAfAXwc4nDYiuqCsrOzpZMIqFpfLpZeXl/80OhNI6CdBRMtcLlefF4Xf778ZwNQkXXxgsVjOSSasAKCqqup6AM8jYiuUiA4iurKiouKoLdMT4XQ685B8tuhl5vmrV6+urqmpSclTYO3atQ2rV69ezMz9zfrjCiVmLgOSxl1anZGRcUEyYdXngNWr1xHRGQA2J6l2qtPpvDLVNiG6VRqHmzoQTCKsAGCntgnp1shCIjvTipzM+BNa1WzCld++EWdedhFOv/RCfPU7N8Fsib/3ous6fK1t8La0IhSMH4b94uud+NJX5+PUr8zD1d/7r6TCT1UERuZHLn261YQD23ch4PMnrG8YjLb2ENrbux8NZpp5QsyworOL25JUqTWbzdeVl5cPWNficrm8VVVVCwH8A6nptgwA15WVlcX1Fu+PioqKFyorK0cR0f0JqkxMS0u7GsDqXt/fmaTZbVLKq7///e8n1ZhWV1ffwsxPIvkGgp+IriorKxuoEB8QzPwdJBYOEsD1g3Tl4TVr1lSUlpYWALg1QZ0znE7nOTU1NV3Gu1dfffWIJPUB4B8+n+/61atXDzhJQk1NzeeLFy++3DCMj5DAjouZfwDgtf7airjixDfjEUQwmRVENwYRCOiQEmhpPIxDO3YiOzsPo/KTb3SbrVbMOuvUuGXe5ha4//4p9m3bibYjPRPdpGdlYfTk8XCccybyRkXMCxWTiuJTU1+85Gano6W9A9mZafjk1e4VstksoKoCzIAeZoT1+O97AttOiBmWz+e7DImVmLqU8vof/OAHg3bHKC8vb2XmG5HalPzx8vLyPwy2LwCoqKh4AMC7SarcEvvHypUrTwGQaIdLMvOipUuXJg3aX11d/Y0TRVgBADPflKT4odWrV//+aNrPy8u7DUlmNVLKHj5oiqI4AfTdbosQIKJr33zzzUFndHnppZe2M/N/J6lyntPpTDaDBgBIVid3fiaKLItOGpsFW3E+TnYUwT4jHzOnRf6dNLZbOH381jsYnZ/Vw7h0IPha2/DKQ0+h/uPaPsIKAPzt7di+wYPXfv0MDu8fvKvu+NF52L91O/ZtjUxiTaqAvbgAM6flY9b0fJTYCjDHXohpk3NRWJAORenWkDDxlBNCYCXbqSOip6I6qaOioqKiFsCafqr5DMP4ydH2BQBSymWJypj5wvvvvz8tpm5CWyBmfq6iouKzZH1FhdXjOEGE1cKFC6cRUSJj11aTyXTv0fYRdT7+UaJyIroi1qSAiC5NVJeZH6ypqUlZ1ZCINWvW1ACoTTQkpGJXGJNxOT/PihnT8lBUkB4J0NdLu5mfl9a1g9jaeATtR5oHOXKg9Ugz9FD/K3NpGGjcs2/Q/SiCUPdB9+JlZFF6H5MGRRHIzjJj/Ngs2GcUdJczZScVWMxcx8yLBvHv9YGcBDOflaT46YG01Q99lN2xENEfly1bdihZnVRZunTph0TUZxcvijUUCp0W8/eXkozp18n6qaysvDUVYcXMVx4PYQUAQoiE5wPg5RdeeOHwUPRjt9vXADiQoLjA4/HYYv4+O0lTTwzFeAAwET2esJD5vH4b4O5ltNmUfD4RDOowjMiGc3ZBftdSbTAUjh0Fk6V/MzkiYOT4kwbdDwCMntjtmGAYyRc9qipidzuzk+qwiOhgeXl5zVGNrh9cLpcgokTmAI0dHR0pbwf3R25u7jvNzc0tiPij9UFK+ceh6gsAmPkVAHG3Tph5BiIRJYDEurXGQCCQUJdWWVl5KxE9hhSEVUVFxTupjHkoiJ5bXIjojaHqx+VyydLS0rUAEuk/ZwFwO53OHGZOtIu3ec2aNVuHaky6rr+qKMqjiH9P+tWhkkBmdxSG5DZSrW3dK9gpjpRsZhNislhwxmUX4e+v/jGpZfzMM09D3ujUfBcTMckxE+vXRQJctLaHMCbRnYmiKKIzimnWv31JmJOTk43EuoUdiWyWBkPUjiqh4SYzD9mDG20v2VJ2DBCxm0Ike0g86pPYbH3zRBRWUcYlKhBCeIayIyLakKR4fLTPMUnqJNvdGzBr165tANCQoDjhdRkMXm+3WeCYqZOOur3pp5Tg7Ksujeu8TATYv3Q6zph/4VH3k1tUgIyciP6twx+OH545lm4JKvsTWMc8lZnP58tIVMbMQ7I860WiJQRUVU30oA0KRVEShj8hoiwAsFqtGUhwnYko7vlXVVV9E8CvcWIKKxBRwnsqpRzSe8rMCa8xc8RaXNf1hOMBMOTPGBElGlNGf646xOjaXOovKF5HIOLiIoRA4dh+pikpUnzqHFxz+62YdkoJ0jIzYUlLw4RZxbjimzfi9EsvTBZyZ0CMHB95RzO6zyMRMWnCfGp6enrA709oD3HUHuz9oaqJY1EIIQa9a5MIIgokinElpRzS/pg5WXudwQBlovEwcx+DmqiC/YQVVgDAyYOIDWmkCCIyJenOiI5HTfJDOxbBABO1Sfv371cQMeuICzMCna8vlomFA0tGMBqxITMvt8sJeijIzsvFudf0Z8B/dOQUdhsFBAN6j9RkvYmZgfnFHXfcEQQQ176JiAZusz/MgOjo6PAhsaFpD+1mZWXlt5j5CfS/G3jFv0tYRUkWpnlopgJRmDlh9AdmPqbhoo8FTNQ15tjsM70J67LLSCczJ6UcpCcUmTndJhmhJOcpJYO7BBa3dj74cX3ymHlcdXX1kK67h+lJVEe1O0HxdJfLlQlEhFV0xzDZnNxPRFeUlZUlswE7HuxKUjbUUTjOSFQghOiTdeVEhyG6bAbCSRJLGDGzSlMCa/UTGZO5e0cyHE4ssIJBo9t4kmh7p8BK5O5ByWyEhhky1if4Pj0tLe2aFIWVj5kvPwGEFQAkVKxLKYcsxlk02miy53Oo49kfc9L0UNfLK14mnLAucaDBi63bu22upJF6xpwTBSNmzA2H/di+swVt7aE+lt3B2GvAtE0AADP/LVHDRPT9xx577GjD0A6TnLcSFTBzZYrC6oqKiop1yTo5XveRiN5HAq8CIlrodDoT7YoOiKampuuR2P9050B8Ak8UXB54ATQBQCBodF1Fw5DYd9ALrf4w9h/w9ZiVJPPJGwzMQMOe/dj0z/Wo/+Rf2L9995ALxYCvp7NzS1sQW3c0Y9PWJrR7uw1YOzpiAqSw3KYCgKIor0opH0J8hej0lpaW7wJYNaQjHqYLXdffUtWEJnH9/bhTElbV1dVjmpub/1xVVfWT8vLylwczzlSpqak56HQ6P2bmM+MUpzPzvQD+62j6cDqdacz8v0mqvHI07f9bYfwLhIukZHQEDYRDBnbtaY3oreLQ4R1UUqg+SCmx6dPPoH3wCbwtrT3KLGlpKD51NkrOPyuhw/RA6PDF35fw+8PYsr0ZeblWTBiXjfYY0w2S6t8FACxZsuQgMyf0n2PmldXV1YNJyjBMCtxzzz17APxzEIemLKyY+V1EDBefq6qqWjSIvgZKMg+FW0pLSweU4q0XJKV8EkCiWO7MzEPpIXF8iYS4AQDsO9CObTubewgrVREYPTITVnPkJedrbe1KajpYmhsO49WHnsJHb/y5j7ACgGBHB+re/wirH3gMezYffSa7WPeek8ZkIzurp5V9U3MAGzc3od0fnW0xjpi1kNa12ySEWJ6kfQszvzbYhArD9A8R/XKAh/iEEJf3J6xWrlw5Lbrk7/TtUwE8118GoSHgGSQx0gXwpNPpHLA+y+l0KqWlpb8gouuSVPvDmjVrhtRA9bhC/GHnx9a2YNfamgRhdFEmHLMKMGZUBrKzIz9yZuDAjkT7Nv2zd+sOvP7Yb9DS2L/HVMDnx1+eW4269wcVzAQAoIfDaIgKLJMqUFiYhmmTczF9Sh4y0rtXGsGQ3m0AQvirK9ZwtKys7BNmfi5JPyMBvFNVVfXj2AQOwwwNkyZNehGJle+98QkhLl+yZElC3SMAVFZWLpZSfoi+cbZUIvrdsRRaNTU1oWhux0RkMPNrpaWly2+44YaUnien0zmemd8A8P0k1XTDMO4Z0GBPMCwtxjvUyzTEYlExY1oexozO6HLZycrsnpXs2rhlUH0d3L0X7zz/CvRQ6omsmYF/vr0O9Z/8a1B97tm8HUY0hExWlrlLOZuVaULxtHyMGpnRR2PLwItAL3seKeVdSG75awLwE8MwtlZWVv6sqqrq7OOVyOA/nUWLFhlE9F1EonD2xyFmnrpixYo+IXlcLldmZWWls7Ky8j0iehGJw/aoRPS7qqqqZE7BR0U0esG6JFUEgKUdHR1bnU7n3U6ns0900uiM6uzS0tIHmHkzgIRRFwCAmVetXbs2mbvOCY9rFwIyRgenqgLFU3ORbu2p58zO6o73/nn9FrQdThqBqA96OIz3X/kDdH1wuV8/efOvA+4TANwx0RpG5PQUHwRg7KhMjC7q8Q47YM01Xgd6JQZYtmzZoerq6q8z85tIHrFyNBEtA7Asmh69FZFECJFOiVaUlZX9vwGfyf9xysrKPqqsrFxKRCv7qTqZmZ8UQjxeVVW1BcBBRIxPixCJq5VSYEZmfmHKlCkfH92ok3dhGMbiaNLUZC7+o5l5JYCVpaWlDYicTxOAImY+CcmjhMbyT7/fv/Qox3xCIJh+x8Q3A4AiBFSl7yaxEISi/HQcaPCCmfHZun/g/NLUA5tu+8yN9qbBh6QxdAPr3/sI5y1IfWW/d8t2HN4XiadlsajIzY6vwI911yGmp1zrIi/yPhbT0RAktyKJ+0AccgBM7vwnpRxcoOhhUFFRcV9/IWViEIgkmpgH4MuIpK1KVVj9dsqUKbcsWrTomBrxrF27tkEIcRWAVPfeiwCUIHJOs5C6sNoppbzqaILwnUisqNP/ikgOAwRDOg43xQ+2W1SY1rVE3L7Bg931qS8N92w+erva/dt3pVw35O/AB7/vtuAZVZQe11inzRtCS2vXbWwOmvQu/W5cF4/y8vJnmXkRgP+Im/9FY8mSJbchkvXmWPFwMBi8+VgLq05qamrWRw2Qj4mrDDNvVxTl4ldeeSWhY/sXEQb9uPPzgYPeuBbhqiowZlT38unvr74Fb2tqlzkUOPrsbjJBOOM+9Zjxwe/fhL+tHQCQkW5Cfpx8i4Yh8fnemPEzu35Ri67dgIQ+aRUVFWsAXEhEe1Id/DBDAxFxeXn5XUR0kleE2QAAGJ9JREFUJyIpp4aKIBHdXl5e/r2hDNuTCq+88sq7zHwuMw9OO5yYN4QQp7/00ktfODec/qjaoL+NaAKVsC6xa09rXGvckQUZyIqaBQT8fvzxyefgbe4/YerYaZP7rdMfE+39ZZKLKOk/eu1PXRsDQhAmjc/uM7liADs/b0Mw2CkEWTtiko/G1kka6qK8vPwfzOxg5oeQmjJ4mCGkrKxsFYDTiejvQ9DcB4qinF5WVvbQELQ1KNasWVMnhJgL4AEc/fPURETfXr169VU1NTV9g5D/hyAM4xZEkviirT2Eg4fiGIkSMCLGjsnb0oo3n3mxXzOFkvPPhu3s0weVTJUImHqyA2fM/3LSeno4jL+tfg2b/tm9Aa4oAqY4sef3H/DGBiX0Gopc9Hgtemxf9qvvKC8vbwVw+8qVK38ppbwbkSSVwzqq40R5efkGZj63urr6Cma+m4jOQepxyhjA+0KI++6+++4/pJqy7FhSU1PjBfCDxYsX/9owjKUAFiFxAMd4NDLzoxaL5ZfPP//84DXGXxCWa9hTMRu3IpqPYP9BL4iAUTG7aOGwgf2HeqoI25ta8Nqjv8GZV1yM6aeUxG1bEOGM+RfCdtZcbNvgQcPuvTj0+T6EE6T1UlUVeaNHYuSEcZgy295vSObWxiN456W1aD7UU3CGwwb2HfThpDHdOXH3H/ThYEO3MCbguyv/hfo+Y0jaYwxLlizZDuA7q1atutPn850P4DwisiFibdwjLZEQoiX6vzQMI1EkiAYAICKdmZPWGUqibcbtj4iGdBYZjb2VqK+U94OjguZ1AK/fd999k6SUV0bjg9sBTEJ3dusQgJ0ANCJ6Twjx+t13370TAJYsWdJfNwYSXBfEmLow88Ek9VLmpZde2gLg5q9//et3BAKBy4noAgAnI5I9O/Z5OgRgC4BPiOgvubm5f40moPg/Q+UG45WKOeoKMC8FIjMRAjAyKrT27Gvviu0uCFBNCkIhA3o4jA/W/hE7tXqc9pULkDcqfmjjzBE5mHN+xLqFmdHh9SHoDyDY0QFmhtligSXNgoycbJDoP0hxOBjEhvc+gufDT2GEO4MMEjIzTGiL5hlsOOxDfq4VaWkq9u73oiEmkSqDf1y5Qf4uXtvHPKLoMMeeTqfmaAjo/wiuvPLK9Ndff31ovXq/4JSXqCuJ+O7Ov/NyrSjMT8eWbU1duq3x47KRN8KC3Xvb0dzSrVQnIkwumYXi007GqAnHJmKUr7UNW/9Vh40f/6uHQ7bFomDyhBGwWhRs3NKEYDAixLKzzQCjS4hF4P+t3CATZuceFljDDPPFgSpmq78E+I7OLxSFujLPpKWpmDUtv+tXfbipA/sPePs4TecU5GHaKSWwn3PGoPRXvWk93IRP3noH+7Zs7xHWmQDk56dh3OjMLgPX5pYgduyOuyHADK6o2iCrk/U1pOFqhxlmmGPLB4fkW+eMFgcIuASAEhsdetyYTKSnddt7p6eZUJCfDiKCvyPclcsh6O+I2E9JxujJifzHUyMcDOGtZ15Ew+d7e+xg5mRZMHlSLgry0npk/zGZBI4cCfSOV98iGIsr6+RT/fU3LLCGGeYLxgcHufb80co7zLgchC7NdTBowGJVYTF3/6yFIGRlmlFUkAaTqiAUNqDrEWFx6PM9kLqBUZMnDCq5hLelFW8/+zKaDzUCiCw7iwrTMXF8NooK02FSu/VdDKC5OYAdu3qHyeG9Cslzlm/odvhOxrDAGmaYLyDvH5R7vjSOnySppAM4DQDpukRTcwA+XxhpaSaYYhKxCkHIyDBBEYSWmHyGh3bvxW7PZljS05CVOyKlZBbella4//4p3lvzOnwxRqomk4Jpk3N7CCoA8PnD2LGrFQ2H/bEZcMIE+rnXZyz4+caEadH60Ees2my2GwG84fF4TkjbFpvNdjoRqZqm/ePfPZbjyfTp0wvMZvOlmqbF3T0ZSkpKSooNw3AqivJcXV3dkEftdDgcZ0kpdY/H8+nRtjVr1iybEGKspmlvD8XYhpLZs2dP13V9ssfjSRhRdigon6POA+NxAncnJCYgL8eKkSMzejhN79jdguaWYFed2HWcEAKZI3KQlT8C6VlZMFksUFUFeiiMUCgEb3ML2ppauqzV4zFrej7S0iL9eX1hHGzworWtp+0zAR/oivGteGYL/aEWFxePMZlMqzVN6/TavzEakuSEFFhCiNOj6a/+Twksi8VSwMw3ADjmAktK+VsAW6WUx8pYeBER+QEMSmDZ7XYXEe1yu93PCCFsiMwwTjiBJaU8m4hKkSQE9lBQtV5f9625sOUZyi3E+CmAkWCgqSWAppYAMjNMGFWUgZxsC9rbuzeSRxdloqW1Ax0Bo3O8aGtqRluqDtEE5OemwecPIRBto90bgiEZBxt8PTJTAwAYnxPwoxV1xm+RIIR2f6hpaWlmXddP7vzC4/Fc1LtScXHxGFVV2zwejxcAzZw5c1R9fX0fv62SkpIiv98f2LZtW0JnpokTJ1ozMjLGBYPBPdu2bQv2LsvOzi6oq6vb2/u4s846K62trS3N7Xb3sdSeMWNGvslkkm63u7n394qiZHg8nj1IcoHmzp1rCgaDozRN25usXizz5s1TDx06NNZut++tqanp4VA1d+5cUzgczq2rq2sAAJvNZiaikb3bt9lsZiHEOLPZfLC2trZrH9jpdCqapo2zWCyt69evbwEAt9u9CRFFa4/zM5vN2XV1dbvijLvzPh3s1WemEKLIbDbvqa2tTWQGMQHAf2ua1uWW5XA4JofD4dZNmzb1sR+bMWNGvq7r3t73M9m5965jMpnGGIbR2vseTp8+vcBkMqXH3kNmnoCon6umaS8D6BHy2W63TwHg1TSty36s81oT0aG6uroe5uIx938fejn9z5w5c7TJZFLq6ur29y6bO3dueigUsnSOefbs2WNDoZBaX1/fO5qemDNnzvhwOLzf4/EMpatVFxGLcONx1xl4MdShLmHiO4GIfsvrC2PbzhakpanQje5TKCywYszIDLS0B9HcGoTPF0IoNktNHAQRLFYFI7KsyMuzwGpR8fm+dgQCkcf3wCFfjz6iNBLzcrMhH3V5js7VjOx2+25E8t/t1DRtit1ub0TE898MYC0iM5nTABQwczmAO4koH0ArgLM1TTs0e/bs6YZhvMTM6URUQETPut3uH6DXA+pwOOYz86OIZF+eSkT3uN3uxwAIu92+EsANAHwA2oUQi+rq6jbb7fanAHgBLCaix6WUKhGla5p2Z0lJyTgp5UuIBBfMBfB7i8Xy7dra2rDdbv8lIlbUBwDkSimv3LhxY58olHa7fRmAOwG0MrMUQlwnpXQLIT6SUr7r8XjustvtMwF8AuACZr4UwNlENAYR16YCZl7k8Xg+iLZVDOBMALWapl3rcDh+xMy3R6+XIYS4rq6u7l92u/1sRGZLhwBMAfCApmmVJSUl45j5LWb2AxgN4G+apt1YUlIyR0r5B03TRkd/KL+Jxkz3AggZhlFaX1+/1W63vwigBZFoB+kAVEVR5m3YsGGLzWa7lYiWI5JWbAKAb2ia9kav6/E6gPkA9jNzqRCijZlfQcSwtBDAu8x8k8fjCdnt9gZmfpSIlgohzq2rq/uoV1suALdFz11n5q95PJ4NDofjAWb2a5q2zGazXUJETxLRPgAnMfM7mqbdBEDa7fZfA7iIiNqYOVNRlCsMw7gUwM8AhAH8lIgMZr5Q07QFDodjMjP/PnremQDe0DTtVofDcQozr0EkBNI4Inrc7Xb/CABsNtv3iagies0UIrre7XZ/OGfOnBG6rr+BSJILHUCaYRiXRa/xb6L1rwXwCBH9SkpZI4SYycwGEW1tb2+/PCsr62vM/F1EFl/Z0fP7hsfjebH3czjUlDuQC0XcRkx3IBIBowdCEGbbCnvs4AERw9FQ2EBDYwcaDkeEUEaGCePHZEE1RVxqYo+QkrF7bxuamuM6Uu8h5l+YTfIJV23K0TqSIlRVPR9AUNO0KXHKxzHzc5qmTQbwDBHdq6rqhZqmFQE4QERXAyDDMH4H4DGPx1NMRFOZ+Uq73d4ndSwz30tEd2qadhYRncHMdwAQNpvtBgDnMvOUaF9rpZS/ijn0Kma+oPMhi2nvCSL6k6ZpUy0Wy0kAZodCoa87HI7JAL5hsVgmaJo2l4juJ6I+SQ8cDsdlAG5g5hmapk0DsIqZH/d4PCEiupGIvmOz2b5ERE8zc7Wmaf8EACI6MxwOX6ZpWgkR/YSInkG3PvCrzHyLpmnX2e32K5j5WiIqjrb/sJTysWgbPwKwXNO0s0wmkw3AjXPnzs0xDOO/AazTNO10i8UyGcBYm812auy4Q6HQXcycVVBQMEnTtJkAXlEU5fGYKmebTKZzNU2bAMCt6/r10T5XCiG+rGna6Yi4WN3e+5pomnYlIj/sSzwezyfM/DQzP6FpmoOZxzPz2KhTNqJt2lVVLewtrBwOx9VEVKqq6nRN06Yx8+MJwubcCeAOt9t9ptlsngbgipkzZ06ZNWuWDcDCmTNnFrvd7lMAPG4Yxs2apq2KCp+fa5oW+4yAmR8B8KamaVPC4fBUAF+ZNWvW6cxcgcgLYa7FYpkO4Bq73T7SbrfPA3CHyWSyaZo2nYjuZeanACAcDl8FYK+mabOi9/ldVVVvjOnuSgDna5rmiibD8Lrd7nEFBQWTmdmSkZHRGc21hIi+oWnaDABLiShZtNQho8qN5qr1crnXZ4wnxk0M2hxbLiVjg6cRn+9tQyA29hQRLGYVZnO34lxVBNLTTTDHCCtdlzjY4IO26Ug8YbWDmP/H0mpMX1EnfzVUwgrox/kZQKvH43kt+nkrM3+8YcOGfQAkEX3OzHklJSUTAcxl5laHw+EEcBGAbUTUZ2kJYBMzr7Db7XcwM2maZou2VcrMG4UQ86NtNCMyyyMAYOZnPR7PxtiGiouLs5j5EinlfofD4QyFQpcD2MbMFymK0gSgIxgMvmi32xd1dHQ86/F47uo9GGYuBbBRCPFlh8PhFEL4AZxis9ny6urqNAAuIvoTM8vCwsKqzuOI6P3NmzfvB4DMzMxnAUwqKSkZG23zDY/H83cAHNVfbARwUfS8/ABOnTt3bg6ATQCW2u32H4bD4QJN02bW1ta2Rq/RdQ6H495wODxX07QLPR7PJ73GfRUzP7Ju3TodAMLh8BMAzrHZbJ0uOi989tlnjYjMcD8lok6nr81SysdtNtuthmFs1jStxxKzNyeffHIhgNN8Pt+jABBdzjzLzBfEjKW6c9na+9oys8cwjIuj5+4FcKbNZsuMrefxeC6TUm6x2+2LAoHADwBkCCEyLBZLAwClvr7+OZvNVsrMv9Y0LWFwvqlTp1oAXGwYxsMAsHnz5nZmPo2IPNFrfZfD4SgLhULj3W63XdO0Q8y8kIg8uq7PczgcTmbWAUwvKSkZ5/F4ng2FQt9zOBzzbTbbbcx8ppQyPabL32ia1qk0vpyIHgHA69at05n5KkRcqQCg1u12uwGAiNYzc3z/mGPEg9sQXFFnPGvdoM8SjKsQjbEFRIRW45EOeLYcwdbtzT3ixyciGNKxZ3873PWHse+At2eyV+I6YtxkyTWKV9TJX7l2xc8ofzT050vYlT4j6s/WewBkGEYhEYUAzJaya+26npn7KFSZ+b+is7JrALjsdnttVlbWVe3t7UVEBCnl3Jjqv7DZbCYAEEL0cVG3WCwFUkoiomIpZedV2wmgfv369S02m62EiG4A8B2r1fr/HA7Hz9xud28r2iIiSuvVb7UQgqPn7GHmDAAbO4UDAEgpD3Z+/vDDDzvsdnuHlLIz0Jw3pl4RADMz92gfAGbMmPHDjRs3vhsVakvsdvt2VVXnr1+//jc2m20bEV0rpXzOZrMJAD1COjJzAWIivKanp4fD4bBitVrVYMRxNTaFio5uwX8xES0SQnyViO632+2/1zTtht7XtpNQKFRIRN5du3bF3vcwEXXFtWXmRDmmiqLXYG5M3Wpd18ncnfVX2O32GgAzmPktABsQWWrhs88+aywuLrabzeYbmfkOInrKbrffo2la3HRzJpMpD4AQQnRdF4/H03mffuxwOP4hpXQS0f84HI4DqqpeEg6Hi5g5u9f9uQ9AyG63L0Yktd2bRKQxc++krLHnXSiE6PLw7dxhdzgc6Dyf6LUwaDAGT0OAC5CoM14H8PrS2eoFAN/OwFUAFHAkaF6bNwSrRcXIonRwL8nl84dx4JAPbX2FGgP4M4HuX7HeeBuDVKanSv+ejP0QDod3ADDpur7K4/GUezyeciLaJYTonStIENEvw+Hwm5qmXev1escAmNHa2lqCiHNrXefxiqI8TURGMgWlyWTaC6ADwG87jxNCuIUQrQ6HY64Q4jpN0+7TNO1CZv4qM9/Wuw1m3sLMOzqP13V9FRFZ3W53i81my2PmxwHcAWBhdPkIILIM6vxss9lmAVCysrJ29W6fiLYS0bbO9lVVfVAIYamtrW2rr6+vllJ+qmnajQUFBWMAZOq6/iW73X4ngLDb7f6epmlTKJLyaUGvprcjJuV7OBw+A8C2WMV9b04++eRCIvqZpmlPu93ur+q6PgnA16ZPn16Q6BhFUXYDSI8usTvP6XSkllF5KxFt6Tx3AI8AMG3evLlrT9xms00GcGVWVtapHo/nrmAw+Cqijs8Oh+Mss9m8wO12V3k8nvMQ0Rd9N1Fn9fX1hwC0KorSdW/sdvsf7Hb72Xa7/V5FUTZ6PJ5bNE0by8zhcDh8IYCtAPZ0jjEcDv9cCJFZXFx8BJH7XuF2u2/WNO3nRJTMQGmLYRiOmPN60G63J3wR/LtZsUF/d8UGY4EQxhSAViLGIiAQ1LF7T1uPyAk+fxibtjb1noEFGXiKWCmp3GBcsmKD/iccY2EFAGogEGhXVdXkcDh+4Ha7BxzlcsuWLYftdvsjJpPpeYfD8TCAmcz8HSHEab2qSgBTzWbzgw6H4yVmtgOgtLS0TcFg8D4Af40qcRuklBUAfpus39ra2rDNZltBRE/b7fZqABOY+YdEdD4ReaWUy+x2e5iZd1EkJdR7vduQUv5KUZRPHQ7H9mhUhe8DeB+R5dzDAD7WNO1Bu93uY+YnZ8yY0flQzrbb7Q8z88dEdBczPxKdafVoXwjxSynlxzabbQcR7ZJS/kBK+W60/TGKojzscDiePHz48BQABeFw+DNVVW1E9IjD4bhXSpnDzGcKIXrofigS8/13DocjzMx+Zr5XCJHQYRQApk6d2lRfX3+ZzWYLCCH+JqU8L3L7tiSMGlFXV+ez2WwPAnjB4XD8HJFY8tcBODXRMTHcz8wfRjd1PgdwFxH9KbaCruuHTCaTr729/X9sNtu+6H1qEUJcCOBVZv6J3W43mHkfgJuY+b3o+bcCuNjhcMSaMkhmXiGlfMJms/08OsZJgUCg1mq13qLr+sN2u/0RAOMBjCeiT3Vdf09RlM9sNts9QojNzPw9AO6amhrDZrNtEUJ83W63e5n5XACnEFGu3W4f2ftEiWgFgIccDodFSllERE7DMFaoqpp0yf3vZvln2A3oZa65+EkgrFxHxHcA5ADQ5Z8IRPRVMTQC9CgZ+iOVGg5F9mKOHyK6TX1dTBz2e00m0wFm3gsgVm/zD8QIESnli0T0LgBomnYnET0T3UHLEEJ8Karr6gERLQawQ0p5PYCRzDyvtra2VdO0OinlPGYeT0QXMfNPNU27L3rMasMw1nUNWIi3iOh1APB4PD8joioAX2HmUVHF/Ka6urq9QoiLAUwjosVE9KnFYvl27/HU19fvFkKcIaUcQUSXMfOjmqaVzZgxI5+I1huG8b3o+T3NzD8zmUzTo2N6nojqieg8AL+aNWvWkuj37yCyswoAqKur20lEZwoh8pl5PjM/5PF4lkbrfpOIPo4KgClCiIs3b968f9asWb8A8CiAa4jobCL6ltvt/puUcl90hw+apr3NzNdIKR2IBPi73e12Px1t94XovQIAMPNfmHltTU2NERUEkFJeL4TQAVyI+G/Fn+m63hC9xj9k5keY+RJmzpJSnqNpWmd0z3t1XY+bZUnTtO3MfDaAQma+lIh+5Xa7fxwd4xtE9KfNmze3CyG+jIgAKTEM43ZENkEsbrd7BzPPJyIbETkB/M3n890JAOFweCUiL6DM2OfS4/GsBPBjIjpFCLE3FAqdt23btmBWVtYdAN4B8DUAM4UQl7vd7h1R05zTiCgdkWX3s263+w4ACAaDd0YF5MXR+3ougFoiygDwcqfwBAC32/0qEV3HzNMBmIQQZ0XbrmXmZzrrKYqyC1GVwImEqxb+qjrjycoNcjaBLkU0ymkvDgJ8V5iNSZUb9P9doSXNrnXMGI7WMEBsNts9RDRO07Tv/LvHMswwx4qls9ULGPJBgGYR8ITZatzt+vjYxOQfCCkH8BtmmGH+77Big/7ut+bi5FxpmlX9WfiEyfP4/wEExBzwn2ZBRgAAAABJRU5ErkJggg=="

/***/ },
/* 1451 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	
	__webpack_require__(1452);
	__webpack_require__(1307);
	__webpack_require__(1453);
	
	var app = __webpack_require__(24).get('apps/timelion', ['angular-sortable-view']);
	var html = __webpack_require__(1454);
	
	app.directive('timelionCells', function () {
	  return {
	    restrict: 'E',
	    scope: {
	      sheet: '=',
	      state: '=',
	      transient: '=',
	      onSearch: '=',
	      onSelect: '='
	    },
	    template: html,
	    link: function link($scope, $elem) {
	
	      $scope.removeCell = function (index) {
	        _.pullAt($scope.state.sheet, index);
	        $scope.onSearch();
	      };
	
	      $scope.dropCell = function (item, partFrom, partTo, indexFrom, indexTo) {
	        $scope.onSelect(indexTo);
	        _.move($scope.sheet, indexFrom, indexTo);
	      };
	    }
	  };
	});

/***/ },
/* 1452 */
/***/ function(module, exports) {

	//
	// Copyright Kamil Pkala http://github.com/kamilkp
	// angular-sortable-view v0.0.15 2015/01/18
	//
	
	;(function(window, angular){
		'use strict';
		/* jshint eqnull:true */
		/* jshint -W041 */
		/* jshint -W030 */
	
		var module = angular.module('angular-sortable-view', []);
		module.directive('svRoot', [function(){
			function shouldBeAfter(elem, pointer, isGrid){
				return isGrid ? elem.x - pointer.x < 0 : elem.y - pointer.y < 0;
			}
			function getSortableElements(key){
				return ROOTS_MAP[key];
			}
			function removeSortableElements(key){
				delete ROOTS_MAP[key];
			}
	
			var sortingInProgress;
			var ROOTS_MAP = Object.create(null);
			// window.ROOTS_MAP = ROOTS_MAP; // for debug purposes
	
			return {
				restrict: 'A',
				controller: ['$scope', '$attrs', '$interpolate', '$parse', function($scope, $attrs, $interpolate, $parse){
					var mapKey = $interpolate($attrs.svRoot)($scope) || $scope.$id;
					if(!ROOTS_MAP[mapKey]) ROOTS_MAP[mapKey] = [];
	
					var that         = this;
					var candidates;  // set of possible destinations
					var $placeholder;// placeholder element
					var options;     // sortable options
					var $helper;     // helper element - the one thats being dragged around with the mouse pointer
					var $original;   // original element
					var $target;     // last best candidate
					var isGrid       = false;
					var onSort       = $parse($attrs.svOnSort);
	
					// ----- hack due to https://github.com/angular/angular.js/issues/8044
					$attrs.svOnStart = $attrs.$$element[0].attributes['sv-on-start'];
					$attrs.svOnStart = $attrs.svOnStart && $attrs.svOnStart.value;
	
					$attrs.svOnStop = $attrs.$$element[0].attributes['sv-on-stop'];
					$attrs.svOnStop = $attrs.svOnStop && $attrs.svOnStop.value;
					// -------------------------------------------------------------------
	
					var onStart = $parse($attrs.svOnStart);
					var onStop = $parse($attrs.svOnStop);
	
					this.sortingInProgress = function(){
						return sortingInProgress;
					};
	
					if($attrs.svGrid){ // sv-grid determined explicite
						isGrid = $attrs.svGrid === "true" ? true : $attrs.svGrid === "false" ? false : null;
						if(isGrid === null)
							throw 'Invalid value of sv-grid attribute';
					}
					else{
						// check if at least one of the lists have a grid like layout
						$scope.$watchCollection(function(){
							return getSortableElements(mapKey);
						}, function(collection){
							isGrid = false;
							var array = collection.filter(function(item){
								return !item.container;
							}).map(function(item){
								return {
									part: item.getPart().id,
									y: item.element[0].getBoundingClientRect().top
								};
							});
							var dict = Object.create(null);
							array.forEach(function(item){
								if(dict[item.part])
									dict[item.part].push(item.y);
								else
									dict[item.part] = [item.y];
							});
							Object.keys(dict).forEach(function(key){
								dict[key].sort();
								dict[key].forEach(function(item, index){
									if(index < dict[key].length - 1){
										if(item > 0 && item === dict[key][index + 1]){
											isGrid = true;
										}
									}
								});
							});
						});
					}
	
					this.$moveUpdate = function(opts, mouse, svElement, svOriginal, svPlaceholder, originatingPart, originatingIndex){
						var svRect = svElement[0].getBoundingClientRect();
						if(opts.tolerance === 'element')
							mouse = {
								x: ~~(svRect.left + svRect.width/2),
								y: ~~(svRect.top + svRect.height/2)
							};
	
						sortingInProgress = true;
						candidates = [];
						if(!$placeholder){
							if(svPlaceholder){ // custom placeholder
								$placeholder = svPlaceholder.clone();
								$placeholder.removeClass('ng-hide');
							}
							else{ // default placeholder
								$placeholder = svOriginal.clone();
								$placeholder.addClass('sv-visibility-hidden');
								$placeholder.addClass('sv-placeholder');
								$placeholder.css({
									'height': svRect.height + 'px',
									'width': svRect.width + 'px'
								});
							}
	
							svOriginal.after($placeholder);
							svOriginal.addClass('ng-hide');
	
							// cache options, helper and original element reference
							$original = svOriginal;
							options = opts;
							$helper = svElement;
	
							onStart($scope, {
								$helper: {element: $helper},
								$part: originatingPart.model(originatingPart.scope),
								$index: originatingIndex,
								$item: originatingPart.model(originatingPart.scope)[originatingIndex]
							});
							$scope.$root && $scope.$root.$$phase || $scope.$apply();
						}
	
						// ----- move the element
						$helper[0].reposition({
							x: mouse.x + document.body.scrollLeft - mouse.offset.x*svRect.width,
							y: mouse.y + document.body.scrollTop - mouse.offset.y*svRect.height
						});
	
						// ----- manage candidates
						getSortableElements(mapKey).forEach(function(se, index){
							if(opts.containment != null){
								// TODO: optimize this since it could be calculated only once when the moving begins
								if(
									!elementMatchesSelector(se.element, opts.containment) &&
									!elementMatchesSelector(se.element, opts.containment + ' *')
								) return; // element is not within allowed containment
							}
							var rect = se.element[0].getBoundingClientRect();
							var center = {
								x: ~~(rect.left + rect.width/2),
								y: ~~(rect.top + rect.height/2)
							};
							if(!se.container && // not the container element
								(se.element[0].scrollHeight || se.element[0].scrollWidth)){ // element is visible
								candidates.push({
									element: se.element,
									q: (center.x - mouse.x)*(center.x - mouse.x) + (center.y - mouse.y)*(center.y - mouse.y),
									view: se.getPart(),
									targetIndex: se.getIndex(),
									after: shouldBeAfter(center, mouse, isGrid)
								});
							}
							if(se.container && !se.element[0].querySelector('[sv-element]:not(.sv-placeholder):not(.sv-source)')){ // empty container
								candidates.push({
									element: se.element,
									q: (center.x - mouse.x)*(center.x - mouse.x) + (center.y - mouse.y)*(center.y - mouse.y),
									view: se.getPart(),
									targetIndex: 0,
									container: true
								});
							}
						});
						var pRect = $placeholder[0].getBoundingClientRect();
						var pCenter = {
							x: ~~(pRect.left + pRect.width/2),
							y: ~~(pRect.top + pRect.height/2)
						};
						candidates.push({
							q: (pCenter.x - mouse.x)*(pCenter.x - mouse.x) + (pCenter.y - mouse.y)*(pCenter.y - mouse.y),
							element: $placeholder,
							placeholder: true
						});
						candidates.sort(function(a, b){
							return a.q - b.q;
						});
	
						candidates.forEach(function(cand, index){
							if(index === 0 && !cand.placeholder && !cand.container){
								$target = cand;
								cand.element.addClass('sv-candidate');
								if(cand.after)
									cand.element.after($placeholder);
								else
									insertElementBefore(cand.element, $placeholder);
							}
							else if(index === 0 && cand.container){
								$target = cand;
								cand.element.append($placeholder);
							}
							else
								cand.element.removeClass('sv-candidate');
						});
					};
	
					this.$drop = function(originatingPart, index, options){
						if(!$placeholder) return;
	
						if(options.revert){
							var placeholderRect = $placeholder[0].getBoundingClientRect();
							var helperRect = $helper[0].getBoundingClientRect();
							var distance = Math.sqrt(
								Math.pow(helperRect.top - placeholderRect.top, 2) +
								Math.pow(helperRect.left - placeholderRect.left, 2)
							);
	
							var duration = +options.revert*distance/200; // constant speed: duration depends on distance
							duration = Math.min(duration, +options.revert); // however it's not longer that options.revert
	
							['-webkit-', '-moz-', '-ms-', '-o-', ''].forEach(function(prefix){
								if(typeof $helper[0].style[prefix + 'transition'] !== "undefined")
									$helper[0].style[prefix + 'transition'] = 'all ' + duration + 'ms ease';
							});
							setTimeout(afterRevert, duration);
							$helper.css({
								'top': placeholderRect.top + document.body.scrollTop + 'px',
								'left': placeholderRect.left + document.body.scrollLeft + 'px'
							});
						}
						else
							afterRevert();
	
						function afterRevert(){
							sortingInProgress = false;
							$placeholder.remove();
							$helper.remove();
							$original.removeClass('ng-hide');
	
							candidates = void 0;
							$placeholder = void 0;
							options = void 0;
							$helper = void 0;
							$original = void 0;
	
							// sv-on-stop callback
							onStop($scope, {
								$part: originatingPart.model(originatingPart.scope),
								$index: index,
								$item: originatingPart.model(originatingPart.scope)[index]
							});
	
							if($target){
								$target.element.removeClass('sv-candidate');
								var spliced = originatingPart.model(originatingPart.scope).splice(index, 1);
								var targetIndex = $target.targetIndex;
								if($target.view === originatingPart && $target.targetIndex > index)
									targetIndex--;
								if($target.after)
									targetIndex++;
								$target.view.model($target.view.scope).splice(targetIndex, 0, spliced[0]);
	
								// sv-on-sort callback
								if($target.view !== originatingPart || index !== targetIndex)
									onSort($scope, {
										$partTo: $target.view.model($target.view.scope),
										$partFrom: originatingPart.model(originatingPart.scope),
										$item: spliced[0],
										$indexTo: targetIndex,
										$indexFrom: index
									});
	
							}
							$target = void 0;
	
							$scope.$root && $scope.$root.$$phase || $scope.$apply();
						}
					};
	
					this.addToSortableElements = function(se){
						getSortableElements(mapKey).push(se);
					};
					this.removeFromSortableElements = function(se){
						var elems = getSortableElements(mapKey);
						var index = elems.indexOf(se);
						if(index > -1){
							elems.splice(index, 1);
							if(elems.length === 0)
								removeSortableElements(mapKey);
						}
					};
				}]
			};
		}]);
	
		module.directive('svPart', ['$parse', function($parse){
			return {
				restrict: 'A',
				require: '^svRoot',
				controller: ['$scope', function($scope){
					$scope.$ctrl = this;
					this.getPart = function(){
						return $scope.part;
					};
					this.$drop = function(index, options){
						$scope.$sortableRoot.$drop($scope.part, index, options);
					};
				}],
				scope: true,
				link: function($scope, $element, $attrs, $sortable){
					if(!$attrs.svPart) throw new Error('no model provided');
					var model = $parse($attrs.svPart);
					if(!model.assign) throw new Error('model not assignable');
	
					$scope.part = {
						id: $scope.$id,
						element: $element,
						model: model,
						scope: $scope
					};
					$scope.$sortableRoot = $sortable;
	
					var sortablePart = {
						element: $element,
						getPart: $scope.$ctrl.getPart,
						container: true
					};
					$sortable.addToSortableElements(sortablePart);
					$scope.$on('$destroy', function(){
						$sortable.removeFromSortableElements(sortablePart);
					});
				}
			};
		}]);
	
		module.directive('svElement', ['$parse', function($parse){
			return {
				restrict: 'A',
				require: ['^svPart', '^svRoot'],
				controller: ['$scope', function($scope){
					$scope.$ctrl = this;
				}],
				link: function($scope, $element, $attrs, $controllers){
					var sortableElement = {
						element: $element,
						getPart: $controllers[0].getPart,
						getIndex: function(){
							return $scope.$index;
						}
					};
					$controllers[1].addToSortableElements(sortableElement);
					$scope.$on('$destroy', function(){
						$controllers[1].removeFromSortableElements(sortableElement);
					});
	
					var handle = $element;
					handle.on('mousedown touchstart', onMousedown);
					$scope.$watch('$ctrl.handle', function(customHandle){
						if(customHandle){
							handle.off('mousedown touchstart', onMousedown);
							handle = customHandle;
							handle.on('mousedown touchstart', onMousedown);
						}
					});
	
					var helper;
					$scope.$watch('$ctrl.helper', function(customHelper){
						if(customHelper){
							helper = customHelper;
						}
					});
	
					var placeholder;
					$scope.$watch('$ctrl.placeholder', function(customPlaceholder){
						if(customPlaceholder){
							placeholder = customPlaceholder;
						}
					});
	
					var body = angular.element(document.body);
					var html = angular.element(document.documentElement);
	
					var moveExecuted;
	
					function onMousedown(e){
						touchFix(e);
	
						if($controllers[1].sortingInProgress()) return;
						if(e.button != 0 && e.type === 'mousedown') return;
	
						moveExecuted = false;
						var opts = $parse($attrs.svElement)($scope);
						opts = angular.extend({}, {
							tolerance: 'pointer',
							revert: 200,
							containment: 'html'
						}, opts);
						if(opts.containment){
							var containmentRect = closestElement.call($element, opts.containment)[0].getBoundingClientRect();
						}
	
						var target = $element;
						var clientRect = $element[0].getBoundingClientRect();
						var clone;
	
						if(!helper) helper = $controllers[0].helper;
						if(!placeholder) placeholder = $controllers[0].placeholder;
						if(helper){
							clone = helper.clone();
							clone.removeClass('ng-hide');
							clone.css({
								'left': clientRect.left + document.body.scrollLeft + 'px',
								'top': clientRect.top + document.body.scrollTop + 'px'
							});
							target.addClass('sv-visibility-hidden');
						}
						else{
							clone = target.clone();
							clone.addClass('sv-helper').css({
								'left': clientRect.left + document.body.scrollLeft + 'px',
								'top': clientRect.top + document.body.scrollTop + 'px',
								'width': clientRect.width + 'px'
							});
						}
	
						clone[0].reposition = function(coords){
							var targetLeft = coords.x;
							var targetTop = coords.y;
							var helperRect = clone[0].getBoundingClientRect();
	
							var body = document.body;
	
							if(containmentRect){
								if(targetTop < containmentRect.top + body.scrollTop) // top boundary
									targetTop = containmentRect.top + body.scrollTop;
								if(targetTop + helperRect.height > containmentRect.top + body.scrollTop + containmentRect.height) // bottom boundary
									targetTop = containmentRect.top + body.scrollTop + containmentRect.height - helperRect.height;
								if(targetLeft < containmentRect.left + body.scrollLeft) // left boundary
									targetLeft = containmentRect.left + body.scrollLeft;
								if(targetLeft + helperRect.width > containmentRect.left + body.scrollLeft + containmentRect.width) // right boundary
									targetLeft = containmentRect.left + body.scrollLeft + containmentRect.width - helperRect.width;
							}
							this.style.left = targetLeft - body.scrollLeft + 'px';
							this.style.top = targetTop - body.scrollTop + 'px';
						};
	
						var pointerOffset = {
							x: (e.clientX - clientRect.left)/clientRect.width,
							y: (e.clientY - clientRect.top)/clientRect.height
						};
						html.addClass('sv-sorting-in-progress');
						html.on('mousemove touchmove', onMousemove).on('mouseup touchend touchcancel', function mouseup(e){
							html.off('mousemove touchmove', onMousemove);
							html.off('mouseup touchend', mouseup);
							html.removeClass('sv-sorting-in-progress');
							if(moveExecuted){
								$controllers[0].$drop($scope.$index, opts);
							}
							$element.removeClass('sv-visibility-hidden');
						});
	
						// onMousemove(e);
						function onMousemove(e){
							touchFix(e);
							if(!moveExecuted){
								$element.parent().prepend(clone);
								moveExecuted = true;
							}
							$controllers[1].$moveUpdate(opts, {
								x: e.clientX,
								y: e.clientY,
								offset: pointerOffset
							}, clone, $element, placeholder, $controllers[0].getPart(), $scope.$index);
						}
					}
				}
			};
		}]);
	
		module.directive('svHandle', function(){
			return {
				require: '?^svElement',
				link: function($scope, $element, $attrs, $ctrl){
					if($ctrl)
						$ctrl.handle = $element.add($ctrl.handle); // support multiple handles
				}
			};
		});
	
		module.directive('svHelper', function(){
			return {
				require: ['?^svPart', '?^svElement'],
				link: function($scope, $element, $attrs, $ctrl){
					$element.addClass('sv-helper').addClass('ng-hide');
					if($ctrl[1])
						$ctrl[1].helper = $element;
					else if($ctrl[0])
						$ctrl[0].helper = $element;
				}
			};
		});
	
		module.directive('svPlaceholder', function(){
			return {
				require: ['?^svPart', '?^svElement'],
				link: function($scope, $element, $attrs, $ctrl){
					$element.addClass('sv-placeholder').addClass('ng-hide');
					if($ctrl[1])
						$ctrl[1].placeholder = $element;
					else if($ctrl[0])
						$ctrl[0].placeholder = $element;
				}
			};
		});
	
		angular.element(document.head).append([
			'<style>' +
			'.sv-helper{' +
				'position: fixed !important;' +
				'z-index: 99999;' +
				'margin: 0 !important;' +
			'}' +
			'.sv-candidate{' +
			'}' +
			'.sv-placeholder{' +
				// 'opacity: 0;' +
			'}' +
			'.sv-sorting-in-progress{' +
				'-webkit-user-select: none;' +
				'-moz-user-select: none;' +
				'-ms-user-select: none;' +
				'user-select: none;' +
			'}' +
			'.sv-visibility-hidden{' +
				'visibility: hidden !important;' +
				'opacity: 0 !important;' +
			'}' +
			'</style>'
		].join(''));
	
		function touchFix(e){
			if(!('clientX' in e) && !('clientY' in e)) {
				var touches = e.touches || e.originalEvent.touches;
				if(touches && touches.length) {
					e.clientX = touches[0].clientX;
					e.clientY = touches[0].clientY;
				}
				e.preventDefault();
			}
		}
	
		function getPreviousSibling(element){
			element = element[0];
			if(element.previousElementSibling)
				return angular.element(element.previousElementSibling);
			else{
				var sib = element.previousSibling;
				while(sib != null && sib.nodeType != 1)
					sib = sib.previousSibling;
				return angular.element(sib);
			}
		}
	
		function insertElementBefore(element, newElement){
			var prevSibl = getPreviousSibling(element);
			if(prevSibl.length > 0){
				prevSibl.after(newElement);
			}
			else{
				element.parent().prepend(newElement);
			}
		}
	
		var dde = document.documentElement,
		matchingFunction = dde.matches ? 'matches' :
							dde.matchesSelector ? 'matchesSelector' :
							dde.webkitMatches ? 'webkitMatches' :
							dde.webkitMatchesSelector ? 'webkitMatchesSelector' :
							dde.msMatches ? 'msMatches' :
							dde.msMatchesSelector ? 'msMatchesSelector' :
							dde.mozMatches ? 'mozMatches' :
							dde.mozMatchesSelector ? 'mozMatchesSelector' : null;
		if(matchingFunction == null)
			throw 'This browser doesn\'t support the HTMLElement.matches method';
	
		function elementMatchesSelector(element, selector){
			if(element instanceof angular.element) element = element[0];
			if(matchingFunction !== null)
				return element[matchingFunction](selector);
		}
	
		var closestElement = angular.element.prototype.closest || function (selector){
			var el = this[0].parentNode;
			while(el !== document.documentElement && !el[matchingFunction](selector))
				el = el.parentNode;
	
			if(el[matchingFunction](selector))
				return angular.element(el);
			else
				return angular.element();
		};
	
		/*
			Simple implementation of jQuery's .add method
		 */
		if(typeof angular.element.prototype.add !== 'function'){
			angular.element.prototype.add = function(elem){
				var i, res = angular.element();
				elem = angular.element(elem);
				for(i=0;i<this.length;i++){
					res.push(this[i]);
				}
				for(i=0;i<elem.length;i++){
					res.push(elem[i]);
				}
				return res;
			};
		}
	
	})(window, window.angular);

/***/ },
/* 1453 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	
	var app = __webpack_require__(24).get('apps/timelion', []);
	app.directive('timelionGrid', function ($compile) {
	  return {
	    restrict: 'A',
	    scope: {
	      timelionGridRows: '=',
	      timelionGridColumns: '='
	    },
	    link: function link($scope, $elem, attrs) {
	
	      function init() {
	        setDimensions();
	      }
	
	      $scope.$on('$destroy', function () {
	        $(window).off('resize'); //remove the handler added earlier
	      });
	
	      $(window).resize(function () {
	        setDimensions();
	      });
	
	      $scope.$watchMulti(['timelionGridColumns', 'timelionGridRows'], function () {
	        setDimensions();
	      });
	
	      function setDimensions() {
	        var borderSize = 2;
	        var headerSize = 45 + 35 + 28 + 20 * 2; // chrome + subnav + buttons + (container padding)
	        var verticalPadding = 10;
	
	        if ($scope.timelionGridColumns != null) {
	          $elem.width($elem.parent().width() / $scope.timelionGridColumns - borderSize * 2);
	        }
	
	        if ($scope.timelionGridRows != null) {
	          $elem.height(($(window).height() - headerSize) / $scope.timelionGridRows - (verticalPadding + borderSize * 2));
	        }
	      }
	
	      init();
	    }
	  };
	});

/***/ },
/* 1454 */
/***/ function(module, exports) {

	module.exports = "<div sv-root\n  sv-part=\"state.sheet\"\n  sv-on-sort=\"dropCell($item, $partFrom, $partTo, $indexFrom, $indexTo)\"\n  >\n\n  <div sv-element\n    ng-repeat=\"cell in state.sheet track by $index\"\n    class=\"chart-container col-md-{{12 / state.columns}} col-sm-12 col-xs-12\"\n    timelion-grid timelion-grid-rows=\"state.rows\"\n    ng-click=\"onSelect($index)\"\n    ng-class=\"{active: $index === state.selected}\"\n    >\n\n    <div chart=\"sheet[$index]\" search=\"onSearch\" interval=\"state.interval\"></div>\n    <div class=\"cell-actions\">\n      <div class=\"cell-id\"><span>{{$index + 1}}</span></div>\n\n      <div class=\"cell-action\" ng-click=\"removeCell($index)\" tooltip=\"Remove\" tooltip-append-to-body=\"1\"><span class=\"fa fa-remove\"></span></div>\n      <div class=\"cell-action\" tooltip=\"Drag to reorder\" tooltip-append-to-body=\"1\" sv-handle><span class=\"fa fa-arrows\"></span></div>\n      <div class=\"cell-action\" ng-click=\"transient.fullscreen = true\" tooltip=\"Full screen\" tooltip-append-to-body=\"1\"><span class=\"fa fa-expand\"></span></div>\n    </div>\n  </div>\n\n</div>\n"

/***/ },
/* 1455 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	
	__webpack_require__(1452);
	__webpack_require__(1307);
	__webpack_require__(1453);
	
	var app = __webpack_require__(24).get('apps/timelion', ['angular-sortable-view']);
	var html = __webpack_require__(1456);
	
	app.directive('timelionFullscreen', function () {
	  return {
	    restrict: 'E',
	    scope: {
	      expression: '=',
	      series: '=',
	      state: '=',
	      transient: '=',
	      onSearch: '='
	    },
	    template: html
	  };
	});

/***/ },
/* 1456 */
/***/ function(module, exports) {

	module.exports = "<div class=\"chart-container col-md-12 col-sm-12 col-xs-12\" timelion-grid timelion-grid-rows=\"1\">\n  <div  chart=\"series\" search=\"onSearch\" interval=\"state.interval\"></div>\n  <div class=\"cell-actions\">\n    <div class=\"cell-fullscreen\" ng-click=\"transient.fullscreen = false\" tooltip=\"Exit full screen\" tooltip-append-to-body=\"1\">\n      <span class=\"fa fa-compress\"></span>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 1457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(3);
	var $ = __webpack_require__(18);
	
	var app = __webpack_require__(24).get('apps/timelion', []);
	app.directive('fixedElementRoot', function ($timeout) {
	  return {
	    restrict: 'A',
	    link: function link($scope, $elem, attrs) {
	      var fixedAt = undefined;
	      $(window).bind('scroll', function () {
	        var fixed = $('[fixed-element]', $elem);
	        var body = $('[fixed-element-body]', $elem);
	        var top = fixed.offset().top;
	
	        if ($(window).scrollTop() > top) {
	          // This is a gross hack, but its better than it was. I guess
	          fixedAt = $(window).scrollTop();
	          fixed.addClass(fixed.attr('fixed-element'));
	          body.addClass(fixed.attr('fixed-element-body'));
	          body.css({ top: fixed.height() });
	        }
	
	        if ($(window).scrollTop() < fixedAt) {
	          fixed.removeClass(fixed.attr('fixed-element'));
	          body.removeClass(fixed.attr('fixed-element-body'));
	          body.removeAttr('style');
	        }
	      });
	    }
	  };
	});

/***/ },
/* 1458 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(1459);
	__webpack_require__(24);
	__webpack_require__(3);
	__webpack_require__(235);
	
	'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var html = __webpack_require__(1459);
	  var app = __webpack_require__(24).get('apps/timelion', []);
	  var _ = __webpack_require__(3);
	  var moment = __webpack_require__(235);
	
	  app.directive('timelionDocs', function (config, $http) {
	    return {
	      restrict: 'E',
	      template: html,
	      controller: function controller($scope, config) {
	        $scope.section = config.get('timelion:showTutorial', true) ? 'tutorial' : 'functions';
	        $scope.page = 1;
	        $scope.functions = {
	          list: [],
	          details: null
	        };
	
	        function init() {
	          $scope.es = {
	            invalidCount: 0
	          };
	          getFunctions();
	          checkElasticsearch();
	        }
	
	        function getFunctions() {
	          return $http.get('../api/timelion/functions').then(function (resp) {
	            $scope.functions.list = resp.data;
	          });
	        }
	        $scope.recheckElasticsearch = function () {
	          $scope.es.valid = null;
	          checkElasticsearch().then(function (valid) {
	            if (!valid) $scope.es.invalidCount++;
	          });
	        };
	
	        function checkElasticsearch() {
	          return $http.get('../api/timelion/validate/es').then(function (resp) {
	            if (resp.data.ok) {
	
	              $scope.es.valid = true;
	              $scope.es.stats = {
	                min: moment(resp.data.min).format('LLL'),
	                max: moment(resp.data.max).format('LLL'),
	                field: resp.data.field
	              };
	            } else {
	              $scope.es.valid = false;
	              $scope.es.invalidReason = (function () {
	                try {
	                  var esResp = JSON.parse(resp.data.resp.response);
	                  return _.get(esResp, 'error.root_cause[0].reason');
	                } catch (e) {
	                  if (_.get(resp, 'data.resp.message')) return _.get(resp, 'data.resp.message');
	                  if (_.get(resp, 'data.resp.output.payload.message')) return _.get(resp, 'data.resp.output.payload.message');
	                  return 'Unknown error';
	                }
	              })();
	            }
	            return $scope.es.valid;
	          });
	        }
	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 1459 */
/***/ function(module, exports) {

	module.exports = "<div ng-show=\"section === 'tutorial'\">\n  <div ng-show=\"page === 1\">\n    <div class=\"doc-container-content\">\n      <h1>Welcome to <strong>Timelion</strong>!</h1>\n      <p>\n        Timelion is the clawing, gnashing, zebra killing, pluggable time\n        series interface for <em>everything</em>. If your datastore can\n        produce a time series, then you have all of the awesome power of\n        Timelion at your disposal. Timelion lets you compare, combine, and\n        combobulate datasets across multiple datasources with one\n        easy-to-master expression syntax. This tutorial focuses on\n        Elasticsearch, but you'll quickly discover that what you learn here\n        applies to any datasource Timelion supports.\n      </p>\n      <p>\n        Ready to get started? Click <strong>Next</strong>. Want to skip the\n        tutorial and view the docs? <a ng-click=\"section = 'functions'\">\n        Jump to the function reference</a>.\n      </p>\n    </div>\n    <div class=\"doc-container-buttons\">\n      <button\n        ng-click=\"opts.dontShowHelp()\"\n        class=\"btn btn-default btn-doc-prev\"\n      >\n        Don't show this again\n      </button>\n      <button\n        ng-click=\"page = page+1\"\n        class=\"btn btn-primary btn-doc-next\"\n      >\n        Next\n      </button>\n    </div>\n  </div>\n  <div ng-show=\"page === 2\">\n    <div ng-show=\"!es.valid\">\n      <div class=\"doc-container-content\">\n        <h2>First time configuration</h2>\n        <p>\n          If you're using Logstash, you don't need to configure anything to\n          start exploring your log data with Timelion. To search other\n          indices, go to <strong>Management / Kibana / Advanced Settings\n          </strong> and configure the <code>timelion:es.default_index</code>\n          and <code>timelion:es.timefield</code> settings to match your\n          indices.\n        </p>\n        <p>\n          You'll also see some other Timelion settings. For now, you don't need\n          to worry about them. Later, you'll see that you can set most of\n          them on the fly if you need to.\n        </p>\n      </div>\n      <div class=\"doc-container-buttons\">\n        <button\n          ng-click=\"page = page-1\"\n          class=\"btn btn-primary btn-doc-prev\"\n        >\n          Previous\n        </button>\n        <span ng-show=\"es.invalidCount > 0 && !es.valid\">\n          Could not validate Elasticsearch settings:\n          <strong>{{es.invalidReason}}.</strong> Check your Advanced Settings\n          and try again. ({{es.invalidCount}})\n        </span>\n        <button\n          ng-click=\"recheckElasticsearch()\"\n          class=\"btn btn-success btn-doc-next\"\n        >\n          Validate Config\n        </button>\n      </div>\n    </div>\n    <div ng-show=\"es.valid\">\n      <div class=\"doc-container-content\">\n        <h2>Good news, Elasticsearch is configured correctly!</h2>\n        <p>\n          We validated your default index and your timefield and everything\n          looks ok. We found data from <strong>{{es.stats.min}}</strong> to\n          <strong>{{es.stats.max}}</strong>. You're probably all set. If this\n          doesn't look right, see <a ng-click=\"es.valid = false\">First time\n          configuration</a> for information about configuring the Elasticsearch\n          datasource.\n        </p>\n        <p>\n          You should already see one chart, but you might need to make a\n          couple adjustments before you see any interesting data:\n        </p>\n        <ul>\n          <li>\n            <strong>Intervals</strong>\n            <p>\n              The interval selector at the right of the input bar lets you\n              control the sampling frequency. It's currently set to\n              <code>{{state.interval}}</code>.\n              <span ng-show=\"state.interval == 'auto'\">\n                <strong>You're all set!</strong>\n              </span>\n              <span ng-show=\"state.interval != 'auto'\">\n                Set it to <code>auto </code> to let Timelion choose an\n                appropriate interval.\n              </span>\n              If Timelion thinks your combination of time range and interval\n              will produce too many data points, it throws an error. You can\n              adjust that limit by configuring <code>timelion:max_buckets</code>\n              in <strong>Management/Kibana/Advanced Settings</strong>.\n            </p>\n          </li>\n          <li>\n            <strong>Time range</strong>\n            <p>\n              Use the timepicker <i class=\"fa fa-clock-o\"></i> in the\n              Kibana toolbar to select the time period that contains the\n              data you want to visualize. Make sure you select a time\n              period that includes all or part of the time range shown\n              above.\n            </p>\n          </li>\n        </ul>\n        <p>\n          Now, you should see a line chart that displays a count of your\n          data points over time.\n        </p>\n      </div>\n      <div class=\"doc-container-buttons\">\n        <button\n          ng-click=\"page = page-1\"\n          class=\"btn btn-primary btn-doc-prev\"\n        >\n          Previous\n        </button>\n        <button\n          ng-click=\"page = page+1\"\n          class=\"btn btn-primary btn-doc-next\"\n        >\n          Next\n        </button>\n      </div>\n    </div>\n  </div>\n  <div ng-show=\"page === 3\">\n    <div class=\"doc-container-content\">\n      <h2>Querying the Elasticsearch datasource</h2>\n      <p>\n        Now that we've validated that you have a working Elasticsearch\n        datasource, you can start submitting queries. For starters,\n        enter <code>.es(*)</code> in the input bar and hit enter.\n      </p>\n      <p>\n        This says <em>hey Elasticsearch, find everything in my default\n        index</em>. If you want to find a subset, you could enter something\n        like <code>.es(html)</code> to count events that match <em>html</em>,\n        or <code>.es('user:bob AND bytes:>100')</code> to find events\n        that contain <em>bob</em> in the <code>user</code> field and have a\n        <code>bytes</code> field that is greater than 100. Note that this query\n        is enclosed in single quotes&mdash;that's because it contains\n        spaces. You can enter any\n        <a\n           href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.1/query-dsl-query-string-query.html#query-string-syntax\"\n           target=\"_blank\"\n        >\n          Lucene query string\n        </a>\n        as the first argument to the <code>.es()</code> function.\n      </p>\n      <h4>Passing arguments</h4>\n      <p>\n        Timelion has a number of shortcuts that make it easy to do common\n        things. One is that for simple arguments that don't contain spaces or\n        special characters, you don't need to use quotes. Many functions also\n        have defaults. For example, <code>.es()</code> and <code>.es(*)</code>\n        do the same thing. Arguments also have names, so you don't have to\n        specify them in a specific order. For example, you can enter\n        <code>.es(index='logstash-*', q='*')</code> to tell the\n        Elasticsearch datasource <em>use * as the q (query) for the\n        logstash-* index</em>.\n      </p>\n      <h4>Beyond count</h4>\n      <p>\n        Counting events is all well and good, but the Elasticsearch datasource\n        also supports any\n        <a\n           href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html\"\n           target=\"_blank\"\n        >\n          Elasticsearch metric aggregation\n        </a>\n        that returns a single value. Some of the most useful are\n        <code>min</code>, <code>max</code>, <code>avg</code>, <code>sum</code>,\n        and <code>cardinality</code>. Let's say you want a unique count of the\n        <code>src_ip</code> field. Simply use the <code>cardinality</code>\n        metric: <code>.es(*, metric='cardinality:src_ip')</code>. To get the\n        average of the <code>bytes</code> field, you can use the\n        <code>avg</code> metric: <code>.es(metric='avg:bytes')</code>.\n      </p>\n    </div>\n    <div class=\"doc-container-buttons\">\n      <button\n        ng-click=\"page = page-1\"\n        class=\"btn btn-primary btn-doc-prev\"\n      >\n        Previous\n      </button>\n      <button\n        ng-click=\"page = page+1\"\n        class=\"btn btn-primary btn-doc-next\"\n      >\n        Next\n      </button>\n    </div>\n  </div>\n\n  <div ng-show=\"page === 4\">\n    <div class=\"doc-container-content\">\n      <h2>Expressing yourself with expressions</h2>\n      <p>\n        Every  expression starts with a datasource function. From there, you\n        can append new functions to the datasource to transform and augment\n        it.\n      </p>\n      <p>\n        By the way, from here on out you probably know more about your data\n        than we do. Feel free to replace the sample queries with something\n        more meaningful!\n      </p>\n      <p>\n        We're going to experiment, so click <strong>Add</strong> in the Kibana\n        toolbar to add another chart or three. Then, select a chart, copy\n        one of the following expressions, paste it into the input bar,\n        and hit enter. Rinse, repeat to try out the other expressions.\n      </p>\n      <table class=\"table table-condensed table-striped\">\n        <tr>\n          <td><code>.es(*), .es(US)</code></td>\n          <td><strong>Double the fun.</strong> Two expressions on the same\n            chart.</td>\n        </tr>\n        <tr>\n          <td><code>.es(*).color(#f66), .es(US).bars(1)</code></td>\n          <td>\n            <strong>Custom styling.</strong> Colorizes the first series red\n            and uses 1 pixel wide bars for the second series.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>.es(*).color(#f66).lines(fill=3),\n            .es(US).bars(1).points(radius=3, weight=1)</code>\n          </td>\n          <td>\n            <strong>Named arguments.</strong> Forget trying to remember what\n            order you need to specify arguments in, use named arguments to make\n            the expressions easier to read and write.\n          </td>\n        </tr>\n        <tr>\n          <td><code>(.es(*), .es(GB)).points()</code></td>\n          <td>\n            <strong>Grouped expressions.</strong> You can also chain groups\n            of expressions to functions. Here, both series are shown as\n            points instead of lines.\n          </td>\n        </tr>\n      </table>\n      <p>\n        Timelion provides additional view transformation functions you can use\n        to customize the appearance of your charts. For the complete list, see\n        the <a ng-click=\"section = 'functions'\">Function reference</a>.\n      </p>\n    </div>\n    <div class=\"doc-container-buttons\">\n      <button\n        ng-click=\"page = page-1\"\n        class=\"btn btn-primary btn-doc-prev\"\n      >\n        Previous\n      </button>\n      <button\n        ng-click=\"page = page+1\"\n        class=\"btn btn-primary btn-doc-next\"\n      >\n        Next\n      </button>\n    </div>\n  </div>\n  <div ng-show=\"page === 5\">\n    <div class=\"doc-container-content\">\n      <h2>Transforming your data: the real fun begins!</h2>\n      <p>\n        Now that you've mastered the basics, it's time to unleash the power of\n        Timelion. Let's figure out what percentage some subset of our data\n        represents of the whole, over time. For example, what percentage of\n        our web traffic comes from the US?\n      </p>\n      <p>\n        First, we need to find all events that contain US:\n        <code>.es('US')</code>.\n      </p>\n      <p>\n        Next, we want to calculate the ratio of US events to the whole. To\n        divide <code>'US'</code> by everything, we can use the\n        <code>divide</code> function: <code>.es('US').divide(.es())</code>.\n      </p>\n      <p>\n        Not bad, but this gives us a number between 0 and 1. To convert it\n        to a percentage, simply multiply by 100:\n        <code>.es('US').divide(.es()).multiply(100)</code>.\n      </p>\n      <p>\n        Now we know what percentage of our traffic comes from the US, and\n        can see how it has changed over time!\n        Timelion has a number of built-in arithmetic functions, such as\n        <code>sum</code>, <code>subtract</code>, <code>multiply</code>, and\n        <code>divide</code>. Many of these can take a series or a number.\n        There are also other useful data transformation functions, such as\n        <code>movingaverage</code>, <code>abs</code>, and\n        <code>derivative</code>.\n      </p>\n      <p>Now that you're familiar with the syntax, refer to the\n        <a ng-click=\"section = 'functions'\">Function reference</a> to see\n        how to use all of the available Timelion functions. You can view\n        the reference at any time by clicking <strong>Docs</strong>\n        in the Kibana toolbar. To get back to this tutorial, click the\n        <strong>Tutorial</strong> link at the top of the reference.\n      </p>\n    </div>\n    <div class=\"doc-container-buttons\">\n      <button\n        ng-click=\"page = page-1\"\n        class=\"btn btn-primary btn-doc-prev\"\n      >\n        Previous\n      </button>\n\n      <button\n        ng-click=\"opts.dontShowHelp()\"\n        class=\"btn btn-default btn-doc-next\"\n      >\n        Don't show this again\n      </button>\n    </div>\n  </div>\n</div>\n<div ng-show=\"section === 'functions'\">\n  <div class=\"kuiLocalDropdownTitle\">\n    Function reference\n  </div>\n  <div class=\"kuiLocalDropdownHelpText\">\n    Click any function for more information. Just getting started?\n    <a ng-click=\"section = 'tutorial'\">Check out the tutorial</a>.\n  </div>\n  <div class=\"timelionFunctionsDropdownContent\">\n    <table class=\"table table-condensed table-bordered timelionFunctionsTable\">\n      <tr\n          class=\"timelionFunctionsTableRow\"\n          ng-repeat-start=\"function in functions.list\"\n          ng-class=\"{active: functions.details === function.name}\"\n          ng-click=\"functions.details =\n                    (functions.details === function.name ?\n                      null : function.name)\"\n      >\n        <td><strong>.{{function.name}}()</strong></td>\n        <td>{{function.help}}</td>\n      </tr>\n      <tr ng-if=\"functions.details === function.name\" ng-repeat-end>\n        <td colspan=2>\n          <div class=\"suggestion-details\" >\n            <table\n              class=\"table table-condensed table-bordered\n                     timelionFunctionDetailsTable\"\n              ng-show=\"function.args.length > (function.chainable ? 1: 0)\"\n            >\n              <thead>\n                <th>Argument Name</th>\n                <th>Accepted Types</th>\n                <th>Information</th>\n              </thead>\n              <tr\n                ng-repeat=\"arg in function.args\"\n                ng-hide=\"$index < 1 && function.chainable\"\n              >\n                <td>{{arg.name}}</td>\n                <td><em>{{arg.types.join(', ')}}</em></td>\n                <td>{{arg.help}}</td>\n              </tr>\n            </table>\n            <div ng-hide=\"function.args.length > (function.chainable ? 1: 0)\">\n              <em>\n                This function does not accept any arguments.\n                Well that's simple, isn't it?\n              </em>\n            </div>\n          </div>\n        </td>\n      </tr>\n    </table>\n  </div>\n</div>\n"

/***/ },
/* 1460 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 1461 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(806);
	__webpack_require__(24);
	__webpack_require__(3);
	__webpack_require__(1462);
	__webpack_require__(808);
	
	'use strict';
	
	var _uiCourierSaved_objectSaved_object_loader = __webpack_require__(806);
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(24).get('app/sheet');
	  var _ = __webpack_require__(3);
	  // bring in the factory
	  __webpack_require__(1462);
	
	  // Register this service with the saved object registry so it can be
	  // edited by the object editor.
	  __webpack_require__(808).register({
	    service: 'savedSheets',
	    title: 'sheets'
	  });
	
	  // This is the only thing that gets injected into controllers
	  module.service('savedSheets', function (Promise, SavedSheet, kbnIndex, esAdmin, kbnUrl) {
	    var savedSheetLoader = new _uiCourierSaved_objectSaved_object_loader.SavedObjectLoader(SavedSheet, kbnIndex, esAdmin, kbnUrl);
	    savedSheetLoader.urlFor = function (id) {
	      return kbnUrl.eval('#/{{id}}', { id: id });
	    };
	    savedSheetLoader.loaderProperties = {
	      name: 'timelion-sheet',
	      noun: 'Saved Sheets',
	      nouns: 'saved sheets'
	    };
	    return savedSheetLoader;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 1462 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _interopRequireDefault = __webpack_require__(2)['default'];
	
	var _uiModules = __webpack_require__(24);
	
	var _uiModules2 = _interopRequireDefault(_uiModules);
	
	var _lodash = __webpack_require__(3);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(235);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _module = _uiModules2['default'].get('app/timelion');
	
	// Used only by the savedSheets service, usually no reason to change this
	_module.factory('SavedSheet', function (courier, config) {
	
	  // SavedSheet constructor. Usually you'd interact with an instance of this.
	  // ID is option, without it one will be generated on save.
	  _lodash2['default']['class'](SavedSheet).inherits(courier.SavedObject);
	  function SavedSheet(id) {
	    // Gives our SavedSheet the properties of a SavedObject
	    courier.SavedObject.call(this, {
	      type: SavedSheet.type,
	      mapping: SavedSheet.mapping,
	
	      // if this is null/undefined then the SavedObject will be assigned the defaults
	      id: id,
	
	      // default values that will get assigned if the doc is new
	      defaults: {
	        title: 'New TimeLion Sheet',
	        hits: 0,
	        description: '',
	        timelion_sheet: ['.es(*)'],
	        timelion_interval: 'auto',
	        timelion_chart_height: 275,
	        timelion_columns: config.get('timelion:default_columns') || 2,
	        timelion_rows: config.get('timelion:default_rows') || 2,
	        version: 1
	      }
	    });
	  }
	
	  // save these objects with the 'sheet' type
	  SavedSheet.type = 'timelion-sheet';
	
	  // if type:sheet has no mapping, we push this mapping into ES
	  SavedSheet.mapping = {
	    title: 'string',
	    hits: 'integer',
	    description: 'string',
	    timelion_sheet: 'string',
	    timelion_interval: 'string',
	    timelion_other_interval: 'string',
	    timelion_chart_height: 'integer',
	    timelion_columns: 'integer',
	    timelion_rows: 'integer',
	    version: 'integer'
	  };
	
	  // Order these fields to the top, the rest are alphabetical
	  SavedSheet.fieldOrder = ['title', 'description'];
	
	  return SavedSheet;
	});

/***/ },
/* 1463 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function savedSearchObjectFn(savedSheets) {
	    return savedSheets;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 1464 */
/***/ function(module, exports) {

	module.exports = "<div class=\"timelion app-container\" ng-controller=\"timelion\">\n  <!-- Local nav. -->\n  <kbn-top-nav name=\"timelion\" config=\"topNavMenu\">\n    <!-- Transcluded elements. -->\n    <div data-transclude-slots>\n      <div data-transclude-slot=\"topLeftCorner\">\n        <span class=\"kuiLocalTitle\" ng-show=\"opts.savedSheet.id\">\n          {{opts.savedSheet.lastSavedTitle}}\n          &nbsp;\n          <span class=\"fa fa-bolt\" ng-click=\"showStats = !showStats\"></span>\n          &nbsp;\n          <span class=\"timelion-stats\" ng-show=\"showStats\">\n            Query Time {{stats.queryTime - stats.invokeTime}}ms /\n            Processing Time {{stats.sheetTime - stats.queryTime}}ms\n          </span>\n        </span>\n      </div>\n\n      <!-- Search. -->\n      <form\n        data-transclude-slot=\"bottomRow\"\n        class=\"fullWidth\"\n        role=\"form\"\n        ng-submit=\"search()\"\n      >\n        <div class=\"kuiLocalSearch timelionLocalSearch\">\n          <input\n            input-focus\n            ng-model=\"state.sheet[state.selected]\"\n            timelion-expression=\"{{state.sheet[state.selected]}}\"\n            placeholder=\"Expression...\"\n            aria-label=\"Expression input\"\n            type=\"text\"\n            class=\"kuiLocalSearchInput timelion-expression\"\n          >\n\n          <timelion-interval model=\"state.interval\"></timelion-interval>\n\n          <button\n            type=\"submit\"\n            aria-label=\"Search\"\n            class=\"kuiLocalSearchButton\"\n          >\n            <span class=\"fa fa-play\"></span>\n          </button>\n        </div>\n      </form>\n    </div>\n  </kbn-top-nav>\n\n  <div class=\"timelion-container\">\n    <div class=\"timelion-container-sheet\">\n      <div class=\"timelion-container-sheet-margin\">\n        <timelion-fullscreen\n          ng-show=\"transient.fullscreen\"\n          transient=\"transient\"\n          state=\"state\"\n          series=\"sheet[state.selected]\"\n          expression=\"state.sheet[state.selected]\"\n          on-search=\"search\"\n        ></timelion-fullscreen>\n\n        <timelion-cells\n          ng-show=\"!transient.fullscreen\"\n          transient=\"transient\"\n          state=\"state\"\n          sheet=\"sheet\"\n          on-search=\"search\"\n          on-select=\"setActiveCell\"\n        ></timelion-cells>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 1465 */
/***/ function(module, exports) {

	module.exports = "<div class=\"list-group\">\n  <a class=\"list-group-item\" ng-click=\"section = 'sheet'\">\n    <h4 class=\"list-group-item-heading\">Save entire Timelion sheet</h4>\n    <p  class=\"list-group-item-text\">\n      You want this option if you mostly use Timelion expressions from within the Timelion app and don't need to\n      add Timelion charts to Kibana dashboards. You may also want this if you make use of references to other\n      panels.\n    </p>\n  </a>\n\n  <div class=\"list-group-item\" ng-show=\"section == 'sheet'\">\n    <form role=\"form\" class=\"container-fluid\" ng-submit=\"opts.saveSheet()\">\n      <div class=\"form-group\">\n        <label for=\"savedSheet\" class=\"control-label\">Save sheet as</label>\n        <input id=\"savedSheet\" ng-model=\"opts.savedSheet.title\" input-focus=\"select\" class=\"form-control\" placeholder=\"Name this sheet...\">\n      </div>\n\n      <saved-object-save-as-check-box saved-object=\"opts.savedSheet\"></saved-object-save-as-check-box>\n      <div class=\"form-group\">\n        <button ng-disabled=\"!opts.savedSheet.title\" type=\"submit\" class=\"btn btn-primary\">\n          Save\n        </button>\n      </div>\n    </form>\n  </div>\n\n  <a class=\"list-group-item\" ng-click=\"section = 'expression'\">\n    <h4 class=\"list-group-item-heading\">Save current expression as Kibana dashboard panel</h4>\n    <p class=\"list-group-item-text\">\n      Need to add a chart to a Kibana dashboard? We can do that! This option will save your currently selected\n      expression as a panel that can be added to Kibana dashboards as you would add anything else. Note, if you\n      use references to other panels you will need to remove the refences by copying the referenced expression\n      directly into the expression you are saving. Click a chart to select a different expression to save.\n    </p>\n  </a>\n\n  <div class=\"list-group-item\" ng-show=\"section == 'expression'\">\n    <form role=\"form\" class=\"container-fluid\" ng-submit=\"opts.saveExpression(panelTitle)\">\n      <div class=\"form-group\">\n        <label class=\"control-label\">Currently selected expression</label>\n        <code>{{opts.state.sheet[opts.state.selected]}}</code>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"savedExpression\" class=\"control-label\">Save expression as</label>\n        <input id=\"savedExpression\" ng-model=\"panelTitle\" input-focus=\"select\" class=\"form-control\" placeholder=\"Name this panel\">\n      </div>\n      <div class=\"form-group\">\n        <button ng-disabled=\"!panelTitle\" type=\"submit\" class=\"btn btn-primary\">Save</button>\n      </div>\n    </form>\n  </div>\n</div>\n"

/***/ },
/* 1466 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" ng-submit=\"fetch()\">\n  <div class=\"kuiLocalDropdownTitle\">Open Sheet</div>\n  <saved-object-finder type=\"timelion-sheet\" use-local-management=\"true\"></saved-object-finder>\n</form>\n"

/***/ },
/* 1467 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\">\n  <div class=\"kuiLocalDropdownTitle\">Sheet options</div>\n  <div>\n    <div class=\"form-group col-md-6\">\n      <label>Columns <small>Column count must divide evenly into 12</small></label>\n      <select class=\"form-control\"\n        ng-change=\"opts.search()\"\n        ng-options=\"column for column in [1, 2, 3, 4, 6, 12]\"\n        ng-model=\"opts.state.columns\">\n      </select>\n    </div>\n    <div class=\"form-group col-md-6\">\n      <label>Rows <small>This is a target based on the current window height</small></label>\n      <select class=\"form-control\"\n        ng-change=\"opts.search()\"\n        ng-options=\"row for row in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\"\n        ng-model=\"opts.state.rows\">\n      </select>\n    </div>\n  </div>\n</form>\n"

/***/ }
]);
//# sourceMappingURL=timelion.bundle.js.map